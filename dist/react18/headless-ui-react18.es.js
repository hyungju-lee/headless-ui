var OU = Object.defineProperty;
var PU = (t, e, i) => e in t ? OU(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i;
var Ve = (t, e, i) => PU(t, typeof e != "symbol" ? e + "" : e, i);
import * as kE from "react";
import rp, { useRef as xn, useEffect as Xn, createContext as Wo, useState as En, useContext as Oi, useMemo as Zs, forwardRef as Av, useImperativeHandle as Xx, useId as Qx, useInsertionEffect as rL, useCallback as ME, Children as LU, isValidElement as aL, useLayoutEffect as NU, Fragment as sL, createElement as zU, Component as FU, cloneElement as VU } from "react";
var Fb = { exports: {} }, zg = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CM;
function jU() {
  if (CM) return zg;
  CM = 1;
  var t = rp, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), a = Object.prototype.hasOwnProperty, o = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, c = { key: !0, ref: !0, __self: !0, __source: !0 };
  function u(h, m, v) {
    var b, S = {}, w = null, E = null;
    v !== void 0 && (w = "" + v), m.key !== void 0 && (w = "" + m.key), m.ref !== void 0 && (E = m.ref);
    for (b in m) a.call(m, b) && !c.hasOwnProperty(b) && (S[b] = m[b]);
    if (h && h.defaultProps) for (b in m = h.defaultProps, m) S[b] === void 0 && (S[b] = m[b]);
    return { $$typeof: e, type: h, key: w, ref: E, props: S, _owner: o.current };
  }
  return zg.Fragment = i, zg.jsx = u, zg.jsxs = u, zg;
}
var Fg = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TM;
function BU() {
  return TM || (TM = 1, process.env.NODE_ENV !== "production" && function() {
    var t = rp, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), a = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), h = Symbol.for("react.context"), m = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), b = Symbol.for("react.suspense_list"), S = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), R = Symbol.iterator, M = "@@iterator";
    function A(H) {
      if (H === null || typeof H != "object")
        return null;
      var ge = R && H[R] || H[M];
      return typeof ge == "function" ? ge : null;
    }
    var P = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function z(H) {
      {
        for (var ge = arguments.length, Be = new Array(ge > 1 ? ge - 1 : 0), ut = 1; ut < ge; ut++)
          Be[ut - 1] = arguments[ut];
        B("error", H, Be);
      }
    }
    function B(H, ge, Be) {
      {
        var ut = P.ReactDebugCurrentFrame, ct = ut.getStackAddendum();
        ct !== "" && (ge += "%s", Be = Be.concat([ct]));
        var Dt = Be.map(function(Pt) {
          return String(Pt);
        });
        Dt.unshift("Warning: " + ge), Function.prototype.apply.call(console[H], console, Dt);
      }
    }
    var j = !1, F = !1, $ = !1, I = !1, K = !1, ee;
    ee = Symbol.for("react.module.reference");
    function ne(H) {
      return !!(typeof H == "string" || typeof H == "function" || H === a || H === c || K || H === o || H === v || H === b || I || H === E || j || F || $ || typeof H == "object" && H !== null && (H.$$typeof === w || H.$$typeof === S || H.$$typeof === u || H.$$typeof === h || H.$$typeof === m || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      H.$$typeof === ee || H.getModuleId !== void 0));
    }
    function le(H, ge, Be) {
      var ut = H.displayName;
      if (ut)
        return ut;
      var ct = ge.displayName || ge.name || "";
      return ct !== "" ? Be + "(" + ct + ")" : Be;
    }
    function re(H) {
      return H.displayName || "Context";
    }
    function se(H) {
      if (H == null)
        return null;
      if (typeof H.tag == "number" && z("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof H == "function")
        return H.displayName || H.name || null;
      if (typeof H == "string")
        return H;
      switch (H) {
        case a:
          return "Fragment";
        case i:
          return "Portal";
        case c:
          return "Profiler";
        case o:
          return "StrictMode";
        case v:
          return "Suspense";
        case b:
          return "SuspenseList";
      }
      if (typeof H == "object")
        switch (H.$$typeof) {
          case h:
            var ge = H;
            return re(ge) + ".Consumer";
          case u:
            var Be = H;
            return re(Be._context) + ".Provider";
          case m:
            return le(H, H.render, "ForwardRef");
          case S:
            var ut = H.displayName || null;
            return ut !== null ? ut : se(H.type) || "Memo";
          case w: {
            var ct = H, Dt = ct._payload, Pt = ct._init;
            try {
              return se(Pt(Dt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ne = Object.assign, Ee = 0, we, Oe, ae, me, pe, Ce, oe;
    function Me() {
    }
    Me.__reactDisabledLog = !0;
    function Pe() {
      {
        if (Ee === 0) {
          we = console.log, Oe = console.info, ae = console.warn, me = console.error, pe = console.group, Ce = console.groupCollapsed, oe = console.groupEnd;
          var H = {
            configurable: !0,
            enumerable: !0,
            value: Me,
            writable: !0
          };
          Object.defineProperties(console, {
            info: H,
            log: H,
            warn: H,
            error: H,
            group: H,
            groupCollapsed: H,
            groupEnd: H
          });
        }
        Ee++;
      }
    }
    function fe() {
      {
        if (Ee--, Ee === 0) {
          var H = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ne({}, H, {
              value: we
            }),
            info: Ne({}, H, {
              value: Oe
            }),
            warn: Ne({}, H, {
              value: ae
            }),
            error: Ne({}, H, {
              value: me
            }),
            group: Ne({}, H, {
              value: pe
            }),
            groupCollapsed: Ne({}, H, {
              value: Ce
            }),
            groupEnd: Ne({}, H, {
              value: oe
            })
          });
        }
        Ee < 0 && z("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Le = P.ReactCurrentDispatcher, Te;
    function xe(H, ge, Be) {
      {
        if (Te === void 0)
          try {
            throw Error();
          } catch (ct) {
            var ut = ct.stack.trim().match(/\n( *(at )?)/);
            Te = ut && ut[1] || "";
          }
        return `
` + Te + H;
      }
    }
    var it = !1, dt;
    {
      var lt = typeof WeakMap == "function" ? WeakMap : Map;
      dt = new lt();
    }
    function St(H, ge) {
      if (!H || it)
        return "";
      {
        var Be = dt.get(H);
        if (Be !== void 0)
          return Be;
      }
      var ut;
      it = !0;
      var ct = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Dt;
      Dt = Le.current, Le.current = null, Pe();
      try {
        if (ge) {
          var Pt = function() {
            throw Error();
          };
          if (Object.defineProperty(Pt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Pt, []);
            } catch (At) {
              ut = At;
            }
            Reflect.construct(H, [], Pt);
          } else {
            try {
              Pt.call();
            } catch (At) {
              ut = At;
            }
            H.call(Pt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (At) {
            ut = At;
          }
          H();
        }
      } catch (At) {
        if (At && ut && typeof At.stack == "string") {
          for (var Ft = At.stack.split(`
`), bi = ut.stack.split(`
`), On = Ft.length - 1, Fn = bi.length - 1; On >= 1 && Fn >= 0 && Ft[On] !== bi[Fn]; )
            Fn--;
          for (; On >= 1 && Fn >= 0; On--, Fn--)
            if (Ft[On] !== bi[Fn]) {
              if (On !== 1 || Fn !== 1)
                do
                  if (On--, Fn--, Fn < 0 || Ft[On] !== bi[Fn]) {
                    var tr = `
` + Ft[On].replace(" at new ", " at ");
                    return H.displayName && tr.includes("<anonymous>") && (tr = tr.replace("<anonymous>", H.displayName)), typeof H == "function" && dt.set(H, tr), tr;
                  }
                while (On >= 1 && Fn >= 0);
              break;
            }
        }
      } finally {
        it = !1, Le.current = Dt, fe(), Error.prepareStackTrace = ct;
      }
      var bs = H ? H.displayName || H.name : "", xs = bs ? xe(bs) : "";
      return typeof H == "function" && dt.set(H, xs), xs;
    }
    function _t(H, ge, Be) {
      return St(H, !1);
    }
    function rt(H) {
      var ge = H.prototype;
      return !!(ge && ge.isReactComponent);
    }
    function xt(H, ge, Be) {
      if (H == null)
        return "";
      if (typeof H == "function")
        return St(H, rt(H));
      if (typeof H == "string")
        return xe(H);
      switch (H) {
        case v:
          return xe("Suspense");
        case b:
          return xe("SuspenseList");
      }
      if (typeof H == "object")
        switch (H.$$typeof) {
          case m:
            return _t(H.render);
          case S:
            return xt(H.type, ge, Be);
          case w: {
            var ut = H, ct = ut._payload, Dt = ut._init;
            try {
              return xt(Dt(ct), ge, Be);
            } catch {
            }
          }
        }
      return "";
    }
    var Wt = Object.prototype.hasOwnProperty, an = {}, sn = P.ReactDebugCurrentFrame;
    function Yt(H) {
      if (H) {
        var ge = H._owner, Be = xt(H.type, H._source, ge ? ge.type : null);
        sn.setExtraStackFrame(Be);
      } else
        sn.setExtraStackFrame(null);
    }
    function Gt(H, ge, Be, ut, ct) {
      {
        var Dt = Function.call.bind(Wt);
        for (var Pt in H)
          if (Dt(H, Pt)) {
            var Ft = void 0;
            try {
              if (typeof H[Pt] != "function") {
                var bi = Error((ut || "React class") + ": " + Be + " type `" + Pt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof H[Pt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw bi.name = "Invariant Violation", bi;
              }
              Ft = H[Pt](ge, Pt, ut, Be, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (On) {
              Ft = On;
            }
            Ft && !(Ft instanceof Error) && (Yt(ct), z("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ut || "React class", Be, Pt, typeof Ft), Yt(null)), Ft instanceof Error && !(Ft.message in an) && (an[Ft.message] = !0, Yt(ct), z("Failed %s type: %s", Be, Ft.message), Yt(null));
          }
      }
    }
    var Ot = Array.isArray;
    function wt(H) {
      return Ot(H);
    }
    function Kt(H) {
      {
        var ge = typeof Symbol == "function" && Symbol.toStringTag, Be = ge && H[Symbol.toStringTag] || H.constructor.name || "Object";
        return Be;
      }
    }
    function wn(H) {
      try {
        return Mn(H), !1;
      } catch {
        return !0;
      }
    }
    function Mn(H) {
      return "" + H;
    }
    function oi(H) {
      if (wn(H))
        return z("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Kt(H)), Mn(H);
    }
    var Pi = P.ReactCurrentOwner, er = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ei, ze;
    function tt(H) {
      if (Wt.call(H, "ref")) {
        var ge = Object.getOwnPropertyDescriptor(H, "ref").get;
        if (ge && ge.isReactWarning)
          return !1;
      }
      return H.ref !== void 0;
    }
    function Et(H) {
      if (Wt.call(H, "key")) {
        var ge = Object.getOwnPropertyDescriptor(H, "key").get;
        if (ge && ge.isReactWarning)
          return !1;
      }
      return H.key !== void 0;
    }
    function Xt(H, ge) {
      typeof H.ref == "string" && Pi.current;
    }
    function ln(H, ge) {
      {
        var Be = function() {
          Ei || (Ei = !0, z("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ge));
        };
        Be.isReactWarning = !0, Object.defineProperty(H, "key", {
          get: Be,
          configurable: !0
        });
      }
    }
    function dn(H, ge) {
      {
        var Be = function() {
          ze || (ze = !0, z("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ge));
        };
        Be.isReactWarning = !0, Object.defineProperty(H, "ref", {
          get: Be,
          configurable: !0
        });
      }
    }
    var gn = function(H, ge, Be, ut, ct, Dt, Pt) {
      var Ft = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: H,
        key: ge,
        ref: Be,
        props: Pt,
        // Record the component responsible for creating this element.
        _owner: Dt
      };
      return Ft._store = {}, Object.defineProperty(Ft._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ft, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ut
      }), Object.defineProperty(Ft, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ct
      }), Object.freeze && (Object.freeze(Ft.props), Object.freeze(Ft)), Ft;
    };
    function zn(H, ge, Be, ut, ct) {
      {
        var Dt, Pt = {}, Ft = null, bi = null;
        Be !== void 0 && (oi(Be), Ft = "" + Be), Et(ge) && (oi(ge.key), Ft = "" + ge.key), tt(ge) && (bi = ge.ref, Xt(ge, ct));
        for (Dt in ge)
          Wt.call(ge, Dt) && !er.hasOwnProperty(Dt) && (Pt[Dt] = ge[Dt]);
        if (H && H.defaultProps) {
          var On = H.defaultProps;
          for (Dt in On)
            Pt[Dt] === void 0 && (Pt[Dt] = On[Dt]);
        }
        if (Ft || bi) {
          var Fn = typeof H == "function" ? H.displayName || H.name || "Unknown" : H;
          Ft && ln(Pt, Fn), bi && dn(Pt, Fn);
        }
        return gn(H, Ft, bi, ct, ut, Pi.current, Pt);
      }
    }
    var on = P.ReactCurrentOwner, jt = P.ReactDebugCurrentFrame;
    function Qt(H) {
      if (H) {
        var ge = H._owner, Be = xt(H.type, H._source, ge ? ge.type : null);
        jt.setExtraStackFrame(Be);
      } else
        jt.setExtraStackFrame(null);
    }
    var Di;
    Di = !1;
    function yi(H) {
      return typeof H == "object" && H !== null && H.$$typeof === e;
    }
    function He() {
      {
        if (on.current) {
          var H = se(on.current.type);
          if (H)
            return `

Check the render method of \`` + H + "`.";
        }
        return "";
      }
    }
    function Fe(H) {
      return "";
    }
    var Qe = {};
    function mt(H) {
      {
        var ge = He();
        if (!ge) {
          var Be = typeof H == "string" ? H : H.displayName || H.name;
          Be && (ge = `

Check the top-level render call using <` + Be + ">.");
        }
        return ge;
      }
    }
    function de(H, ge) {
      {
        if (!H._store || H._store.validated || H.key != null)
          return;
        H._store.validated = !0;
        var Be = mt(ge);
        if (Qe[Be])
          return;
        Qe[Be] = !0;
        var ut = "";
        H && H._owner && H._owner !== on.current && (ut = " It was passed a child from " + se(H._owner.type) + "."), Qt(H), z('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Be, ut), Qt(null);
      }
    }
    function ve(H, ge) {
      {
        if (typeof H != "object")
          return;
        if (wt(H))
          for (var Be = 0; Be < H.length; Be++) {
            var ut = H[Be];
            yi(ut) && de(ut, ge);
          }
        else if (yi(H))
          H._store && (H._store.validated = !0);
        else if (H) {
          var ct = A(H);
          if (typeof ct == "function" && ct !== H.entries)
            for (var Dt = ct.call(H), Pt; !(Pt = Dt.next()).done; )
              yi(Pt.value) && de(Pt.value, ge);
        }
      }
    }
    function ke(H) {
      {
        var ge = H.type;
        if (ge == null || typeof ge == "string")
          return;
        var Be;
        if (typeof ge == "function")
          Be = ge.propTypes;
        else if (typeof ge == "object" && (ge.$$typeof === m || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ge.$$typeof === S))
          Be = ge.propTypes;
        else
          return;
        if (Be) {
          var ut = se(ge);
          Gt(Be, H.props, "prop", ut, H);
        } else if (ge.PropTypes !== void 0 && !Di) {
          Di = !0;
          var ct = se(ge);
          z("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ct || "Unknown");
        }
        typeof ge.getDefaultProps == "function" && !ge.getDefaultProps.isReactClassApproved && z("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function $e(H) {
      {
        for (var ge = Object.keys(H.props), Be = 0; Be < ge.length; Be++) {
          var ut = ge[Be];
          if (ut !== "children" && ut !== "key") {
            Qt(H), z("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ut), Qt(null);
            break;
          }
        }
        H.ref !== null && (Qt(H), z("Invalid attribute `ref` supplied to `React.Fragment`."), Qt(null));
      }
    }
    var hn = {};
    function An(H, ge, Be, ut, ct, Dt) {
      {
        var Pt = ne(H);
        if (!Pt) {
          var Ft = "";
          (H === void 0 || typeof H == "object" && H !== null && Object.keys(H).length === 0) && (Ft += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var bi = Fe();
          bi ? Ft += bi : Ft += He();
          var On;
          H === null ? On = "null" : wt(H) ? On = "array" : H !== void 0 && H.$$typeof === e ? (On = "<" + (se(H.type) || "Unknown") + " />", Ft = " Did you accidentally export a JSX literal instead of a component?") : On = typeof H, z("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", On, Ft);
        }
        var Fn = zn(H, ge, Be, ct, Dt);
        if (Fn == null)
          return Fn;
        if (Pt) {
          var tr = ge.children;
          if (tr !== void 0)
            if (ut)
              if (wt(tr)) {
                for (var bs = 0; bs < tr.length; bs++)
                  ve(tr[bs], H);
                Object.freeze && Object.freeze(tr);
              } else
                z("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ve(tr, H);
        }
        if (Wt.call(ge, "key")) {
          var xs = se(H), At = Object.keys(ge).filter(function(lc) {
            return lc !== "key";
          }), Lt = At.length > 0 ? "{key: someKey, " + At.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!hn[xs + Lt]) {
            var Ss = At.length > 0 ? "{" + At.join(": ..., ") + ": ...}" : "{}";
            z(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Lt, xs, Ss, xs), hn[xs + Lt] = !0;
          }
        }
        return H === a ? $e(Fn) : ke(Fn), Fn;
      }
    }
    function yr(H, ge, Be) {
      return An(H, ge, Be, !0);
    }
    function Hr(H, ge, Be) {
      return An(H, ge, Be, !1);
    }
    var Da = Hr, Ra = yr;
    Fg.Fragment = a, Fg.jsx = Da, Fg.jsxs = Ra;
  }()), Fg;
}
var EM;
function HU() {
  return EM || (EM = 1, process.env.NODE_ENV === "production" ? Fb.exports = jU() : Fb.exports = BU()), Fb.exports;
}
var Ae = HU();
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function Ov(t) {
  return t + 0.5 | 0;
}
const Yu = (t, e, i) => Math.max(Math.min(t, i), e);
function Wg(t) {
  return Yu(Ov(t * 2.55), 0, 255);
}
function Qu(t) {
  return Yu(Ov(t * 255), 0, 255);
}
function Il(t) {
  return Yu(Ov(t / 2.55) / 100, 0, 1);
}
function DM(t) {
  return Yu(Ov(t * 100), 0, 100);
}
const ps = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, AT = [..."0123456789ABCDEF"], UU = (t) => AT[t & 15], IU = (t) => AT[(t & 240) >> 4] + AT[t & 15], Vb = (t) => (t & 240) >> 4 === (t & 15), $U = (t) => Vb(t.r) && Vb(t.g) && Vb(t.b) && Vb(t.a);
function WU(t) {
  var e = t.length, i;
  return t[0] === "#" && (e === 4 || e === 5 ? i = {
    r: 255 & ps[t[1]] * 17,
    g: 255 & ps[t[2]] * 17,
    b: 255 & ps[t[3]] * 17,
    a: e === 5 ? ps[t[4]] * 17 : 255
  } : (e === 7 || e === 9) && (i = {
    r: ps[t[1]] << 4 | ps[t[2]],
    g: ps[t[3]] << 4 | ps[t[4]],
    b: ps[t[5]] << 4 | ps[t[6]],
    a: e === 9 ? ps[t[7]] << 4 | ps[t[8]] : 255
  })), i;
}
const YU = (t, e) => t < 255 ? e(t) : "";
function GU(t) {
  var e = $U(t) ? UU : IU;
  return t ? "#" + e(t.r) + e(t.g) + e(t.b) + YU(t.a, e) : void 0;
}
const KU = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function oL(t, e, i) {
  const a = e * Math.min(i, 1 - i), o = (c, u = (c + t / 30) % 12) => i - a * Math.max(Math.min(u - 3, 9 - u, 1), -1);
  return [o(0), o(8), o(4)];
}
function XU(t, e, i) {
  const a = (o, c = (o + t / 60) % 6) => i - i * e * Math.max(Math.min(c, 4 - c, 1), 0);
  return [a(5), a(3), a(1)];
}
function QU(t, e, i) {
  const a = oL(t, 1, 0.5);
  let o;
  for (e + i > 1 && (o = 1 / (e + i), e *= o, i *= o), o = 0; o < 3; o++)
    a[o] *= 1 - e - i, a[o] += e;
  return a;
}
function qU(t, e, i, a, o) {
  return t === o ? (e - i) / a + (e < i ? 6 : 0) : e === o ? (i - t) / a + 2 : (t - e) / a + 4;
}
function AE(t) {
  const i = t.r / 255, a = t.g / 255, o = t.b / 255, c = Math.max(i, a, o), u = Math.min(i, a, o), h = (c + u) / 2;
  let m, v, b;
  return c !== u && (b = c - u, v = h > 0.5 ? b / (2 - c - u) : b / (c + u), m = qU(i, a, o, b, c), m = m * 60 + 0.5), [m | 0, v || 0, h];
}
function OE(t, e, i, a) {
  return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, a)).map(Qu);
}
function PE(t, e, i) {
  return OE(oL, t, e, i);
}
function ZU(t, e, i) {
  return OE(QU, t, e, i);
}
function JU(t, e, i) {
  return OE(XU, t, e, i);
}
function lL(t) {
  return (t % 360 + 360) % 360;
}
function eI(t) {
  const e = KU.exec(t);
  let i = 255, a;
  if (!e)
    return;
  e[5] !== a && (i = e[6] ? Wg(+e[5]) : Qu(+e[5]));
  const o = lL(+e[2]), c = +e[3] / 100, u = +e[4] / 100;
  return e[1] === "hwb" ? a = ZU(o, c, u) : e[1] === "hsv" ? a = JU(o, c, u) : a = PE(o, c, u), {
    r: a[0],
    g: a[1],
    b: a[2],
    a: i
  };
}
function tI(t, e) {
  var i = AE(t);
  i[0] = lL(i[0] + e), i = PE(i), t.r = i[0], t.g = i[1], t.b = i[2];
}
function nI(t) {
  if (!t)
    return;
  const e = AE(t), i = e[0], a = DM(e[1]), o = DM(e[2]);
  return t.a < 255 ? `hsla(${i}, ${a}%, ${o}%, ${Il(t.a)})` : `hsl(${i}, ${a}%, ${o}%)`;
}
const RM = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, kM = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function iI() {
  const t = {}, e = Object.keys(kM), i = Object.keys(RM);
  let a, o, c, u, h;
  for (a = 0; a < e.length; a++) {
    for (u = h = e[a], o = 0; o < i.length; o++)
      c = i[o], h = h.replace(c, RM[c]);
    c = parseInt(kM[u], 16), t[h] = [c >> 16 & 255, c >> 8 & 255, c & 255];
  }
  return t;
}
let jb;
function rI(t) {
  jb || (jb = iI(), jb.transparent = [0, 0, 0, 0]);
  const e = jb[t.toLowerCase()];
  return e && {
    r: e[0],
    g: e[1],
    b: e[2],
    a: e.length === 4 ? e[3] : 255
  };
}
const aI = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function sI(t) {
  const e = aI.exec(t);
  let i = 255, a, o, c;
  if (e) {
    if (e[7] !== a) {
      const u = +e[7];
      i = e[8] ? Wg(u) : Yu(u * 255, 0, 255);
    }
    return a = +e[1], o = +e[3], c = +e[5], a = 255 & (e[2] ? Wg(a) : Yu(a, 0, 255)), o = 255 & (e[4] ? Wg(o) : Yu(o, 0, 255)), c = 255 & (e[6] ? Wg(c) : Yu(c, 0, 255)), {
      r: a,
      g: o,
      b: c,
      a: i
    };
  }
}
function oI(t) {
  return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Il(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`);
}
const XC = (t) => t <= 31308e-7 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - 0.055, $h = (t) => t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
function lI(t, e, i) {
  const a = $h(Il(t.r)), o = $h(Il(t.g)), c = $h(Il(t.b));
  return {
    r: Qu(XC(a + i * ($h(Il(e.r)) - a))),
    g: Qu(XC(o + i * ($h(Il(e.g)) - o))),
    b: Qu(XC(c + i * ($h(Il(e.b)) - c))),
    a: t.a + i * (e.a - t.a)
  };
}
function Bb(t, e, i) {
  if (t) {
    let a = AE(t);
    a[e] = Math.max(0, Math.min(a[e] + a[e] * i, e === 0 ? 360 : 1)), a = PE(a), t.r = a[0], t.g = a[1], t.b = a[2];
  }
}
function uL(t, e) {
  return t && Object.assign(e || {}, t);
}
function MM(t) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = Qu(t[3]))) : (e = uL(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = Qu(e.a)), e;
}
function uI(t) {
  return t.charAt(0) === "r" ? sI(t) : eI(t);
}
class fv {
  constructor(e) {
    if (e instanceof fv)
      return e;
    const i = typeof e;
    let a;
    i === "object" ? a = MM(e) : i === "string" && (a = WU(e) || rI(e) || uI(e)), this._rgb = a, this._valid = !!a;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var e = uL(this._rgb);
    return e && (e.a = Il(e.a)), e;
  }
  set rgb(e) {
    this._rgb = MM(e);
  }
  rgbString() {
    return this._valid ? oI(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? GU(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? nI(this._rgb) : void 0;
  }
  mix(e, i) {
    if (e) {
      const a = this.rgb, o = e.rgb;
      let c;
      const u = i === c ? 0.5 : i, h = 2 * u - 1, m = a.a - o.a, v = ((h * m === -1 ? h : (h + m) / (1 + h * m)) + 1) / 2;
      c = 1 - v, a.r = 255 & v * a.r + c * o.r + 0.5, a.g = 255 & v * a.g + c * o.g + 0.5, a.b = 255 & v * a.b + c * o.b + 0.5, a.a = u * a.a + (1 - u) * o.a, this.rgb = a;
    }
    return this;
  }
  interpolate(e, i) {
    return e && (this._rgb = lI(this._rgb, e._rgb, i)), this;
  }
  clone() {
    return new fv(this.rgb);
  }
  alpha(e) {
    return this._rgb.a = Qu(e), this;
  }
  clearer(e) {
    const i = this._rgb;
    return i.a *= 1 - e, this;
  }
  greyscale() {
    const e = this._rgb, i = Ov(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
    return e.r = e.g = e.b = i, this;
  }
  opaquer(e) {
    const i = this._rgb;
    return i.a *= 1 + e, this;
  }
  negate() {
    const e = this._rgb;
    return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
  }
  lighten(e) {
    return Bb(this._rgb, 2, e), this;
  }
  darken(e) {
    return Bb(this._rgb, 2, -e), this;
  }
  saturate(e) {
    return Bb(this._rgb, 1, e), this;
  }
  desaturate(e) {
    return Bb(this._rgb, 1, -e), this;
  }
  rotate(e) {
    return tI(this._rgb, e), this;
  }
}
/*!
 * Chart.js v4.4.8
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function Vl() {
}
const cI = /* @__PURE__ */ (() => {
  let t = 0;
  return () => t++;
})();
function $t(t) {
  return t == null;
}
function Kn(t) {
  if (Array.isArray && Array.isArray(t))
    return !0;
  const e = Object.prototype.toString.call(t);
  return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
}
function qt(t) {
  return t !== null && Object.prototype.toString.call(t) === "[object Object]";
}
function vi(t) {
  return (typeof t == "number" || t instanceof Number) && isFinite(+t);
}
function Ha(t, e) {
  return vi(t) ? t : e;
}
function zt(t, e) {
  return typeof t > "u" ? e : t;
}
const fI = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 : +t / e, cL = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;
function Nn(t, e, i) {
  if (t && typeof t.call == "function")
    return t.apply(i, e);
}
function _n(t, e, i, a) {
  let o, c, u;
  if (Kn(t))
    for (c = t.length, o = 0; o < c; o++)
      e.call(i, t[o], o);
  else if (qt(t))
    for (u = Object.keys(t), c = u.length, o = 0; o < c; o++)
      e.call(i, t[u[o]], u[o]);
}
function Cx(t, e) {
  let i, a, o, c;
  if (!t || !e || t.length !== e.length)
    return !1;
  for (i = 0, a = t.length; i < a; ++i)
    if (o = t[i], c = e[i], o.datasetIndex !== c.datasetIndex || o.index !== c.index)
      return !1;
  return !0;
}
function Tx(t) {
  if (Kn(t))
    return t.map(Tx);
  if (qt(t)) {
    const e = /* @__PURE__ */ Object.create(null), i = Object.keys(t), a = i.length;
    let o = 0;
    for (; o < a; ++o)
      e[i[o]] = Tx(t[i[o]]);
    return e;
  }
  return t;
}
function fL(t) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(t) === -1;
}
function dI(t, e, i, a) {
  if (!fL(t))
    return;
  const o = e[t], c = i[t];
  qt(o) && qt(c) ? dv(o, c, a) : e[t] = Tx(c);
}
function dv(t, e, i) {
  const a = Kn(e) ? e : [
    e
  ], o = a.length;
  if (!qt(t))
    return t;
  i = i || {};
  const c = i.merger || dI;
  let u;
  for (let h = 0; h < o; ++h) {
    if (u = a[h], !qt(u))
      continue;
    const m = Object.keys(u);
    for (let v = 0, b = m.length; v < b; ++v)
      c(m[v], t, u, i);
  }
  return t;
}
function tv(t, e) {
  return dv(t, e, {
    merger: hI
  });
}
function hI(t, e, i) {
  if (!fL(t))
    return;
  const a = e[t], o = i[t];
  qt(a) && qt(o) ? tv(a, o) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = Tx(o));
}
const AM = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (t) => t,
  // default resolvers
  x: (t) => t.x,
  y: (t) => t.y
};
function pI(t) {
  const e = t.split("."), i = [];
  let a = "";
  for (const o of e)
    a += o, a.endsWith("\\") ? a = a.slice(0, -1) + "." : (i.push(a), a = "");
  return i;
}
function mI(t) {
  const e = pI(t);
  return (i) => {
    for (const a of e) {
      if (a === "")
        break;
      i = i && i[a];
    }
    return i;
  };
}
function ec(t, e) {
  return (AM[e] || (AM[e] = mI(e)))(t);
}
function LE(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
const hv = (t) => typeof t < "u", tc = (t) => typeof t == "function", OM = (t, e) => {
  if (t.size !== e.size)
    return !1;
  for (const i of t)
    if (!e.has(i))
      return !1;
  return !0;
};
function gI(t) {
  return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu";
}
const In = Math.PI, Un = 2 * In, vI = Un + In, Ex = Number.POSITIVE_INFINITY, yI = In / 180, Ti = In / 2, Df = In / 4, PM = In * 2 / 3, Gu = Math.log10, jo = Math.sign;
function nv(t, e, i) {
  return Math.abs(t - e) < i;
}
function LM(t) {
  const e = Math.round(t);
  t = nv(t, e, t / 1e3) ? e : t;
  const i = Math.pow(10, Math.floor(Gu(t))), a = t / i;
  return (a <= 1 ? 1 : a <= 2 ? 2 : a <= 5 ? 5 : 10) * i;
}
function bI(t) {
  const e = [], i = Math.sqrt(t);
  let a;
  for (a = 1; a < i; a++)
    t % a === 0 && (e.push(a), e.push(t / a));
  return i === (i | 0) && e.push(i), e.sort((o, c) => o - c).pop(), e;
}
function xI(t) {
  return typeof t == "symbol" || typeof t == "object" && t !== null && !(Symbol.toPrimitive in t || "toString" in t || "valueOf" in t);
}
function ap(t) {
  return !xI(t) && !isNaN(parseFloat(t)) && isFinite(t);
}
function SI(t, e) {
  const i = Math.round(t);
  return i - e <= t && i + e >= t;
}
function dL(t, e, i) {
  let a, o, c;
  for (a = 0, o = t.length; a < o; a++)
    c = t[a][i], isNaN(c) || (e.min = Math.min(e.min, c), e.max = Math.max(e.max, c));
}
function Xs(t) {
  return t * (In / 180);
}
function NE(t) {
  return t * (180 / In);
}
function NM(t) {
  if (!vi(t))
    return;
  let e = 1, i = 0;
  for (; Math.round(t * e) / e !== t; )
    e *= 10, i++;
  return i;
}
function hL(t, e) {
  const i = e.x - t.x, a = e.y - t.y, o = Math.sqrt(i * i + a * a);
  let c = Math.atan2(a, i);
  return c < -0.5 * In && (c += Un), {
    angle: c,
    distance: o
  };
}
function OT(t, e) {
  return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
function _I(t, e) {
  return (t - e + vI) % Un - In;
}
function Ia(t) {
  return (t % Un + Un) % Un;
}
function pv(t, e, i, a) {
  const o = Ia(t), c = Ia(e), u = Ia(i), h = Ia(c - o), m = Ia(u - o), v = Ia(o - c), b = Ia(o - u);
  return o === c || o === u || a && c === u || h > m && v < b;
}
function Ji(t, e, i) {
  return Math.max(e, Math.min(i, t));
}
function wI(t) {
  return Ji(t, -32768, 32767);
}
function $l(t, e, i, a = 1e-6) {
  return t >= Math.min(e, i) - a && t <= Math.max(e, i) + a;
}
function zE(t, e, i) {
  i = i || ((u) => t[u] < e);
  let a = t.length - 1, o = 0, c;
  for (; a - o > 1; )
    c = o + a >> 1, i(c) ? o = c : a = c;
  return {
    lo: o,
    hi: a
  };
}
const Wl = (t, e, i, a) => zE(t, i, a ? (o) => {
  const c = t[o][e];
  return c < i || c === i && t[o + 1][e] === i;
} : (o) => t[o][e] < i), CI = (t, e, i) => zE(t, i, (a) => t[a][e] >= i);
function TI(t, e, i) {
  let a = 0, o = t.length;
  for (; a < o && t[a] < e; )
    a++;
  for (; o > a && t[o - 1] > i; )
    o--;
  return a > 0 || o < t.length ? t.slice(a, o) : t;
}
const pL = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function EI(t, e) {
  if (t._chartjs) {
    t._chartjs.listeners.push(e);
    return;
  }
  Object.defineProperty(t, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        e
      ]
    }
  }), pL.forEach((i) => {
    const a = "_onData" + LE(i), o = t[i];
    Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !1,
      value(...c) {
        const u = o.apply(this, c);
        return t._chartjs.listeners.forEach((h) => {
          typeof h[a] == "function" && h[a](...c);
        }), u;
      }
    });
  });
}
function zM(t, e) {
  const i = t._chartjs;
  if (!i)
    return;
  const a = i.listeners, o = a.indexOf(e);
  o !== -1 && a.splice(o, 1), !(a.length > 0) && (pL.forEach((c) => {
    delete t[c];
  }), delete t._chartjs);
}
function mL(t) {
  const e = new Set(t);
  return e.size === t.length ? t : Array.from(e);
}
const gL = function() {
  return typeof window > "u" ? function(t) {
    return t();
  } : window.requestAnimationFrame;
}();
function vL(t, e) {
  let i = [], a = !1;
  return function(...o) {
    i = o, a || (a = !0, gL.call(window, () => {
      a = !1, t.apply(e, i);
    }));
  };
}
function DI(t, e) {
  let i;
  return function(...a) {
    return e ? (clearTimeout(i), i = setTimeout(t, e, a)) : t.apply(this, a), e;
  };
}
const FE = (t) => t === "start" ? "left" : t === "end" ? "right" : "center", zr = (t, e, i) => t === "start" ? e : t === "end" ? i : (e + i) / 2, RI = (t, e, i, a) => t === (a ? "left" : "right") ? i : t === "center" ? (e + i) / 2 : e;
function yL(t, e, i) {
  const a = e.length;
  let o = 0, c = a;
  if (t._sorted) {
    const { iScale: u, vScale: h, _parsed: m } = t, v = t.dataset && t.dataset.options ? t.dataset.options.spanGaps : null, b = u.axis, { min: S, max: w, minDefined: E, maxDefined: R } = u.getUserBounds();
    if (E) {
      if (o = Math.min(
        // @ts-expect-error Need to type _parsed
        Wl(m, b, S).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? a : Wl(e, b, u.getPixelForValue(S)).lo
      ), v) {
        const M = m.slice(0, o + 1).reverse().findIndex((A) => !$t(A[h.axis]));
        o -= Math.max(0, M);
      }
      o = Ji(o, 0, a - 1);
    }
    if (R) {
      let M = Math.max(
        // @ts-expect-error Need to type _parsed
        Wl(m, u.axis, w, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? 0 : Wl(e, b, u.getPixelForValue(w), !0).hi + 1
      );
      if (v) {
        const A = m.slice(M - 1).findIndex((P) => !$t(P[h.axis]));
        M += Math.max(0, A);
      }
      c = Ji(M, o, a) - o;
    } else
      c = a - o;
  }
  return {
    start: o,
    count: c
  };
}
function bL(t) {
  const { xScale: e, yScale: i, _scaleRanges: a } = t, o = {
    xmin: e.min,
    xmax: e.max,
    ymin: i.min,
    ymax: i.max
  };
  if (!a)
    return t._scaleRanges = o, !0;
  const c = a.xmin !== e.min || a.xmax !== e.max || a.ymin !== i.min || a.ymax !== i.max;
  return Object.assign(a, o), c;
}
const Hb = (t) => t === 0 || t === 1, FM = (t, e, i) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * Un / i)), VM = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * Un / i) + 1, iv = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * Ti) + 1,
  easeOutSine: (t) => Math.sin(t * Ti),
  easeInOutSine: (t) => -0.5 * (Math.cos(In * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => Hb(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => Hb(t) ? t : FM(t, 0.075, 0.3),
  easeOutElastic: (t) => Hb(t) ? t : VM(t, 0.075, 0.3),
  easeInOutElastic(t) {
    return Hb(t) ? t : t < 0.5 ? 0.5 * FM(t * 2, 0.1125, 0.45) : 0.5 + 0.5 * VM(t * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(t) {
    return t * t * ((1.70158 + 1) * t - 1.70158);
  },
  easeOutBack(t) {
    return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1;
  },
  easeInOutBack(t) {
    let e = 1.70158;
    return (t /= 0.5) < 1 ? 0.5 * (t * t * (((e *= 1.525) + 1) * t - e)) : 0.5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2);
  },
  easeInBounce: (t) => 1 - iv.easeOutBounce(1 - t),
  easeOutBounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? iv.easeInBounce(t * 2) * 0.5 : iv.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function VE(t) {
  if (t && typeof t == "object") {
    const e = t.toString();
    return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
  }
  return !1;
}
function jM(t) {
  return VE(t) ? t : new fv(t);
}
function QC(t) {
  return VE(t) ? t : new fv(t).saturate(0.5).darken(0.1).hexString();
}
const kI = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], MI = [
  "color",
  "borderColor",
  "backgroundColor"
];
function AI(t) {
  t.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), t.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
  }), t.set("animations", {
    colors: {
      type: "color",
      properties: MI
    },
    numbers: {
      type: "number",
      properties: kI
    }
  }), t.describe("animations", {
    _fallback: "animation"
  }), t.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (e) => e | 0
        }
      }
    }
  });
}
function OI(t) {
  t.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const BM = /* @__PURE__ */ new Map();
function PI(t, e) {
  e = e || {};
  const i = t + JSON.stringify(e);
  let a = BM.get(i);
  return a || (a = new Intl.NumberFormat(t, e), BM.set(i, a)), a;
}
function Pv(t, e, i) {
  return PI(e, i).format(t);
}
const xL = {
  values(t) {
    return Kn(t) ? t : "" + t;
  },
  numeric(t, e, i) {
    if (t === 0)
      return "0";
    const a = this.chart.options.locale;
    let o, c = t;
    if (i.length > 1) {
      const v = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
      (v < 1e-4 || v > 1e15) && (o = "scientific"), c = LI(t, i);
    }
    const u = Gu(Math.abs(c)), h = isNaN(u) ? 1 : Math.max(Math.min(-1 * Math.floor(u), 20), 0), m = {
      notation: o,
      minimumFractionDigits: h,
      maximumFractionDigits: h
    };
    return Object.assign(m, this.options.ticks.format), Pv(t, a, m);
  },
  logarithmic(t, e, i) {
    if (t === 0)
      return "0";
    const a = i[e].significand || t / Math.pow(10, Math.floor(Gu(t)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(a) || e > 0.8 * i.length ? xL.numeric.call(this, t, e, i) : "";
  }
};
function LI(t, e) {
  let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
  return Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t)), i;
}
var qx = {
  formatters: xL
};
function NI(t) {
  t.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (e, i) => i.lineWidth,
      tickColor: (e, i) => i.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: qx.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", {
    _fallback: !1,
    _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
    _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
  }), t.describe("scales", {
    _fallback: "scale"
  }), t.describe("scale.ticks", {
    _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
    _indexable: (e) => e !== "backdropPadding"
  });
}
const $f = /* @__PURE__ */ Object.create(null), PT = /* @__PURE__ */ Object.create(null);
function rv(t, e) {
  if (!e)
    return t;
  const i = e.split(".");
  for (let a = 0, o = i.length; a < o; ++a) {
    const c = i[a];
    t = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
  }
  return t;
}
function qC(t, e, i) {
  return typeof e == "string" ? dv(rv(t, e), i) : dv(rv(t, ""), e);
}
class zI {
  constructor(e, i) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (a) => a.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (a, o) => QC(o.backgroundColor), this.hoverBorderColor = (a, o) => QC(o.borderColor), this.hoverColor = (a, o) => QC(o.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(i);
  }
  set(e, i) {
    return qC(this, e, i);
  }
  get(e) {
    return rv(this, e);
  }
  describe(e, i) {
    return qC(PT, e, i);
  }
  override(e, i) {
    return qC($f, e, i);
  }
  route(e, i, a, o) {
    const c = rv(this, e), u = rv(this, a), h = "_" + i;
    Object.defineProperties(c, {
      [h]: {
        value: c[i],
        writable: !0
      },
      [i]: {
        enumerable: !0,
        get() {
          const m = this[h], v = u[o];
          return qt(m) ? Object.assign({}, v, m) : zt(m, v);
        },
        set(m) {
          this[h] = m;
        }
      }
    });
  }
  apply(e) {
    e.forEach((i) => i(this));
  }
}
var Qn = /* @__PURE__ */ new zI({
  _scriptable: (t) => !t.startsWith("on"),
  _indexable: (t) => t !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  AI,
  OI,
  NI
]);
function FI(t) {
  return !t || $t(t.size) || $t(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family;
}
function Dx(t, e, i, a, o) {
  let c = e[o];
  return c || (c = e[o] = t.measureText(o).width, i.push(o)), c > a && (a = c), a;
}
function VI(t, e, i, a) {
  a = a || {};
  let o = a.data = a.data || {}, c = a.garbageCollect = a.garbageCollect || [];
  a.font !== e && (o = a.data = {}, c = a.garbageCollect = [], a.font = e), t.save(), t.font = e;
  let u = 0;
  const h = i.length;
  let m, v, b, S, w;
  for (m = 0; m < h; m++)
    if (S = i[m], S != null && !Kn(S))
      u = Dx(t, o, c, u, S);
    else if (Kn(S))
      for (v = 0, b = S.length; v < b; v++)
        w = S[v], w != null && !Kn(w) && (u = Dx(t, o, c, u, w));
  t.restore();
  const E = c.length / 2;
  if (E > i.length) {
    for (m = 0; m < E; m++)
      delete o[c[m]];
    c.splice(0, E);
  }
  return u;
}
function Rf(t, e, i) {
  const a = t.currentDevicePixelRatio, o = i !== 0 ? Math.max(i / 2, 0.5) : 0;
  return Math.round((e - o) * a) / a + o;
}
function HM(t, e) {
  !e && !t || (e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore());
}
function LT(t, e, i, a) {
  SL(t, e, i, a, null);
}
function SL(t, e, i, a, o) {
  let c, u, h, m, v, b, S, w;
  const E = e.pointStyle, R = e.rotation, M = e.radius;
  let A = (R || 0) * yI;
  if (E && typeof E == "object" && (c = E.toString(), c === "[object HTMLImageElement]" || c === "[object HTMLCanvasElement]")) {
    t.save(), t.translate(i, a), t.rotate(A), t.drawImage(E, -E.width / 2, -E.height / 2, E.width, E.height), t.restore();
    return;
  }
  if (!(isNaN(M) || M <= 0)) {
    switch (t.beginPath(), E) {
      // Default includes circle
      default:
        o ? t.ellipse(i, a, o / 2, M, 0, 0, Un) : t.arc(i, a, M, 0, Un), t.closePath();
        break;
      case "triangle":
        b = o ? o / 2 : M, t.moveTo(i + Math.sin(A) * b, a - Math.cos(A) * M), A += PM, t.lineTo(i + Math.sin(A) * b, a - Math.cos(A) * M), A += PM, t.lineTo(i + Math.sin(A) * b, a - Math.cos(A) * M), t.closePath();
        break;
      case "rectRounded":
        v = M * 0.516, m = M - v, u = Math.cos(A + Df) * m, S = Math.cos(A + Df) * (o ? o / 2 - v : m), h = Math.sin(A + Df) * m, w = Math.sin(A + Df) * (o ? o / 2 - v : m), t.arc(i - S, a - h, v, A - In, A - Ti), t.arc(i + w, a - u, v, A - Ti, A), t.arc(i + S, a + h, v, A, A + Ti), t.arc(i - w, a + u, v, A + Ti, A + In), t.closePath();
        break;
      case "rect":
        if (!R) {
          m = Math.SQRT1_2 * M, b = o ? o / 2 : m, t.rect(i - b, a - m, 2 * b, 2 * m);
          break;
        }
        A += Df;
      /* falls through */
      case "rectRot":
        S = Math.cos(A) * (o ? o / 2 : M), u = Math.cos(A) * M, h = Math.sin(A) * M, w = Math.sin(A) * (o ? o / 2 : M), t.moveTo(i - S, a - h), t.lineTo(i + w, a - u), t.lineTo(i + S, a + h), t.lineTo(i - w, a + u), t.closePath();
        break;
      case "crossRot":
        A += Df;
      /* falls through */
      case "cross":
        S = Math.cos(A) * (o ? o / 2 : M), u = Math.cos(A) * M, h = Math.sin(A) * M, w = Math.sin(A) * (o ? o / 2 : M), t.moveTo(i - S, a - h), t.lineTo(i + S, a + h), t.moveTo(i + w, a - u), t.lineTo(i - w, a + u);
        break;
      case "star":
        S = Math.cos(A) * (o ? o / 2 : M), u = Math.cos(A) * M, h = Math.sin(A) * M, w = Math.sin(A) * (o ? o / 2 : M), t.moveTo(i - S, a - h), t.lineTo(i + S, a + h), t.moveTo(i + w, a - u), t.lineTo(i - w, a + u), A += Df, S = Math.cos(A) * (o ? o / 2 : M), u = Math.cos(A) * M, h = Math.sin(A) * M, w = Math.sin(A) * (o ? o / 2 : M), t.moveTo(i - S, a - h), t.lineTo(i + S, a + h), t.moveTo(i + w, a - u), t.lineTo(i - w, a + u);
        break;
      case "line":
        u = o ? o / 2 : Math.cos(A) * M, h = Math.sin(A) * M, t.moveTo(i - u, a - h), t.lineTo(i + u, a + h);
        break;
      case "dash":
        t.moveTo(i, a), t.lineTo(i + Math.cos(A) * (o ? o / 2 : M), a + Math.sin(A) * M);
        break;
      case !1:
        t.closePath();
        break;
    }
    t.fill(), e.borderWidth > 0 && t.stroke();
  }
}
function Yl(t, e, i) {
  return i = i || 0.5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i;
}
function Zx(t, e) {
  t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();
}
function Jx(t) {
  t.restore();
}
function jI(t, e, i, a, o) {
  if (!e)
    return t.lineTo(i.x, i.y);
  if (o === "middle") {
    const c = (e.x + i.x) / 2;
    t.lineTo(c, e.y), t.lineTo(c, i.y);
  } else o === "after" != !!a ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
  t.lineTo(i.x, i.y);
}
function BI(t, e, i, a) {
  if (!e)
    return t.lineTo(i.x, i.y);
  t.bezierCurveTo(a ? e.cp1x : e.cp2x, a ? e.cp1y : e.cp2y, a ? i.cp2x : i.cp1x, a ? i.cp2y : i.cp1y, i.x, i.y);
}
function HI(t, e) {
  e.translation && t.translate(e.translation[0], e.translation[1]), $t(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline);
}
function UI(t, e, i, a, o) {
  if (o.strikethrough || o.underline) {
    const c = t.measureText(a), u = e - c.actualBoundingBoxLeft, h = e + c.actualBoundingBoxRight, m = i - c.actualBoundingBoxAscent, v = i + c.actualBoundingBoxDescent, b = o.strikethrough ? (m + v) / 2 : v;
    t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = o.decorationWidth || 2, t.moveTo(u, b), t.lineTo(h, b), t.stroke();
  }
}
function II(t, e) {
  const i = t.fillStyle;
  t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i;
}
function Wf(t, e, i, a, o, c = {}) {
  const u = Kn(e) ? e : [
    e
  ], h = c.strokeWidth > 0 && c.strokeColor !== "";
  let m, v;
  for (t.save(), t.font = o.string, HI(t, c), m = 0; m < u.length; ++m)
    v = u[m], c.backdrop && II(t, c.backdrop), h && (c.strokeColor && (t.strokeStyle = c.strokeColor), $t(c.strokeWidth) || (t.lineWidth = c.strokeWidth), t.strokeText(v, i, a, c.maxWidth)), t.fillText(v, i, a, c.maxWidth), UI(t, i, a, v, c), a += Number(o.lineHeight);
  t.restore();
}
function mv(t, e) {
  const { x: i, y: a, w: o, h: c, radius: u } = e;
  t.arc(i + u.topLeft, a + u.topLeft, u.topLeft, 1.5 * In, In, !0), t.lineTo(i, a + c - u.bottomLeft), t.arc(i + u.bottomLeft, a + c - u.bottomLeft, u.bottomLeft, In, Ti, !0), t.lineTo(i + o - u.bottomRight, a + c), t.arc(i + o - u.bottomRight, a + c - u.bottomRight, u.bottomRight, Ti, 0, !0), t.lineTo(i + o, a + u.topRight), t.arc(i + o - u.topRight, a + u.topRight, u.topRight, 0, -Ti, !0), t.lineTo(i + u.topLeft, a);
}
const $I = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, WI = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function YI(t, e) {
  const i = ("" + t).match($I);
  if (!i || i[1] === "normal")
    return e * 1.2;
  switch (t = +i[2], i[3]) {
    case "px":
      return t;
    case "%":
      t /= 100;
      break;
  }
  return e * t;
}
const GI = (t) => +t || 0;
function jE(t, e) {
  const i = {}, a = qt(e), o = a ? Object.keys(e) : e, c = qt(t) ? a ? (u) => zt(t[u], t[e[u]]) : (u) => t[u] : () => t;
  for (const u of o)
    i[u] = GI(c(u));
  return i;
}
function _L(t) {
  return jE(t, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Bf(t) {
  return jE(t, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Br(t) {
  const e = _L(t);
  return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
}
function Ki(t, e) {
  t = t || {}, e = e || Qn.font;
  let i = zt(t.size, e.size);
  typeof i == "string" && (i = parseInt(i, 10));
  let a = zt(t.style, e.style);
  a && !("" + a).match(WI) && (console.warn('Invalid font style specified: "' + a + '"'), a = void 0);
  const o = {
    family: zt(t.family, e.family),
    lineHeight: YI(zt(t.lineHeight, e.lineHeight), i),
    size: i,
    style: a,
    weight: zt(t.weight, e.weight),
    string: ""
  };
  return o.string = FI(o), o;
}
function Yg(t, e, i, a) {
  let o, c, u;
  for (o = 0, c = t.length; o < c; ++o)
    if (u = t[o], u !== void 0 && u !== void 0)
      return u;
}
function KI(t, e, i) {
  const { min: a, max: o } = t, c = cL(e, (o - a) / 2), u = (h, m) => i && h === 0 ? 0 : h + m;
  return {
    min: u(a, -Math.abs(c)),
    max: u(o, c)
  };
}
function ac(t, e) {
  return Object.assign(Object.create(t), e);
}
function BE(t, e = [
  ""
], i, a, o = () => t[0]) {
  const c = i || t;
  typeof a > "u" && (a = EL("_fallback", t));
  const u = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: t,
    _rootScopes: c,
    _fallback: a,
    _getTarget: o,
    override: (h) => BE([
      h,
      ...t
    ], e, c, a)
  };
  return new Proxy(u, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(h, m) {
      return delete h[m], delete h._keys, delete t[0][m], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(h, m) {
      return CL(h, m, () => n$(m, e, t, h));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(h, m) {
      return Reflect.getOwnPropertyDescriptor(h._scopes[0], m);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(h, m) {
      return IM(h).includes(m);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(h) {
      return IM(h);
    },
    /**
    * A trap for setting property values.
    */
    set(h, m, v) {
      const b = h._storage || (h._storage = o());
      return h[m] = b[m] = v, delete h._keys, !0;
    }
  });
}
function sp(t, e, i, a) {
  const o = {
    _cacheable: !1,
    _proxy: t,
    _context: e,
    _subProxy: i,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: wL(t, a),
    setContext: (c) => sp(t, c, i, a),
    override: (c) => sp(t.override(c), e, i, a)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(c, u) {
      return delete c[u], delete t[u], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(c, u, h) {
      return CL(c, u, () => QI(c, u, h));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(c, u) {
      return c._descriptors.allKeys ? Reflect.has(t, u) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(t, u);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t);
    },
    /**
    * A trap for the in operator.
    */
    has(c, u) {
      return Reflect.has(t, u);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(t);
    },
    /**
    * A trap for setting property values.
    */
    set(c, u, h) {
      return t[u] = h, delete c[u], !0;
    }
  });
}
function wL(t, e = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: i = e.scriptable, _indexable: a = e.indexable, _allKeys: o = e.allKeys } = t;
  return {
    allKeys: o,
    scriptable: i,
    indexable: a,
    isScriptable: tc(i) ? i : () => i,
    isIndexable: tc(a) ? a : () => a
  };
}
const XI = (t, e) => t ? t + LE(e) : e, HE = (t, e) => qt(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
function CL(t, e, i) {
  if (Object.prototype.hasOwnProperty.call(t, e) || e === "constructor")
    return t[e];
  const a = i();
  return t[e] = a, a;
}
function QI(t, e, i) {
  const { _proxy: a, _context: o, _subProxy: c, _descriptors: u } = t;
  let h = a[e];
  return tc(h) && u.isScriptable(e) && (h = qI(e, h, t, i)), Kn(h) && h.length && (h = ZI(e, h, t, u.isIndexable)), HE(e, h) && (h = sp(h, o, c && c[e], u)), h;
}
function qI(t, e, i, a) {
  const { _proxy: o, _context: c, _subProxy: u, _stack: h } = i;
  if (h.has(t))
    throw new Error("Recursion detected: " + Array.from(h).join("->") + "->" + t);
  h.add(t);
  let m = e(c, u || a);
  return h.delete(t), HE(t, m) && (m = UE(o._scopes, o, t, m)), m;
}
function ZI(t, e, i, a) {
  const { _proxy: o, _context: c, _subProxy: u, _descriptors: h } = i;
  if (typeof c.index < "u" && a(t))
    return e[c.index % e.length];
  if (qt(e[0])) {
    const m = e, v = o._scopes.filter((b) => b !== m);
    e = [];
    for (const b of m) {
      const S = UE(v, o, t, b);
      e.push(sp(S, c, u && u[t], h));
    }
  }
  return e;
}
function TL(t, e, i) {
  return tc(t) ? t(e, i) : t;
}
const JI = (t, e) => t === !0 ? e : typeof t == "string" ? ec(e, t) : void 0;
function e$(t, e, i, a, o) {
  for (const c of e) {
    const u = JI(i, c);
    if (u) {
      t.add(u);
      const h = TL(u._fallback, i, o);
      if (typeof h < "u" && h !== i && h !== a)
        return h;
    } else if (u === !1 && typeof a < "u" && i !== a)
      return null;
  }
  return !1;
}
function UE(t, e, i, a) {
  const o = e._rootScopes, c = TL(e._fallback, i, a), u = [
    ...t,
    ...o
  ], h = /* @__PURE__ */ new Set();
  h.add(a);
  let m = UM(h, u, i, c || i, a);
  return m === null || typeof c < "u" && c !== i && (m = UM(h, u, c, m, a), m === null) ? !1 : BE(Array.from(h), [
    ""
  ], o, c, () => t$(e, i, a));
}
function UM(t, e, i, a, o) {
  for (; i; )
    i = e$(t, e, i, a, o);
  return i;
}
function t$(t, e, i) {
  const a = t._getTarget();
  e in a || (a[e] = {});
  const o = a[e];
  return Kn(o) && qt(i) ? i : o || {};
}
function n$(t, e, i, a) {
  let o;
  for (const c of e)
    if (o = EL(XI(c, t), i), typeof o < "u")
      return HE(t, o) ? UE(i, a, t, o) : o;
}
function EL(t, e) {
  for (const i of e) {
    if (!i)
      continue;
    const a = i[t];
    if (typeof a < "u")
      return a;
  }
}
function IM(t) {
  let e = t._keys;
  return e || (e = t._keys = i$(t._scopes)), e;
}
function i$(t) {
  const e = /* @__PURE__ */ new Set();
  for (const i of t)
    for (const a of Object.keys(i).filter((o) => !o.startsWith("_")))
      e.add(a);
  return Array.from(e);
}
function DL(t, e, i, a) {
  const { iScale: o } = t, { key: c = "r" } = this._parsing, u = new Array(a);
  let h, m, v, b;
  for (h = 0, m = a; h < m; ++h)
    v = h + i, b = e[v], u[h] = {
      r: o.parse(ec(b, c), v)
    };
  return u;
}
const r$ = Number.EPSILON || 1e-14, op = (t, e) => e < t.length && !t[e].skip && t[e], RL = (t) => t === "x" ? "y" : "x";
function a$(t, e, i, a) {
  const o = t.skip ? e : t, c = e, u = i.skip ? e : i, h = OT(c, o), m = OT(u, c);
  let v = h / (h + m), b = m / (h + m);
  v = isNaN(v) ? 0 : v, b = isNaN(b) ? 0 : b;
  const S = a * v, w = a * b;
  return {
    previous: {
      x: c.x - S * (u.x - o.x),
      y: c.y - S * (u.y - o.y)
    },
    next: {
      x: c.x + w * (u.x - o.x),
      y: c.y + w * (u.y - o.y)
    }
  };
}
function s$(t, e, i) {
  const a = t.length;
  let o, c, u, h, m, v = op(t, 0);
  for (let b = 0; b < a - 1; ++b)
    if (m = v, v = op(t, b + 1), !(!m || !v)) {
      if (nv(e[b], 0, r$)) {
        i[b] = i[b + 1] = 0;
        continue;
      }
      o = i[b] / e[b], c = i[b + 1] / e[b], h = Math.pow(o, 2) + Math.pow(c, 2), !(h <= 9) && (u = 3 / Math.sqrt(h), i[b] = o * u * e[b], i[b + 1] = c * u * e[b]);
    }
}
function o$(t, e, i = "x") {
  const a = RL(i), o = t.length;
  let c, u, h, m = op(t, 0);
  for (let v = 0; v < o; ++v) {
    if (u = h, h = m, m = op(t, v + 1), !h)
      continue;
    const b = h[i], S = h[a];
    u && (c = (b - u[i]) / 3, h[`cp1${i}`] = b - c, h[`cp1${a}`] = S - c * e[v]), m && (c = (m[i] - b) / 3, h[`cp2${i}`] = b + c, h[`cp2${a}`] = S + c * e[v]);
  }
}
function l$(t, e = "x") {
  const i = RL(e), a = t.length, o = Array(a).fill(0), c = Array(a);
  let u, h, m, v = op(t, 0);
  for (u = 0; u < a; ++u)
    if (h = m, m = v, v = op(t, u + 1), !!m) {
      if (v) {
        const b = v[e] - m[e];
        o[u] = b !== 0 ? (v[i] - m[i]) / b : 0;
      }
      c[u] = h ? v ? jo(o[u - 1]) !== jo(o[u]) ? 0 : (o[u - 1] + o[u]) / 2 : o[u - 1] : o[u];
    }
  s$(t, o, c), o$(t, c, e);
}
function Ub(t, e, i) {
  return Math.max(Math.min(t, i), e);
}
function u$(t, e) {
  let i, a, o, c, u, h = Yl(t[0], e);
  for (i = 0, a = t.length; i < a; ++i)
    u = c, c = h, h = i < a - 1 && Yl(t[i + 1], e), c && (o = t[i], u && (o.cp1x = Ub(o.cp1x, e.left, e.right), o.cp1y = Ub(o.cp1y, e.top, e.bottom)), h && (o.cp2x = Ub(o.cp2x, e.left, e.right), o.cp2y = Ub(o.cp2y, e.top, e.bottom)));
}
function c$(t, e, i, a, o) {
  let c, u, h, m;
  if (e.spanGaps && (t = t.filter((v) => !v.skip)), e.cubicInterpolationMode === "monotone")
    l$(t, o);
  else {
    let v = a ? t[t.length - 1] : t[0];
    for (c = 0, u = t.length; c < u; ++c)
      h = t[c], m = a$(v, h, t[Math.min(c + 1, u - (a ? 0 : 1)) % u], e.tension), h.cp1x = m.previous.x, h.cp1y = m.previous.y, h.cp2x = m.next.x, h.cp2y = m.next.y, v = h;
  }
  e.capBezierPoints && u$(t, i);
}
function IE() {
  return typeof window < "u" && typeof document < "u";
}
function $E(t) {
  let e = t.parentNode;
  return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
}
function Rx(t, e, i) {
  let a;
  return typeof t == "string" ? (a = parseInt(t, 10), t.indexOf("%") !== -1 && (a = a / 100 * e.parentNode[i])) : a = t, a;
}
const eS = (t) => t.ownerDocument.defaultView.getComputedStyle(t, null);
function f$(t, e) {
  return eS(t).getPropertyValue(e);
}
const d$ = [
  "top",
  "right",
  "bottom",
  "left"
];
function Hf(t, e, i) {
  const a = {};
  i = i ? "-" + i : "";
  for (let o = 0; o < 4; o++) {
    const c = d$[o];
    a[c] = parseFloat(t[e + "-" + c + i]) || 0;
  }
  return a.width = a.left + a.right, a.height = a.top + a.bottom, a;
}
const h$ = (t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot);
function p$(t, e) {
  const i = t.touches, a = i && i.length ? i[0] : t, { offsetX: o, offsetY: c } = a;
  let u = !1, h, m;
  if (h$(o, c, t.target))
    h = o, m = c;
  else {
    const v = e.getBoundingClientRect();
    h = a.clientX - v.left, m = a.clientY - v.top, u = !0;
  }
  return {
    x: h,
    y: m,
    box: u
  };
}
function Pf(t, e) {
  if ("native" in t)
    return t;
  const { canvas: i, currentDevicePixelRatio: a } = e, o = eS(i), c = o.boxSizing === "border-box", u = Hf(o, "padding"), h = Hf(o, "border", "width"), { x: m, y: v, box: b } = p$(t, i), S = u.left + (b && h.left), w = u.top + (b && h.top);
  let { width: E, height: R } = e;
  return c && (E -= u.width + h.width, R -= u.height + h.height), {
    x: Math.round((m - S) / E * i.width / a),
    y: Math.round((v - w) / R * i.height / a)
  };
}
function m$(t, e, i) {
  let a, o;
  if (e === void 0 || i === void 0) {
    const c = t && $E(t);
    if (!c)
      e = t.clientWidth, i = t.clientHeight;
    else {
      const u = c.getBoundingClientRect(), h = eS(c), m = Hf(h, "border", "width"), v = Hf(h, "padding");
      e = u.width - v.width - m.width, i = u.height - v.height - m.height, a = Rx(h.maxWidth, c, "clientWidth"), o = Rx(h.maxHeight, c, "clientHeight");
    }
  }
  return {
    width: e,
    height: i,
    maxWidth: a || Ex,
    maxHeight: o || Ex
  };
}
const Ib = (t) => Math.round(t * 10) / 10;
function g$(t, e, i, a) {
  const o = eS(t), c = Hf(o, "margin"), u = Rx(o.maxWidth, t, "clientWidth") || Ex, h = Rx(o.maxHeight, t, "clientHeight") || Ex, m = m$(t, e, i);
  let { width: v, height: b } = m;
  if (o.boxSizing === "content-box") {
    const w = Hf(o, "border", "width"), E = Hf(o, "padding");
    v -= E.width + w.width, b -= E.height + w.height;
  }
  return v = Math.max(0, v - c.width), b = Math.max(0, a ? v / a : b - c.height), v = Ib(Math.min(v, u, m.maxWidth)), b = Ib(Math.min(b, h, m.maxHeight)), v && !b && (b = Ib(v / 2)), (e !== void 0 || i !== void 0) && a && m.height && b > m.height && (b = m.height, v = Ib(Math.floor(b * a))), {
    width: v,
    height: b
  };
}
function $M(t, e, i) {
  const a = e || 1, o = Math.floor(t.height * a), c = Math.floor(t.width * a);
  t.height = Math.floor(t.height), t.width = Math.floor(t.width);
  const u = t.canvas;
  return u.style && (i || !u.style.height && !u.style.width) && (u.style.height = `${t.height}px`, u.style.width = `${t.width}px`), t.currentDevicePixelRatio !== a || u.height !== o || u.width !== c ? (t.currentDevicePixelRatio = a, u.height = o, u.width = c, t.ctx.setTransform(a, 0, 0, a, 0, 0), !0) : !1;
}
const v$ = function() {
  let t = !1;
  try {
    const e = {
      get passive() {
        return t = !0, !1;
      }
    };
    IE() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e));
  } catch {
  }
  return t;
}();
function WM(t, e) {
  const i = f$(t, e), a = i && i.match(/^(\d+)(\.\d+)?px$/);
  return a ? +a[1] : void 0;
}
function Lf(t, e, i, a) {
  return {
    x: t.x + i * (e.x - t.x),
    y: t.y + i * (e.y - t.y)
  };
}
function y$(t, e, i, a) {
  return {
    x: t.x + i * (e.x - t.x),
    y: a === "middle" ? i < 0.5 ? t.y : e.y : a === "after" ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y
  };
}
function b$(t, e, i, a) {
  const o = {
    x: t.cp2x,
    y: t.cp2y
  }, c = {
    x: e.cp1x,
    y: e.cp1y
  }, u = Lf(t, o, i), h = Lf(o, c, i), m = Lf(c, e, i), v = Lf(u, h, i), b = Lf(h, m, i);
  return Lf(v, b, i);
}
const x$ = function(t, e) {
  return {
    x(i) {
      return t + t + e - i;
    },
    setWidth(i) {
      e = i;
    },
    textAlign(i) {
      return i === "center" ? i : i === "right" ? "left" : "right";
    },
    xPlus(i, a) {
      return i - a;
    },
    leftForLtr(i, a) {
      return i - a;
    }
  };
}, S$ = function() {
  return {
    x(t) {
      return t;
    },
    setWidth(t) {
    },
    textAlign(t) {
      return t;
    },
    xPlus(t, e) {
      return t + e;
    },
    leftForLtr(t, e) {
      return t;
    }
  };
};
function tp(t, e, i) {
  return t ? x$(e, i) : S$();
}
function kL(t, e) {
  let i, a;
  (e === "ltr" || e === "rtl") && (i = t.canvas.style, a = [
    i.getPropertyValue("direction"),
    i.getPropertyPriority("direction")
  ], i.setProperty("direction", e, "important"), t.prevTextDirection = a);
}
function ML(t, e) {
  e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]));
}
function AL(t) {
  return t === "angle" ? {
    between: pv,
    compare: _I,
    normalize: Ia
  } : {
    between: $l,
    compare: (e, i) => e - i,
    normalize: (e) => e
  };
}
function YM({ start: t, end: e, count: i, loop: a, style: o }) {
  return {
    start: t % i,
    end: e % i,
    loop: a && (e - t + 1) % i === 0,
    style: o
  };
}
function _$(t, e, i) {
  const { property: a, start: o, end: c } = i, { between: u, normalize: h } = AL(a), m = e.length;
  let { start: v, end: b, loop: S } = t, w, E;
  if (S) {
    for (v += m, b += m, w = 0, E = m; w < E && u(h(e[v % m][a]), o, c); ++w)
      v--, b--;
    v %= m, b %= m;
  }
  return b < v && (b += m), {
    start: v,
    end: b,
    loop: S,
    style: t.style
  };
}
function OL(t, e, i) {
  if (!i)
    return [
      t
    ];
  const { property: a, start: o, end: c } = i, u = e.length, { compare: h, between: m, normalize: v } = AL(a), { start: b, end: S, loop: w, style: E } = _$(t, e, i), R = [];
  let M = !1, A = null, P, z, B;
  const j = () => m(o, B, P) && h(o, B) !== 0, F = () => h(c, P) === 0 || m(c, B, P), $ = () => M || j(), I = () => !M || F();
  for (let K = b, ee = b; K <= S; ++K)
    z = e[K % u], !z.skip && (P = v(z[a]), P !== B && (M = m(P, o, c), A === null && $() && (A = h(P, o) === 0 ? K : ee), A !== null && I() && (R.push(YM({
      start: A,
      end: K,
      loop: w,
      count: u,
      style: E
    })), A = null), ee = K, B = P));
  return A !== null && R.push(YM({
    start: A,
    end: S,
    loop: w,
    count: u,
    style: E
  })), R;
}
function PL(t, e) {
  const i = [], a = t.segments;
  for (let o = 0; o < a.length; o++) {
    const c = OL(a[o], t.points, e);
    c.length && i.push(...c);
  }
  return i;
}
function w$(t, e, i, a) {
  let o = 0, c = e - 1;
  if (i && !a)
    for (; o < e && !t[o].skip; )
      o++;
  for (; o < e && t[o].skip; )
    o++;
  for (o %= e, i && (c += o); c > o && t[c % e].skip; )
    c--;
  return c %= e, {
    start: o,
    end: c
  };
}
function C$(t, e, i, a) {
  const o = t.length, c = [];
  let u = e, h = t[e], m;
  for (m = e + 1; m <= i; ++m) {
    const v = t[m % o];
    v.skip || v.stop ? h.skip || (a = !1, c.push({
      start: e % o,
      end: (m - 1) % o,
      loop: a
    }), e = u = v.stop ? m : null) : (u = m, h.skip && (e = m)), h = v;
  }
  return u !== null && c.push({
    start: e % o,
    end: u % o,
    loop: a
  }), c;
}
function T$(t, e) {
  const i = t.points, a = t.options.spanGaps, o = i.length;
  if (!o)
    return [];
  const c = !!t._loop, { start: u, end: h } = w$(i, o, c, a);
  if (a === !0)
    return GM(t, [
      {
        start: u,
        end: h,
        loop: c
      }
    ], i, e);
  const m = h < u ? h + o : h, v = !!t._fullLoop && u === 0 && h === o - 1;
  return GM(t, C$(i, u, m, v), i, e);
}
function GM(t, e, i, a) {
  return !a || !a.setContext || !i ? e : E$(t, e, i, a);
}
function E$(t, e, i, a) {
  const o = t._chart.getContext(), c = KM(t.options), { _datasetIndex: u, options: { spanGaps: h } } = t, m = i.length, v = [];
  let b = c, S = e[0].start, w = S;
  function E(R, M, A, P) {
    const z = h ? -1 : 1;
    if (R !== M) {
      for (R += m; i[R % m].skip; )
        R -= z;
      for (; i[M % m].skip; )
        M += z;
      R % m !== M % m && (v.push({
        start: R % m,
        end: M % m,
        loop: A,
        style: P
      }), b = P, S = M % m);
    }
  }
  for (const R of e) {
    S = h ? S : R.start;
    let M = i[S % m], A;
    for (w = S + 1; w <= R.end; w++) {
      const P = i[w % m];
      A = KM(a.setContext(ac(o, {
        type: "segment",
        p0: M,
        p1: P,
        p0DataIndex: (w - 1) % m,
        p1DataIndex: w % m,
        datasetIndex: u
      }))), D$(A, b) && E(S, w - 1, R.loop, b), M = P, b = A;
    }
    S < w - 1 && E(S, w - 1, R.loop, b);
  }
  return v;
}
function KM(t) {
  return {
    backgroundColor: t.backgroundColor,
    borderCapStyle: t.borderCapStyle,
    borderDash: t.borderDash,
    borderDashOffset: t.borderDashOffset,
    borderJoinStyle: t.borderJoinStyle,
    borderWidth: t.borderWidth,
    borderColor: t.borderColor
  };
}
function D$(t, e) {
  if (!e)
    return !1;
  const i = [], a = function(o, c) {
    return VE(c) ? (i.includes(c) || i.push(c), i.indexOf(c)) : c;
  };
  return JSON.stringify(t, a) !== JSON.stringify(e, a);
}
/*!
 * Chart.js v4.4.8
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
class R$ {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(e, i, a, o) {
    const c = i.listeners[o], u = i.duration;
    c.forEach((h) => h({
      chart: e,
      initial: i.initial,
      numSteps: u,
      currentStep: Math.min(a - i.start, u)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = gL.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(e = Date.now()) {
    let i = 0;
    this._charts.forEach((a, o) => {
      if (!a.running || !a.items.length)
        return;
      const c = a.items;
      let u = c.length - 1, h = !1, m;
      for (; u >= 0; --u)
        m = c[u], m._active ? (m._total > a.duration && (a.duration = m._total), m.tick(e), h = !0) : (c[u] = c[c.length - 1], c.pop());
      h && (o.draw(), this._notify(o, a, e, "progress")), c.length || (a.running = !1, this._notify(o, a, e, "complete"), a.initial = !1), i += c.length;
    }), this._lastDate = e, i === 0 && (this._running = !1);
  }
  _getAnims(e) {
    const i = this._charts;
    let a = i.get(e);
    return a || (a = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, i.set(e, a)), a;
  }
  listen(e, i, a) {
    this._getAnims(e).listeners[i].push(a);
  }
  add(e, i) {
    !i || !i.length || this._getAnims(e).items.push(...i);
  }
  has(e) {
    return this._getAnims(e).items.length > 0;
  }
  start(e) {
    const i = this._charts.get(e);
    i && (i.running = !0, i.start = Date.now(), i.duration = i.items.reduce((a, o) => Math.max(a, o._duration), 0), this._refresh());
  }
  running(e) {
    if (!this._running)
      return !1;
    const i = this._charts.get(e);
    return !(!i || !i.running || !i.items.length);
  }
  stop(e) {
    const i = this._charts.get(e);
    if (!i || !i.items.length)
      return;
    const a = i.items;
    let o = a.length - 1;
    for (; o >= 0; --o)
      a[o].cancel();
    i.items = [], this._notify(e, i, Date.now(), "complete");
  }
  remove(e) {
    return this._charts.delete(e);
  }
}
var jl = /* @__PURE__ */ new R$();
const XM = "transparent", k$ = {
  boolean(t, e, i) {
    return i > 0.5 ? e : t;
  },
  color(t, e, i) {
    const a = jM(t || XM), o = a.valid && jM(e || XM);
    return o && o.valid ? o.mix(a, i).hexString() : e;
  },
  number(t, e, i) {
    return t + (e - t) * i;
  }
};
class M$ {
  constructor(e, i, a, o) {
    const c = i[a];
    o = Yg([
      e.to,
      o,
      c,
      e.from
    ]);
    const u = Yg([
      e.from,
      c,
      o
    ]);
    this._active = !0, this._fn = e.fn || k$[e.type || typeof u], this._easing = iv[e.easing] || iv.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = i, this._prop = a, this._from = u, this._to = o, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(e, i, a) {
    if (this._active) {
      this._notify(!1);
      const o = this._target[this._prop], c = a - this._start, u = this._duration - c;
      this._start = a, this._duration = Math.floor(Math.max(u, e.duration)), this._total += c, this._loop = !!e.loop, this._to = Yg([
        e.to,
        i,
        o,
        e.from
      ]), this._from = Yg([
        e.from,
        o,
        i
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(e) {
    const i = e - this._start, a = this._duration, o = this._prop, c = this._from, u = this._loop, h = this._to;
    let m;
    if (this._active = c !== h && (u || i < a), !this._active) {
      this._target[o] = h, this._notify(!0);
      return;
    }
    if (i < 0) {
      this._target[o] = c;
      return;
    }
    m = i / a % 2, m = u && m > 1 ? 2 - m : m, m = this._easing(Math.min(1, Math.max(0, m))), this._target[o] = this._fn(c, h, m);
  }
  wait() {
    const e = this._promises || (this._promises = []);
    return new Promise((i, a) => {
      e.push({
        res: i,
        rej: a
      });
    });
  }
  _notify(e) {
    const i = e ? "res" : "rej", a = this._promises || [];
    for (let o = 0; o < a.length; o++)
      a[o][i]();
  }
}
class LL {
  constructor(e, i) {
    this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(i);
  }
  configure(e) {
    if (!qt(e))
      return;
    const i = Object.keys(Qn.animation), a = this._properties;
    Object.getOwnPropertyNames(e).forEach((o) => {
      const c = e[o];
      if (!qt(c))
        return;
      const u = {};
      for (const h of i)
        u[h] = c[h];
      (Kn(c.properties) && c.properties || [
        o
      ]).forEach((h) => {
        (h === o || !a.has(h)) && a.set(h, u);
      });
    });
  }
  _animateOptions(e, i) {
    const a = i.options, o = O$(e, a);
    if (!o)
      return [];
    const c = this._createAnimations(o, a);
    return a.$shared && A$(e.options.$animations, a).then(() => {
      e.options = a;
    }, () => {
    }), c;
  }
  _createAnimations(e, i) {
    const a = this._properties, o = [], c = e.$animations || (e.$animations = {}), u = Object.keys(i), h = Date.now();
    let m;
    for (m = u.length - 1; m >= 0; --m) {
      const v = u[m];
      if (v.charAt(0) === "$")
        continue;
      if (v === "options") {
        o.push(...this._animateOptions(e, i));
        continue;
      }
      const b = i[v];
      let S = c[v];
      const w = a.get(v);
      if (S)
        if (w && S.active()) {
          S.update(w, b, h);
          continue;
        } else
          S.cancel();
      if (!w || !w.duration) {
        e[v] = b;
        continue;
      }
      c[v] = S = new M$(w, e, v, b), o.push(S);
    }
    return o;
  }
  update(e, i) {
    if (this._properties.size === 0) {
      Object.assign(e, i);
      return;
    }
    const a = this._createAnimations(e, i);
    if (a.length)
      return jl.add(this._chart, a), !0;
  }
}
function A$(t, e) {
  const i = [], a = Object.keys(e);
  for (let o = 0; o < a.length; o++) {
    const c = t[a[o]];
    c && c.active() && i.push(c.wait());
  }
  return Promise.all(i);
}
function O$(t, e) {
  if (!e)
    return;
  let i = t.options;
  if (!i) {
    t.options = e;
    return;
  }
  return i.$shared && (t.options = i = Object.assign({}, i, {
    $shared: !1,
    $animations: {}
  })), i;
}
function QM(t, e) {
  const i = t && t.options || {}, a = i.reverse, o = i.min === void 0 ? e : 0, c = i.max === void 0 ? e : 0;
  return {
    start: a ? c : o,
    end: a ? o : c
  };
}
function P$(t, e, i) {
  if (i === !1)
    return !1;
  const a = QM(t, i), o = QM(e, i);
  return {
    top: o.end,
    right: a.end,
    bottom: o.start,
    left: a.start
  };
}
function L$(t) {
  let e, i, a, o;
  return qt(t) ? (e = t.top, i = t.right, a = t.bottom, o = t.left) : e = i = a = o = t, {
    top: e,
    right: i,
    bottom: a,
    left: o,
    disabled: t === !1
  };
}
function NL(t, e) {
  const i = [], a = t._getSortedDatasetMetas(e);
  let o, c;
  for (o = 0, c = a.length; o < c; ++o)
    i.push(a[o].index);
  return i;
}
function qM(t, e, i, a = {}) {
  const o = t.keys, c = a.mode === "single";
  let u, h, m, v;
  if (e === null)
    return;
  let b = !1;
  for (u = 0, h = o.length; u < h; ++u) {
    if (m = +o[u], m === i) {
      if (b = !0, a.all)
        continue;
      break;
    }
    v = t.values[m], vi(v) && (c || e === 0 || jo(e) === jo(v)) && (e += v);
  }
  return !b && !a.all ? 0 : e;
}
function N$(t, e) {
  const { iScale: i, vScale: a } = e, o = i.axis === "x" ? "x" : "y", c = a.axis === "x" ? "x" : "y", u = Object.keys(t), h = new Array(u.length);
  let m, v, b;
  for (m = 0, v = u.length; m < v; ++m)
    b = u[m], h[m] = {
      [o]: b,
      [c]: t[b]
    };
  return h;
}
function ZC(t, e) {
  const i = t && t.options.stacked;
  return i || i === void 0 && e.stack !== void 0;
}
function z$(t, e, i) {
  return `${t.id}.${e.id}.${i.stack || i.type}`;
}
function F$(t) {
  const { min: e, max: i, minDefined: a, maxDefined: o } = t.getUserBounds();
  return {
    min: a ? e : Number.NEGATIVE_INFINITY,
    max: o ? i : Number.POSITIVE_INFINITY
  };
}
function V$(t, e, i) {
  const a = t[e] || (t[e] = {});
  return a[i] || (a[i] = {});
}
function ZM(t, e, i, a) {
  for (const o of e.getMatchingVisibleMetas(a).reverse()) {
    const c = t[o.index];
    if (i && c > 0 || !i && c < 0)
      return o.index;
  }
  return null;
}
function JM(t, e) {
  const { chart: i, _cachedMeta: a } = t, o = i._stacks || (i._stacks = {}), { iScale: c, vScale: u, index: h } = a, m = c.axis, v = u.axis, b = z$(c, u, a), S = e.length;
  let w;
  for (let E = 0; E < S; ++E) {
    const R = e[E], { [m]: M, [v]: A } = R, P = R._stacks || (R._stacks = {});
    w = P[v] = V$(o, b, M), w[h] = A, w._top = ZM(w, u, !0, a.type), w._bottom = ZM(w, u, !1, a.type);
    const z = w._visualValues || (w._visualValues = {});
    z[h] = A;
  }
}
function JC(t, e) {
  const i = t.scales;
  return Object.keys(i).filter((a) => i[a].axis === e).shift();
}
function j$(t, e) {
  return ac(t, {
    active: !1,
    dataset: void 0,
    datasetIndex: e,
    index: e,
    mode: "default",
    type: "dataset"
  });
}
function B$(t, e, i) {
  return ac(t, {
    active: !1,
    dataIndex: e,
    parsed: void 0,
    raw: void 0,
    element: i,
    index: e,
    mode: "default",
    type: "data"
  });
}
function Vg(t, e) {
  const i = t.controller.index, a = t.vScale && t.vScale.axis;
  if (a) {
    e = e || t._parsed;
    for (const o of e) {
      const c = o._stacks;
      if (!c || c[a] === void 0 || c[a][i] === void 0)
        return;
      delete c[a][i], c[a]._visualValues !== void 0 && c[a]._visualValues[i] !== void 0 && delete c[a]._visualValues[i];
    }
  }
}
const eT = (t) => t === "reset" || t === "none", eA = (t, e) => e ? t : Object.assign({}, t), H$ = (t, e, i) => t && !e.hidden && e._stacked && {
  keys: NL(i, !0),
  values: null
};
class qs {
  constructor(e, i) {
    this.chart = e, this._ctx = e.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const e = this._cachedMeta;
    this.configure(), this.linkScales(), e._stacked = ZC(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(e) {
    this.index !== e && Vg(this._cachedMeta), this.index = e;
  }
  linkScales() {
    const e = this.chart, i = this._cachedMeta, a = this.getDataset(), o = (S, w, E, R) => S === "x" ? w : S === "r" ? R : E, c = i.xAxisID = zt(a.xAxisID, JC(e, "x")), u = i.yAxisID = zt(a.yAxisID, JC(e, "y")), h = i.rAxisID = zt(a.rAxisID, JC(e, "r")), m = i.indexAxis, v = i.iAxisID = o(m, c, u, h), b = i.vAxisID = o(m, u, c, h);
    i.xScale = this.getScaleForId(c), i.yScale = this.getScaleForId(u), i.rScale = this.getScaleForId(h), i.iScale = this.getScaleForId(v), i.vScale = this.getScaleForId(b);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(e) {
    return this.chart.scales[e];
  }
  _getOtherScale(e) {
    const i = this._cachedMeta;
    return e === i.iScale ? i.vScale : i.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const e = this._cachedMeta;
    this._data && zM(this._data, this), e._stacked && Vg(e);
  }
  _dataCheck() {
    const e = this.getDataset(), i = e.data || (e.data = []), a = this._data;
    if (qt(i)) {
      const o = this._cachedMeta;
      this._data = N$(i, o);
    } else if (a !== i) {
      if (a) {
        zM(a, this);
        const o = this._cachedMeta;
        Vg(o), o._parsed = [];
      }
      i && Object.isExtensible(i) && EI(i, this), this._syncList = [], this._data = i;
    }
  }
  addElements() {
    const e = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(e) {
    const i = this._cachedMeta, a = this.getDataset();
    let o = !1;
    this._dataCheck();
    const c = i._stacked;
    i._stacked = ZC(i.vScale, i), i.stack !== a.stack && (o = !0, Vg(i), i.stack = a.stack), this._resyncElements(e), (o || c !== i._stacked) && (JM(this, i._parsed), i._stacked = ZC(i.vScale, i));
  }
  configure() {
    const e = this.chart.config, i = e.datasetScopeKeys(this._type), a = e.getOptionScopes(this.getDataset(), i, !0);
    this.options = e.createResolver(a, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(e, i) {
    const { _cachedMeta: a, _data: o } = this, { iScale: c, _stacked: u } = a, h = c.axis;
    let m = e === 0 && i === o.length ? !0 : a._sorted, v = e > 0 && a._parsed[e - 1], b, S, w;
    if (this._parsing === !1)
      a._parsed = o, a._sorted = !0, w = o;
    else {
      Kn(o[e]) ? w = this.parseArrayData(a, o, e, i) : qt(o[e]) ? w = this.parseObjectData(a, o, e, i) : w = this.parsePrimitiveData(a, o, e, i);
      const E = () => S[h] === null || v && S[h] < v[h];
      for (b = 0; b < i; ++b)
        a._parsed[b + e] = S = w[b], m && (E() && (m = !1), v = S);
      a._sorted = m;
    }
    u && JM(this, w);
  }
  parsePrimitiveData(e, i, a, o) {
    const { iScale: c, vScale: u } = e, h = c.axis, m = u.axis, v = c.getLabels(), b = c === u, S = new Array(o);
    let w, E, R;
    for (w = 0, E = o; w < E; ++w)
      R = w + a, S[w] = {
        [h]: b || c.parse(v[R], R),
        [m]: u.parse(i[R], R)
      };
    return S;
  }
  parseArrayData(e, i, a, o) {
    const { xScale: c, yScale: u } = e, h = new Array(o);
    let m, v, b, S;
    for (m = 0, v = o; m < v; ++m)
      b = m + a, S = i[b], h[m] = {
        x: c.parse(S[0], b),
        y: u.parse(S[1], b)
      };
    return h;
  }
  parseObjectData(e, i, a, o) {
    const { xScale: c, yScale: u } = e, { xAxisKey: h = "x", yAxisKey: m = "y" } = this._parsing, v = new Array(o);
    let b, S, w, E;
    for (b = 0, S = o; b < S; ++b)
      w = b + a, E = i[w], v[b] = {
        x: c.parse(ec(E, h), w),
        y: u.parse(ec(E, m), w)
      };
    return v;
  }
  getParsed(e) {
    return this._cachedMeta._parsed[e];
  }
  getDataElement(e) {
    return this._cachedMeta.data[e];
  }
  applyStack(e, i, a) {
    const o = this.chart, c = this._cachedMeta, u = i[e.axis], h = {
      keys: NL(o, !0),
      values: i._stacks[e.axis]._visualValues
    };
    return qM(h, u, c.index, {
      mode: a
    });
  }
  updateRangeFromParsed(e, i, a, o) {
    const c = a[i.axis];
    let u = c === null ? NaN : c;
    const h = o && a._stacks[i.axis];
    o && h && (o.values = h, u = qM(o, c, this._cachedMeta.index)), e.min = Math.min(e.min, u), e.max = Math.max(e.max, u);
  }
  getMinMax(e, i) {
    const a = this._cachedMeta, o = a._parsed, c = a._sorted && e === a.iScale, u = o.length, h = this._getOtherScale(e), m = H$(i, a, this.chart), v = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: b, max: S } = F$(h);
    let w, E;
    function R() {
      E = o[w];
      const M = E[h.axis];
      return !vi(E[e.axis]) || b > M || S < M;
    }
    for (w = 0; w < u && !(!R() && (this.updateRangeFromParsed(v, e, E, m), c)); ++w)
      ;
    if (c) {
      for (w = u - 1; w >= 0; --w)
        if (!R()) {
          this.updateRangeFromParsed(v, e, E, m);
          break;
        }
    }
    return v;
  }
  getAllParsedValues(e) {
    const i = this._cachedMeta._parsed, a = [];
    let o, c, u;
    for (o = 0, c = i.length; o < c; ++o)
      u = i[o][e.axis], vi(u) && a.push(u);
    return a;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = i.iScale, o = i.vScale, c = this.getParsed(e);
    return {
      label: a ? "" + a.getLabelForValue(c[a.axis]) : "",
      value: o ? "" + o.getLabelForValue(c[o.axis]) : ""
    };
  }
  _update(e) {
    const i = this._cachedMeta;
    this.update(e || "default"), i._clip = L$(zt(this.options.clip, P$(i.xScale, i.yScale, this.getMaxOverflow())));
  }
  update(e) {
  }
  draw() {
    const e = this._ctx, i = this.chart, a = this._cachedMeta, o = a.data || [], c = i.chartArea, u = [], h = this._drawStart || 0, m = this._drawCount || o.length - h, v = this.options.drawActiveElementsOnTop;
    let b;
    for (a.dataset && a.dataset.draw(e, c, h, m), b = h; b < h + m; ++b) {
      const S = o[b];
      S.hidden || (S.active && v ? u.push(S) : S.draw(e, c));
    }
    for (b = 0; b < u.length; ++b)
      u[b].draw(e, c);
  }
  getStyle(e, i) {
    const a = i ? "active" : "default";
    return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(a) : this.resolveDataElementOptions(e || 0, a);
  }
  getContext(e, i, a) {
    const o = this.getDataset();
    let c;
    if (e >= 0 && e < this._cachedMeta.data.length) {
      const u = this._cachedMeta.data[e];
      c = u.$context || (u.$context = B$(this.getContext(), e, u)), c.parsed = this.getParsed(e), c.raw = o.data[e], c.index = c.dataIndex = e;
    } else
      c = this.$context || (this.$context = j$(this.chart.getContext(), this.index)), c.dataset = o, c.index = c.datasetIndex = this.index;
    return c.active = !!i, c.mode = a, c;
  }
  resolveDatasetElementOptions(e) {
    return this._resolveElementOptions(this.datasetElementType.id, e);
  }
  resolveDataElementOptions(e, i) {
    return this._resolveElementOptions(this.dataElementType.id, i, e);
  }
  _resolveElementOptions(e, i = "default", a) {
    const o = i === "active", c = this._cachedDataOpts, u = e + "-" + i, h = c[u], m = this.enableOptionSharing && hv(a);
    if (h)
      return eA(h, m);
    const v = this.chart.config, b = v.datasetElementScopeKeys(this._type, e), S = o ? [
      `${e}Hover`,
      "hover",
      e,
      ""
    ] : [
      e,
      ""
    ], w = v.getOptionScopes(this.getDataset(), b), E = Object.keys(Qn.elements[e]), R = () => this.getContext(a, o, i), M = v.resolveNamedOptions(w, E, R, S);
    return M.$shared && (M.$shared = m, c[u] = Object.freeze(eA(M, m))), M;
  }
  _resolveAnimations(e, i, a) {
    const o = this.chart, c = this._cachedDataOpts, u = `animation-${i}`, h = c[u];
    if (h)
      return h;
    let m;
    if (o.options.animation !== !1) {
      const b = this.chart.config, S = b.datasetAnimationScopeKeys(this._type, i), w = b.getOptionScopes(this.getDataset(), S);
      m = b.createResolver(w, this.getContext(e, a, i));
    }
    const v = new LL(o, m && m.animations);
    return m && m._cacheable && (c[u] = Object.freeze(v)), v;
  }
  getSharedOptions(e) {
    if (e.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
  }
  includeOptions(e, i) {
    return !i || eT(e) || this.chart._animationsDisabled;
  }
  _getSharedOptions(e, i) {
    const a = this.resolveDataElementOptions(e, i), o = this._sharedOptions, c = this.getSharedOptions(a), u = this.includeOptions(i, c) || c !== o;
    return this.updateSharedOptions(c, i, a), {
      sharedOptions: c,
      includeOptions: u
    };
  }
  updateElement(e, i, a, o) {
    eT(o) ? Object.assign(e, a) : this._resolveAnimations(i, o).update(e, a);
  }
  updateSharedOptions(e, i, a) {
    e && !eT(i) && this._resolveAnimations(void 0, i).update(e, a);
  }
  _setStyle(e, i, a, o) {
    e.active = o;
    const c = this.getStyle(i, o);
    this._resolveAnimations(i, a, o).update(e, {
      options: !o && this.getSharedOptions(c) || c
    });
  }
  removeHoverStyle(e, i, a) {
    this._setStyle(e, a, "active", !1);
  }
  setHoverStyle(e, i, a) {
    this._setStyle(e, a, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !0);
  }
  _resyncElements(e) {
    const i = this._data, a = this._cachedMeta.data;
    for (const [h, m, v] of this._syncList)
      this[h](m, v);
    this._syncList = [];
    const o = a.length, c = i.length, u = Math.min(c, o);
    u && this.parse(0, u), c > o ? this._insertElements(o, c - o, e) : c < o && this._removeElements(c, o - c);
  }
  _insertElements(e, i, a = !0) {
    const o = this._cachedMeta, c = o.data, u = e + i;
    let h;
    const m = (v) => {
      for (v.length += i, h = v.length - 1; h >= u; h--)
        v[h] = v[h - i];
    };
    for (m(c), h = e; h < u; ++h)
      c[h] = new this.dataElementType();
    this._parsing && m(o._parsed), this.parse(e, i), a && this.updateElements(c, e, i, "reset");
  }
  updateElements(e, i, a, o) {
  }
  _removeElements(e, i) {
    const a = this._cachedMeta;
    if (this._parsing) {
      const o = a._parsed.splice(e, i);
      a._stacked && Vg(a, o);
    }
    a.data.splice(e, i);
  }
  _sync(e) {
    if (this._parsing)
      this._syncList.push(e);
    else {
      const [i, a, o] = e;
      this[i](a, o);
    }
    this.chart._dataChanges.push([
      this.index,
      ...e
    ]);
  }
  _onDataPush() {
    const e = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - e,
      e
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(e, i) {
    i && this._sync([
      "_removeElements",
      e,
      i
    ]);
    const a = arguments.length - 2;
    a && this._sync([
      "_insertElements",
      e,
      a
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
Ve(qs, "defaults", {}), Ve(qs, "datasetElementType", null), Ve(qs, "dataElementType", null);
function U$(t, e) {
  if (!t._cache.$bar) {
    const i = t.getMatchingVisibleMetas(e);
    let a = [];
    for (let o = 0, c = i.length; o < c; o++)
      a = a.concat(i[o].controller.getAllParsedValues(t));
    t._cache.$bar = mL(a.sort((o, c) => o - c));
  }
  return t._cache.$bar;
}
function I$(t) {
  const e = t.iScale, i = U$(e, t.type);
  let a = e._length, o, c, u, h;
  const m = () => {
    u === 32767 || u === -32768 || (hv(h) && (a = Math.min(a, Math.abs(u - h) || a)), h = u);
  };
  for (o = 0, c = i.length; o < c; ++o)
    u = e.getPixelForValue(i[o]), m();
  for (h = void 0, o = 0, c = e.ticks.length; o < c; ++o)
    u = e.getPixelForTick(o), m();
  return a;
}
function $$(t, e, i, a) {
  const o = i.barThickness;
  let c, u;
  return $t(o) ? (c = e.min * i.categoryPercentage, u = i.barPercentage) : (c = o * a, u = 1), {
    chunk: c / a,
    ratio: u,
    start: e.pixels[t] - c / 2
  };
}
function W$(t, e, i, a) {
  const o = e.pixels, c = o[t];
  let u = t > 0 ? o[t - 1] : null, h = t < o.length - 1 ? o[t + 1] : null;
  const m = i.categoryPercentage;
  u === null && (u = c - (h === null ? e.end - e.start : h - c)), h === null && (h = c + c - u);
  const v = c - (c - Math.min(u, h)) / 2 * m;
  return {
    chunk: Math.abs(h - u) / 2 * m / a,
    ratio: i.barPercentage,
    start: v
  };
}
function Y$(t, e, i, a) {
  const o = i.parse(t[0], a), c = i.parse(t[1], a), u = Math.min(o, c), h = Math.max(o, c);
  let m = u, v = h;
  Math.abs(u) > Math.abs(h) && (m = h, v = u), e[i.axis] = v, e._custom = {
    barStart: m,
    barEnd: v,
    start: o,
    end: c,
    min: u,
    max: h
  };
}
function zL(t, e, i, a) {
  return Kn(t) ? Y$(t, e, i, a) : e[i.axis] = i.parse(t, a), e;
}
function tA(t, e, i, a) {
  const o = t.iScale, c = t.vScale, u = o.getLabels(), h = o === c, m = [];
  let v, b, S, w;
  for (v = i, b = i + a; v < b; ++v)
    w = e[v], S = {}, S[o.axis] = h || o.parse(u[v], v), m.push(zL(w, S, c, v));
  return m;
}
function tT(t) {
  return t && t.barStart !== void 0 && t.barEnd !== void 0;
}
function G$(t, e, i) {
  return t !== 0 ? jo(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1);
}
function K$(t) {
  let e, i, a, o, c;
  return t.horizontal ? (e = t.base > t.x, i = "left", a = "right") : (e = t.base < t.y, i = "bottom", a = "top"), e ? (o = "end", c = "start") : (o = "start", c = "end"), {
    start: i,
    end: a,
    reverse: e,
    top: o,
    bottom: c
  };
}
function X$(t, e, i, a) {
  let o = e.borderSkipped;
  const c = {};
  if (!o) {
    t.borderSkipped = c;
    return;
  }
  if (o === !0) {
    t.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: u, end: h, reverse: m, top: v, bottom: b } = K$(t);
  o === "middle" && i && (t.enableBorderRadius = !0, (i._top || 0) === a ? o = v : (i._bottom || 0) === a ? o = b : (c[nA(b, u, h, m)] = !0, o = v)), c[nA(o, u, h, m)] = !0, t.borderSkipped = c;
}
function nA(t, e, i, a) {
  return a ? (t = Q$(t, e, i), t = iA(t, i, e)) : t = iA(t, e, i), t;
}
function Q$(t, e, i) {
  return t === e ? i : t === i ? e : t;
}
function iA(t, e, i) {
  return t === "start" ? e : t === "end" ? i : t;
}
function q$(t, { inflateAmount: e }, i) {
  t.inflateAmount = e === "auto" ? i === 1 ? 0.33 : 0 : e;
}
class ux extends qs {
  parsePrimitiveData(e, i, a, o) {
    return tA(e, i, a, o);
  }
  parseArrayData(e, i, a, o) {
    return tA(e, i, a, o);
  }
  parseObjectData(e, i, a, o) {
    const { iScale: c, vScale: u } = e, { xAxisKey: h = "x", yAxisKey: m = "y" } = this._parsing, v = c.axis === "x" ? h : m, b = u.axis === "x" ? h : m, S = [];
    let w, E, R, M;
    for (w = a, E = a + o; w < E; ++w)
      M = i[w], R = {}, R[c.axis] = c.parse(ec(M, v), w), S.push(zL(ec(M, b), R, u, w));
    return S;
  }
  updateRangeFromParsed(e, i, a, o) {
    super.updateRangeFromParsed(e, i, a, o);
    const c = a._custom;
    c && i === this._cachedMeta.vScale && (e.min = Math.min(e.min, c.min), e.max = Math.max(e.max, c.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, { iScale: a, vScale: o } = i, c = this.getParsed(e), u = c._custom, h = tT(u) ? "[" + u.start + ", " + u.end + "]" : "" + o.getLabelForValue(c[o.axis]);
    return {
      label: "" + a.getLabelForValue(c[a.axis]),
      value: h
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const e = this._cachedMeta;
    e.stack = this.getDataset().stack;
  }
  update(e) {
    const i = this._cachedMeta;
    this.updateElements(i.data, 0, i.data.length, e);
  }
  updateElements(e, i, a, o) {
    const c = o === "reset", { index: u, _cachedMeta: { vScale: h } } = this, m = h.getBasePixel(), v = h.isHorizontal(), b = this._getRuler(), { sharedOptions: S, includeOptions: w } = this._getSharedOptions(i, o);
    for (let E = i; E < i + a; E++) {
      const R = this.getParsed(E), M = c || $t(R[h.axis]) ? {
        base: m,
        head: m
      } : this._calculateBarValuePixels(E), A = this._calculateBarIndexPixels(E, b), P = (R._stacks || {})[h.axis], z = {
        horizontal: v,
        base: M.base,
        enableBorderRadius: !P || tT(R._custom) || u === P._top || u === P._bottom,
        x: v ? M.head : A.center,
        y: v ? A.center : M.head,
        height: v ? A.size : Math.abs(M.size),
        width: v ? Math.abs(M.size) : A.size
      };
      w && (z.options = S || this.resolveDataElementOptions(E, e[E].active ? "active" : o));
      const B = z.options || e[E].options;
      X$(z, B, P, u), q$(z, B, b.ratio), this.updateElement(e[E], E, z, o);
    }
  }
  _getStacks(e, i) {
    const { iScale: a } = this._cachedMeta, o = a.getMatchingVisibleMetas(this._type).filter((b) => b.controller.options.grouped), c = a.options.stacked, u = [], h = this._cachedMeta.controller.getParsed(i), m = h && h[a.axis], v = (b) => {
      const S = b._parsed.find((E) => E[a.axis] === m), w = S && S[b.vScale.axis];
      if ($t(w) || isNaN(w))
        return !0;
    };
    for (const b of o)
      if (!(i !== void 0 && v(b)) && ((c === !1 || u.indexOf(b.stack) === -1 || c === void 0 && b.stack === void 0) && u.push(b.stack), b.index === e))
        break;
    return u.length || u.push(void 0), u;
  }
  _getStackCount(e) {
    return this._getStacks(void 0, e).length;
  }
  _getStackIndex(e, i, a) {
    const o = this._getStacks(e, a), c = i !== void 0 ? o.indexOf(i) : -1;
    return c === -1 ? o.length - 1 : c;
  }
  _getRuler() {
    const e = this.options, i = this._cachedMeta, a = i.iScale, o = [];
    let c, u;
    for (c = 0, u = i.data.length; c < u; ++c)
      o.push(a.getPixelForValue(this.getParsed(c)[a.axis], c));
    const h = e.barThickness;
    return {
      min: h || I$(i),
      pixels: o,
      start: a._startPixel,
      end: a._endPixel,
      stackCount: this._getStackCount(),
      scale: a,
      grouped: e.grouped,
      ratio: h ? 1 : e.categoryPercentage * e.barPercentage
    };
  }
  _calculateBarValuePixels(e) {
    const { _cachedMeta: { vScale: i, _stacked: a, index: o }, options: { base: c, minBarLength: u } } = this, h = c || 0, m = this.getParsed(e), v = m._custom, b = tT(v);
    let S = m[i.axis], w = 0, E = a ? this.applyStack(i, m, a) : S, R, M;
    E !== S && (w = E - S, E = S), b && (S = v.barStart, E = v.barEnd - v.barStart, S !== 0 && jo(S) !== jo(v.barEnd) && (w = 0), w += S);
    const A = !$t(c) && !b ? c : w;
    let P = i.getPixelForValue(A);
    if (this.chart.getDataVisibility(e) ? R = i.getPixelForValue(w + E) : R = P, M = R - P, Math.abs(M) < u) {
      M = G$(M, i, h) * u, S === h && (P -= M / 2);
      const z = i.getPixelForDecimal(0), B = i.getPixelForDecimal(1), j = Math.min(z, B), F = Math.max(z, B);
      P = Math.max(Math.min(P, F), j), R = P + M, a && !b && (m._stacks[i.axis]._visualValues[o] = i.getValueForPixel(R) - i.getValueForPixel(P));
    }
    if (P === i.getPixelForValue(h)) {
      const z = jo(M) * i.getLineWidthForValue(h) / 2;
      P += z, M -= z;
    }
    return {
      size: M,
      base: P,
      head: R,
      center: R + M / 2
    };
  }
  _calculateBarIndexPixels(e, i) {
    const a = i.scale, o = this.options, c = o.skipNull, u = zt(o.maxBarThickness, 1 / 0);
    let h, m;
    if (i.grouped) {
      const v = c ? this._getStackCount(e) : i.stackCount, b = o.barThickness === "flex" ? W$(e, i, o, v) : $$(e, i, o, v), S = this._getStackIndex(this.index, this._cachedMeta.stack, c ? e : void 0);
      h = b.start + b.chunk * S + b.chunk / 2, m = Math.min(u, b.chunk * b.ratio);
    } else
      h = a.getPixelForValue(this.getParsed(e)[a.axis], e), m = Math.min(u, i.min * i.ratio);
    return {
      base: h - m / 2,
      head: h + m / 2,
      center: h,
      size: m
    };
  }
  draw() {
    const e = this._cachedMeta, i = e.vScale, a = e.data, o = a.length;
    let c = 0;
    for (; c < o; ++c)
      this.getParsed(c)[i.axis] !== null && !a[c].hidden && a[c].draw(this._ctx);
  }
}
Ve(ux, "id", "bar"), Ve(ux, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), Ve(ux, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
class cx extends qs {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(e, i, a, o) {
    const c = super.parsePrimitiveData(e, i, a, o);
    for (let u = 0; u < c.length; u++)
      c[u]._custom = this.resolveDataElementOptions(u + a).radius;
    return c;
  }
  parseArrayData(e, i, a, o) {
    const c = super.parseArrayData(e, i, a, o);
    for (let u = 0; u < c.length; u++) {
      const h = i[a + u];
      c[u]._custom = zt(h[2], this.resolveDataElementOptions(u + a).radius);
    }
    return c;
  }
  parseObjectData(e, i, a, o) {
    const c = super.parseObjectData(e, i, a, o);
    for (let u = 0; u < c.length; u++) {
      const h = i[a + u];
      c[u]._custom = zt(h && h.r && +h.r, this.resolveDataElementOptions(u + a).radius);
    }
    return c;
  }
  getMaxOverflow() {
    const e = this._cachedMeta.data;
    let i = 0;
    for (let a = e.length - 1; a >= 0; --a)
      i = Math.max(i, e[a].size(this.resolveDataElementOptions(a)) / 2);
    return i > 0 && i;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = this.chart.data.labels || [], { xScale: o, yScale: c } = i, u = this.getParsed(e), h = o.getLabelForValue(u.x), m = c.getLabelForValue(u.y), v = u._custom;
    return {
      label: a[e] || "",
      value: "(" + h + ", " + m + (v ? ", " + v : "") + ")"
    };
  }
  update(e) {
    const i = this._cachedMeta.data;
    this.updateElements(i, 0, i.length, e);
  }
  updateElements(e, i, a, o) {
    const c = o === "reset", { iScale: u, vScale: h } = this._cachedMeta, { sharedOptions: m, includeOptions: v } = this._getSharedOptions(i, o), b = u.axis, S = h.axis;
    for (let w = i; w < i + a; w++) {
      const E = e[w], R = !c && this.getParsed(w), M = {}, A = M[b] = c ? u.getPixelForDecimal(0.5) : u.getPixelForValue(R[b]), P = M[S] = c ? h.getBasePixel() : h.getPixelForValue(R[S]);
      M.skip = isNaN(A) || isNaN(P), v && (M.options = m || this.resolveDataElementOptions(w, E.active ? "active" : o), c && (M.options.radius = 0)), this.updateElement(E, w, M, o);
    }
  }
  resolveDataElementOptions(e, i) {
    const a = this.getParsed(e);
    let o = super.resolveDataElementOptions(e, i);
    o.$shared && (o = Object.assign({}, o, {
      $shared: !1
    }));
    const c = o.radius;
    return i !== "active" && (o.radius = 0), o.radius += zt(a && a._custom, c), o;
  }
}
Ve(cx, "id", "bubble"), Ve(cx, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
}), Ve(cx, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function Z$(t, e, i) {
  let a = 1, o = 1, c = 0, u = 0;
  if (e < Un) {
    const h = t, m = h + e, v = Math.cos(h), b = Math.sin(h), S = Math.cos(m), w = Math.sin(m), E = (B, j, F) => pv(B, h, m, !0) ? 1 : Math.max(j, j * i, F, F * i), R = (B, j, F) => pv(B, h, m, !0) ? -1 : Math.min(j, j * i, F, F * i), M = E(0, v, S), A = E(Ti, b, w), P = R(In, v, S), z = R(In + Ti, b, w);
    a = (M - P) / 2, o = (A - z) / 2, c = -(M + P) / 2, u = -(A + z) / 2;
  }
  return {
    ratioX: a,
    ratioY: o,
    offsetX: c,
    offsetY: u
  };
}
class Ff extends qs {
  constructor(e, i) {
    super(e, i), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(e, i) {
    const a = this.getDataset().data, o = this._cachedMeta;
    if (this._parsing === !1)
      o._parsed = a;
    else {
      let c = (m) => +a[m];
      if (qt(a[e])) {
        const { key: m = "value" } = this._parsing;
        c = (v) => +ec(a[v], m);
      }
      let u, h;
      for (u = e, h = e + i; u < h; ++u)
        o._parsed[u] = c(u);
    }
  }
  _getRotation() {
    return Xs(this.options.rotation - 90);
  }
  _getCircumference() {
    return Xs(this.options.circumference);
  }
  _getRotationExtents() {
    let e = Un, i = -Un;
    for (let a = 0; a < this.chart.data.datasets.length; ++a)
      if (this.chart.isDatasetVisible(a) && this.chart.getDatasetMeta(a).type === this._type) {
        const o = this.chart.getDatasetMeta(a).controller, c = o._getRotation(), u = o._getCircumference();
        e = Math.min(e, c), i = Math.max(i, c + u);
      }
    return {
      rotation: e,
      circumference: i - e
    };
  }
  update(e) {
    const i = this.chart, { chartArea: a } = i, o = this._cachedMeta, c = o.data, u = this.getMaxBorderWidth() + this.getMaxOffset(c) + this.options.spacing, h = Math.max((Math.min(a.width, a.height) - u) / 2, 0), m = Math.min(fI(this.options.cutout, h), 1), v = this._getRingWeight(this.index), { circumference: b, rotation: S } = this._getRotationExtents(), { ratioX: w, ratioY: E, offsetX: R, offsetY: M } = Z$(S, b, m), A = (a.width - u) / w, P = (a.height - u) / E, z = Math.max(Math.min(A, P) / 2, 0), B = cL(this.options.radius, z), j = Math.max(B * m, 0), F = (B - j) / this._getVisibleDatasetWeightTotal();
    this.offsetX = R * B, this.offsetY = M * B, o.total = this.calculateTotal(), this.outerRadius = B - F * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - F * v, 0), this.updateElements(c, 0, c.length, e);
  }
  _circumference(e, i) {
    const a = this.options, o = this._cachedMeta, c = this._getCircumference();
    return i && a.animation.animateRotate || !this.chart.getDataVisibility(e) || o._parsed[e] === null || o.data[e].hidden ? 0 : this.calculateCircumference(o._parsed[e] * c / Un);
  }
  updateElements(e, i, a, o) {
    const c = o === "reset", u = this.chart, h = u.chartArea, v = u.options.animation, b = (h.left + h.right) / 2, S = (h.top + h.bottom) / 2, w = c && v.animateScale, E = w ? 0 : this.innerRadius, R = w ? 0 : this.outerRadius, { sharedOptions: M, includeOptions: A } = this._getSharedOptions(i, o);
    let P = this._getRotation(), z;
    for (z = 0; z < i; ++z)
      P += this._circumference(z, c);
    for (z = i; z < i + a; ++z) {
      const B = this._circumference(z, c), j = e[z], F = {
        x: b + this.offsetX,
        y: S + this.offsetY,
        startAngle: P,
        endAngle: P + B,
        circumference: B,
        outerRadius: R,
        innerRadius: E
      };
      A && (F.options = M || this.resolveDataElementOptions(z, j.active ? "active" : o)), P += B, this.updateElement(j, z, F, o);
    }
  }
  calculateTotal() {
    const e = this._cachedMeta, i = e.data;
    let a = 0, o;
    for (o = 0; o < i.length; o++) {
      const c = e._parsed[o];
      c !== null && !isNaN(c) && this.chart.getDataVisibility(o) && !i[o].hidden && (a += Math.abs(c));
    }
    return a;
  }
  calculateCircumference(e) {
    const i = this._cachedMeta.total;
    return i > 0 && !isNaN(e) ? Un * (Math.abs(e) / i) : 0;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = this.chart, o = a.data.labels || [], c = Pv(i._parsed[e], a.options.locale);
    return {
      label: o[e] || "",
      value: c
    };
  }
  getMaxBorderWidth(e) {
    let i = 0;
    const a = this.chart;
    let o, c, u, h, m;
    if (!e) {
      for (o = 0, c = a.data.datasets.length; o < c; ++o)
        if (a.isDatasetVisible(o)) {
          u = a.getDatasetMeta(o), e = u.data, h = u.controller;
          break;
        }
    }
    if (!e)
      return 0;
    for (o = 0, c = e.length; o < c; ++o)
      m = h.resolveDataElementOptions(o), m.borderAlign !== "inner" && (i = Math.max(i, m.borderWidth || 0, m.hoverBorderWidth || 0));
    return i;
  }
  getMaxOffset(e) {
    let i = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const c = this.resolveDataElementOptions(a);
      i = Math.max(i, c.offset || 0, c.hoverOffset || 0);
    }
    return i;
  }
  _getRingWeightOffset(e) {
    let i = 0;
    for (let a = 0; a < e; ++a)
      this.chart.isDatasetVisible(a) && (i += this._getRingWeight(a));
    return i;
  }
  _getRingWeight(e) {
    return Math.max(zt(this.chart.data.datasets[e].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
Ve(Ff, "id", "doughnut"), Ve(Ff, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), Ve(Ff, "descriptors", {
  _scriptable: (e) => e !== "spacing",
  _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
}), Ve(Ff, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const i = e.data;
          if (i.labels.length && i.datasets.length) {
            const { labels: { pointStyle: a, color: o } } = e.legend.options;
            return i.labels.map((c, u) => {
              const m = e.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: c,
                fillStyle: m.backgroundColor,
                strokeStyle: m.borderColor,
                fontColor: o,
                lineWidth: m.borderWidth,
                pointStyle: a,
                hidden: !e.getDataVisibility(u),
                index: u
              };
            });
          }
          return [];
        }
      },
      onClick(e, i, a) {
        a.chart.toggleDataVisibility(i.index), a.chart.update();
      }
    }
  }
});
class fx extends qs {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(e) {
    const i = this._cachedMeta, { dataset: a, data: o = [], _dataset: c } = i, u = this.chart._animationsDisabled;
    let { start: h, count: m } = yL(i, o, u);
    this._drawStart = h, this._drawCount = m, bL(i) && (h = 0, m = o.length), a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!c._decimated, a.points = o;
    const v = this.resolveDatasetElementOptions(e);
    this.options.showLine || (v.borderWidth = 0), v.segment = this.options.segment, this.updateElement(a, void 0, {
      animated: !u,
      options: v
    }, e), this.updateElements(o, h, m, e);
  }
  updateElements(e, i, a, o) {
    const c = o === "reset", { iScale: u, vScale: h, _stacked: m, _dataset: v } = this._cachedMeta, { sharedOptions: b, includeOptions: S } = this._getSharedOptions(i, o), w = u.axis, E = h.axis, { spanGaps: R, segment: M } = this.options, A = ap(R) ? R : Number.POSITIVE_INFINITY, P = this.chart._animationsDisabled || c || o === "none", z = i + a, B = e.length;
    let j = i > 0 && this.getParsed(i - 1);
    for (let F = 0; F < B; ++F) {
      const $ = e[F], I = P ? $ : {};
      if (F < i || F >= z) {
        I.skip = !0;
        continue;
      }
      const K = this.getParsed(F), ee = $t(K[E]), ne = I[w] = u.getPixelForValue(K[w], F), le = I[E] = c || ee ? h.getBasePixel() : h.getPixelForValue(m ? this.applyStack(h, K, m) : K[E], F);
      I.skip = isNaN(ne) || isNaN(le) || ee, I.stop = F > 0 && Math.abs(K[w] - j[w]) > A, M && (I.parsed = K, I.raw = v.data[F]), S && (I.options = b || this.resolveDataElementOptions(F, $.active ? "active" : o)), P || this.updateElement($, F, I, o), j = K;
    }
  }
  getMaxOverflow() {
    const e = this._cachedMeta, i = e.dataset, a = i.options && i.options.borderWidth || 0, o = e.data || [];
    if (!o.length)
      return a;
    const c = o[0].size(this.resolveDataElementOptions(0)), u = o[o.length - 1].size(this.resolveDataElementOptions(o.length - 1));
    return Math.max(a, c, u) / 2;
  }
  draw() {
    const e = this._cachedMeta;
    e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw();
  }
}
Ve(fx, "id", "line"), Ve(fx, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), Ve(fx, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class av extends qs {
  constructor(e, i) {
    super(e, i), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = this.chart, o = a.data.labels || [], c = Pv(i._parsed[e].r, a.options.locale);
    return {
      label: o[e] || "",
      value: c
    };
  }
  parseObjectData(e, i, a, o) {
    return DL.bind(this)(e, i, a, o);
  }
  update(e) {
    const i = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(i, 0, i.length, e);
  }
  getMinMax() {
    const e = this._cachedMeta, i = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return e.data.forEach((a, o) => {
      const c = this.getParsed(o).r;
      !isNaN(c) && this.chart.getDataVisibility(o) && (c < i.min && (i.min = c), c > i.max && (i.max = c));
    }), i;
  }
  _updateRadius() {
    const e = this.chart, i = e.chartArea, a = e.options, o = Math.min(i.right - i.left, i.bottom - i.top), c = Math.max(o / 2, 0), u = Math.max(a.cutoutPercentage ? c / 100 * a.cutoutPercentage : 1, 0), h = (c - u) / e.getVisibleDatasetCount();
    this.outerRadius = c - h * this.index, this.innerRadius = this.outerRadius - h;
  }
  updateElements(e, i, a, o) {
    const c = o === "reset", u = this.chart, m = u.options.animation, v = this._cachedMeta.rScale, b = v.xCenter, S = v.yCenter, w = v.getIndexAngle(0) - 0.5 * In;
    let E = w, R;
    const M = 360 / this.countVisibleElements();
    for (R = 0; R < i; ++R)
      E += this._computeAngle(R, o, M);
    for (R = i; R < i + a; R++) {
      const A = e[R];
      let P = E, z = E + this._computeAngle(R, o, M), B = u.getDataVisibility(R) ? v.getDistanceFromCenterForValue(this.getParsed(R).r) : 0;
      E = z, c && (m.animateScale && (B = 0), m.animateRotate && (P = z = w));
      const j = {
        x: b,
        y: S,
        innerRadius: 0,
        outerRadius: B,
        startAngle: P,
        endAngle: z,
        options: this.resolveDataElementOptions(R, A.active ? "active" : o)
      };
      this.updateElement(A, R, j, o);
    }
  }
  countVisibleElements() {
    const e = this._cachedMeta;
    let i = 0;
    return e.data.forEach((a, o) => {
      !isNaN(this.getParsed(o).r) && this.chart.getDataVisibility(o) && i++;
    }), i;
  }
  _computeAngle(e, i, a) {
    return this.chart.getDataVisibility(e) ? Xs(this.resolveDataElementOptions(e, i).angle || a) : 0;
  }
}
Ve(av, "id", "polarArea"), Ve(av, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), Ve(av, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const i = e.data;
          if (i.labels.length && i.datasets.length) {
            const { labels: { pointStyle: a, color: o } } = e.legend.options;
            return i.labels.map((c, u) => {
              const m = e.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: c,
                fillStyle: m.backgroundColor,
                strokeStyle: m.borderColor,
                fontColor: o,
                lineWidth: m.borderWidth,
                pointStyle: a,
                hidden: !e.getDataVisibility(u),
                index: u
              };
            });
          }
          return [];
        }
      },
      onClick(e, i, a) {
        a.chart.toggleDataVisibility(i.index), a.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
class NT extends Ff {
}
Ve(NT, "id", "pie"), Ve(NT, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class dx extends qs {
  getLabelAndValue(e) {
    const i = this._cachedMeta.vScale, a = this.getParsed(e);
    return {
      label: i.getLabels()[e],
      value: "" + i.getLabelForValue(a[i.axis])
    };
  }
  parseObjectData(e, i, a, o) {
    return DL.bind(this)(e, i, a, o);
  }
  update(e) {
    const i = this._cachedMeta, a = i.dataset, o = i.data || [], c = i.iScale.getLabels();
    if (a.points = o, e !== "resize") {
      const u = this.resolveDatasetElementOptions(e);
      this.options.showLine || (u.borderWidth = 0);
      const h = {
        _loop: !0,
        _fullLoop: c.length === o.length,
        options: u
      };
      this.updateElement(a, void 0, h, e);
    }
    this.updateElements(o, 0, o.length, e);
  }
  updateElements(e, i, a, o) {
    const c = this._cachedMeta.rScale, u = o === "reset";
    for (let h = i; h < i + a; h++) {
      const m = e[h], v = this.resolveDataElementOptions(h, m.active ? "active" : o), b = c.getPointPositionForValue(h, this.getParsed(h).r), S = u ? c.xCenter : b.x, w = u ? c.yCenter : b.y, E = {
        x: S,
        y: w,
        angle: b.angle,
        skip: isNaN(S) || isNaN(w),
        options: v
      };
      this.updateElement(m, h, E, o);
    }
  }
}
Ve(dx, "id", "radar"), Ve(dx, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
}), Ve(dx, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class hx extends qs {
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = this.chart.data.labels || [], { xScale: o, yScale: c } = i, u = this.getParsed(e), h = o.getLabelForValue(u.x), m = c.getLabelForValue(u.y);
    return {
      label: a[e] || "",
      value: "(" + h + ", " + m + ")"
    };
  }
  update(e) {
    const i = this._cachedMeta, { data: a = [] } = i, o = this.chart._animationsDisabled;
    let { start: c, count: u } = yL(i, a, o);
    if (this._drawStart = c, this._drawCount = u, bL(i) && (c = 0, u = a.length), this.options.showLine) {
      this.datasetElementType || this.addElements();
      const { dataset: h, _dataset: m } = i;
      h._chart = this.chart, h._datasetIndex = this.index, h._decimated = !!m._decimated, h.points = a;
      const v = this.resolveDatasetElementOptions(e);
      v.segment = this.options.segment, this.updateElement(h, void 0, {
        animated: !o,
        options: v
      }, e);
    } else this.datasetElementType && (delete i.dataset, this.datasetElementType = !1);
    this.updateElements(a, c, u, e);
  }
  addElements() {
    const { showLine: e } = this.options;
    !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
  }
  updateElements(e, i, a, o) {
    const c = o === "reset", { iScale: u, vScale: h, _stacked: m, _dataset: v } = this._cachedMeta, b = this.resolveDataElementOptions(i, o), S = this.getSharedOptions(b), w = this.includeOptions(o, S), E = u.axis, R = h.axis, { spanGaps: M, segment: A } = this.options, P = ap(M) ? M : Number.POSITIVE_INFINITY, z = this.chart._animationsDisabled || c || o === "none";
    let B = i > 0 && this.getParsed(i - 1);
    for (let j = i; j < i + a; ++j) {
      const F = e[j], $ = this.getParsed(j), I = z ? F : {}, K = $t($[R]), ee = I[E] = u.getPixelForValue($[E], j), ne = I[R] = c || K ? h.getBasePixel() : h.getPixelForValue(m ? this.applyStack(h, $, m) : $[R], j);
      I.skip = isNaN(ee) || isNaN(ne) || K, I.stop = j > 0 && Math.abs($[E] - B[E]) > P, A && (I.parsed = $, I.raw = v.data[j]), w && (I.options = S || this.resolveDataElementOptions(j, F.active ? "active" : o)), z || this.updateElement(F, j, I, o), B = $;
    }
    this.updateSharedOptions(S, o, b);
  }
  getMaxOverflow() {
    const e = this._cachedMeta, i = e.data || [];
    if (!this.options.showLine) {
      let h = 0;
      for (let m = i.length - 1; m >= 0; --m)
        h = Math.max(h, i[m].size(this.resolveDataElementOptions(m)) / 2);
      return h > 0 && h;
    }
    const a = e.dataset, o = a.options && a.options.borderWidth || 0;
    if (!i.length)
      return o;
    const c = i[0].size(this.resolveDataElementOptions(0)), u = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
    return Math.max(o, c, u) / 2;
  }
}
Ve(hx, "id", "scatter"), Ve(hx, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
}), Ve(hx, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var J$ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: ux,
  BubbleController: cx,
  DoughnutController: Ff,
  LineController: fx,
  PieController: NT,
  PolarAreaController: av,
  RadarController: dx,
  ScatterController: hx
});
function kf() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class WE {
  constructor(e) {
    Ve(this, "options");
    this.options = e || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(e) {
    Object.assign(WE.prototype, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return kf();
  }
  parse() {
    return kf();
  }
  format() {
    return kf();
  }
  add() {
    return kf();
  }
  diff() {
    return kf();
  }
  startOf() {
    return kf();
  }
  endOf() {
    return kf();
  }
}
var e3 = {
  _date: WE
};
function t3(t, e, i, a) {
  const { controller: o, data: c, _sorted: u } = t, h = o._cachedMeta.iScale, m = t.dataset && t.dataset.options ? t.dataset.options.spanGaps : null;
  if (h && e === h.axis && e !== "r" && u && c.length) {
    const v = h._reversePixels ? CI : Wl;
    if (a) {
      if (o._sharedOptions) {
        const b = c[0], S = typeof b.getRange == "function" && b.getRange(e);
        if (S) {
          const w = v(c, e, i - S), E = v(c, e, i + S);
          return {
            lo: w.lo,
            hi: E.hi
          };
        }
      }
    } else {
      const b = v(c, e, i);
      if (m) {
        const { vScale: S } = o._cachedMeta, { _parsed: w } = t, E = w.slice(0, b.lo + 1).reverse().findIndex((M) => !$t(M[S.axis]));
        b.lo -= Math.max(0, E);
        const R = w.slice(b.hi).findIndex((M) => !$t(M[S.axis]));
        b.hi += Math.max(0, R);
      }
      return b;
    }
  }
  return {
    lo: 0,
    hi: c.length - 1
  };
}
function tS(t, e, i, a, o) {
  const c = t.getSortedVisibleDatasetMetas(), u = i[e];
  for (let h = 0, m = c.length; h < m; ++h) {
    const { index: v, data: b } = c[h], { lo: S, hi: w } = t3(c[h], e, u, o);
    for (let E = S; E <= w; ++E) {
      const R = b[E];
      R.skip || a(R, v, E);
    }
  }
}
function n3(t) {
  const e = t.indexOf("x") !== -1, i = t.indexOf("y") !== -1;
  return function(a, o) {
    const c = e ? Math.abs(a.x - o.x) : 0, u = i ? Math.abs(a.y - o.y) : 0;
    return Math.sqrt(Math.pow(c, 2) + Math.pow(u, 2));
  };
}
function nT(t, e, i, a, o) {
  const c = [];
  return !o && !t.isPointInArea(e) || tS(t, i, e, function(h, m, v) {
    !o && !Yl(h, t.chartArea, 0) || h.inRange(e.x, e.y, a) && c.push({
      element: h,
      datasetIndex: m,
      index: v
    });
  }, !0), c;
}
function i3(t, e, i, a) {
  let o = [];
  function c(u, h, m) {
    const { startAngle: v, endAngle: b } = u.getProps([
      "startAngle",
      "endAngle"
    ], a), { angle: S } = hL(u, {
      x: e.x,
      y: e.y
    });
    pv(S, v, b) && o.push({
      element: u,
      datasetIndex: h,
      index: m
    });
  }
  return tS(t, i, e, c), o;
}
function r3(t, e, i, a, o, c) {
  let u = [];
  const h = n3(i);
  let m = Number.POSITIVE_INFINITY;
  function v(b, S, w) {
    const E = b.inRange(e.x, e.y, o);
    if (a && !E)
      return;
    const R = b.getCenterPoint(o);
    if (!(!!c || t.isPointInArea(R)) && !E)
      return;
    const A = h(e, R);
    A < m ? (u = [
      {
        element: b,
        datasetIndex: S,
        index: w
      }
    ], m = A) : A === m && u.push({
      element: b,
      datasetIndex: S,
      index: w
    });
  }
  return tS(t, i, e, v), u;
}
function iT(t, e, i, a, o, c) {
  return !c && !t.isPointInArea(e) ? [] : i === "r" && !a ? i3(t, e, i, o) : r3(t, e, i, a, o, c);
}
function rA(t, e, i, a, o) {
  const c = [], u = i === "x" ? "inXRange" : "inYRange";
  let h = !1;
  return tS(t, i, e, (m, v, b) => {
    m[u] && m[u](e[i], o) && (c.push({
      element: m,
      datasetIndex: v,
      index: b
    }), h = h || m.inRange(e.x, e.y, o));
  }), a && !h ? [] : c;
}
var a3 = {
  modes: {
    index(t, e, i, a) {
      const o = Pf(e, t), c = i.axis || "x", u = i.includeInvisible || !1, h = i.intersect ? nT(t, o, c, a, u) : iT(t, o, c, !1, a, u), m = [];
      return h.length ? (t.getSortedVisibleDatasetMetas().forEach((v) => {
        const b = h[0].index, S = v.data[b];
        S && !S.skip && m.push({
          element: S,
          datasetIndex: v.index,
          index: b
        });
      }), m) : [];
    },
    dataset(t, e, i, a) {
      const o = Pf(e, t), c = i.axis || "xy", u = i.includeInvisible || !1;
      let h = i.intersect ? nT(t, o, c, a, u) : iT(t, o, c, !1, a, u);
      if (h.length > 0) {
        const m = h[0].datasetIndex, v = t.getDatasetMeta(m).data;
        h = [];
        for (let b = 0; b < v.length; ++b)
          h.push({
            element: v[b],
            datasetIndex: m,
            index: b
          });
      }
      return h;
    },
    point(t, e, i, a) {
      const o = Pf(e, t), c = i.axis || "xy", u = i.includeInvisible || !1;
      return nT(t, o, c, a, u);
    },
    nearest(t, e, i, a) {
      const o = Pf(e, t), c = i.axis || "xy", u = i.includeInvisible || !1;
      return iT(t, o, c, i.intersect, a, u);
    },
    x(t, e, i, a) {
      const o = Pf(e, t);
      return rA(t, o, "x", i.intersect, a);
    },
    y(t, e, i, a) {
      const o = Pf(e, t);
      return rA(t, o, "y", i.intersect, a);
    }
  }
};
const FL = [
  "left",
  "top",
  "right",
  "bottom"
];
function jg(t, e) {
  return t.filter((i) => i.pos === e);
}
function aA(t, e) {
  return t.filter((i) => FL.indexOf(i.pos) === -1 && i.box.axis === e);
}
function Bg(t, e) {
  return t.sort((i, a) => {
    const o = e ? a : i, c = e ? i : a;
    return o.weight === c.weight ? o.index - c.index : o.weight - c.weight;
  });
}
function s3(t) {
  const e = [];
  let i, a, o, c, u, h;
  for (i = 0, a = (t || []).length; i < a; ++i)
    o = t[i], { position: c, options: { stack: u, stackWeight: h = 1 } } = o, e.push({
      index: i,
      box: o,
      pos: c,
      horizontal: o.isHorizontal(),
      weight: o.weight,
      stack: u && c + u,
      stackWeight: h
    });
  return e;
}
function o3(t) {
  const e = {};
  for (const i of t) {
    const { stack: a, pos: o, stackWeight: c } = i;
    if (!a || !FL.includes(o))
      continue;
    const u = e[a] || (e[a] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    u.count++, u.weight += c;
  }
  return e;
}
function l3(t, e) {
  const i = o3(t), { vBoxMaxWidth: a, hBoxMaxHeight: o } = e;
  let c, u, h;
  for (c = 0, u = t.length; c < u; ++c) {
    h = t[c];
    const { fullSize: m } = h.box, v = i[h.stack], b = v && h.stackWeight / v.weight;
    h.horizontal ? (h.width = b ? b * a : m && e.availableWidth, h.height = o) : (h.width = a, h.height = b ? b * o : m && e.availableHeight);
  }
  return i;
}
function u3(t) {
  const e = s3(t), i = Bg(e.filter((v) => v.box.fullSize), !0), a = Bg(jg(e, "left"), !0), o = Bg(jg(e, "right")), c = Bg(jg(e, "top"), !0), u = Bg(jg(e, "bottom")), h = aA(e, "x"), m = aA(e, "y");
  return {
    fullSize: i,
    leftAndTop: a.concat(c),
    rightAndBottom: o.concat(m).concat(u).concat(h),
    chartArea: jg(e, "chartArea"),
    vertical: a.concat(o).concat(m),
    horizontal: c.concat(u).concat(h)
  };
}
function sA(t, e, i, a) {
  return Math.max(t[i], e[i]) + Math.max(t[a], e[a]);
}
function VL(t, e) {
  t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);
}
function c3(t, e, i, a) {
  const { pos: o, box: c } = i, u = t.maxPadding;
  if (!qt(o)) {
    i.size && (t[o] -= i.size);
    const S = a[i.stack] || {
      size: 0,
      count: 1
    };
    S.size = Math.max(S.size, i.horizontal ? c.height : c.width), i.size = S.size / S.count, t[o] += i.size;
  }
  c.getPadding && VL(u, c.getPadding());
  const h = Math.max(0, e.outerWidth - sA(u, t, "left", "right")), m = Math.max(0, e.outerHeight - sA(u, t, "top", "bottom")), v = h !== t.w, b = m !== t.h;
  return t.w = h, t.h = m, i.horizontal ? {
    same: v,
    other: b
  } : {
    same: b,
    other: v
  };
}
function f3(t) {
  const e = t.maxPadding;
  function i(a) {
    const o = Math.max(e[a] - t[a], 0);
    return t[a] += o, o;
  }
  t.y += i("top"), t.x += i("left"), i("right"), i("bottom");
}
function d3(t, e) {
  const i = e.maxPadding;
  function a(o) {
    const c = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return o.forEach((u) => {
      c[u] = Math.max(e[u], i[u]);
    }), c;
  }
  return a(t ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Gg(t, e, i, a) {
  const o = [];
  let c, u, h, m, v, b;
  for (c = 0, u = t.length, v = 0; c < u; ++c) {
    h = t[c], m = h.box, m.update(h.width || e.w, h.height || e.h, d3(h.horizontal, e));
    const { same: S, other: w } = c3(e, i, h, a);
    v |= S && o.length, b = b || w, m.fullSize || o.push(h);
  }
  return v && Gg(o, e, i, a) || b;
}
function $b(t, e, i, a, o) {
  t.top = i, t.left = e, t.right = e + a, t.bottom = i + o, t.width = a, t.height = o;
}
function oA(t, e, i, a) {
  const o = i.padding;
  let { x: c, y: u } = e;
  for (const h of t) {
    const m = h.box, v = a[h.stack] || {
      placed: 0,
      weight: 1
    }, b = h.stackWeight / v.weight || 1;
    if (h.horizontal) {
      const S = e.w * b, w = v.size || m.height;
      hv(v.start) && (u = v.start), m.fullSize ? $b(m, o.left, u, i.outerWidth - o.right - o.left, w) : $b(m, e.left + v.placed, u, S, w), v.start = u, v.placed += S, u = m.bottom;
    } else {
      const S = e.h * b, w = v.size || m.width;
      hv(v.start) && (c = v.start), m.fullSize ? $b(m, c, o.top, w, i.outerHeight - o.bottom - o.top) : $b(m, c, e.top + v.placed, w, S), v.start = c, v.placed += S, c = m.right;
    }
  }
  e.x = c, e.y = u;
}
var Vr = {
  addBox(t, e) {
    t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
      return [
        {
          z: 0,
          draw(i) {
            e.draw(i);
          }
        }
      ];
    }, t.boxes.push(e);
  },
  removeBox(t, e) {
    const i = t.boxes ? t.boxes.indexOf(e) : -1;
    i !== -1 && t.boxes.splice(i, 1);
  },
  configure(t, e, i) {
    e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight;
  },
  update(t, e, i, a) {
    if (!t)
      return;
    const o = Br(t.options.layout.padding), c = Math.max(e - o.width, 0), u = Math.max(i - o.height, 0), h = u3(t.boxes), m = h.vertical, v = h.horizontal;
    _n(t.boxes, (M) => {
      typeof M.beforeLayout == "function" && M.beforeLayout();
    });
    const b = m.reduce((M, A) => A.box.options && A.box.options.display === !1 ? M : M + 1, 0) || 1, S = Object.freeze({
      outerWidth: e,
      outerHeight: i,
      padding: o,
      availableWidth: c,
      availableHeight: u,
      vBoxMaxWidth: c / 2 / b,
      hBoxMaxHeight: u / 2
    }), w = Object.assign({}, o);
    VL(w, Br(a));
    const E = Object.assign({
      maxPadding: w,
      w: c,
      h: u,
      x: o.left,
      y: o.top
    }, o), R = l3(m.concat(v), S);
    Gg(h.fullSize, E, S, R), Gg(m, E, S, R), Gg(v, E, S, R) && Gg(m, E, S, R), f3(E), oA(h.leftAndTop, E, S, R), E.x += E.w, E.y += E.h, oA(h.rightAndBottom, E, S, R), t.chartArea = {
      left: E.left,
      top: E.top,
      right: E.left + E.w,
      bottom: E.top + E.h,
      height: E.h,
      width: E.w
    }, _n(h.chartArea, (M) => {
      const A = M.box;
      Object.assign(A, t.chartArea), A.update(E.w, E.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class jL {
  acquireContext(e, i) {
  }
  releaseContext(e) {
    return !1;
  }
  addEventListener(e, i, a) {
  }
  removeEventListener(e, i, a) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(e, i, a, o) {
    return i = Math.max(0, i || e.width), a = a || e.height, {
      width: i,
      height: Math.max(0, o ? Math.floor(i / o) : a)
    };
  }
  isAttached(e) {
    return !0;
  }
  updateConfig(e) {
  }
}
class h3 extends jL {
  acquireContext(e) {
    return e && e.getContext && e.getContext("2d") || null;
  }
  updateConfig(e) {
    e.options.animation = !1;
  }
}
const px = "$chartjs", p3 = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, lA = (t) => t === null || t === "";
function m3(t, e) {
  const i = t.style, a = t.getAttribute("height"), o = t.getAttribute("width");
  if (t[px] = {
    initial: {
      height: a,
      width: o,
      style: {
        display: i.display,
        height: i.height,
        width: i.width
      }
    }
  }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", lA(o)) {
    const c = WM(t, "width");
    c !== void 0 && (t.width = c);
  }
  if (lA(a))
    if (t.style.height === "")
      t.height = t.width / (e || 2);
    else {
      const c = WM(t, "height");
      c !== void 0 && (t.height = c);
    }
  return t;
}
const BL = v$ ? {
  passive: !0
} : !1;
function g3(t, e, i) {
  t && t.addEventListener(e, i, BL);
}
function v3(t, e, i) {
  t && t.canvas && t.canvas.removeEventListener(e, i, BL);
}
function y3(t, e) {
  const i = p3[t.type] || t.type, { x: a, y: o } = Pf(t, e);
  return {
    type: i,
    chart: e,
    native: t,
    x: a !== void 0 ? a : null,
    y: o !== void 0 ? o : null
  };
}
function kx(t, e) {
  for (const i of t)
    if (i === e || i.contains(e))
      return !0;
}
function b3(t, e, i) {
  const a = t.canvas, o = new MutationObserver((c) => {
    let u = !1;
    for (const h of c)
      u = u || kx(h.addedNodes, a), u = u && !kx(h.removedNodes, a);
    u && i();
  });
  return o.observe(document, {
    childList: !0,
    subtree: !0
  }), o;
}
function x3(t, e, i) {
  const a = t.canvas, o = new MutationObserver((c) => {
    let u = !1;
    for (const h of c)
      u = u || kx(h.removedNodes, a), u = u && !kx(h.addedNodes, a);
    u && i();
  });
  return o.observe(document, {
    childList: !0,
    subtree: !0
  }), o;
}
const gv = /* @__PURE__ */ new Map();
let uA = 0;
function HL() {
  const t = window.devicePixelRatio;
  t !== uA && (uA = t, gv.forEach((e, i) => {
    i.currentDevicePixelRatio !== t && e();
  }));
}
function S3(t, e) {
  gv.size || window.addEventListener("resize", HL), gv.set(t, e);
}
function _3(t) {
  gv.delete(t), gv.size || window.removeEventListener("resize", HL);
}
function w3(t, e, i) {
  const a = t.canvas, o = a && $E(a);
  if (!o)
    return;
  const c = vL((h, m) => {
    const v = o.clientWidth;
    i(h, m), v < o.clientWidth && i();
  }, window), u = new ResizeObserver((h) => {
    const m = h[0], v = m.contentRect.width, b = m.contentRect.height;
    v === 0 && b === 0 || c(v, b);
  });
  return u.observe(o), S3(t, c), u;
}
function rT(t, e, i) {
  i && i.disconnect(), e === "resize" && _3(t);
}
function C3(t, e, i) {
  const a = t.canvas, o = vL((c) => {
    t.ctx !== null && i(y3(c, t));
  }, t);
  return g3(a, e, o), o;
}
class T3 extends jL {
  acquireContext(e, i) {
    const a = e && e.getContext && e.getContext("2d");
    return a && a.canvas === e ? (m3(e, i), a) : null;
  }
  releaseContext(e) {
    const i = e.canvas;
    if (!i[px])
      return !1;
    const a = i[px].initial;
    [
      "height",
      "width"
    ].forEach((c) => {
      const u = a[c];
      $t(u) ? i.removeAttribute(c) : i.setAttribute(c, u);
    });
    const o = a.style || {};
    return Object.keys(o).forEach((c) => {
      i.style[c] = o[c];
    }), i.width = i.width, delete i[px], !0;
  }
  addEventListener(e, i, a) {
    this.removeEventListener(e, i);
    const o = e.$proxies || (e.$proxies = {}), u = {
      attach: b3,
      detach: x3,
      resize: w3
    }[i] || C3;
    o[i] = u(e, i, a);
  }
  removeEventListener(e, i) {
    const a = e.$proxies || (e.$proxies = {}), o = a[i];
    if (!o)
      return;
    ({
      attach: rT,
      detach: rT,
      resize: rT
    }[i] || v3)(e, i, o), a[i] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(e, i, a, o) {
    return g$(e, i, a, o);
  }
  isAttached(e) {
    const i = e && $E(e);
    return !!(i && i.isConnected);
  }
}
function E3(t) {
  return !IE() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? h3 : T3;
}
var lx;
let Ql = (lx = class {
  constructor() {
    Ve(this, "x");
    Ve(this, "y");
    Ve(this, "active", !1);
    Ve(this, "options");
    Ve(this, "$animations");
  }
  tooltipPosition(e) {
    const { x: i, y: a } = this.getProps([
      "x",
      "y"
    ], e);
    return {
      x: i,
      y: a
    };
  }
  hasValue() {
    return ap(this.x) && ap(this.y);
  }
  getProps(e, i) {
    const a = this.$animations;
    if (!i || !a)
      return this;
    const o = {};
    return e.forEach((c) => {
      o[c] = a[c] && a[c].active() ? a[c]._to : this[c];
    }), o;
  }
}, Ve(lx, "defaults", {}), Ve(lx, "defaultRoutes"), lx);
function D3(t, e) {
  const i = t.options.ticks, a = R3(t), o = Math.min(i.maxTicksLimit || a, a), c = i.major.enabled ? M3(e) : [], u = c.length, h = c[0], m = c[u - 1], v = [];
  if (u > o)
    return A3(e, v, c, u / o), v;
  const b = k3(c, e, o);
  if (u > 0) {
    let S, w;
    const E = u > 1 ? Math.round((m - h) / (u - 1)) : null;
    for (Wb(e, v, b, $t(E) ? 0 : h - E, h), S = 0, w = u - 1; S < w; S++)
      Wb(e, v, b, c[S], c[S + 1]);
    return Wb(e, v, b, m, $t(E) ? e.length : m + E), v;
  }
  return Wb(e, v, b), v;
}
function R3(t) {
  const e = t.options.offset, i = t._tickSize(), a = t._length / i + (e ? 0 : 1), o = t._maxLength / i;
  return Math.floor(Math.min(a, o));
}
function k3(t, e, i) {
  const a = O3(t), o = e.length / i;
  if (!a)
    return Math.max(o, 1);
  const c = bI(a);
  for (let u = 0, h = c.length - 1; u < h; u++) {
    const m = c[u];
    if (m > o)
      return m;
  }
  return Math.max(o, 1);
}
function M3(t) {
  const e = [];
  let i, a;
  for (i = 0, a = t.length; i < a; i++)
    t[i].major && e.push(i);
  return e;
}
function A3(t, e, i, a) {
  let o = 0, c = i[0], u;
  for (a = Math.ceil(a), u = 0; u < t.length; u++)
    u === c && (e.push(t[u]), o++, c = i[o * a]);
}
function Wb(t, e, i, a, o) {
  const c = zt(a, 0), u = Math.min(zt(o, t.length), t.length);
  let h = 0, m, v, b;
  for (i = Math.ceil(i), o && (m = o - a, i = m / Math.floor(m / i)), b = c; b < 0; )
    h++, b = Math.round(c + h * i);
  for (v = Math.max(c, 0); v < u; v++)
    v === b && (e.push(t[v]), h++, b = Math.round(c + h * i));
}
function O3(t) {
  const e = t.length;
  let i, a;
  if (e < 2)
    return !1;
  for (a = t[0], i = 1; i < e; ++i)
    if (t[i] - t[i - 1] !== a)
      return !1;
  return a;
}
const P3 = (t) => t === "left" ? "right" : t === "right" ? "left" : t, cA = (t, e, i) => e === "top" || e === "left" ? t[e] + i : t[e] - i, fA = (t, e) => Math.min(e || t, t);
function dA(t, e) {
  const i = [], a = t.length / e, o = t.length;
  let c = 0;
  for (; c < o; c += a)
    i.push(t[Math.floor(c)]);
  return i;
}
function L3(t, e, i) {
  const a = t.ticks.length, o = Math.min(e, a - 1), c = t._startPixel, u = t._endPixel, h = 1e-6;
  let m = t.getPixelForTick(o), v;
  if (!(i && (a === 1 ? v = Math.max(m - c, u - m) : e === 0 ? v = (t.getPixelForTick(1) - m) / 2 : v = (m - t.getPixelForTick(o - 1)) / 2, m += o < e ? v : -v, m < c - h || m > u + h)))
    return m;
}
function N3(t, e) {
  _n(t, (i) => {
    const a = i.gc, o = a.length / 2;
    let c;
    if (o > e) {
      for (c = 0; c < o; ++c)
        delete i.data[a[c]];
      a.splice(0, o);
    }
  });
}
function Hg(t) {
  return t.drawTicks ? t.tickLength : 0;
}
function hA(t, e) {
  if (!t.display)
    return 0;
  const i = Ki(t.font, e), a = Br(t.padding);
  return (Kn(t.text) ? t.text.length : 1) * i.lineHeight + a.height;
}
function z3(t, e) {
  return ac(t, {
    scale: e,
    type: "scale"
  });
}
function F3(t, e, i) {
  return ac(t, {
    tick: i,
    index: e,
    type: "tick"
  });
}
function V3(t, e, i) {
  let a = FE(t);
  return (i && e !== "right" || !i && e === "right") && (a = P3(a)), a;
}
function j3(t, e, i, a) {
  const { top: o, left: c, bottom: u, right: h, chart: m } = t, { chartArea: v, scales: b } = m;
  let S = 0, w, E, R;
  const M = u - o, A = h - c;
  if (t.isHorizontal()) {
    if (E = zr(a, c, h), qt(i)) {
      const P = Object.keys(i)[0], z = i[P];
      R = b[P].getPixelForValue(z) + M - e;
    } else i === "center" ? R = (v.bottom + v.top) / 2 + M - e : R = cA(t, i, e);
    w = h - c;
  } else {
    if (qt(i)) {
      const P = Object.keys(i)[0], z = i[P];
      E = b[P].getPixelForValue(z) - A + e;
    } else i === "center" ? E = (v.left + v.right) / 2 - A + e : E = cA(t, i, e);
    R = zr(a, u, o), S = i === "left" ? -Ti : Ti;
  }
  return {
    titleX: E,
    titleY: R,
    maxWidth: w,
    rotation: S
  };
}
class Gf extends Ql {
  constructor(e) {
    super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(e) {
    this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
  }
  parse(e, i) {
    return e;
  }
  getUserBounds() {
    let { _userMin: e, _userMax: i, _suggestedMin: a, _suggestedMax: o } = this;
    return e = Ha(e, Number.POSITIVE_INFINITY), i = Ha(i, Number.NEGATIVE_INFINITY), a = Ha(a, Number.POSITIVE_INFINITY), o = Ha(o, Number.NEGATIVE_INFINITY), {
      min: Ha(e, a),
      max: Ha(i, o),
      minDefined: vi(e),
      maxDefined: vi(i)
    };
  }
  getMinMax(e) {
    let { min: i, max: a, minDefined: o, maxDefined: c } = this.getUserBounds(), u;
    if (o && c)
      return {
        min: i,
        max: a
      };
    const h = this.getMatchingVisibleMetas();
    for (let m = 0, v = h.length; m < v; ++m)
      u = h[m].controller.getMinMax(this, e), o || (i = Math.min(i, u.min)), c || (a = Math.max(a, u.max));
    return i = c && i > a ? a : i, a = o && i > a ? i : a, {
      min: Ha(i, Ha(a, i)),
      max: Ha(a, Ha(i, a))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const e = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
  }
  getLabelItems(e = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(e));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    Nn(this.options.beforeUpdate, [
      this
    ]);
  }
  update(e, i, a) {
    const { beginAtZero: o, grace: c, ticks: u } = this.options, h = u.sampleSize;
    this.beforeUpdate(), this.maxWidth = e, this.maxHeight = i, this._margins = a = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, a), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + a.left + a.right : this.height + a.top + a.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = KI(this, c, o), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const m = h < this.ticks.length;
    this._convertTicksToLabels(m ? dA(this.ticks, h) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), u.display && (u.autoSkip || u.source === "auto") && (this.ticks = D3(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), m && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let e = this.options.reverse, i, a;
    this.isHorizontal() ? (i = this.left, a = this.right) : (i = this.top, a = this.bottom, e = !e), this._startPixel = i, this._endPixel = a, this._reversePixels = e, this._length = a - i, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    Nn(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    Nn(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    Nn(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(e) {
    this.chart.notifyPlugins(e, this.getContext()), Nn(this.options[e], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    Nn(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(e) {
    const i = this.options.ticks;
    let a, o, c;
    for (a = 0, o = e.length; a < o; a++)
      c = e[a], c.label = Nn(i.callback, [
        c.value,
        a,
        e
      ], this);
  }
  afterTickToLabelConversion() {
    Nn(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    Nn(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const e = this.options, i = e.ticks, a = fA(this.ticks.length, e.ticks.maxTicksLimit), o = i.minRotation || 0, c = i.maxRotation;
    let u = o, h, m, v;
    if (!this._isVisible() || !i.display || o >= c || a <= 1 || !this.isHorizontal()) {
      this.labelRotation = o;
      return;
    }
    const b = this._getLabelSizes(), S = b.widest.width, w = b.highest.height, E = Ji(this.chart.width - S, 0, this.maxWidth);
    h = e.offset ? this.maxWidth / a : E / (a - 1), S + 6 > h && (h = E / (a - (e.offset ? 0.5 : 1)), m = this.maxHeight - Hg(e.grid) - i.padding - hA(e.title, this.chart.options.font), v = Math.sqrt(S * S + w * w), u = NE(Math.min(Math.asin(Ji((b.highest.height + 6) / h, -1, 1)), Math.asin(Ji(m / v, -1, 1)) - Math.asin(Ji(w / v, -1, 1)))), u = Math.max(o, Math.min(c, u))), this.labelRotation = u;
  }
  afterCalculateLabelRotation() {
    Nn(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    Nn(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const e = {
      width: 0,
      height: 0
    }, { chart: i, options: { ticks: a, title: o, grid: c } } = this, u = this._isVisible(), h = this.isHorizontal();
    if (u) {
      const m = hA(o, i.options.font);
      if (h ? (e.width = this.maxWidth, e.height = Hg(c) + m) : (e.height = this.maxHeight, e.width = Hg(c) + m), a.display && this.ticks.length) {
        const { first: v, last: b, widest: S, highest: w } = this._getLabelSizes(), E = a.padding * 2, R = Xs(this.labelRotation), M = Math.cos(R), A = Math.sin(R);
        if (h) {
          const P = a.mirror ? 0 : A * S.width + M * w.height;
          e.height = Math.min(this.maxHeight, e.height + P + E);
        } else {
          const P = a.mirror ? 0 : M * S.width + A * w.height;
          e.width = Math.min(this.maxWidth, e.width + P + E);
        }
        this._calculatePadding(v, b, A, M);
      }
    }
    this._handleMargins(), h ? (this.width = this._length = i.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = i.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(e, i, a, o) {
    const { ticks: { align: c, padding: u }, position: h } = this.options, m = this.labelRotation !== 0, v = h !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const b = this.getPixelForTick(0) - this.left, S = this.right - this.getPixelForTick(this.ticks.length - 1);
      let w = 0, E = 0;
      m ? v ? (w = o * e.width, E = a * i.height) : (w = a * e.height, E = o * i.width) : c === "start" ? E = i.width : c === "end" ? w = e.width : c !== "inner" && (w = e.width / 2, E = i.width / 2), this.paddingLeft = Math.max((w - b + u) * this.width / (this.width - b), 0), this.paddingRight = Math.max((E - S + u) * this.width / (this.width - S), 0);
    } else {
      let b = i.height / 2, S = e.height / 2;
      c === "start" ? (b = 0, S = e.height) : c === "end" && (b = i.height, S = 0), this.paddingTop = b + u, this.paddingBottom = S + u;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    Nn(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: e, position: i } = this.options;
    return i === "top" || i === "bottom" || e === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(e) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(e);
    let i, a;
    for (i = 0, a = e.length; i < a; i++)
      $t(e[i].label) && (e.splice(i, 1), a--, i--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let e = this._labelSizes;
    if (!e) {
      const i = this.options.ticks.sampleSize;
      let a = this.ticks;
      i < a.length && (a = dA(a, i)), this._labelSizes = e = this._computeLabelSizes(a, a.length, this.options.ticks.maxTicksLimit);
    }
    return e;
  }
  _computeLabelSizes(e, i, a) {
    const { ctx: o, _longestTextCache: c } = this, u = [], h = [], m = Math.floor(i / fA(i, a));
    let v = 0, b = 0, S, w, E, R, M, A, P, z, B, j, F;
    for (S = 0; S < i; S += m) {
      if (R = e[S].label, M = this._resolveTickFontOptions(S), o.font = A = M.string, P = c[A] = c[A] || {
        data: {},
        gc: []
      }, z = M.lineHeight, B = j = 0, !$t(R) && !Kn(R))
        B = Dx(o, P.data, P.gc, B, R), j = z;
      else if (Kn(R))
        for (w = 0, E = R.length; w < E; ++w)
          F = R[w], !$t(F) && !Kn(F) && (B = Dx(o, P.data, P.gc, B, F), j += z);
      u.push(B), h.push(j), v = Math.max(B, v), b = Math.max(j, b);
    }
    N3(c, i);
    const $ = u.indexOf(v), I = h.indexOf(b), K = (ee) => ({
      width: u[ee] || 0,
      height: h[ee] || 0
    });
    return {
      first: K(0),
      last: K(i - 1),
      widest: K($),
      highest: K(I),
      widths: u,
      heights: h
    };
  }
  getLabelForValue(e) {
    return e;
  }
  getPixelForValue(e, i) {
    return NaN;
  }
  getValueForPixel(e) {
  }
  getPixelForTick(e) {
    const i = this.ticks;
    return e < 0 || e > i.length - 1 ? null : this.getPixelForValue(i[e].value);
  }
  getPixelForDecimal(e) {
    this._reversePixels && (e = 1 - e);
    const i = this._startPixel + e * this._length;
    return wI(this._alignToPixels ? Rf(this.chart, i, 0) : i);
  }
  getDecimalForPixel(e) {
    const i = (e - this._startPixel) / this._length;
    return this._reversePixels ? 1 - i : i;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: e, max: i } = this;
    return e < 0 && i < 0 ? i : e > 0 && i > 0 ? e : 0;
  }
  getContext(e) {
    const i = this.ticks || [];
    if (e >= 0 && e < i.length) {
      const a = i[e];
      return a.$context || (a.$context = F3(this.getContext(), e, a));
    }
    return this.$context || (this.$context = z3(this.chart.getContext(), this));
  }
  _tickSize() {
    const e = this.options.ticks, i = Xs(this.labelRotation), a = Math.abs(Math.cos(i)), o = Math.abs(Math.sin(i)), c = this._getLabelSizes(), u = e.autoSkipPadding || 0, h = c ? c.widest.width + u : 0, m = c ? c.highest.height + u : 0;
    return this.isHorizontal() ? m * a > h * o ? h / a : m / o : m * o < h * a ? m / a : h / o;
  }
  _isVisible() {
    const e = this.options.display;
    return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(e) {
    const i = this.axis, a = this.chart, o = this.options, { grid: c, position: u, border: h } = o, m = c.offset, v = this.isHorizontal(), S = this.ticks.length + (m ? 1 : 0), w = Hg(c), E = [], R = h.setContext(this.getContext()), M = R.display ? R.width : 0, A = M / 2, P = function(we) {
      return Rf(a, we, M);
    };
    let z, B, j, F, $, I, K, ee, ne, le, re, se;
    if (u === "top")
      z = P(this.bottom), I = this.bottom - w, ee = z - A, le = P(e.top) + A, se = e.bottom;
    else if (u === "bottom")
      z = P(this.top), le = e.top, se = P(e.bottom) - A, I = z + A, ee = this.top + w;
    else if (u === "left")
      z = P(this.right), $ = this.right - w, K = z - A, ne = P(e.left) + A, re = e.right;
    else if (u === "right")
      z = P(this.left), ne = e.left, re = P(e.right) - A, $ = z + A, K = this.left + w;
    else if (i === "x") {
      if (u === "center")
        z = P((e.top + e.bottom) / 2 + 0.5);
      else if (qt(u)) {
        const we = Object.keys(u)[0], Oe = u[we];
        z = P(this.chart.scales[we].getPixelForValue(Oe));
      }
      le = e.top, se = e.bottom, I = z + A, ee = I + w;
    } else if (i === "y") {
      if (u === "center")
        z = P((e.left + e.right) / 2);
      else if (qt(u)) {
        const we = Object.keys(u)[0], Oe = u[we];
        z = P(this.chart.scales[we].getPixelForValue(Oe));
      }
      $ = z - A, K = $ - w, ne = e.left, re = e.right;
    }
    const Ne = zt(o.ticks.maxTicksLimit, S), Ee = Math.max(1, Math.ceil(S / Ne));
    for (B = 0; B < S; B += Ee) {
      const we = this.getContext(B), Oe = c.setContext(we), ae = h.setContext(we), me = Oe.lineWidth, pe = Oe.color, Ce = ae.dash || [], oe = ae.dashOffset, Me = Oe.tickWidth, Pe = Oe.tickColor, fe = Oe.tickBorderDash || [], Le = Oe.tickBorderDashOffset;
      j = L3(this, B, m), j !== void 0 && (F = Rf(a, j, me), v ? $ = K = ne = re = F : I = ee = le = se = F, E.push({
        tx1: $,
        ty1: I,
        tx2: K,
        ty2: ee,
        x1: ne,
        y1: le,
        x2: re,
        y2: se,
        width: me,
        color: pe,
        borderDash: Ce,
        borderDashOffset: oe,
        tickWidth: Me,
        tickColor: Pe,
        tickBorderDash: fe,
        tickBorderDashOffset: Le
      }));
    }
    return this._ticksLength = S, this._borderValue = z, E;
  }
  _computeLabelItems(e) {
    const i = this.axis, a = this.options, { position: o, ticks: c } = a, u = this.isHorizontal(), h = this.ticks, { align: m, crossAlign: v, padding: b, mirror: S } = c, w = Hg(a.grid), E = w + b, R = S ? -b : E, M = -Xs(this.labelRotation), A = [];
    let P, z, B, j, F, $, I, K, ee, ne, le, re, se = "middle";
    if (o === "top")
      $ = this.bottom - R, I = this._getXAxisLabelAlignment();
    else if (o === "bottom")
      $ = this.top + R, I = this._getXAxisLabelAlignment();
    else if (o === "left") {
      const Ee = this._getYAxisLabelAlignment(w);
      I = Ee.textAlign, F = Ee.x;
    } else if (o === "right") {
      const Ee = this._getYAxisLabelAlignment(w);
      I = Ee.textAlign, F = Ee.x;
    } else if (i === "x") {
      if (o === "center")
        $ = (e.top + e.bottom) / 2 + E;
      else if (qt(o)) {
        const Ee = Object.keys(o)[0], we = o[Ee];
        $ = this.chart.scales[Ee].getPixelForValue(we) + E;
      }
      I = this._getXAxisLabelAlignment();
    } else if (i === "y") {
      if (o === "center")
        F = (e.left + e.right) / 2 - E;
      else if (qt(o)) {
        const Ee = Object.keys(o)[0], we = o[Ee];
        F = this.chart.scales[Ee].getPixelForValue(we);
      }
      I = this._getYAxisLabelAlignment(w).textAlign;
    }
    i === "y" && (m === "start" ? se = "top" : m === "end" && (se = "bottom"));
    const Ne = this._getLabelSizes();
    for (P = 0, z = h.length; P < z; ++P) {
      B = h[P], j = B.label;
      const Ee = c.setContext(this.getContext(P));
      K = this.getPixelForTick(P) + c.labelOffset, ee = this._resolveTickFontOptions(P), ne = ee.lineHeight, le = Kn(j) ? j.length : 1;
      const we = le / 2, Oe = Ee.color, ae = Ee.textStrokeColor, me = Ee.textStrokeWidth;
      let pe = I;
      u ? (F = K, I === "inner" && (P === z - 1 ? pe = this.options.reverse ? "left" : "right" : P === 0 ? pe = this.options.reverse ? "right" : "left" : pe = "center"), o === "top" ? v === "near" || M !== 0 ? re = -le * ne + ne / 2 : v === "center" ? re = -Ne.highest.height / 2 - we * ne + ne : re = -Ne.highest.height + ne / 2 : v === "near" || M !== 0 ? re = ne / 2 : v === "center" ? re = Ne.highest.height / 2 - we * ne : re = Ne.highest.height - le * ne, S && (re *= -1), M !== 0 && !Ee.showLabelBackdrop && (F += ne / 2 * Math.sin(M))) : ($ = K, re = (1 - le) * ne / 2);
      let Ce;
      if (Ee.showLabelBackdrop) {
        const oe = Br(Ee.backdropPadding), Me = Ne.heights[P], Pe = Ne.widths[P];
        let fe = re - oe.top, Le = 0 - oe.left;
        switch (se) {
          case "middle":
            fe -= Me / 2;
            break;
          case "bottom":
            fe -= Me;
            break;
        }
        switch (I) {
          case "center":
            Le -= Pe / 2;
            break;
          case "right":
            Le -= Pe;
            break;
          case "inner":
            P === z - 1 ? Le -= Pe : P > 0 && (Le -= Pe / 2);
            break;
        }
        Ce = {
          left: Le,
          top: fe,
          width: Pe + oe.width,
          height: Me + oe.height,
          color: Ee.backdropColor
        };
      }
      A.push({
        label: j,
        font: ee,
        textOffset: re,
        options: {
          rotation: M,
          color: Oe,
          strokeColor: ae,
          strokeWidth: me,
          textAlign: pe,
          textBaseline: se,
          translation: [
            F,
            $
          ],
          backdrop: Ce
        }
      });
    }
    return A;
  }
  _getXAxisLabelAlignment() {
    const { position: e, ticks: i } = this.options;
    if (-Xs(this.labelRotation))
      return e === "top" ? "left" : "right";
    let o = "center";
    return i.align === "start" ? o = "left" : i.align === "end" ? o = "right" : i.align === "inner" && (o = "inner"), o;
  }
  _getYAxisLabelAlignment(e) {
    const { position: i, ticks: { crossAlign: a, mirror: o, padding: c } } = this.options, u = this._getLabelSizes(), h = e + c, m = u.widest.width;
    let v, b;
    return i === "left" ? o ? (b = this.right + c, a === "near" ? v = "left" : a === "center" ? (v = "center", b += m / 2) : (v = "right", b += m)) : (b = this.right - h, a === "near" ? v = "right" : a === "center" ? (v = "center", b -= m / 2) : (v = "left", b = this.left)) : i === "right" ? o ? (b = this.left + c, a === "near" ? v = "right" : a === "center" ? (v = "center", b -= m / 2) : (v = "left", b -= m)) : (b = this.left + h, a === "near" ? v = "left" : a === "center" ? (v = "center", b += m / 2) : (v = "right", b = this.right)) : v = "right", {
      textAlign: v,
      x: b
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const e = this.chart, i = this.options.position;
    if (i === "left" || i === "right")
      return {
        top: 0,
        left: this.left,
        bottom: e.height,
        right: this.right
      };
    if (i === "top" || i === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: e.width
      };
  }
  drawBackground() {
    const { ctx: e, options: { backgroundColor: i }, left: a, top: o, width: c, height: u } = this;
    i && (e.save(), e.fillStyle = i, e.fillRect(a, o, c, u), e.restore());
  }
  getLineWidthForValue(e) {
    const i = this.options.grid;
    if (!this._isVisible() || !i.display)
      return 0;
    const o = this.ticks.findIndex((c) => c.value === e);
    return o >= 0 ? i.setContext(this.getContext(o)).lineWidth : 0;
  }
  drawGrid(e) {
    const i = this.options.grid, a = this.ctx, o = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
    let c, u;
    const h = (m, v, b) => {
      !b.width || !b.color || (a.save(), a.lineWidth = b.width, a.strokeStyle = b.color, a.setLineDash(b.borderDash || []), a.lineDashOffset = b.borderDashOffset, a.beginPath(), a.moveTo(m.x, m.y), a.lineTo(v.x, v.y), a.stroke(), a.restore());
    };
    if (i.display)
      for (c = 0, u = o.length; c < u; ++c) {
        const m = o[c];
        i.drawOnChartArea && h({
          x: m.x1,
          y: m.y1
        }, {
          x: m.x2,
          y: m.y2
        }, m), i.drawTicks && h({
          x: m.tx1,
          y: m.ty1
        }, {
          x: m.tx2,
          y: m.ty2
        }, {
          color: m.tickColor,
          width: m.tickWidth,
          borderDash: m.tickBorderDash,
          borderDashOffset: m.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: e, ctx: i, options: { border: a, grid: o } } = this, c = a.setContext(this.getContext()), u = a.display ? c.width : 0;
    if (!u)
      return;
    const h = o.setContext(this.getContext(0)).lineWidth, m = this._borderValue;
    let v, b, S, w;
    this.isHorizontal() ? (v = Rf(e, this.left, u) - u / 2, b = Rf(e, this.right, h) + h / 2, S = w = m) : (S = Rf(e, this.top, u) - u / 2, w = Rf(e, this.bottom, h) + h / 2, v = b = m), i.save(), i.lineWidth = c.width, i.strokeStyle = c.color, i.beginPath(), i.moveTo(v, S), i.lineTo(b, w), i.stroke(), i.restore();
  }
  drawLabels(e) {
    if (!this.options.ticks.display)
      return;
    const a = this.ctx, o = this._computeLabelArea();
    o && Zx(a, o);
    const c = this.getLabelItems(e);
    for (const u of c) {
      const h = u.options, m = u.font, v = u.label, b = u.textOffset;
      Wf(a, v, 0, b, m, h);
    }
    o && Jx(a);
  }
  drawTitle() {
    const { ctx: e, options: { position: i, title: a, reverse: o } } = this;
    if (!a.display)
      return;
    const c = Ki(a.font), u = Br(a.padding), h = a.align;
    let m = c.lineHeight / 2;
    i === "bottom" || i === "center" || qt(i) ? (m += u.bottom, Kn(a.text) && (m += c.lineHeight * (a.text.length - 1))) : m += u.top;
    const { titleX: v, titleY: b, maxWidth: S, rotation: w } = j3(this, m, i, h);
    Wf(e, a.text, 0, 0, c, {
      color: a.color,
      maxWidth: S,
      rotation: w,
      textAlign: V3(h, i, o),
      textBaseline: "middle",
      translation: [
        v,
        b
      ]
    });
  }
  draw(e) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
  }
  _layers() {
    const e = this.options, i = e.ticks && e.ticks.z || 0, a = zt(e.grid && e.grid.z, -1), o = zt(e.border && e.border.z, 0);
    return !this._isVisible() || this.draw !== Gf.prototype.draw ? [
      {
        z: i,
        draw: (c) => {
          this.draw(c);
        }
      }
    ] : [
      {
        z: a,
        draw: (c) => {
          this.drawBackground(), this.drawGrid(c), this.drawTitle();
        }
      },
      {
        z: o,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: i,
        draw: (c) => {
          this.drawLabels(c);
        }
      }
    ];
  }
  getMatchingVisibleMetas(e) {
    const i = this.chart.getSortedVisibleDatasetMetas(), a = this.axis + "AxisID", o = [];
    let c, u;
    for (c = 0, u = i.length; c < u; ++c) {
      const h = i[c];
      h[a] === this.id && (!e || h.type === e) && o.push(h);
    }
    return o;
  }
  _resolveTickFontOptions(e) {
    const i = this.options.ticks.setContext(this.getContext(e));
    return Ki(i.font);
  }
  _maxDigits() {
    const e = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / e;
  }
}
class Yb {
  constructor(e, i, a) {
    this.type = e, this.scope = i, this.override = a, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(e) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
  }
  register(e) {
    const i = Object.getPrototypeOf(e);
    let a;
    U3(i) && (a = this.register(i));
    const o = this.items, c = e.id, u = this.scope + "." + c;
    if (!c)
      throw new Error("class does not have id: " + e);
    return c in o || (o[c] = e, B3(e, u, a), this.override && Qn.override(e.id, e.overrides)), u;
  }
  get(e) {
    return this.items[e];
  }
  unregister(e) {
    const i = this.items, a = e.id, o = this.scope;
    a in i && delete i[a], o && a in Qn[o] && (delete Qn[o][a], this.override && delete $f[a]);
  }
}
function B3(t, e, i) {
  const a = dv(/* @__PURE__ */ Object.create(null), [
    i ? Qn.get(i) : {},
    Qn.get(e),
    t.defaults
  ]);
  Qn.set(e, a), t.defaultRoutes && H3(e, t.defaultRoutes), t.descriptors && Qn.describe(e, t.descriptors);
}
function H3(t, e) {
  Object.keys(e).forEach((i) => {
    const a = i.split("."), o = a.pop(), c = [
      t
    ].concat(a).join("."), u = e[i].split("."), h = u.pop(), m = u.join(".");
    Qn.route(c, o, m, h);
  });
}
function U3(t) {
  return "id" in t && "defaults" in t;
}
class I3 {
  constructor() {
    this.controllers = new Yb(qs, "datasets", !0), this.elements = new Yb(Ql, "elements"), this.plugins = new Yb(Object, "plugins"), this.scales = new Yb(Gf, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...e) {
    this._each("register", e);
  }
  remove(...e) {
    this._each("unregister", e);
  }
  addControllers(...e) {
    this._each("register", e, this.controllers);
  }
  addElements(...e) {
    this._each("register", e, this.elements);
  }
  addPlugins(...e) {
    this._each("register", e, this.plugins);
  }
  addScales(...e) {
    this._each("register", e, this.scales);
  }
  getController(e) {
    return this._get(e, this.controllers, "controller");
  }
  getElement(e) {
    return this._get(e, this.elements, "element");
  }
  getPlugin(e) {
    return this._get(e, this.plugins, "plugin");
  }
  getScale(e) {
    return this._get(e, this.scales, "scale");
  }
  removeControllers(...e) {
    this._each("unregister", e, this.controllers);
  }
  removeElements(...e) {
    this._each("unregister", e, this.elements);
  }
  removePlugins(...e) {
    this._each("unregister", e, this.plugins);
  }
  removeScales(...e) {
    this._each("unregister", e, this.scales);
  }
  _each(e, i, a) {
    [
      ...i
    ].forEach((o) => {
      const c = a || this._getRegistryForType(o);
      a || c.isForType(o) || c === this.plugins && o.id ? this._exec(e, c, o) : _n(o, (u) => {
        const h = a || this._getRegistryForType(u);
        this._exec(e, h, u);
      });
    });
  }
  _exec(e, i, a) {
    const o = LE(e);
    Nn(a["before" + o], [], a), i[e](a), Nn(a["after" + o], [], a);
  }
  _getRegistryForType(e) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const a = this._typedRegistries[i];
      if (a.isForType(e))
        return a;
    }
    return this.plugins;
  }
  _get(e, i, a) {
    const o = i.get(e);
    if (o === void 0)
      throw new Error('"' + e + '" is not a registered ' + a + ".");
    return o;
  }
}
var zo = /* @__PURE__ */ new I3();
class $3 {
  constructor() {
    this._init = [];
  }
  notify(e, i, a, o) {
    i === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install"));
    const c = o ? this._descriptors(e).filter(o) : this._descriptors(e), u = this._notify(c, e, i, a);
    return i === "afterDestroy" && (this._notify(c, e, "stop"), this._notify(this._init, e, "uninstall")), u;
  }
  _notify(e, i, a, o) {
    o = o || {};
    for (const c of e) {
      const u = c.plugin, h = u[a], m = [
        i,
        o,
        c.options
      ];
      if (Nn(h, m, u) === !1 && o.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    $t(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(e) {
    if (this._cache)
      return this._cache;
    const i = this._cache = this._createDescriptors(e);
    return this._notifyStateChanges(e), i;
  }
  _createDescriptors(e, i) {
    const a = e && e.config, o = zt(a.options && a.options.plugins, {}), c = W3(a);
    return o === !1 && !i ? [] : G3(e, c, o, i);
  }
  _notifyStateChanges(e) {
    const i = this._oldCache || [], a = this._cache, o = (c, u) => c.filter((h) => !u.some((m) => h.plugin.id === m.plugin.id));
    this._notify(o(i, a), e, "stop"), this._notify(o(a, i), e, "start");
  }
}
function W3(t) {
  const e = {}, i = [], a = Object.keys(zo.plugins.items);
  for (let c = 0; c < a.length; c++)
    i.push(zo.getPlugin(a[c]));
  const o = t.plugins || [];
  for (let c = 0; c < o.length; c++) {
    const u = o[c];
    i.indexOf(u) === -1 && (i.push(u), e[u.id] = !0);
  }
  return {
    plugins: i,
    localIds: e
  };
}
function Y3(t, e) {
  return !e && t === !1 ? null : t === !0 ? {} : t;
}
function G3(t, { plugins: e, localIds: i }, a, o) {
  const c = [], u = t.getContext();
  for (const h of e) {
    const m = h.id, v = Y3(a[m], o);
    v !== null && c.push({
      plugin: h,
      options: K3(t.config, {
        plugin: h,
        local: i[m]
      }, v, u)
    });
  }
  return c;
}
function K3(t, { plugin: e, local: i }, a, o) {
  const c = t.pluginScopeKeys(e), u = t.getOptionScopes(a, c);
  return i && e.defaults && u.push(e.defaults), t.createResolver(u, o, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function zT(t, e) {
  const i = Qn.datasets[t] || {};
  return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x";
}
function X3(t, e) {
  let i = t;
  return t === "_index_" ? i = e : t === "_value_" && (i = e === "x" ? "y" : "x"), i;
}
function Q3(t, e) {
  return t === e ? "_index_" : "_value_";
}
function pA(t) {
  if (t === "x" || t === "y" || t === "r")
    return t;
}
function q3(t) {
  if (t === "top" || t === "bottom")
    return "x";
  if (t === "left" || t === "right")
    return "y";
}
function FT(t, ...e) {
  if (pA(t))
    return t;
  for (const i of e) {
    const a = i.axis || q3(i.position) || t.length > 1 && pA(t[0].toLowerCase());
    if (a)
      return a;
  }
  throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`);
}
function mA(t, e, i) {
  if (i[e + "AxisID"] === t)
    return {
      axis: e
    };
}
function Z3(t, e) {
  if (e.data && e.data.datasets) {
    const i = e.data.datasets.filter((a) => a.xAxisID === t || a.yAxisID === t);
    if (i.length)
      return mA(t, "x", i[0]) || mA(t, "y", i[0]);
  }
  return {};
}
function J3(t, e) {
  const i = $f[t.type] || {
    scales: {}
  }, a = e.scales || {}, o = zT(t.type, e), c = /* @__PURE__ */ Object.create(null);
  return Object.keys(a).forEach((u) => {
    const h = a[u];
    if (!qt(h))
      return console.error(`Invalid scale configuration for scale: ${u}`);
    if (h._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${u}`);
    const m = FT(u, h, Z3(u, t), Qn.scales[h.type]), v = Q3(m, o), b = i.scales || {};
    c[u] = tv(/* @__PURE__ */ Object.create(null), [
      {
        axis: m
      },
      h,
      b[m],
      b[v]
    ]);
  }), t.data.datasets.forEach((u) => {
    const h = u.type || t.type, m = u.indexAxis || zT(h, e), b = ($f[h] || {}).scales || {};
    Object.keys(b).forEach((S) => {
      const w = X3(S, m), E = u[w + "AxisID"] || w;
      c[E] = c[E] || /* @__PURE__ */ Object.create(null), tv(c[E], [
        {
          axis: w
        },
        a[E],
        b[S]
      ]);
    });
  }), Object.keys(c).forEach((u) => {
    const h = c[u];
    tv(h, [
      Qn.scales[h.type],
      Qn.scale
    ]);
  }), c;
}
function UL(t) {
  const e = t.options || (t.options = {});
  e.plugins = zt(e.plugins, {}), e.scales = J3(t, e);
}
function IL(t) {
  return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t;
}
function e5(t) {
  return t = t || {}, t.data = IL(t.data), UL(t), t;
}
const gA = /* @__PURE__ */ new Map(), $L = /* @__PURE__ */ new Set();
function Gb(t, e) {
  let i = gA.get(t);
  return i || (i = e(), gA.set(t, i), $L.add(i)), i;
}
const Ug = (t, e, i) => {
  const a = ec(e, i);
  a !== void 0 && t.add(a);
};
class t5 {
  constructor(e) {
    this._config = e5(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(e) {
    this._config.type = e;
  }
  get data() {
    return this._config.data;
  }
  set data(e) {
    this._config.data = IL(e);
  }
  get options() {
    return this._config.options;
  }
  set options(e) {
    this._config.options = e;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const e = this._config;
    this.clearCache(), UL(e);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(e) {
    return Gb(e, () => [
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(e, i) {
    return Gb(`${e}.transition.${i}`, () => [
      [
        `datasets.${e}.transitions.${i}`,
        `transitions.${i}`
      ],
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(e, i) {
    return Gb(`${e}-${i}`, () => [
      [
        `datasets.${e}.elements.${i}`,
        `datasets.${e}`,
        `elements.${i}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(e) {
    const i = e.id, a = this.type;
    return Gb(`${a}-plugin-${i}`, () => [
      [
        `plugins.${i}`,
        ...e.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(e, i) {
    const a = this._scopeCache;
    let o = a.get(e);
    return (!o || i) && (o = /* @__PURE__ */ new Map(), a.set(e, o)), o;
  }
  getOptionScopes(e, i, a) {
    const { options: o, type: c } = this, u = this._cachedScopes(e, a), h = u.get(i);
    if (h)
      return h;
    const m = /* @__PURE__ */ new Set();
    i.forEach((b) => {
      e && (m.add(e), b.forEach((S) => Ug(m, e, S))), b.forEach((S) => Ug(m, o, S)), b.forEach((S) => Ug(m, $f[c] || {}, S)), b.forEach((S) => Ug(m, Qn, S)), b.forEach((S) => Ug(m, PT, S));
    });
    const v = Array.from(m);
    return v.length === 0 && v.push(/* @__PURE__ */ Object.create(null)), $L.has(i) && u.set(i, v), v;
  }
  chartOptionScopes() {
    const { options: e, type: i } = this;
    return [
      e,
      $f[i] || {},
      Qn.datasets[i] || {},
      {
        type: i
      },
      Qn,
      PT
    ];
  }
  resolveNamedOptions(e, i, a, o = [
    ""
  ]) {
    const c = {
      $shared: !0
    }, { resolver: u, subPrefixes: h } = vA(this._resolverCache, e, o);
    let m = u;
    if (i5(u, i)) {
      c.$shared = !1, a = tc(a) ? a() : a;
      const v = this.createResolver(e, a, h);
      m = sp(u, a, v);
    }
    for (const v of i)
      c[v] = m[v];
    return c;
  }
  createResolver(e, i, a = [
    ""
  ], o) {
    const { resolver: c } = vA(this._resolverCache, e, a);
    return qt(i) ? sp(c, i, void 0, o) : c;
  }
}
function vA(t, e, i) {
  let a = t.get(e);
  a || (a = /* @__PURE__ */ new Map(), t.set(e, a));
  const o = i.join();
  let c = a.get(o);
  return c || (c = {
    resolver: BE(e, i),
    subPrefixes: i.filter((h) => !h.toLowerCase().includes("hover"))
  }, a.set(o, c)), c;
}
const n5 = (t) => qt(t) && Object.getOwnPropertyNames(t).some((e) => tc(t[e]));
function i5(t, e) {
  const { isScriptable: i, isIndexable: a } = wL(t);
  for (const o of e) {
    const c = i(o), u = a(o), h = (u || c) && t[o];
    if (c && (tc(h) || n5(h)) || u && Kn(h))
      return !0;
  }
  return !1;
}
var r5 = "4.4.8";
const a5 = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function yA(t, e) {
  return t === "top" || t === "bottom" || a5.indexOf(t) === -1 && e === "x";
}
function bA(t, e) {
  return function(i, a) {
    return i[t] === a[t] ? i[e] - a[e] : i[t] - a[t];
  };
}
function xA(t) {
  const e = t.chart, i = e.options.animation;
  e.notifyPlugins("afterRender"), Nn(i && i.onComplete, [
    t
  ], e);
}
function s5(t) {
  const e = t.chart, i = e.options.animation;
  Nn(i && i.onProgress, [
    t
  ], e);
}
function WL(t) {
  return IE() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;
}
const mx = {}, SA = (t) => {
  const e = WL(t);
  return Object.values(mx).filter((i) => i.canvas === e).pop();
};
function o5(t, e, i) {
  const a = Object.keys(t);
  for (const o of a) {
    const c = +o;
    if (c >= e) {
      const u = t[o];
      delete t[o], (i > 0 || c > e) && (t[c + i] = u);
    }
  }
}
function l5(t, e, i, a) {
  return !i || t.type === "mouseout" ? null : a ? e : t;
}
function Kb(t, e, i) {
  return t.options.clip ? t[i] : e[i];
}
function u5(t, e) {
  const { xScale: i, yScale: a } = t;
  return i && a ? {
    left: Kb(i, e, "left"),
    right: Kb(i, e, "right"),
    top: Kb(a, e, "top"),
    bottom: Kb(a, e, "bottom")
  } : e;
}
class Fo {
  static register(...e) {
    zo.add(...e), _A();
  }
  static unregister(...e) {
    zo.remove(...e), _A();
  }
  constructor(e, i) {
    const a = this.config = new t5(i), o = WL(e), c = SA(o);
    if (c)
      throw new Error("Canvas is already in use. Chart with ID '" + c.id + "' must be destroyed before the canvas with ID '" + c.canvas.id + "' can be reused.");
    const u = a.createResolver(a.chartOptionScopes(), this.getContext());
    this.platform = new (a.platform || E3(o))(), this.platform.updateConfig(a);
    const h = this.platform.acquireContext(o, u.aspectRatio), m = h && h.canvas, v = m && m.height, b = m && m.width;
    if (this.id = cI(), this.ctx = h, this.canvas = m, this.width = b, this.height = v, this._options = u, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new $3(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = DI((S) => this.update(S), u.resizeDelay || 0), this._dataChanges = [], mx[this.id] = this, !h || !m) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    jl.listen(this, "complete", xA), jl.listen(this, "progress", s5), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: e, maintainAspectRatio: i }, width: a, height: o, _aspectRatio: c } = this;
    return $t(e) ? i && c ? c : o ? a / o : null : e;
  }
  get data() {
    return this.config.data;
  }
  set data(e) {
    this.config.data = e;
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this.config.options = e;
  }
  get registry() {
    return zo;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : $M(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return HM(this.canvas, this.ctx), this;
  }
  stop() {
    return jl.stop(this), this;
  }
  resize(e, i) {
    jl.running(this) ? this._resizeBeforeDraw = {
      width: e,
      height: i
    } : this._resize(e, i);
  }
  _resize(e, i) {
    const a = this.options, o = this.canvas, c = a.maintainAspectRatio && this.aspectRatio, u = this.platform.getMaximumSize(o, e, i, c), h = a.devicePixelRatio || this.platform.getDevicePixelRatio(), m = this.width ? "resize" : "attach";
    this.width = u.width, this.height = u.height, this._aspectRatio = this.aspectRatio, $M(this, h, !0) && (this.notifyPlugins("resize", {
      size: u
    }), Nn(a.onResize, [
      this,
      u
    ], this), this.attached && this._doResize(m) && this.render());
  }
  ensureScalesHaveIDs() {
    const i = this.options.scales || {};
    _n(i, (a, o) => {
      a.id = o;
    });
  }
  buildOrUpdateScales() {
    const e = this.options, i = e.scales, a = this.scales, o = Object.keys(a).reduce((u, h) => (u[h] = !1, u), {});
    let c = [];
    i && (c = c.concat(Object.keys(i).map((u) => {
      const h = i[u], m = FT(u, h), v = m === "r", b = m === "x";
      return {
        options: h,
        dposition: v ? "chartArea" : b ? "bottom" : "left",
        dtype: v ? "radialLinear" : b ? "category" : "linear"
      };
    }))), _n(c, (u) => {
      const h = u.options, m = h.id, v = FT(m, h), b = zt(h.type, u.dtype);
      (h.position === void 0 || yA(h.position, v) !== yA(u.dposition)) && (h.position = u.dposition), o[m] = !0;
      let S = null;
      if (m in a && a[m].type === b)
        S = a[m];
      else {
        const w = zo.getScale(b);
        S = new w({
          id: m,
          type: b,
          ctx: this.ctx,
          chart: this
        }), a[S.id] = S;
      }
      S.init(h, e);
    }), _n(o, (u, h) => {
      u || delete a[h];
    }), _n(a, (u) => {
      Vr.configure(this, u, u.options), Vr.addBox(this, u);
    });
  }
  _updateMetasets() {
    const e = this._metasets, i = this.data.datasets.length, a = e.length;
    if (e.sort((o, c) => o.index - c.index), a > i) {
      for (let o = i; o < a; ++o)
        this._destroyDatasetMeta(o);
      e.splice(i, a - i);
    }
    this._sortedMetasets = e.slice(0).sort(bA("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: e, data: { datasets: i } } = this;
    e.length > i.length && delete this._stacks, e.forEach((a, o) => {
      i.filter((c) => c === a._dataset).length === 0 && this._destroyDatasetMeta(o);
    });
  }
  buildOrUpdateControllers() {
    const e = [], i = this.data.datasets;
    let a, o;
    for (this._removeUnreferencedMetasets(), a = 0, o = i.length; a < o; a++) {
      const c = i[a];
      let u = this.getDatasetMeta(a);
      const h = c.type || this.config.type;
      if (u.type && u.type !== h && (this._destroyDatasetMeta(a), u = this.getDatasetMeta(a)), u.type = h, u.indexAxis = c.indexAxis || zT(h, this.options), u.order = c.order || 0, u.index = a, u.label = "" + c.label, u.visible = this.isDatasetVisible(a), u.controller)
        u.controller.updateIndex(a), u.controller.linkScales();
      else {
        const m = zo.getController(h), { datasetElementType: v, dataElementType: b } = Qn.datasets[h];
        Object.assign(m, {
          dataElementType: zo.getElement(b),
          datasetElementType: v && zo.getElement(v)
        }), u.controller = new m(this, a), e.push(u.controller);
      }
    }
    return this._updateMetasets(), e;
  }
  _resetElements() {
    _n(this.data.datasets, (e, i) => {
      this.getDatasetMeta(i).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(e) {
    const i = this.config;
    i.update();
    const a = this._options = i.createResolver(i.chartOptionScopes(), this.getContext()), o = this._animationsDisabled = !a.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: e,
      cancelable: !0
    }) === !1)
      return;
    const c = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let u = 0;
    for (let v = 0, b = this.data.datasets.length; v < b; v++) {
      const { controller: S } = this.getDatasetMeta(v), w = !o && c.indexOf(S) === -1;
      S.buildOrUpdateElements(w), u = Math.max(+S.getMaxOverflow(), u);
    }
    u = this._minPadding = a.layout.autoPadding ? u : 0, this._updateLayout(u), o || _n(c, (v) => {
      v.reset();
    }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
      mode: e
    }), this._layers.sort(bA("z", "_idx"));
    const { _active: h, _lastEvent: m } = this;
    m ? this._eventHandler(m, !0) : h.length && this._updateHoverStyles(h, h, !0), this.render();
  }
  _updateScales() {
    _n(this.scales, (e) => {
      Vr.removeBox(this, e);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const e = this.options, i = new Set(Object.keys(this._listeners)), a = new Set(e.events);
    (!OM(i, a) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: e } = this, i = this._getUniformDataChanges() || [];
    for (const { method: a, start: o, count: c } of i) {
      const u = a === "_removeElements" ? -c : c;
      o5(e, o, u);
    }
  }
  _getUniformDataChanges() {
    const e = this._dataChanges;
    if (!e || !e.length)
      return;
    this._dataChanges = [];
    const i = this.data.datasets.length, a = (c) => new Set(e.filter((u) => u[0] === c).map((u, h) => h + "," + u.splice(1).join(","))), o = a(0);
    for (let c = 1; c < i; c++)
      if (!OM(o, a(c)))
        return;
    return Array.from(o).map((c) => c.split(",")).map((c) => ({
      method: c[1],
      start: +c[2],
      count: +c[3]
    }));
  }
  _updateLayout(e) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    Vr.update(this, this.width, this.height, e);
    const i = this.chartArea, a = i.width <= 0 || i.height <= 0;
    this._layers = [], _n(this.boxes, (o) => {
      a && o.position === "chartArea" || (o.configure && o.configure(), this._layers.push(...o._layers()));
    }, this), this._layers.forEach((o, c) => {
      o._idx = c;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(e) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: e,
      cancelable: !0
    }) !== !1) {
      for (let i = 0, a = this.data.datasets.length; i < a; ++i)
        this.getDatasetMeta(i).controller.configure();
      for (let i = 0, a = this.data.datasets.length; i < a; ++i)
        this._updateDataset(i, tc(e) ? e({
          datasetIndex: i
        }) : e);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: e
      });
    }
  }
  _updateDataset(e, i) {
    const a = this.getDatasetMeta(e), o = {
      meta: a,
      index: e,
      mode: i,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", o) !== !1 && (a.controller._update(i), o.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", o));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (jl.has(this) ? this.attached && !jl.running(this) && jl.start(this) : (this.draw(), xA({
      chart: this
    })));
  }
  draw() {
    let e;
    if (this._resizeBeforeDraw) {
      const { width: a, height: o } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(a, o);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this._layers;
    for (e = 0; e < i.length && i[e].z <= 0; ++e)
      i[e].draw(this.chartArea);
    for (this._drawDatasets(); e < i.length; ++e)
      i[e].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(e) {
    const i = this._sortedMetasets, a = [];
    let o, c;
    for (o = 0, c = i.length; o < c; ++o) {
      const u = i[o];
      (!e || u.visible) && a.push(u);
    }
    return a;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const e = this.getSortedVisibleDatasetMetas();
    for (let i = e.length - 1; i >= 0; --i)
      this._drawDataset(e[i]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(e) {
    const i = this.ctx, a = e._clip, o = !a.disabled, c = u5(e, this.chartArea), u = {
      meta: e,
      index: e.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", u) !== !1 && (o && Zx(i, {
      left: a.left === !1 ? 0 : c.left - a.left,
      right: a.right === !1 ? this.width : c.right + a.right,
      top: a.top === !1 ? 0 : c.top - a.top,
      bottom: a.bottom === !1 ? this.height : c.bottom + a.bottom
    }), e.controller.draw(), o && Jx(i), u.cancelable = !1, this.notifyPlugins("afterDatasetDraw", u));
  }
  isPointInArea(e) {
    return Yl(e, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, i, a, o) {
    const c = a3.modes[i];
    return typeof c == "function" ? c(this, e, a, o) : [];
  }
  getDatasetMeta(e) {
    const i = this.data.datasets[e], a = this._metasets;
    let o = a.filter((c) => c && c._dataset === i).pop();
    return o || (o = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: i && i.order || 0,
      index: e,
      _dataset: i,
      _parsed: [],
      _sorted: !1
    }, a.push(o)), o;
  }
  getContext() {
    return this.$context || (this.$context = ac(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(e) {
    const i = this.data.datasets[e];
    if (!i)
      return !1;
    const a = this.getDatasetMeta(e);
    return typeof a.hidden == "boolean" ? !a.hidden : !i.hidden;
  }
  setDatasetVisibility(e, i) {
    const a = this.getDatasetMeta(e);
    a.hidden = !i;
  }
  toggleDataVisibility(e) {
    this._hiddenIndices[e] = !this._hiddenIndices[e];
  }
  getDataVisibility(e) {
    return !this._hiddenIndices[e];
  }
  _updateVisibility(e, i, a) {
    const o = a ? "show" : "hide", c = this.getDatasetMeta(e), u = c.controller._resolveAnimations(void 0, o);
    hv(i) ? (c.data[i].hidden = !a, this.update()) : (this.setDatasetVisibility(e, a), u.update(c, {
      visible: a
    }), this.update((h) => h.datasetIndex === e ? o : void 0));
  }
  hide(e, i) {
    this._updateVisibility(e, i, !1);
  }
  show(e, i) {
    this._updateVisibility(e, i, !0);
  }
  _destroyDatasetMeta(e) {
    const i = this._metasets[e];
    i && i.controller && i.controller._destroy(), delete this._metasets[e];
  }
  _stop() {
    let e, i;
    for (this.stop(), jl.remove(this), e = 0, i = this.data.datasets.length; e < i; ++e)
      this._destroyDatasetMeta(e);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: e, ctx: i } = this;
    this._stop(), this.config.clearCache(), e && (this.unbindEvents(), HM(e, i), this.platform.releaseContext(i), this.canvas = null, this.ctx = null), delete mx[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...e) {
    return this.canvas.toDataURL(...e);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const e = this._listeners, i = this.platform, a = (c, u) => {
      i.addEventListener(this, c, u), e[c] = u;
    }, o = (c, u, h) => {
      c.offsetX = u, c.offsetY = h, this._eventHandler(c);
    };
    _n(this.options.events, (c) => a(c, o));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const e = this._responsiveListeners, i = this.platform, a = (m, v) => {
      i.addEventListener(this, m, v), e[m] = v;
    }, o = (m, v) => {
      e[m] && (i.removeEventListener(this, m, v), delete e[m]);
    }, c = (m, v) => {
      this.canvas && this.resize(m, v);
    };
    let u;
    const h = () => {
      o("attach", h), this.attached = !0, this.resize(), a("resize", c), a("detach", u);
    };
    u = () => {
      this.attached = !1, o("resize", c), this._stop(), this._resize(0, 0), a("attach", h);
    }, i.isAttached(this.canvas) ? h() : u();
  }
  unbindEvents() {
    _n(this._listeners, (e, i) => {
      this.platform.removeEventListener(this, i, e);
    }), this._listeners = {}, _n(this._responsiveListeners, (e, i) => {
      this.platform.removeEventListener(this, i, e);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(e, i, a) {
    const o = a ? "set" : "remove";
    let c, u, h, m;
    for (i === "dataset" && (c = this.getDatasetMeta(e[0].datasetIndex), c.controller["_" + o + "DatasetHoverStyle"]()), h = 0, m = e.length; h < m; ++h) {
      u = e[h];
      const v = u && this.getDatasetMeta(u.datasetIndex).controller;
      v && v[o + "HoverStyle"](u.element, u.datasetIndex, u.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e) {
    const i = this._active || [], a = e.map(({ datasetIndex: c, index: u }) => {
      const h = this.getDatasetMeta(c);
      if (!h)
        throw new Error("No dataset found at index " + c);
      return {
        datasetIndex: c,
        element: h.data[u],
        index: u
      };
    });
    !Cx(a, i) && (this._active = a, this._lastEvent = null, this._updateHoverStyles(a, i));
  }
  notifyPlugins(e, i, a) {
    return this._plugins.notify(this, e, i, a);
  }
  isPluginEnabled(e) {
    return this._plugins._cache.filter((i) => i.plugin.id === e).length === 1;
  }
  _updateHoverStyles(e, i, a) {
    const o = this.options.hover, c = (m, v) => m.filter((b) => !v.some((S) => b.datasetIndex === S.datasetIndex && b.index === S.index)), u = c(i, e), h = a ? e : c(e, i);
    u.length && this.updateHoverStyle(u, o.mode, !1), h.length && o.mode && this.updateHoverStyle(h, o.mode, !0);
  }
  _eventHandler(e, i) {
    const a = {
      event: e,
      replay: i,
      cancelable: !0,
      inChartArea: this.isPointInArea(e)
    }, o = (u) => (u.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", a, o) === !1)
      return;
    const c = this._handleEvent(e, i, a.inChartArea);
    return a.cancelable = !1, this.notifyPlugins("afterEvent", a, o), (c || a.changed) && this.render(), this;
  }
  _handleEvent(e, i, a) {
    const { _active: o = [], options: c } = this, u = i, h = this._getActiveElements(e, o, a, u), m = gI(e), v = l5(e, this._lastEvent, a, m);
    a && (this._lastEvent = null, Nn(c.onHover, [
      e,
      h,
      this
    ], this), m && Nn(c.onClick, [
      e,
      h,
      this
    ], this));
    const b = !Cx(h, o);
    return (b || i) && (this._active = h, this._updateHoverStyles(h, o, i)), this._lastEvent = v, b;
  }
  _getActiveElements(e, i, a, o) {
    if (e.type === "mouseout")
      return [];
    if (!a)
      return i;
    const c = this.options.hover;
    return this.getElementsAtEventForMode(e, c.mode, c, o);
  }
}
Ve(Fo, "defaults", Qn), Ve(Fo, "instances", mx), Ve(Fo, "overrides", $f), Ve(Fo, "registry", zo), Ve(Fo, "version", r5), Ve(Fo, "getChart", SA);
function _A() {
  return _n(Fo.instances, (t) => t._plugins.invalidate());
}
function c5(t, e, i) {
  const { startAngle: a, pixelMargin: o, x: c, y: u, outerRadius: h, innerRadius: m } = e;
  let v = o / h;
  t.beginPath(), t.arc(c, u, h, a - v, i + v), m > o ? (v = o / m, t.arc(c, u, m, i + v, a - v, !0)) : t.arc(c, u, o, i + Ti, a - Ti), t.closePath(), t.clip();
}
function f5(t) {
  return jE(t, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function d5(t, e, i, a) {
  const o = f5(t.options.borderRadius), c = (i - e) / 2, u = Math.min(c, a * e / 2), h = (m) => {
    const v = (i - Math.min(c, m)) * a / 2;
    return Ji(m, 0, Math.min(c, v));
  };
  return {
    outerStart: h(o.outerStart),
    outerEnd: h(o.outerEnd),
    innerStart: Ji(o.innerStart, 0, u),
    innerEnd: Ji(o.innerEnd, 0, u)
  };
}
function Wh(t, e, i, a) {
  return {
    x: i + t * Math.cos(e),
    y: a + t * Math.sin(e)
  };
}
function Mx(t, e, i, a, o, c) {
  const { x: u, y: h, startAngle: m, pixelMargin: v, innerRadius: b } = e, S = Math.max(e.outerRadius + a + i - v, 0), w = b > 0 ? b + a + i + v : 0;
  let E = 0;
  const R = o - m;
  if (a) {
    const Ee = b > 0 ? b - a : 0, we = S > 0 ? S - a : 0, Oe = (Ee + we) / 2, ae = Oe !== 0 ? R * Oe / (Oe + a) : R;
    E = (R - ae) / 2;
  }
  const M = Math.max(1e-3, R * S - i / In) / S, A = (R - M) / 2, P = m + A + E, z = o - A - E, { outerStart: B, outerEnd: j, innerStart: F, innerEnd: $ } = d5(e, w, S, z - P), I = S - B, K = S - j, ee = P + B / I, ne = z - j / K, le = w + F, re = w + $, se = P + F / le, Ne = z - $ / re;
  if (t.beginPath(), c) {
    const Ee = (ee + ne) / 2;
    if (t.arc(u, h, S, ee, Ee), t.arc(u, h, S, Ee, ne), j > 0) {
      const me = Wh(K, ne, u, h);
      t.arc(me.x, me.y, j, ne, z + Ti);
    }
    const we = Wh(re, z, u, h);
    if (t.lineTo(we.x, we.y), $ > 0) {
      const me = Wh(re, Ne, u, h);
      t.arc(me.x, me.y, $, z + Ti, Ne + Math.PI);
    }
    const Oe = (z - $ / w + (P + F / w)) / 2;
    if (t.arc(u, h, w, z - $ / w, Oe, !0), t.arc(u, h, w, Oe, P + F / w, !0), F > 0) {
      const me = Wh(le, se, u, h);
      t.arc(me.x, me.y, F, se + Math.PI, P - Ti);
    }
    const ae = Wh(I, P, u, h);
    if (t.lineTo(ae.x, ae.y), B > 0) {
      const me = Wh(I, ee, u, h);
      t.arc(me.x, me.y, B, P - Ti, ee);
    }
  } else {
    t.moveTo(u, h);
    const Ee = Math.cos(ee) * S + u, we = Math.sin(ee) * S + h;
    t.lineTo(Ee, we);
    const Oe = Math.cos(ne) * S + u, ae = Math.sin(ne) * S + h;
    t.lineTo(Oe, ae);
  }
  t.closePath();
}
function h5(t, e, i, a, o) {
  const { fullCircles: c, startAngle: u, circumference: h } = e;
  let m = e.endAngle;
  if (c) {
    Mx(t, e, i, a, m, o);
    for (let v = 0; v < c; ++v)
      t.fill();
    isNaN(h) || (m = u + (h % Un || Un));
  }
  return Mx(t, e, i, a, m, o), t.fill(), m;
}
function p5(t, e, i, a, o) {
  const { fullCircles: c, startAngle: u, circumference: h, options: m } = e, { borderWidth: v, borderJoinStyle: b, borderDash: S, borderDashOffset: w } = m, E = m.borderAlign === "inner";
  if (!v)
    return;
  t.setLineDash(S || []), t.lineDashOffset = w, E ? (t.lineWidth = v * 2, t.lineJoin = b || "round") : (t.lineWidth = v, t.lineJoin = b || "bevel");
  let R = e.endAngle;
  if (c) {
    Mx(t, e, i, a, R, o);
    for (let M = 0; M < c; ++M)
      t.stroke();
    isNaN(h) || (R = u + (h % Un || Un));
  }
  E && c5(t, e, R), c || (Mx(t, e, i, a, R, o), t.stroke());
}
class Kg extends Ql {
  constructor(i) {
    super();
    Ve(this, "circumference");
    Ve(this, "endAngle");
    Ve(this, "fullCircles");
    Ve(this, "innerRadius");
    Ve(this, "outerRadius");
    Ve(this, "pixelMargin");
    Ve(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, i && Object.assign(this, i);
  }
  inRange(i, a, o) {
    const c = this.getProps([
      "x",
      "y"
    ], o), { angle: u, distance: h } = hL(c, {
      x: i,
      y: a
    }), { startAngle: m, endAngle: v, innerRadius: b, outerRadius: S, circumference: w } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], o), E = (this.options.spacing + this.options.borderWidth) / 2, R = zt(w, v - m), M = pv(u, m, v) && m !== v, A = R >= Un || M, P = $l(h, b + E, S + E);
    return A && P;
  }
  getCenterPoint(i) {
    const { x: a, y: o, startAngle: c, endAngle: u, innerRadius: h, outerRadius: m } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], i), { offset: v, spacing: b } = this.options, S = (c + u) / 2, w = (h + m + b + v) / 2;
    return {
      x: a + Math.cos(S) * w,
      y: o + Math.sin(S) * w
    };
  }
  tooltipPosition(i) {
    return this.getCenterPoint(i);
  }
  draw(i) {
    const { options: a, circumference: o } = this, c = (a.offset || 0) / 4, u = (a.spacing || 0) / 2, h = a.circular;
    if (this.pixelMargin = a.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = o > Un ? Math.floor(o / Un) : 0, o === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    i.save();
    const m = (this.startAngle + this.endAngle) / 2;
    i.translate(Math.cos(m) * c, Math.sin(m) * c);
    const v = 1 - Math.sin(Math.min(In, o || 0)), b = c * v;
    i.fillStyle = a.backgroundColor, i.strokeStyle = a.borderColor, h5(i, this, b, u, h), p5(i, this, b, u, h), i.restore();
  }
}
Ve(Kg, "id", "arc"), Ve(Kg, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
}), Ve(Kg, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), Ve(Kg, "descriptors", {
  _scriptable: !0,
  _indexable: (i) => i !== "borderDash"
});
function YL(t, e, i = e) {
  t.lineCap = zt(i.borderCapStyle, e.borderCapStyle), t.setLineDash(zt(i.borderDash, e.borderDash)), t.lineDashOffset = zt(i.borderDashOffset, e.borderDashOffset), t.lineJoin = zt(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = zt(i.borderWidth, e.borderWidth), t.strokeStyle = zt(i.borderColor, e.borderColor);
}
function m5(t, e, i) {
  t.lineTo(i.x, i.y);
}
function g5(t) {
  return t.stepped ? jI : t.tension || t.cubicInterpolationMode === "monotone" ? BI : m5;
}
function GL(t, e, i = {}) {
  const a = t.length, { start: o = 0, end: c = a - 1 } = i, { start: u, end: h } = e, m = Math.max(o, u), v = Math.min(c, h), b = o < u && c < u || o > h && c > h;
  return {
    count: a,
    start: m,
    loop: e.loop,
    ilen: v < m && !b ? a + v - m : v - m
  };
}
function v5(t, e, i, a) {
  const { points: o, options: c } = e, { count: u, start: h, loop: m, ilen: v } = GL(o, i, a), b = g5(c);
  let { move: S = !0, reverse: w } = a || {}, E, R, M;
  for (E = 0; E <= v; ++E)
    R = o[(h + (w ? v - E : E)) % u], !R.skip && (S ? (t.moveTo(R.x, R.y), S = !1) : b(t, M, R, w, c.stepped), M = R);
  return m && (R = o[(h + (w ? v : 0)) % u], b(t, M, R, w, c.stepped)), !!m;
}
function y5(t, e, i, a) {
  const o = e.points, { count: c, start: u, ilen: h } = GL(o, i, a), { move: m = !0, reverse: v } = a || {};
  let b = 0, S = 0, w, E, R, M, A, P;
  const z = (j) => (u + (v ? h - j : j)) % c, B = () => {
    M !== A && (t.lineTo(b, A), t.lineTo(b, M), t.lineTo(b, P));
  };
  for (m && (E = o[z(0)], t.moveTo(E.x, E.y)), w = 0; w <= h; ++w) {
    if (E = o[z(w)], E.skip)
      continue;
    const j = E.x, F = E.y, $ = j | 0;
    $ === R ? (F < M ? M = F : F > A && (A = F), b = (S * b + j) / ++S) : (B(), t.lineTo(j, F), R = $, S = 0, M = A = F), P = F;
  }
  B();
}
function VT(t) {
  const e = t.options, i = e.borderDash && e.borderDash.length;
  return !t._decimated && !t._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !i ? y5 : v5;
}
function b5(t) {
  return t.stepped ? y$ : t.tension || t.cubicInterpolationMode === "monotone" ? b$ : Lf;
}
function x5(t, e, i, a) {
  let o = e._path;
  o || (o = e._path = new Path2D(), e.path(o, i, a) && o.closePath()), YL(t, e.options), t.stroke(o);
}
function S5(t, e, i, a) {
  const { segments: o, options: c } = e, u = VT(e);
  for (const h of o)
    YL(t, c, h.style), t.beginPath(), u(t, e, h, {
      start: i,
      end: i + a - 1
    }) && t.closePath(), t.stroke();
}
const _5 = typeof Path2D == "function";
function w5(t, e, i, a) {
  _5 && !e.options.segment ? x5(t, e, i, a) : S5(t, e, i, a);
}
class Ku extends Ql {
  constructor(e) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e);
  }
  updateControlPoints(e, i) {
    const a = this.options;
    if ((a.tension || a.cubicInterpolationMode === "monotone") && !a.stepped && !this._pointsUpdated) {
      const o = a.spanGaps ? this._loop : this._fullLoop;
      c$(this._points, a, e, o, i), this._pointsUpdated = !0;
    }
  }
  set points(e) {
    this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = T$(this, this.options.segment));
  }
  first() {
    const e = this.segments, i = this.points;
    return e.length && i[e[0].start];
  }
  last() {
    const e = this.segments, i = this.points, a = e.length;
    return a && i[e[a - 1].end];
  }
  interpolate(e, i) {
    const a = this.options, o = e[i], c = this.points, u = PL(this, {
      property: i,
      start: o,
      end: o
    });
    if (!u.length)
      return;
    const h = [], m = b5(a);
    let v, b;
    for (v = 0, b = u.length; v < b; ++v) {
      const { start: S, end: w } = u[v], E = c[S], R = c[w];
      if (E === R) {
        h.push(E);
        continue;
      }
      const M = Math.abs((o - E[i]) / (R[i] - E[i])), A = m(E, R, M, a.stepped);
      A[i] = e[i], h.push(A);
    }
    return h.length === 1 ? h[0] : h;
  }
  pathSegment(e, i, a) {
    return VT(this)(e, this, i, a);
  }
  path(e, i, a) {
    const o = this.segments, c = VT(this);
    let u = this._loop;
    i = i || 0, a = a || this.points.length - i;
    for (const h of o)
      u &= c(e, this, h, {
        start: i,
        end: i + a - 1
      });
    return !!u;
  }
  draw(e, i, a, o) {
    const c = this.options || {};
    (this.points || []).length && c.borderWidth && (e.save(), w5(e, this, a, o), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
Ve(Ku, "id", "line"), Ve(Ku, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), Ve(Ku, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), Ve(Ku, "descriptors", {
  _scriptable: !0,
  _indexable: (e) => e !== "borderDash" && e !== "fill"
});
function wA(t, e, i, a) {
  const o = t.options, { [i]: c } = t.getProps([
    i
  ], a);
  return Math.abs(e - c) < o.radius + o.hitRadius;
}
class gx extends Ql {
  constructor(i) {
    super();
    Ve(this, "parsed");
    Ve(this, "skip");
    Ve(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, i && Object.assign(this, i);
  }
  inRange(i, a, o) {
    const c = this.options, { x: u, y: h } = this.getProps([
      "x",
      "y"
    ], o);
    return Math.pow(i - u, 2) + Math.pow(a - h, 2) < Math.pow(c.hitRadius + c.radius, 2);
  }
  inXRange(i, a) {
    return wA(this, i, "x", a);
  }
  inYRange(i, a) {
    return wA(this, i, "y", a);
  }
  getCenterPoint(i) {
    const { x: a, y: o } = this.getProps([
      "x",
      "y"
    ], i);
    return {
      x: a,
      y: o
    };
  }
  size(i) {
    i = i || this.options || {};
    let a = i.radius || 0;
    a = Math.max(a, a && i.hoverRadius || 0);
    const o = a && i.borderWidth || 0;
    return (a + o) * 2;
  }
  draw(i, a) {
    const o = this.options;
    this.skip || o.radius < 0.1 || !Yl(this, a, this.size(o) / 2) || (i.strokeStyle = o.borderColor, i.lineWidth = o.borderWidth, i.fillStyle = o.backgroundColor, LT(i, o, this.x, this.y));
  }
  getRange() {
    const i = this.options || {};
    return i.radius + i.hitRadius;
  }
}
Ve(gx, "id", "point"), /**
* @type {any}
*/
Ve(gx, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
Ve(gx, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function KL(t, e) {
  const { x: i, y: a, base: o, width: c, height: u } = t.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], e);
  let h, m, v, b, S;
  return t.horizontal ? (S = u / 2, h = Math.min(i, o), m = Math.max(i, o), v = a - S, b = a + S) : (S = c / 2, h = i - S, m = i + S, v = Math.min(a, o), b = Math.max(a, o)), {
    left: h,
    top: v,
    right: m,
    bottom: b
  };
}
function Xu(t, e, i, a) {
  return t ? 0 : Ji(e, i, a);
}
function C5(t, e, i) {
  const a = t.options.borderWidth, o = t.borderSkipped, c = _L(a);
  return {
    t: Xu(o.top, c.top, 0, i),
    r: Xu(o.right, c.right, 0, e),
    b: Xu(o.bottom, c.bottom, 0, i),
    l: Xu(o.left, c.left, 0, e)
  };
}
function T5(t, e, i) {
  const { enableBorderRadius: a } = t.getProps([
    "enableBorderRadius"
  ]), o = t.options.borderRadius, c = Bf(o), u = Math.min(e, i), h = t.borderSkipped, m = a || qt(o);
  return {
    topLeft: Xu(!m || h.top || h.left, c.topLeft, 0, u),
    topRight: Xu(!m || h.top || h.right, c.topRight, 0, u),
    bottomLeft: Xu(!m || h.bottom || h.left, c.bottomLeft, 0, u),
    bottomRight: Xu(!m || h.bottom || h.right, c.bottomRight, 0, u)
  };
}
function E5(t) {
  const e = KL(t), i = e.right - e.left, a = e.bottom - e.top, o = C5(t, i / 2, a / 2), c = T5(t, i / 2, a / 2);
  return {
    outer: {
      x: e.left,
      y: e.top,
      w: i,
      h: a,
      radius: c
    },
    inner: {
      x: e.left + o.l,
      y: e.top + o.t,
      w: i - o.l - o.r,
      h: a - o.t - o.b,
      radius: {
        topLeft: Math.max(0, c.topLeft - Math.max(o.t, o.l)),
        topRight: Math.max(0, c.topRight - Math.max(o.t, o.r)),
        bottomLeft: Math.max(0, c.bottomLeft - Math.max(o.b, o.l)),
        bottomRight: Math.max(0, c.bottomRight - Math.max(o.b, o.r))
      }
    }
  };
}
function aT(t, e, i, a) {
  const o = e === null, c = i === null, h = t && !(o && c) && KL(t, a);
  return h && (o || $l(e, h.left, h.right)) && (c || $l(i, h.top, h.bottom));
}
function D5(t) {
  return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight;
}
function R5(t, e) {
  t.rect(e.x, e.y, e.w, e.h);
}
function sT(t, e, i = {}) {
  const a = t.x !== i.x ? -e : 0, o = t.y !== i.y ? -e : 0, c = (t.x + t.w !== i.x + i.w ? e : 0) - a, u = (t.y + t.h !== i.y + i.h ? e : 0) - o;
  return {
    x: t.x + a,
    y: t.y + o,
    w: t.w + c,
    h: t.h + u,
    radius: t.radius
  };
}
class vx extends Ql {
  constructor(e) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e);
  }
  draw(e) {
    const { inflateAmount: i, options: { borderColor: a, backgroundColor: o } } = this, { inner: c, outer: u } = E5(this), h = D5(u.radius) ? mv : R5;
    e.save(), (u.w !== c.w || u.h !== c.h) && (e.beginPath(), h(e, sT(u, i, c)), e.clip(), h(e, sT(c, -i, u)), e.fillStyle = a, e.fill("evenodd")), e.beginPath(), h(e, sT(c, i)), e.fillStyle = o, e.fill(), e.restore();
  }
  inRange(e, i, a) {
    return aT(this, e, i, a);
  }
  inXRange(e, i) {
    return aT(this, e, null, i);
  }
  inYRange(e, i) {
    return aT(this, null, e, i);
  }
  getCenterPoint(e) {
    const { x: i, y: a, base: o, horizontal: c } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], e);
    return {
      x: c ? (i + o) / 2 : i,
      y: c ? a : (a + o) / 2
    };
  }
  getRange(e) {
    return e === "x" ? this.width / 2 : this.height / 2;
  }
}
Ve(vx, "id", "bar"), Ve(vx, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), Ve(vx, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var k5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: Kg,
  BarElement: vx,
  LineElement: Ku,
  PointElement: gx
});
const jT = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
], CA = /* @__PURE__ */ jT.map((t) => t.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function XL(t) {
  return jT[t % jT.length];
}
function QL(t) {
  return CA[t % CA.length];
}
function M5(t, e) {
  return t.borderColor = XL(e), t.backgroundColor = QL(e), ++e;
}
function A5(t, e) {
  return t.backgroundColor = t.data.map(() => XL(e++)), e;
}
function O5(t, e) {
  return t.backgroundColor = t.data.map(() => QL(e++)), e;
}
function P5(t) {
  let e = 0;
  return (i, a) => {
    const o = t.getDatasetMeta(a).controller;
    o instanceof Ff ? e = A5(i, e) : o instanceof av ? e = O5(i, e) : o && (e = M5(i, e));
  };
}
function TA(t) {
  let e;
  for (e in t)
    if (t[e].borderColor || t[e].backgroundColor)
      return !0;
  return !1;
}
function L5(t) {
  return t && (t.borderColor || t.backgroundColor);
}
function N5() {
  return Qn.borderColor !== "rgba(0,0,0,0.1)" || Qn.backgroundColor !== "rgba(0,0,0,0.1)";
}
var z5 = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(t, e, i) {
    if (!i.enabled)
      return;
    const { data: { datasets: a }, options: o } = t.config, { elements: c } = o, u = TA(a) || L5(o) || c && TA(c) || N5();
    if (!i.forceOverride && u)
      return;
    const h = P5(t);
    a.forEach(h);
  }
};
function F5(t, e, i, a, o) {
  const c = o.samples || a;
  if (c >= i)
    return t.slice(e, e + i);
  const u = [], h = (i - 2) / (c - 2);
  let m = 0;
  const v = e + i - 1;
  let b = e, S, w, E, R, M;
  for (u[m++] = t[b], S = 0; S < c - 2; S++) {
    let A = 0, P = 0, z;
    const B = Math.floor((S + 1) * h) + 1 + e, j = Math.min(Math.floor((S + 2) * h) + 1, i) + e, F = j - B;
    for (z = B; z < j; z++)
      A += t[z].x, P += t[z].y;
    A /= F, P /= F;
    const $ = Math.floor(S * h) + 1 + e, I = Math.min(Math.floor((S + 1) * h) + 1, i) + e, { x: K, y: ee } = t[b];
    for (E = R = -1, z = $; z < I; z++)
      R = 0.5 * Math.abs((K - A) * (t[z].y - ee) - (K - t[z].x) * (P - ee)), R > E && (E = R, w = t[z], M = z);
    u[m++] = w, b = M;
  }
  return u[m++] = t[v], u;
}
function V5(t, e, i, a) {
  let o = 0, c = 0, u, h, m, v, b, S, w, E, R, M;
  const A = [], P = e + i - 1, z = t[e].x, j = t[P].x - z;
  for (u = e; u < e + i; ++u) {
    h = t[u], m = (h.x - z) / j * a, v = h.y;
    const F = m | 0;
    if (F === b)
      v < R ? (R = v, S = u) : v > M && (M = v, w = u), o = (c * o + h.x) / ++c;
    else {
      const $ = u - 1;
      if (!$t(S) && !$t(w)) {
        const I = Math.min(S, w), K = Math.max(S, w);
        I !== E && I !== $ && A.push({
          ...t[I],
          x: o
        }), K !== E && K !== $ && A.push({
          ...t[K],
          x: o
        });
      }
      u > 0 && $ !== E && A.push(t[$]), A.push(h), b = F, c = 0, R = M = v, S = w = E = u;
    }
  }
  return A;
}
function qL(t) {
  if (t._decimated) {
    const e = t._data;
    delete t._decimated, delete t._data, Object.defineProperty(t, "data", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: e
    });
  }
}
function EA(t) {
  t.data.datasets.forEach((e) => {
    qL(e);
  });
}
function j5(t, e) {
  const i = e.length;
  let a = 0, o;
  const { iScale: c } = t, { min: u, max: h, minDefined: m, maxDefined: v } = c.getUserBounds();
  return m && (a = Ji(Wl(e, c.axis, u).lo, 0, i - 1)), v ? o = Ji(Wl(e, c.axis, h).hi + 1, a, i) - a : o = i - a, {
    start: a,
    count: o
  };
}
var B5 = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (t, e, i) => {
    if (!i.enabled) {
      EA(t);
      return;
    }
    const a = t.width;
    t.data.datasets.forEach((o, c) => {
      const { _data: u, indexAxis: h } = o, m = t.getDatasetMeta(c), v = u || o.data;
      if (Yg([
        h,
        t.options.indexAxis
      ]) === "y" || !m.controller.supportsDecimation)
        return;
      const b = t.scales[m.xAxisID];
      if (b.type !== "linear" && b.type !== "time" || t.options.parsing)
        return;
      let { start: S, count: w } = j5(m, v);
      const E = i.threshold || 4 * a;
      if (w <= E) {
        qL(o);
        return;
      }
      $t(u) && (o._data = v, delete o.data, Object.defineProperty(o, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(M) {
          this._data = M;
        }
      }));
      let R;
      switch (i.algorithm) {
        case "lttb":
          R = F5(v, S, w, a, i);
          break;
        case "min-max":
          R = V5(v, S, w, a);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`);
      }
      o._decimated = R;
    });
  },
  destroy(t) {
    EA(t);
  }
};
function H5(t, e, i) {
  const a = t.segments, o = t.points, c = e.points, u = [];
  for (const h of a) {
    let { start: m, end: v } = h;
    v = YE(m, v, o);
    const b = BT(i, o[m], o[v], h.loop);
    if (!e.segments) {
      u.push({
        source: h,
        target: b,
        start: o[m],
        end: o[v]
      });
      continue;
    }
    const S = PL(e, b);
    for (const w of S) {
      const E = BT(i, c[w.start], c[w.end], w.loop), R = OL(h, o, E);
      for (const M of R)
        u.push({
          source: M,
          target: w,
          start: {
            [i]: DA(b, E, "start", Math.max)
          },
          end: {
            [i]: DA(b, E, "end", Math.min)
          }
        });
    }
  }
  return u;
}
function BT(t, e, i, a) {
  if (a)
    return;
  let o = e[t], c = i[t];
  return t === "angle" && (o = Ia(o), c = Ia(c)), {
    property: t,
    start: o,
    end: c
  };
}
function U5(t, e) {
  const { x: i = null, y: a = null } = t || {}, o = e.points, c = [];
  return e.segments.forEach(({ start: u, end: h }) => {
    h = YE(u, h, o);
    const m = o[u], v = o[h];
    a !== null ? (c.push({
      x: m.x,
      y: a
    }), c.push({
      x: v.x,
      y: a
    })) : i !== null && (c.push({
      x: i,
      y: m.y
    }), c.push({
      x: i,
      y: v.y
    }));
  }), c;
}
function YE(t, e, i) {
  for (; e > t; e--) {
    const a = i[e];
    if (!isNaN(a.x) && !isNaN(a.y))
      break;
  }
  return e;
}
function DA(t, e, i, a) {
  return t && e ? a(t[i], e[i]) : t ? t[i] : e ? e[i] : 0;
}
function ZL(t, e) {
  let i = [], a = !1;
  return Kn(t) ? (a = !0, i = t) : i = U5(t, e), i.length ? new Ku({
    points: i,
    options: {
      tension: 0
    },
    _loop: a,
    _fullLoop: a
  }) : null;
}
function RA(t) {
  return t && t.fill !== !1;
}
function I5(t, e, i) {
  let o = t[e].fill;
  const c = [
    e
  ];
  let u;
  if (!i)
    return o;
  for (; o !== !1 && c.indexOf(o) === -1; ) {
    if (!vi(o))
      return o;
    if (u = t[o], !u)
      return !1;
    if (u.visible)
      return o;
    c.push(o), o = u.fill;
  }
  return !1;
}
function $5(t, e, i) {
  const a = K5(t);
  if (qt(a))
    return isNaN(a.value) ? !1 : a;
  let o = parseFloat(a);
  return vi(o) && Math.floor(o) === o ? W5(a[0], e, o, i) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(a) >= 0 && a;
}
function W5(t, e, i, a) {
  return (t === "-" || t === "+") && (i = e + i), i === e || i < 0 || i >= a ? !1 : i;
}
function Y5(t, e) {
  let i = null;
  return t === "start" ? i = e.bottom : t === "end" ? i = e.top : qt(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i;
}
function G5(t, e, i) {
  let a;
  return t === "start" ? a = i : t === "end" ? a = e.options.reverse ? e.min : e.max : qt(t) ? a = t.value : a = e.getBaseValue(), a;
}
function K5(t) {
  const e = t.options, i = e.fill;
  let a = zt(i && i.target, i);
  return a === void 0 && (a = !!e.backgroundColor), a === !1 || a === null ? !1 : a === !0 ? "origin" : a;
}
function X5(t) {
  const { scale: e, index: i, line: a } = t, o = [], c = a.segments, u = a.points, h = Q5(e, i);
  h.push(ZL({
    x: null,
    y: e.bottom
  }, a));
  for (let m = 0; m < c.length; m++) {
    const v = c[m];
    for (let b = v.start; b <= v.end; b++)
      q5(o, u[b], h);
  }
  return new Ku({
    points: o,
    options: {}
  });
}
function Q5(t, e) {
  const i = [], a = t.getMatchingVisibleMetas("line");
  for (let o = 0; o < a.length; o++) {
    const c = a[o];
    if (c.index === e)
      break;
    c.hidden || i.unshift(c.dataset);
  }
  return i;
}
function q5(t, e, i) {
  const a = [];
  for (let o = 0; o < i.length; o++) {
    const c = i[o], { first: u, last: h, point: m } = Z5(c, e, "x");
    if (!(!m || u && h)) {
      if (u)
        a.unshift(m);
      else if (t.push(m), !h)
        break;
    }
  }
  t.push(...a);
}
function Z5(t, e, i) {
  const a = t.interpolate(e, i);
  if (!a)
    return {};
  const o = a[i], c = t.segments, u = t.points;
  let h = !1, m = !1;
  for (let v = 0; v < c.length; v++) {
    const b = c[v], S = u[b.start][i], w = u[b.end][i];
    if ($l(o, S, w)) {
      h = o === S, m = o === w;
      break;
    }
  }
  return {
    first: h,
    last: m,
    point: a
  };
}
class JL {
  constructor(e) {
    this.x = e.x, this.y = e.y, this.radius = e.radius;
  }
  pathSegment(e, i, a) {
    const { x: o, y: c, radius: u } = this;
    return i = i || {
      start: 0,
      end: Un
    }, e.arc(o, c, u, i.end, i.start, !0), !a.bounds;
  }
  interpolate(e) {
    const { x: i, y: a, radius: o } = this, c = e.angle;
    return {
      x: i + Math.cos(c) * o,
      y: a + Math.sin(c) * o,
      angle: c
    };
  }
}
function J5(t) {
  const { chart: e, fill: i, line: a } = t;
  if (vi(i))
    return e4(e, i);
  if (i === "stack")
    return X5(t);
  if (i === "shape")
    return !0;
  const o = t4(t);
  return o instanceof JL ? o : ZL(o, a);
}
function e4(t, e) {
  const i = t.getDatasetMeta(e);
  return i && t.isDatasetVisible(e) ? i.dataset : null;
}
function t4(t) {
  return (t.scale || {}).getPointPositionForValue ? i4(t) : n4(t);
}
function n4(t) {
  const { scale: e = {}, fill: i } = t, a = Y5(i, e);
  if (vi(a)) {
    const o = e.isHorizontal();
    return {
      x: o ? a : null,
      y: o ? null : a
    };
  }
  return null;
}
function i4(t) {
  const { scale: e, fill: i } = t, a = e.options, o = e.getLabels().length, c = a.reverse ? e.max : e.min, u = G5(i, e, c), h = [];
  if (a.grid.circular) {
    const m = e.getPointPositionForValue(0, c);
    return new JL({
      x: m.x,
      y: m.y,
      radius: e.getDistanceFromCenterForValue(u)
    });
  }
  for (let m = 0; m < o; ++m)
    h.push(e.getPointPositionForValue(m, u));
  return h;
}
function oT(t, e, i) {
  const a = J5(e), { line: o, scale: c, axis: u } = e, h = o.options, m = h.fill, v = h.backgroundColor, { above: b = v, below: S = v } = m || {};
  a && o.points.length && (Zx(t, i), r4(t, {
    line: o,
    target: a,
    above: b,
    below: S,
    area: i,
    scale: c,
    axis: u
  }), Jx(t));
}
function r4(t, e) {
  const { line: i, target: a, above: o, below: c, area: u, scale: h } = e, m = i._loop ? "angle" : e.axis;
  t.save(), m === "x" && c !== o && (kA(t, a, u.top), MA(t, {
    line: i,
    target: a,
    color: o,
    scale: h,
    property: m
  }), t.restore(), t.save(), kA(t, a, u.bottom)), MA(t, {
    line: i,
    target: a,
    color: c,
    scale: h,
    property: m
  }), t.restore();
}
function kA(t, e, i) {
  const { segments: a, points: o } = e;
  let c = !0, u = !1;
  t.beginPath();
  for (const h of a) {
    const { start: m, end: v } = h, b = o[m], S = o[YE(m, v, o)];
    c ? (t.moveTo(b.x, b.y), c = !1) : (t.lineTo(b.x, i), t.lineTo(b.x, b.y)), u = !!e.pathSegment(t, h, {
      move: u
    }), u ? t.closePath() : t.lineTo(S.x, i);
  }
  t.lineTo(e.first().x, i), t.closePath(), t.clip();
}
function MA(t, e) {
  const { line: i, target: a, property: o, color: c, scale: u } = e, h = H5(i, a, o);
  for (const { source: m, target: v, start: b, end: S } of h) {
    const { style: { backgroundColor: w = c } = {} } = m, E = a !== !0;
    t.save(), t.fillStyle = w, a4(t, u, E && BT(o, b, S)), t.beginPath();
    const R = !!i.pathSegment(t, m);
    let M;
    if (E) {
      R ? t.closePath() : AA(t, a, S, o);
      const A = !!a.pathSegment(t, v, {
        move: R,
        reverse: !0
      });
      M = R && A, M || AA(t, a, b, o);
    }
    t.closePath(), t.fill(M ? "evenodd" : "nonzero"), t.restore();
  }
}
function a4(t, e, i) {
  const { top: a, bottom: o } = e.chart.chartArea, { property: c, start: u, end: h } = i || {};
  c === "x" && (t.beginPath(), t.rect(u, a, h - u, o - a), t.clip());
}
function AA(t, e, i, a) {
  const o = e.interpolate(i, a);
  o && t.lineTo(o.x, o.y);
}
var s4 = {
  id: "filler",
  afterDatasetsUpdate(t, e, i) {
    const a = (t.data.datasets || []).length, o = [];
    let c, u, h, m;
    for (u = 0; u < a; ++u)
      c = t.getDatasetMeta(u), h = c.dataset, m = null, h && h.options && h instanceof Ku && (m = {
        visible: t.isDatasetVisible(u),
        index: u,
        fill: $5(h, u, a),
        chart: t,
        axis: c.controller.options.indexAxis,
        scale: c.vScale,
        line: h
      }), c.$filler = m, o.push(m);
    for (u = 0; u < a; ++u)
      m = o[u], !(!m || m.fill === !1) && (m.fill = I5(o, u, i.propagate));
  },
  beforeDraw(t, e, i) {
    const a = i.drawTime === "beforeDraw", o = t.getSortedVisibleDatasetMetas(), c = t.chartArea;
    for (let u = o.length - 1; u >= 0; --u) {
      const h = o[u].$filler;
      h && (h.line.updateControlPoints(c, h.axis), a && h.fill && oT(t.ctx, h, c));
    }
  },
  beforeDatasetsDraw(t, e, i) {
    if (i.drawTime !== "beforeDatasetsDraw")
      return;
    const a = t.getSortedVisibleDatasetMetas();
    for (let o = a.length - 1; o >= 0; --o) {
      const c = a[o].$filler;
      RA(c) && oT(t.ctx, c, t.chartArea);
    }
  },
  beforeDatasetDraw(t, e, i) {
    const a = e.meta.$filler;
    !RA(a) || i.drawTime !== "beforeDatasetDraw" || oT(t.ctx, a, t.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const OA = (t, e) => {
  let { boxHeight: i = e, boxWidth: a = e } = t;
  return t.usePointStyle && (i = Math.min(i, e), a = t.pointStyleWidth || Math.min(a, e)), {
    boxWidth: a,
    boxHeight: i,
    itemHeight: Math.max(e, i)
  };
}, o4 = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index;
class PA extends Ql {
  constructor(e) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, i, a) {
    this.maxWidth = e, this.maxHeight = i, this._margins = a, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const e = this.options.labels || {};
    let i = Nn(e.generateLabels, [
      this.chart
    ], this) || [];
    e.filter && (i = i.filter((a) => e.filter(a, this.chart.data))), e.sort && (i = i.sort((a, o) => e.sort(a, o, this.chart.data))), this.options.reverse && i.reverse(), this.legendItems = i;
  }
  fit() {
    const { options: e, ctx: i } = this;
    if (!e.display) {
      this.width = this.height = 0;
      return;
    }
    const a = e.labels, o = Ki(a.font), c = o.size, u = this._computeTitleHeight(), { boxWidth: h, itemHeight: m } = OA(a, c);
    let v, b;
    i.font = o.string, this.isHorizontal() ? (v = this.maxWidth, b = this._fitRows(u, c, h, m) + 10) : (b = this.maxHeight, v = this._fitCols(u, o, h, m) + 10), this.width = Math.min(v, e.maxWidth || this.maxWidth), this.height = Math.min(b, e.maxHeight || this.maxHeight);
  }
  _fitRows(e, i, a, o) {
    const { ctx: c, maxWidth: u, options: { labels: { padding: h } } } = this, m = this.legendHitBoxes = [], v = this.lineWidths = [
      0
    ], b = o + h;
    let S = e;
    c.textAlign = "left", c.textBaseline = "middle";
    let w = -1, E = -b;
    return this.legendItems.forEach((R, M) => {
      const A = a + i / 2 + c.measureText(R.text).width;
      (M === 0 || v[v.length - 1] + A + 2 * h > u) && (S += b, v[v.length - (M > 0 ? 0 : 1)] = 0, E += b, w++), m[M] = {
        left: 0,
        top: E,
        row: w,
        width: A,
        height: o
      }, v[v.length - 1] += A + h;
    }), S;
  }
  _fitCols(e, i, a, o) {
    const { ctx: c, maxHeight: u, options: { labels: { padding: h } } } = this, m = this.legendHitBoxes = [], v = this.columnSizes = [], b = u - e;
    let S = h, w = 0, E = 0, R = 0, M = 0;
    return this.legendItems.forEach((A, P) => {
      const { itemWidth: z, itemHeight: B } = l4(a, i, c, A, o);
      P > 0 && E + B + 2 * h > b && (S += w + h, v.push({
        width: w,
        height: E
      }), R += w + h, M++, w = E = 0), m[P] = {
        left: R,
        top: E,
        col: M,
        width: z,
        height: B
      }, w = Math.max(w, z), E += B + h;
    }), S += w, v.push({
      width: w,
      height: E
    }), S;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const e = this._computeTitleHeight(), { legendHitBoxes: i, options: { align: a, labels: { padding: o }, rtl: c } } = this, u = tp(c, this.left, this.width);
    if (this.isHorizontal()) {
      let h = 0, m = zr(a, this.left + o, this.right - this.lineWidths[h]);
      for (const v of i)
        h !== v.row && (h = v.row, m = zr(a, this.left + o, this.right - this.lineWidths[h])), v.top += this.top + e + o, v.left = u.leftForLtr(u.x(m), v.width), m += v.width + o;
    } else {
      let h = 0, m = zr(a, this.top + e + o, this.bottom - this.columnSizes[h].height);
      for (const v of i)
        v.col !== h && (h = v.col, m = zr(a, this.top + e + o, this.bottom - this.columnSizes[h].height)), v.top = m, v.left += this.left + o, v.left = u.leftForLtr(u.x(v.left), v.width), m += v.height + o;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const e = this.ctx;
      Zx(e, this), this._draw(), Jx(e);
    }
  }
  _draw() {
    const { options: e, columnSizes: i, lineWidths: a, ctx: o } = this, { align: c, labels: u } = e, h = Qn.color, m = tp(e.rtl, this.left, this.width), v = Ki(u.font), { padding: b } = u, S = v.size, w = S / 2;
    let E;
    this.drawTitle(), o.textAlign = m.textAlign("left"), o.textBaseline = "middle", o.lineWidth = 0.5, o.font = v.string;
    const { boxWidth: R, boxHeight: M, itemHeight: A } = OA(u, S), P = function($, I, K) {
      if (isNaN(R) || R <= 0 || isNaN(M) || M < 0)
        return;
      o.save();
      const ee = zt(K.lineWidth, 1);
      if (o.fillStyle = zt(K.fillStyle, h), o.lineCap = zt(K.lineCap, "butt"), o.lineDashOffset = zt(K.lineDashOffset, 0), o.lineJoin = zt(K.lineJoin, "miter"), o.lineWidth = ee, o.strokeStyle = zt(K.strokeStyle, h), o.setLineDash(zt(K.lineDash, [])), u.usePointStyle) {
        const ne = {
          radius: M * Math.SQRT2 / 2,
          pointStyle: K.pointStyle,
          rotation: K.rotation,
          borderWidth: ee
        }, le = m.xPlus($, R / 2), re = I + w;
        SL(o, ne, le, re, u.pointStyleWidth && R);
      } else {
        const ne = I + Math.max((S - M) / 2, 0), le = m.leftForLtr($, R), re = Bf(K.borderRadius);
        o.beginPath(), Object.values(re).some((se) => se !== 0) ? mv(o, {
          x: le,
          y: ne,
          w: R,
          h: M,
          radius: re
        }) : o.rect(le, ne, R, M), o.fill(), ee !== 0 && o.stroke();
      }
      o.restore();
    }, z = function($, I, K) {
      Wf(o, K.text, $, I + A / 2, v, {
        strikethrough: K.hidden,
        textAlign: m.textAlign(K.textAlign)
      });
    }, B = this.isHorizontal(), j = this._computeTitleHeight();
    B ? E = {
      x: zr(c, this.left + b, this.right - a[0]),
      y: this.top + b + j,
      line: 0
    } : E = {
      x: this.left + b,
      y: zr(c, this.top + j + b, this.bottom - i[0].height),
      line: 0
    }, kL(this.ctx, e.textDirection);
    const F = A + b;
    this.legendItems.forEach(($, I) => {
      o.strokeStyle = $.fontColor, o.fillStyle = $.fontColor;
      const K = o.measureText($.text).width, ee = m.textAlign($.textAlign || ($.textAlign = u.textAlign)), ne = R + w + K;
      let le = E.x, re = E.y;
      m.setWidth(this.width), B ? I > 0 && le + ne + b > this.right && (re = E.y += F, E.line++, le = E.x = zr(c, this.left + b, this.right - a[E.line])) : I > 0 && re + F > this.bottom && (le = E.x = le + i[E.line].width + b, E.line++, re = E.y = zr(c, this.top + j + b, this.bottom - i[E.line].height));
      const se = m.x(le);
      if (P(se, re, $), le = RI(ee, le + R + w, B ? le + ne : this.right, e.rtl), z(m.x(le), re, $), B)
        E.x += ne + b;
      else if (typeof $.text != "string") {
        const Ne = v.lineHeight;
        E.y += eN($, Ne) + b;
      } else
        E.y += F;
    }), ML(this.ctx, e.textDirection);
  }
  drawTitle() {
    const e = this.options, i = e.title, a = Ki(i.font), o = Br(i.padding);
    if (!i.display)
      return;
    const c = tp(e.rtl, this.left, this.width), u = this.ctx, h = i.position, m = a.size / 2, v = o.top + m;
    let b, S = this.left, w = this.width;
    if (this.isHorizontal())
      w = Math.max(...this.lineWidths), b = this.top + v, S = zr(e.align, S, this.right - w);
    else {
      const R = this.columnSizes.reduce((M, A) => Math.max(M, A.height), 0);
      b = v + zr(e.align, this.top, this.bottom - R - e.labels.padding - this._computeTitleHeight());
    }
    const E = zr(h, S, S + w);
    u.textAlign = c.textAlign(FE(h)), u.textBaseline = "middle", u.strokeStyle = i.color, u.fillStyle = i.color, u.font = a.string, Wf(u, i.text, E, b, a);
  }
  _computeTitleHeight() {
    const e = this.options.title, i = Ki(e.font), a = Br(e.padding);
    return e.display ? i.lineHeight + a.height : 0;
  }
  _getLegendItemAt(e, i) {
    let a, o, c;
    if ($l(e, this.left, this.right) && $l(i, this.top, this.bottom)) {
      for (c = this.legendHitBoxes, a = 0; a < c.length; ++a)
        if (o = c[a], $l(e, o.left, o.left + o.width) && $l(i, o.top, o.top + o.height))
          return this.legendItems[a];
    }
    return null;
  }
  handleEvent(e) {
    const i = this.options;
    if (!f4(e.type, i))
      return;
    const a = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const o = this._hoveredItem, c = o4(o, a);
      o && !c && Nn(i.onLeave, [
        e,
        o,
        this
      ], this), this._hoveredItem = a, a && !c && Nn(i.onHover, [
        e,
        a,
        this
      ], this);
    } else a && Nn(i.onClick, [
      e,
      a,
      this
    ], this);
  }
}
function l4(t, e, i, a, o) {
  const c = u4(a, t, e, i), u = c4(o, a, e.lineHeight);
  return {
    itemWidth: c,
    itemHeight: u
  };
}
function u4(t, e, i, a) {
  let o = t.text;
  return o && typeof o != "string" && (o = o.reduce((c, u) => c.length > u.length ? c : u)), e + i.size / 2 + a.measureText(o).width;
}
function c4(t, e, i) {
  let a = t;
  return typeof e.text != "string" && (a = eN(e, i)), a;
}
function eN(t, e) {
  const i = t.text ? t.text.length : 0;
  return e * i;
}
function f4(t, e) {
  return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup"));
}
var d4 = {
  id: "legend",
  _element: PA,
  start(t, e, i) {
    const a = t.legend = new PA({
      ctx: t.ctx,
      options: i,
      chart: t
    });
    Vr.configure(t, a, i), Vr.addBox(t, a);
  },
  stop(t) {
    Vr.removeBox(t, t.legend), delete t.legend;
  },
  beforeUpdate(t, e, i) {
    const a = t.legend;
    Vr.configure(t, a, i), a.options = i;
  },
  afterUpdate(t) {
    const e = t.legend;
    e.buildLabels(), e.adjustHitBoxes();
  },
  afterEvent(t, e) {
    e.replay || t.legend.handleEvent(e.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(t, e, i) {
      const a = e.datasetIndex, o = i.chart;
      o.isDatasetVisible(a) ? (o.hide(a), e.hidden = !0) : (o.show(a), e.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (t) => t.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(t) {
        const e = t.data.datasets, { labels: { usePointStyle: i, pointStyle: a, textAlign: o, color: c, useBorderRadius: u, borderRadius: h } } = t.legend.options;
        return t._getSortedDatasetMetas().map((m) => {
          const v = m.controller.getStyle(i ? 0 : void 0), b = Br(v.borderWidth);
          return {
            text: e[m.index].label,
            fillStyle: v.backgroundColor,
            fontColor: c,
            hidden: !m.visible,
            lineCap: v.borderCapStyle,
            lineDash: v.borderDash,
            lineDashOffset: v.borderDashOffset,
            lineJoin: v.borderJoinStyle,
            lineWidth: (b.width + b.height) / 4,
            strokeStyle: v.borderColor,
            pointStyle: a || v.pointStyle,
            rotation: v.rotation,
            textAlign: o || v.textAlign,
            borderRadius: u && (h || v.borderRadius),
            datasetIndex: m.index
          };
        }, this);
      }
    },
    title: {
      color: (t) => t.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (t) => !t.startsWith("on"),
    labels: {
      _scriptable: (t) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(t)
    }
  }
};
class GE extends Ql {
  constructor(e) {
    super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, i) {
    const a = this.options;
    if (this.left = 0, this.top = 0, !a.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = e, this.height = this.bottom = i;
    const o = Kn(a.text) ? a.text.length : 1;
    this._padding = Br(a.padding);
    const c = o * Ki(a.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = c : this.width = c;
  }
  isHorizontal() {
    const e = this.options.position;
    return e === "top" || e === "bottom";
  }
  _drawArgs(e) {
    const { top: i, left: a, bottom: o, right: c, options: u } = this, h = u.align;
    let m = 0, v, b, S;
    return this.isHorizontal() ? (b = zr(h, a, c), S = i + e, v = c - a) : (u.position === "left" ? (b = a + e, S = zr(h, o, i), m = In * -0.5) : (b = c - e, S = zr(h, i, o), m = In * 0.5), v = o - i), {
      titleX: b,
      titleY: S,
      maxWidth: v,
      rotation: m
    };
  }
  draw() {
    const e = this.ctx, i = this.options;
    if (!i.display)
      return;
    const a = Ki(i.font), c = a.lineHeight / 2 + this._padding.top, { titleX: u, titleY: h, maxWidth: m, rotation: v } = this._drawArgs(c);
    Wf(e, i.text, 0, 0, a, {
      color: i.color,
      maxWidth: m,
      rotation: v,
      textAlign: FE(i.align),
      textBaseline: "middle",
      translation: [
        u,
        h
      ]
    });
  }
}
function h4(t, e) {
  const i = new GE({
    ctx: t.ctx,
    options: e,
    chart: t
  });
  Vr.configure(t, i, e), Vr.addBox(t, i), t.titleBlock = i;
}
var p4 = {
  id: "title",
  _element: GE,
  start(t, e, i) {
    h4(t, i);
  },
  stop(t) {
    const e = t.titleBlock;
    Vr.removeBox(t, e), delete t.titleBlock;
  },
  beforeUpdate(t, e, i) {
    const a = t.titleBlock;
    Vr.configure(t, a, i), a.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Xb = /* @__PURE__ */ new WeakMap();
var m4 = {
  id: "subtitle",
  start(t, e, i) {
    const a = new GE({
      ctx: t.ctx,
      options: i,
      chart: t
    });
    Vr.configure(t, a, i), Vr.addBox(t, a), Xb.set(t, a);
  },
  stop(t) {
    Vr.removeBox(t, Xb.get(t)), Xb.delete(t);
  },
  beforeUpdate(t, e, i) {
    const a = Xb.get(t);
    Vr.configure(t, a, i), a.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Xg = {
  average(t) {
    if (!t.length)
      return !1;
    let e, i, a = /* @__PURE__ */ new Set(), o = 0, c = 0;
    for (e = 0, i = t.length; e < i; ++e) {
      const h = t[e].element;
      if (h && h.hasValue()) {
        const m = h.tooltipPosition();
        a.add(m.x), o += m.y, ++c;
      }
    }
    return c === 0 || a.size === 0 ? !1 : {
      x: [
        ...a
      ].reduce((h, m) => h + m) / a.size,
      y: o / c
    };
  },
  nearest(t, e) {
    if (!t.length)
      return !1;
    let i = e.x, a = e.y, o = Number.POSITIVE_INFINITY, c, u, h;
    for (c = 0, u = t.length; c < u; ++c) {
      const m = t[c].element;
      if (m && m.hasValue()) {
        const v = m.getCenterPoint(), b = OT(e, v);
        b < o && (o = b, h = m);
      }
    }
    if (h) {
      const m = h.tooltipPosition();
      i = m.x, a = m.y;
    }
    return {
      x: i,
      y: a
    };
  }
};
function Lo(t, e) {
  return e && (Kn(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
}
function Bl(t) {
  return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t;
}
function g4(t, e) {
  const { element: i, datasetIndex: a, index: o } = e, c = t.getDatasetMeta(a).controller, { label: u, value: h } = c.getLabelAndValue(o);
  return {
    chart: t,
    label: u,
    parsed: c.getParsed(o),
    raw: t.data.datasets[a].data[o],
    formattedValue: h,
    dataset: c.getDataset(),
    dataIndex: o,
    datasetIndex: a,
    element: i
  };
}
function LA(t, e) {
  const i = t.chart.ctx, { body: a, footer: o, title: c } = t, { boxWidth: u, boxHeight: h } = e, m = Ki(e.bodyFont), v = Ki(e.titleFont), b = Ki(e.footerFont), S = c.length, w = o.length, E = a.length, R = Br(e.padding);
  let M = R.height, A = 0, P = a.reduce((j, F) => j + F.before.length + F.lines.length + F.after.length, 0);
  if (P += t.beforeBody.length + t.afterBody.length, S && (M += S * v.lineHeight + (S - 1) * e.titleSpacing + e.titleMarginBottom), P) {
    const j = e.displayColors ? Math.max(h, m.lineHeight) : m.lineHeight;
    M += E * j + (P - E) * m.lineHeight + (P - 1) * e.bodySpacing;
  }
  w && (M += e.footerMarginTop + w * b.lineHeight + (w - 1) * e.footerSpacing);
  let z = 0;
  const B = function(j) {
    A = Math.max(A, i.measureText(j).width + z);
  };
  return i.save(), i.font = v.string, _n(t.title, B), i.font = m.string, _n(t.beforeBody.concat(t.afterBody), B), z = e.displayColors ? u + 2 + e.boxPadding : 0, _n(a, (j) => {
    _n(j.before, B), _n(j.lines, B), _n(j.after, B);
  }), z = 0, i.font = b.string, _n(t.footer, B), i.restore(), A += R.width, {
    width: A,
    height: M
  };
}
function v4(t, e) {
  const { y: i, height: a } = e;
  return i < a / 2 ? "top" : i > t.height - a / 2 ? "bottom" : "center";
}
function y4(t, e, i, a) {
  const { x: o, width: c } = a, u = i.caretSize + i.caretPadding;
  if (t === "left" && o + c + u > e.width || t === "right" && o - c - u < 0)
    return !0;
}
function b4(t, e, i, a) {
  const { x: o, width: c } = i, { width: u, chartArea: { left: h, right: m } } = t;
  let v = "center";
  return a === "center" ? v = o <= (h + m) / 2 ? "left" : "right" : o <= c / 2 ? v = "left" : o >= u - c / 2 && (v = "right"), y4(v, t, e, i) && (v = "center"), v;
}
function NA(t, e, i) {
  const a = i.yAlign || e.yAlign || v4(t, i);
  return {
    xAlign: i.xAlign || e.xAlign || b4(t, e, i, a),
    yAlign: a
  };
}
function x4(t, e) {
  let { x: i, width: a } = t;
  return e === "right" ? i -= a : e === "center" && (i -= a / 2), i;
}
function S4(t, e, i) {
  let { y: a, height: o } = t;
  return e === "top" ? a += i : e === "bottom" ? a -= o + i : a -= o / 2, a;
}
function zA(t, e, i, a) {
  const { caretSize: o, caretPadding: c, cornerRadius: u } = t, { xAlign: h, yAlign: m } = i, v = o + c, { topLeft: b, topRight: S, bottomLeft: w, bottomRight: E } = Bf(u);
  let R = x4(e, h);
  const M = S4(e, m, v);
  return m === "center" ? h === "left" ? R += v : h === "right" && (R -= v) : h === "left" ? R -= Math.max(b, w) + o : h === "right" && (R += Math.max(S, E) + o), {
    x: Ji(R, 0, a.width - e.width),
    y: Ji(M, 0, a.height - e.height)
  };
}
function Qb(t, e, i) {
  const a = Br(i.padding);
  return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - a.right : t.x + a.left;
}
function FA(t) {
  return Lo([], Bl(t));
}
function _4(t, e, i) {
  return ac(t, {
    tooltip: e,
    tooltipItems: i,
    type: "tooltip"
  });
}
function VA(t, e) {
  const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
  return i ? t.override(i) : t;
}
const tN = {
  beforeTitle: Vl,
  title(t) {
    if (t.length > 0) {
      const e = t[0], i = e.chart.data.labels, a = i ? i.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return e.dataset.label || "";
      if (e.label)
        return e.label;
      if (a > 0 && e.dataIndex < a)
        return i[e.dataIndex];
    }
    return "";
  },
  afterTitle: Vl,
  beforeBody: Vl,
  beforeLabel: Vl,
  label(t) {
    if (this && this.options && this.options.mode === "dataset")
      return t.label + ": " + t.formattedValue || t.formattedValue;
    let e = t.dataset.label || "";
    e && (e += ": ");
    const i = t.formattedValue;
    return $t(i) || (e += i), e;
  },
  labelColor(t) {
    const i = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
    return {
      borderColor: i.borderColor,
      backgroundColor: i.backgroundColor,
      borderWidth: i.borderWidth,
      borderDash: i.borderDash,
      borderDashOffset: i.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(t) {
    const i = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
    return {
      pointStyle: i.pointStyle,
      rotation: i.rotation
    };
  },
  afterLabel: Vl,
  afterBody: Vl,
  beforeFooter: Vl,
  footer: Vl,
  afterFooter: Vl
};
function ya(t, e, i, a) {
  const o = t[e].call(i, a);
  return typeof o > "u" ? tN[e].call(i, a) : o;
}
class HT extends Ql {
  constructor(e) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(e) {
    this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const e = this._cachedAnimations;
    if (e)
      return e;
    const i = this.chart, a = this.options.setContext(this.getContext()), o = a.enabled && i.options.animation && a.animations, c = new LL(this.chart, o);
    return o._cacheable && (this._cachedAnimations = Object.freeze(c)), c;
  }
  getContext() {
    return this.$context || (this.$context = _4(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(e, i) {
    const { callbacks: a } = i, o = ya(a, "beforeTitle", this, e), c = ya(a, "title", this, e), u = ya(a, "afterTitle", this, e);
    let h = [];
    return h = Lo(h, Bl(o)), h = Lo(h, Bl(c)), h = Lo(h, Bl(u)), h;
  }
  getBeforeBody(e, i) {
    return FA(ya(i.callbacks, "beforeBody", this, e));
  }
  getBody(e, i) {
    const { callbacks: a } = i, o = [];
    return _n(e, (c) => {
      const u = {
        before: [],
        lines: [],
        after: []
      }, h = VA(a, c);
      Lo(u.before, Bl(ya(h, "beforeLabel", this, c))), Lo(u.lines, ya(h, "label", this, c)), Lo(u.after, Bl(ya(h, "afterLabel", this, c))), o.push(u);
    }), o;
  }
  getAfterBody(e, i) {
    return FA(ya(i.callbacks, "afterBody", this, e));
  }
  getFooter(e, i) {
    const { callbacks: a } = i, o = ya(a, "beforeFooter", this, e), c = ya(a, "footer", this, e), u = ya(a, "afterFooter", this, e);
    let h = [];
    return h = Lo(h, Bl(o)), h = Lo(h, Bl(c)), h = Lo(h, Bl(u)), h;
  }
  _createItems(e) {
    const i = this._active, a = this.chart.data, o = [], c = [], u = [];
    let h = [], m, v;
    for (m = 0, v = i.length; m < v; ++m)
      h.push(g4(this.chart, i[m]));
    return e.filter && (h = h.filter((b, S, w) => e.filter(b, S, w, a))), e.itemSort && (h = h.sort((b, S) => e.itemSort(b, S, a))), _n(h, (b) => {
      const S = VA(e.callbacks, b);
      o.push(ya(S, "labelColor", this, b)), c.push(ya(S, "labelPointStyle", this, b)), u.push(ya(S, "labelTextColor", this, b));
    }), this.labelColors = o, this.labelPointStyles = c, this.labelTextColors = u, this.dataPoints = h, h;
  }
  update(e, i) {
    const a = this.options.setContext(this.getContext()), o = this._active;
    let c, u = [];
    if (!o.length)
      this.opacity !== 0 && (c = {
        opacity: 0
      });
    else {
      const h = Xg[a.position].call(this, o, this._eventPosition);
      u = this._createItems(a), this.title = this.getTitle(u, a), this.beforeBody = this.getBeforeBody(u, a), this.body = this.getBody(u, a), this.afterBody = this.getAfterBody(u, a), this.footer = this.getFooter(u, a);
      const m = this._size = LA(this, a), v = Object.assign({}, h, m), b = NA(this.chart, a, v), S = zA(a, v, b, this.chart);
      this.xAlign = b.xAlign, this.yAlign = b.yAlign, c = {
        opacity: 1,
        x: S.x,
        y: S.y,
        width: m.width,
        height: m.height,
        caretX: h.x,
        caretY: h.y
      };
    }
    this._tooltipItems = u, this.$context = void 0, c && this._resolveAnimations().update(this, c), e && a.external && a.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: i
    });
  }
  drawCaret(e, i, a, o) {
    const c = this.getCaretPosition(e, a, o);
    i.lineTo(c.x1, c.y1), i.lineTo(c.x2, c.y2), i.lineTo(c.x3, c.y3);
  }
  getCaretPosition(e, i, a) {
    const { xAlign: o, yAlign: c } = this, { caretSize: u, cornerRadius: h } = a, { topLeft: m, topRight: v, bottomLeft: b, bottomRight: S } = Bf(h), { x: w, y: E } = e, { width: R, height: M } = i;
    let A, P, z, B, j, F;
    return c === "center" ? (j = E + M / 2, o === "left" ? (A = w, P = A - u, B = j + u, F = j - u) : (A = w + R, P = A + u, B = j - u, F = j + u), z = A) : (o === "left" ? P = w + Math.max(m, b) + u : o === "right" ? P = w + R - Math.max(v, S) - u : P = this.caretX, c === "top" ? (B = E, j = B - u, A = P - u, z = P + u) : (B = E + M, j = B + u, A = P + u, z = P - u), F = B), {
      x1: A,
      x2: P,
      x3: z,
      y1: B,
      y2: j,
      y3: F
    };
  }
  drawTitle(e, i, a) {
    const o = this.title, c = o.length;
    let u, h, m;
    if (c) {
      const v = tp(a.rtl, this.x, this.width);
      for (e.x = Qb(this, a.titleAlign, a), i.textAlign = v.textAlign(a.titleAlign), i.textBaseline = "middle", u = Ki(a.titleFont), h = a.titleSpacing, i.fillStyle = a.titleColor, i.font = u.string, m = 0; m < c; ++m)
        i.fillText(o[m], v.x(e.x), e.y + u.lineHeight / 2), e.y += u.lineHeight + h, m + 1 === c && (e.y += a.titleMarginBottom - h);
    }
  }
  _drawColorBox(e, i, a, o, c) {
    const u = this.labelColors[a], h = this.labelPointStyles[a], { boxHeight: m, boxWidth: v } = c, b = Ki(c.bodyFont), S = Qb(this, "left", c), w = o.x(S), E = m < b.lineHeight ? (b.lineHeight - m) / 2 : 0, R = i.y + E;
    if (c.usePointStyle) {
      const M = {
        radius: Math.min(v, m) / 2,
        pointStyle: h.pointStyle,
        rotation: h.rotation,
        borderWidth: 1
      }, A = o.leftForLtr(w, v) + v / 2, P = R + m / 2;
      e.strokeStyle = c.multiKeyBackground, e.fillStyle = c.multiKeyBackground, LT(e, M, A, P), e.strokeStyle = u.borderColor, e.fillStyle = u.backgroundColor, LT(e, M, A, P);
    } else {
      e.lineWidth = qt(u.borderWidth) ? Math.max(...Object.values(u.borderWidth)) : u.borderWidth || 1, e.strokeStyle = u.borderColor, e.setLineDash(u.borderDash || []), e.lineDashOffset = u.borderDashOffset || 0;
      const M = o.leftForLtr(w, v), A = o.leftForLtr(o.xPlus(w, 1), v - 2), P = Bf(u.borderRadius);
      Object.values(P).some((z) => z !== 0) ? (e.beginPath(), e.fillStyle = c.multiKeyBackground, mv(e, {
        x: M,
        y: R,
        w: v,
        h: m,
        radius: P
      }), e.fill(), e.stroke(), e.fillStyle = u.backgroundColor, e.beginPath(), mv(e, {
        x: A,
        y: R + 1,
        w: v - 2,
        h: m - 2,
        radius: P
      }), e.fill()) : (e.fillStyle = c.multiKeyBackground, e.fillRect(M, R, v, m), e.strokeRect(M, R, v, m), e.fillStyle = u.backgroundColor, e.fillRect(A, R + 1, v - 2, m - 2));
    }
    e.fillStyle = this.labelTextColors[a];
  }
  drawBody(e, i, a) {
    const { body: o } = this, { bodySpacing: c, bodyAlign: u, displayColors: h, boxHeight: m, boxWidth: v, boxPadding: b } = a, S = Ki(a.bodyFont);
    let w = S.lineHeight, E = 0;
    const R = tp(a.rtl, this.x, this.width), M = function(K) {
      i.fillText(K, R.x(e.x + E), e.y + w / 2), e.y += w + c;
    }, A = R.textAlign(u);
    let P, z, B, j, F, $, I;
    for (i.textAlign = u, i.textBaseline = "middle", i.font = S.string, e.x = Qb(this, A, a), i.fillStyle = a.bodyColor, _n(this.beforeBody, M), E = h && A !== "right" ? u === "center" ? v / 2 + b : v + 2 + b : 0, j = 0, $ = o.length; j < $; ++j) {
      for (P = o[j], z = this.labelTextColors[j], i.fillStyle = z, _n(P.before, M), B = P.lines, h && B.length && (this._drawColorBox(i, e, j, R, a), w = Math.max(S.lineHeight, m)), F = 0, I = B.length; F < I; ++F)
        M(B[F]), w = S.lineHeight;
      _n(P.after, M);
    }
    E = 0, w = S.lineHeight, _n(this.afterBody, M), e.y -= c;
  }
  drawFooter(e, i, a) {
    const o = this.footer, c = o.length;
    let u, h;
    if (c) {
      const m = tp(a.rtl, this.x, this.width);
      for (e.x = Qb(this, a.footerAlign, a), e.y += a.footerMarginTop, i.textAlign = m.textAlign(a.footerAlign), i.textBaseline = "middle", u = Ki(a.footerFont), i.fillStyle = a.footerColor, i.font = u.string, h = 0; h < c; ++h)
        i.fillText(o[h], m.x(e.x), e.y + u.lineHeight / 2), e.y += u.lineHeight + a.footerSpacing;
    }
  }
  drawBackground(e, i, a, o) {
    const { xAlign: c, yAlign: u } = this, { x: h, y: m } = e, { width: v, height: b } = a, { topLeft: S, topRight: w, bottomLeft: E, bottomRight: R } = Bf(o.cornerRadius);
    i.fillStyle = o.backgroundColor, i.strokeStyle = o.borderColor, i.lineWidth = o.borderWidth, i.beginPath(), i.moveTo(h + S, m), u === "top" && this.drawCaret(e, i, a, o), i.lineTo(h + v - w, m), i.quadraticCurveTo(h + v, m, h + v, m + w), u === "center" && c === "right" && this.drawCaret(e, i, a, o), i.lineTo(h + v, m + b - R), i.quadraticCurveTo(h + v, m + b, h + v - R, m + b), u === "bottom" && this.drawCaret(e, i, a, o), i.lineTo(h + E, m + b), i.quadraticCurveTo(h, m + b, h, m + b - E), u === "center" && c === "left" && this.drawCaret(e, i, a, o), i.lineTo(h, m + S), i.quadraticCurveTo(h, m, h + S, m), i.closePath(), i.fill(), o.borderWidth > 0 && i.stroke();
  }
  _updateAnimationTarget(e) {
    const i = this.chart, a = this.$animations, o = a && a.x, c = a && a.y;
    if (o || c) {
      const u = Xg[e.position].call(this, this._active, this._eventPosition);
      if (!u)
        return;
      const h = this._size = LA(this, e), m = Object.assign({}, u, this._size), v = NA(i, e, m), b = zA(e, m, v, i);
      (o._to !== b.x || c._to !== b.y) && (this.xAlign = v.xAlign, this.yAlign = v.yAlign, this.width = h.width, this.height = h.height, this.caretX = u.x, this.caretY = u.y, this._resolveAnimations().update(this, b));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(e) {
    const i = this.options.setContext(this.getContext());
    let a = this.opacity;
    if (!a)
      return;
    this._updateAnimationTarget(i);
    const o = {
      width: this.width,
      height: this.height
    }, c = {
      x: this.x,
      y: this.y
    };
    a = Math.abs(a) < 1e-3 ? 0 : a;
    const u = Br(i.padding), h = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    i.enabled && h && (e.save(), e.globalAlpha = a, this.drawBackground(c, e, o, i), kL(e, i.textDirection), c.y += u.top, this.drawTitle(c, e, i), this.drawBody(c, e, i), this.drawFooter(c, e, i), ML(e, i.textDirection), e.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e, i) {
    const a = this._active, o = e.map(({ datasetIndex: h, index: m }) => {
      const v = this.chart.getDatasetMeta(h);
      if (!v)
        throw new Error("Cannot find a dataset at index " + h);
      return {
        datasetIndex: h,
        element: v.data[m],
        index: m
      };
    }), c = !Cx(a, o), u = this._positionChanged(o, i);
    (c || u) && (this._active = o, this._eventPosition = i, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(e, i, a = !0) {
    if (i && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const o = this.options, c = this._active || [], u = this._getActiveElements(e, c, i, a), h = this._positionChanged(u, e), m = i || !Cx(u, c) || h;
    return m && (this._active = u, (o.enabled || o.external) && (this._eventPosition = {
      x: e.x,
      y: e.y
    }, this.update(!0, i))), m;
  }
  _getActiveElements(e, i, a, o) {
    const c = this.options;
    if (e.type === "mouseout")
      return [];
    if (!o)
      return i.filter((h) => this.chart.data.datasets[h.datasetIndex] && this.chart.getDatasetMeta(h.datasetIndex).controller.getParsed(h.index) !== void 0);
    const u = this.chart.getElementsAtEventForMode(e, c.mode, c, a);
    return c.reverse && u.reverse(), u;
  }
  _positionChanged(e, i) {
    const { caretX: a, caretY: o, options: c } = this, u = Xg[c.position].call(this, e, i);
    return u !== !1 && (a !== u.x || o !== u.y);
  }
}
Ve(HT, "positioners", Xg);
var w4 = {
  id: "tooltip",
  _element: HT,
  positioners: Xg,
  afterInit(t, e, i) {
    i && (t.tooltip = new HT({
      chart: t,
      options: i
    }));
  },
  beforeUpdate(t, e, i) {
    t.tooltip && t.tooltip.initialize(i);
  },
  reset(t, e, i) {
    t.tooltip && t.tooltip.initialize(i);
  },
  afterDraw(t) {
    const e = t.tooltip;
    if (e && e._willRender()) {
      const i = {
        tooltip: e
      };
      if (t.notifyPlugins("beforeTooltipDraw", {
        ...i,
        cancelable: !0
      }) === !1)
        return;
      e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i);
    }
  },
  afterEvent(t, e) {
    if (t.tooltip) {
      const i = e.replay;
      t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (t, e) => e.bodyFont.size,
    boxWidth: (t, e) => e.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: tN
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (t) => t !== "filter" && t !== "itemSort" && t !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
}, C4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: z5,
  Decimation: B5,
  Filler: s4,
  Legend: d4,
  SubTitle: m4,
  Title: p4,
  Tooltip: w4
});
const T4 = (t, e, i, a) => (typeof e == "string" ? (i = t.push(e) - 1, a.unshift({
  index: i,
  label: e
})) : isNaN(e) && (i = null), i);
function E4(t, e, i, a) {
  const o = t.indexOf(e);
  if (o === -1)
    return T4(t, e, i, a);
  const c = t.lastIndexOf(e);
  return o !== c ? i : o;
}
const D4 = (t, e) => t === null ? null : Ji(Math.round(t), 0, e);
function jA(t) {
  const e = this.getLabels();
  return t >= 0 && t < e.length ? e[t] : t;
}
class UT extends Gf {
  constructor(e) {
    super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(e) {
    const i = this._addedLabels;
    if (i.length) {
      const a = this.getLabels();
      for (const { index: o, label: c } of i)
        a[o] === c && a.splice(o, 1);
      this._addedLabels = [];
    }
    super.init(e);
  }
  parse(e, i) {
    if ($t(e))
      return null;
    const a = this.getLabels();
    return i = isFinite(i) && a[i] === e ? i : E4(a, e, zt(i, e), this._addedLabels), D4(i, a.length - 1);
  }
  determineDataLimits() {
    const { minDefined: e, maxDefined: i } = this.getUserBounds();
    let { min: a, max: o } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (e || (a = 0), i || (o = this.getLabels().length - 1)), this.min = a, this.max = o;
  }
  buildTicks() {
    const e = this.min, i = this.max, a = this.options.offset, o = [];
    let c = this.getLabels();
    c = e === 0 && i === c.length - 1 ? c : c.slice(e, i + 1), this._valueRange = Math.max(c.length - (a ? 0 : 1), 1), this._startValue = this.min - (a ? 0.5 : 0);
    for (let u = e; u <= i; u++)
      o.push({
        value: u
      });
    return o;
  }
  getLabelForValue(e) {
    return jA.call(this, e);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(e) {
    return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getPixelForTick(e) {
    const i = this.ticks;
    return e < 0 || e > i.length - 1 ? null : this.getPixelForValue(i[e].value);
  }
  getValueForPixel(e) {
    return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
Ve(UT, "id", "category"), Ve(UT, "defaults", {
  ticks: {
    callback: jA
  }
});
function R4(t, e) {
  const i = [], { bounds: o, step: c, min: u, max: h, precision: m, count: v, maxTicks: b, maxDigits: S, includeBounds: w } = t, E = c || 1, R = b - 1, { min: M, max: A } = e, P = !$t(u), z = !$t(h), B = !$t(v), j = (A - M) / (S + 1);
  let F = LM((A - M) / R / E) * E, $, I, K, ee;
  if (F < 1e-14 && !P && !z)
    return [
      {
        value: M
      },
      {
        value: A
      }
    ];
  ee = Math.ceil(A / F) - Math.floor(M / F), ee > R && (F = LM(ee * F / R / E) * E), $t(m) || ($ = Math.pow(10, m), F = Math.ceil(F * $) / $), o === "ticks" ? (I = Math.floor(M / F) * F, K = Math.ceil(A / F) * F) : (I = M, K = A), P && z && c && SI((h - u) / c, F / 1e3) ? (ee = Math.round(Math.min((h - u) / F, b)), F = (h - u) / ee, I = u, K = h) : B ? (I = P ? u : I, K = z ? h : K, ee = v - 1, F = (K - I) / ee) : (ee = (K - I) / F, nv(ee, Math.round(ee), F / 1e3) ? ee = Math.round(ee) : ee = Math.ceil(ee));
  const ne = Math.max(NM(F), NM(I));
  $ = Math.pow(10, $t(m) ? ne : m), I = Math.round(I * $) / $, K = Math.round(K * $) / $;
  let le = 0;
  for (P && (w && I !== u ? (i.push({
    value: u
  }), I < u && le++, nv(Math.round((I + le * F) * $) / $, u, BA(u, j, t)) && le++) : I < u && le++); le < ee; ++le) {
    const re = Math.round((I + le * F) * $) / $;
    if (z && re > h)
      break;
    i.push({
      value: re
    });
  }
  return z && w && K !== h ? i.length && nv(i[i.length - 1].value, h, BA(h, j, t)) ? i[i.length - 1].value = h : i.push({
    value: h
  }) : (!z || K === h) && i.push({
    value: K
  }), i;
}
function BA(t, e, { horizontal: i, minRotation: a }) {
  const o = Xs(a), c = (i ? Math.sin(o) : Math.cos(o)) || 1e-3, u = 0.75 * e * ("" + t).length;
  return Math.min(e / c, u);
}
class Ax extends Gf {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(e, i) {
    return $t(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e;
  }
  handleTickRangeOptions() {
    const { beginAtZero: e } = this.options, { minDefined: i, maxDefined: a } = this.getUserBounds();
    let { min: o, max: c } = this;
    const u = (m) => o = i ? o : m, h = (m) => c = a ? c : m;
    if (e) {
      const m = jo(o), v = jo(c);
      m < 0 && v < 0 ? h(0) : m > 0 && v > 0 && u(0);
    }
    if (o === c) {
      let m = c === 0 ? 1 : Math.abs(c * 0.05);
      h(c + m), e || u(o - m);
    }
    this.min = o, this.max = c;
  }
  getTickLimit() {
    const e = this.options.ticks;
    let { maxTicksLimit: i, stepSize: a } = e, o;
    return a ? (o = Math.ceil(this.max / a) - Math.floor(this.min / a) + 1, o > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${a} would result generating up to ${o} ticks. Limiting to 1000.`), o = 1e3)) : (o = this.computeTickLimit(), i = i || 11), i && (o = Math.min(i, o)), o;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const e = this.options, i = e.ticks;
    let a = this.getTickLimit();
    a = Math.max(2, a);
    const o = {
      maxTicks: a,
      bounds: e.bounds,
      min: e.min,
      max: e.max,
      precision: i.precision,
      step: i.stepSize,
      count: i.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: i.minRotation || 0,
      includeBounds: i.includeBounds !== !1
    }, c = this._range || this, u = R4(o, c);
    return e.bounds === "ticks" && dL(u, this, "value"), e.reverse ? (u.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), u;
  }
  configure() {
    const e = this.ticks;
    let i = this.min, a = this.max;
    if (super.configure(), this.options.offset && e.length) {
      const o = (a - i) / Math.max(e.length - 1, 1) / 2;
      i -= o, a += o;
    }
    this._startValue = i, this._endValue = a, this._valueRange = a - i;
  }
  getLabelForValue(e) {
    return Pv(e, this.chart.options.locale, this.options.ticks.format);
  }
}
class IT extends Ax {
  determineDataLimits() {
    const { min: e, max: i } = this.getMinMax(!0);
    this.min = vi(e) ? e : 0, this.max = vi(i) ? i : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const e = this.isHorizontal(), i = e ? this.width : this.height, a = Xs(this.options.ticks.minRotation), o = (e ? Math.sin(a) : Math.cos(a)) || 1e-3, c = this._resolveTickFontOptions(0);
    return Math.ceil(i / Math.min(40, c.lineHeight / o));
  }
  getPixelForValue(e) {
    return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    return this._startValue + this.getDecimalForPixel(e) * this._valueRange;
  }
}
Ve(IT, "id", "linear"), Ve(IT, "defaults", {
  ticks: {
    callback: qx.formatters.numeric
  }
});
const vv = (t) => Math.floor(Gu(t)), Mf = (t, e) => Math.pow(10, vv(t) + e);
function HA(t) {
  return t / Math.pow(10, vv(t)) === 1;
}
function UA(t, e, i) {
  const a = Math.pow(10, i), o = Math.floor(t / a);
  return Math.ceil(e / a) - o;
}
function k4(t, e) {
  const i = e - t;
  let a = vv(i);
  for (; UA(t, e, a) > 10; )
    a++;
  for (; UA(t, e, a) < 10; )
    a--;
  return Math.min(a, vv(t));
}
function M4(t, { min: e, max: i }) {
  e = Ha(t.min, e);
  const a = [], o = vv(e);
  let c = k4(e, i), u = c < 0 ? Math.pow(10, Math.abs(c)) : 1;
  const h = Math.pow(10, c), m = o > c ? Math.pow(10, o) : 0, v = Math.round((e - m) * u) / u, b = Math.floor((e - m) / h / 10) * h * 10;
  let S = Math.floor((v - b) / Math.pow(10, c)), w = Ha(t.min, Math.round((m + b + S * Math.pow(10, c)) * u) / u);
  for (; w < i; )
    a.push({
      value: w,
      major: HA(w),
      significand: S
    }), S >= 10 ? S = S < 15 ? 15 : 20 : S++, S >= 20 && (c++, S = 2, u = c >= 0 ? 1 : u), w = Math.round((m + b + S * Math.pow(10, c)) * u) / u;
  const E = Ha(t.max, w);
  return a.push({
    value: E,
    major: HA(E),
    significand: S
  }), a;
}
class $T extends Gf {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(e, i) {
    const a = Ax.prototype.parse.apply(this, [
      e,
      i
    ]);
    if (a === 0) {
      this._zero = !0;
      return;
    }
    return vi(a) && a > 0 ? a : null;
  }
  determineDataLimits() {
    const { min: e, max: i } = this.getMinMax(!0);
    this.min = vi(e) ? Math.max(0, e) : null, this.max = vi(i) ? Math.max(0, i) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !vi(this._userMin) && (this.min = e === Mf(this.min, 0) ? Mf(this.min, -1) : Mf(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: e, maxDefined: i } = this.getUserBounds();
    let a = this.min, o = this.max;
    const c = (h) => a = e ? a : h, u = (h) => o = i ? o : h;
    a === o && (a <= 0 ? (c(1), u(10)) : (c(Mf(a, -1)), u(Mf(o, 1)))), a <= 0 && c(Mf(o, -1)), o <= 0 && u(Mf(a, 1)), this.min = a, this.max = o;
  }
  buildTicks() {
    const e = this.options, i = {
      min: this._userMin,
      max: this._userMax
    }, a = M4(i, this);
    return e.bounds === "ticks" && dL(a, this, "value"), e.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a;
  }
  getLabelForValue(e) {
    return e === void 0 ? "0" : Pv(e, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const e = this.min;
    super.configure(), this._startValue = Gu(e), this._valueRange = Gu(this.max) - Gu(e);
  }
  getPixelForValue(e) {
    return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (Gu(e) - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    const i = this.getDecimalForPixel(e);
    return Math.pow(10, this._startValue + i * this._valueRange);
  }
}
Ve($T, "id", "logarithmic"), Ve($T, "defaults", {
  ticks: {
    callback: qx.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function WT(t) {
  const e = t.ticks;
  if (e.display && t.display) {
    const i = Br(e.backdropPadding);
    return zt(e.font && e.font.size, Qn.font.size) + i.height;
  }
  return 0;
}
function A4(t, e, i) {
  return i = Kn(i) ? i : [
    i
  ], {
    w: VI(t, e.string, i),
    h: i.length * e.lineHeight
  };
}
function IA(t, e, i, a, o) {
  return t === a || t === o ? {
    start: e - i / 2,
    end: e + i / 2
  } : t < a || t > o ? {
    start: e - i,
    end: e
  } : {
    start: e,
    end: e + i
  };
}
function O4(t) {
  const e = {
    l: t.left + t._padding.left,
    r: t.right - t._padding.right,
    t: t.top + t._padding.top,
    b: t.bottom - t._padding.bottom
  }, i = Object.assign({}, e), a = [], o = [], c = t._pointLabels.length, u = t.options.pointLabels, h = u.centerPointLabels ? In / c : 0;
  for (let m = 0; m < c; m++) {
    const v = u.setContext(t.getPointLabelContext(m));
    o[m] = v.padding;
    const b = t.getPointPosition(m, t.drawingArea + o[m], h), S = Ki(v.font), w = A4(t.ctx, S, t._pointLabels[m]);
    a[m] = w;
    const E = Ia(t.getIndexAngle(m) + h), R = Math.round(NE(E)), M = IA(R, b.x, w.w, 0, 180), A = IA(R, b.y, w.h, 90, 270);
    P4(i, e, E, M, A);
  }
  t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = z4(t, a, o);
}
function P4(t, e, i, a, o) {
  const c = Math.abs(Math.sin(i)), u = Math.abs(Math.cos(i));
  let h = 0, m = 0;
  a.start < e.l ? (h = (e.l - a.start) / c, t.l = Math.min(t.l, e.l - h)) : a.end > e.r && (h = (a.end - e.r) / c, t.r = Math.max(t.r, e.r + h)), o.start < e.t ? (m = (e.t - o.start) / u, t.t = Math.min(t.t, e.t - m)) : o.end > e.b && (m = (o.end - e.b) / u, t.b = Math.max(t.b, e.b + m));
}
function L4(t, e, i) {
  const a = t.drawingArea, { extra: o, additionalAngle: c, padding: u, size: h } = i, m = t.getPointPosition(e, a + o + u, c), v = Math.round(NE(Ia(m.angle + Ti))), b = j4(m.y, h.h, v), S = F4(v), w = V4(m.x, h.w, S);
  return {
    visible: !0,
    x: m.x,
    y: b,
    textAlign: S,
    left: w,
    top: b,
    right: w + h.w,
    bottom: b + h.h
  };
}
function N4(t, e) {
  if (!e)
    return !0;
  const { left: i, top: a, right: o, bottom: c } = t;
  return !(Yl({
    x: i,
    y: a
  }, e) || Yl({
    x: i,
    y: c
  }, e) || Yl({
    x: o,
    y: a
  }, e) || Yl({
    x: o,
    y: c
  }, e));
}
function z4(t, e, i) {
  const a = [], o = t._pointLabels.length, c = t.options, { centerPointLabels: u, display: h } = c.pointLabels, m = {
    extra: WT(c) / 2,
    additionalAngle: u ? In / o : 0
  };
  let v;
  for (let b = 0; b < o; b++) {
    m.padding = i[b], m.size = e[b];
    const S = L4(t, b, m);
    a.push(S), h === "auto" && (S.visible = N4(S, v), S.visible && (v = S));
  }
  return a;
}
function F4(t) {
  return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right";
}
function V4(t, e, i) {
  return i === "right" ? t -= e : i === "center" && (t -= e / 2), t;
}
function j4(t, e, i) {
  return i === 90 || i === 270 ? t -= e / 2 : (i > 270 || i < 90) && (t -= e), t;
}
function B4(t, e, i) {
  const { left: a, top: o, right: c, bottom: u } = i, { backdropColor: h } = e;
  if (!$t(h)) {
    const m = Bf(e.borderRadius), v = Br(e.backdropPadding);
    t.fillStyle = h;
    const b = a - v.left, S = o - v.top, w = c - a + v.width, E = u - o + v.height;
    Object.values(m).some((R) => R !== 0) ? (t.beginPath(), mv(t, {
      x: b,
      y: S,
      w,
      h: E,
      radius: m
    }), t.fill()) : t.fillRect(b, S, w, E);
  }
}
function H4(t, e) {
  const { ctx: i, options: { pointLabels: a } } = t;
  for (let o = e - 1; o >= 0; o--) {
    const c = t._pointLabelItems[o];
    if (!c.visible)
      continue;
    const u = a.setContext(t.getPointLabelContext(o));
    B4(i, u, c);
    const h = Ki(u.font), { x: m, y: v, textAlign: b } = c;
    Wf(i, t._pointLabels[o], m, v + h.lineHeight / 2, h, {
      color: u.color,
      textAlign: b,
      textBaseline: "middle"
    });
  }
}
function nN(t, e, i, a) {
  const { ctx: o } = t;
  if (i)
    o.arc(t.xCenter, t.yCenter, e, 0, Un);
  else {
    let c = t.getPointPosition(0, e);
    o.moveTo(c.x, c.y);
    for (let u = 1; u < a; u++)
      c = t.getPointPosition(u, e), o.lineTo(c.x, c.y);
  }
}
function U4(t, e, i, a, o) {
  const c = t.ctx, u = e.circular, { color: h, lineWidth: m } = e;
  !u && !a || !h || !m || i < 0 || (c.save(), c.strokeStyle = h, c.lineWidth = m, c.setLineDash(o.dash || []), c.lineDashOffset = o.dashOffset, c.beginPath(), nN(t, i, u, a), c.closePath(), c.stroke(), c.restore());
}
function I4(t, e, i) {
  return ac(t, {
    label: i,
    index: e,
    type: "pointLabel"
  });
}
class Qg extends Ax {
  constructor(e) {
    super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const e = this._padding = Br(WT(this.options) / 2), i = this.width = this.maxWidth - e.width, a = this.height = this.maxHeight - e.height;
    this.xCenter = Math.floor(this.left + i / 2 + e.left), this.yCenter = Math.floor(this.top + a / 2 + e.top), this.drawingArea = Math.floor(Math.min(i, a) / 2);
  }
  determineDataLimits() {
    const { min: e, max: i } = this.getMinMax(!1);
    this.min = vi(e) && !isNaN(e) ? e : 0, this.max = vi(i) && !isNaN(i) ? i : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / WT(this.options));
  }
  generateTickLabels(e) {
    Ax.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((i, a) => {
      const o = Nn(this.options.pointLabels.callback, [
        i,
        a
      ], this);
      return o || o === 0 ? o : "";
    }).filter((i, a) => this.chart.getDataVisibility(a));
  }
  fit() {
    const e = this.options;
    e.display && e.pointLabels.display ? O4(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(e, i, a, o) {
    this.xCenter += Math.floor((e - i) / 2), this.yCenter += Math.floor((a - o) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, i, a, o));
  }
  getIndexAngle(e) {
    const i = Un / (this._pointLabels.length || 1), a = this.options.startAngle || 0;
    return Ia(e * i + Xs(a));
  }
  getDistanceFromCenterForValue(e) {
    if ($t(e))
      return NaN;
    const i = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - e) * i : (e - this.min) * i;
  }
  getValueForDistanceFromCenter(e) {
    if ($t(e))
      return NaN;
    const i = e / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - i : this.min + i;
  }
  getPointLabelContext(e) {
    const i = this._pointLabels || [];
    if (e >= 0 && e < i.length) {
      const a = i[e];
      return I4(this.getContext(), e, a);
    }
  }
  getPointPosition(e, i, a = 0) {
    const o = this.getIndexAngle(e) - Ti + a;
    return {
      x: Math.cos(o) * i + this.xCenter,
      y: Math.sin(o) * i + this.yCenter,
      angle: o
    };
  }
  getPointPositionForValue(e, i) {
    return this.getPointPosition(e, this.getDistanceFromCenterForValue(i));
  }
  getBasePosition(e) {
    return this.getPointPositionForValue(e || 0, this.getBaseValue());
  }
  getPointLabelPosition(e) {
    const { left: i, top: a, right: o, bottom: c } = this._pointLabelItems[e];
    return {
      left: i,
      top: a,
      right: o,
      bottom: c
    };
  }
  drawBackground() {
    const { backgroundColor: e, grid: { circular: i } } = this.options;
    if (e) {
      const a = this.ctx;
      a.save(), a.beginPath(), nN(this, this.getDistanceFromCenterForValue(this._endValue), i, this._pointLabels.length), a.closePath(), a.fillStyle = e, a.fill(), a.restore();
    }
  }
  drawGrid() {
    const e = this.ctx, i = this.options, { angleLines: a, grid: o, border: c } = i, u = this._pointLabels.length;
    let h, m, v;
    if (i.pointLabels.display && H4(this, u), o.display && this.ticks.forEach((b, S) => {
      if (S !== 0 || S === 0 && this.min < 0) {
        m = this.getDistanceFromCenterForValue(b.value);
        const w = this.getContext(S), E = o.setContext(w), R = c.setContext(w);
        U4(this, E, m, u, R);
      }
    }), a.display) {
      for (e.save(), h = u - 1; h >= 0; h--) {
        const b = a.setContext(this.getPointLabelContext(h)), { color: S, lineWidth: w } = b;
        !w || !S || (e.lineWidth = w, e.strokeStyle = S, e.setLineDash(b.borderDash), e.lineDashOffset = b.borderDashOffset, m = this.getDistanceFromCenterForValue(i.reverse ? this.min : this.max), v = this.getPointPosition(h, m), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(v.x, v.y), e.stroke());
      }
      e.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const e = this.ctx, i = this.options, a = i.ticks;
    if (!a.display)
      return;
    const o = this.getIndexAngle(0);
    let c, u;
    e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(o), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((h, m) => {
      if (m === 0 && this.min >= 0 && !i.reverse)
        return;
      const v = a.setContext(this.getContext(m)), b = Ki(v.font);
      if (c = this.getDistanceFromCenterForValue(this.ticks[m].value), v.showLabelBackdrop) {
        e.font = b.string, u = e.measureText(h.label).width, e.fillStyle = v.backdropColor;
        const S = Br(v.backdropPadding);
        e.fillRect(-u / 2 - S.left, -c - b.size / 2 - S.top, u + S.width, b.size + S.height);
      }
      Wf(e, h.label, 0, -c, b, {
        color: v.color,
        strokeColor: v.textStrokeColor,
        strokeWidth: v.textStrokeWidth
      });
    }), e.restore();
  }
  drawTitle() {
  }
}
Ve(Qg, "id", "radialLinear"), Ve(Qg, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: qx.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(e) {
      return e;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), Ve(Qg, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), Ve(Qg, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const nS = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, wa = /* @__PURE__ */ Object.keys(nS);
function $A(t, e) {
  return t - e;
}
function WA(t, e) {
  if ($t(e))
    return null;
  const i = t._adapter, { parser: a, round: o, isoWeekday: c } = t._parseOpts;
  let u = e;
  return typeof a == "function" && (u = a(u)), vi(u) || (u = typeof a == "string" ? i.parse(u, a) : i.parse(u)), u === null ? null : (o && (u = o === "week" && (ap(c) || c === !0) ? i.startOf(u, "isoWeek", c) : i.startOf(u, o)), +u);
}
function YA(t, e, i, a) {
  const o = wa.length;
  for (let c = wa.indexOf(t); c < o - 1; ++c) {
    const u = nS[wa[c]], h = u.steps ? u.steps : Number.MAX_SAFE_INTEGER;
    if (u.common && Math.ceil((i - e) / (h * u.size)) <= a)
      return wa[c];
  }
  return wa[o - 1];
}
function $4(t, e, i, a, o) {
  for (let c = wa.length - 1; c >= wa.indexOf(i); c--) {
    const u = wa[c];
    if (nS[u].common && t._adapter.diff(o, a, u) >= e - 1)
      return u;
  }
  return wa[i ? wa.indexOf(i) : 0];
}
function W4(t) {
  for (let e = wa.indexOf(t) + 1, i = wa.length; e < i; ++e)
    if (nS[wa[e]].common)
      return wa[e];
}
function GA(t, e, i) {
  if (!i)
    t[e] = !0;
  else if (i.length) {
    const { lo: a, hi: o } = zE(i, e), c = i[a] >= e ? i[a] : i[o];
    t[c] = !0;
  }
}
function Y4(t, e, i, a) {
  const o = t._adapter, c = +o.startOf(e[0].value, a), u = e[e.length - 1].value;
  let h, m;
  for (h = c; h <= u; h = +o.add(h, 1, a))
    m = i[h], m >= 0 && (e[m].major = !0);
  return e;
}
function KA(t, e, i) {
  const a = [], o = {}, c = e.length;
  let u, h;
  for (u = 0; u < c; ++u)
    h = e[u], o[h] = u, a.push({
      value: h,
      major: !1
    });
  return c === 0 || !i ? a : Y4(t, a, o, i);
}
class yv extends Gf {
  constructor(e) {
    super(e), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(e, i = {}) {
    const a = e.time || (e.time = {}), o = this._adapter = new e3._date(e.adapters.date);
    o.init(i), tv(a.displayFormats, o.formats()), this._parseOpts = {
      parser: a.parser,
      round: a.round,
      isoWeekday: a.isoWeekday
    }, super.init(e), this._normalized = i.normalized;
  }
  parse(e, i) {
    return e === void 0 ? null : WA(this, e);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const e = this.options, i = this._adapter, a = e.time.unit || "day";
    let { min: o, max: c, minDefined: u, maxDefined: h } = this.getUserBounds();
    function m(v) {
      !u && !isNaN(v.min) && (o = Math.min(o, v.min)), !h && !isNaN(v.max) && (c = Math.max(c, v.max));
    }
    (!u || !h) && (m(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && m(this.getMinMax(!1))), o = vi(o) && !isNaN(o) ? o : +i.startOf(Date.now(), a), c = vi(c) && !isNaN(c) ? c : +i.endOf(Date.now(), a) + 1, this.min = Math.min(o, c - 1), this.max = Math.max(o + 1, c);
  }
  _getLabelBounds() {
    const e = this.getLabelTimestamps();
    let i = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY;
    return e.length && (i = e[0], a = e[e.length - 1]), {
      min: i,
      max: a
    };
  }
  buildTicks() {
    const e = this.options, i = e.time, a = e.ticks, o = a.source === "labels" ? this.getLabelTimestamps() : this._generate();
    e.bounds === "ticks" && o.length && (this.min = this._userMin || o[0], this.max = this._userMax || o[o.length - 1]);
    const c = this.min, u = this.max, h = TI(o, c, u);
    return this._unit = i.unit || (a.autoSkip ? YA(i.minUnit, this.min, this.max, this._getLabelCapacity(c)) : $4(this, h.length, i.minUnit, this.min, this.max)), this._majorUnit = !a.major.enabled || this._unit === "year" ? void 0 : W4(this._unit), this.initOffsets(o), e.reverse && h.reverse(), KA(this, h, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
  }
  initOffsets(e = []) {
    let i = 0, a = 0, o, c;
    this.options.offset && e.length && (o = this.getDecimalForValue(e[0]), e.length === 1 ? i = 1 - o : i = (this.getDecimalForValue(e[1]) - o) / 2, c = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? a = c : a = (c - this.getDecimalForValue(e[e.length - 2])) / 2);
    const u = e.length < 3 ? 0.5 : 0.25;
    i = Ji(i, 0, u), a = Ji(a, 0, u), this._offsets = {
      start: i,
      end: a,
      factor: 1 / (i + 1 + a)
    };
  }
  _generate() {
    const e = this._adapter, i = this.min, a = this.max, o = this.options, c = o.time, u = c.unit || YA(c.minUnit, i, a, this._getLabelCapacity(i)), h = zt(o.ticks.stepSize, 1), m = u === "week" ? c.isoWeekday : !1, v = ap(m) || m === !0, b = {};
    let S = i, w, E;
    if (v && (S = +e.startOf(S, "isoWeek", m)), S = +e.startOf(S, v ? "day" : u), e.diff(a, i, u) > 1e5 * h)
      throw new Error(i + " and " + a + " are too far apart with stepSize of " + h + " " + u);
    const R = o.ticks.source === "data" && this.getDataTimestamps();
    for (w = S, E = 0; w < a; w = +e.add(w, h, u), E++)
      GA(b, w, R);
    return (w === a || o.bounds === "ticks" || E === 1) && GA(b, w, R), Object.keys(b).sort($A).map((M) => +M);
  }
  getLabelForValue(e) {
    const i = this._adapter, a = this.options.time;
    return a.tooltipFormat ? i.format(e, a.tooltipFormat) : i.format(e, a.displayFormats.datetime);
  }
  format(e, i) {
    const o = this.options.time.displayFormats, c = this._unit, u = i || o[c];
    return this._adapter.format(e, u);
  }
  _tickFormatFunction(e, i, a, o) {
    const c = this.options, u = c.ticks.callback;
    if (u)
      return Nn(u, [
        e,
        i,
        a
      ], this);
    const h = c.time.displayFormats, m = this._unit, v = this._majorUnit, b = m && h[m], S = v && h[v], w = a[i], E = v && S && w && w.major;
    return this._adapter.format(e, o || (E ? S : b));
  }
  generateTickLabels(e) {
    let i, a, o;
    for (i = 0, a = e.length; i < a; ++i)
      o = e[i], o.label = this._tickFormatFunction(o.value, i, e);
  }
  getDecimalForValue(e) {
    return e === null ? NaN : (e - this.min) / (this.max - this.min);
  }
  getPixelForValue(e) {
    const i = this._offsets, a = this.getDecimalForValue(e);
    return this.getPixelForDecimal((i.start + a) * i.factor);
  }
  getValueForPixel(e) {
    const i = this._offsets, a = this.getDecimalForPixel(e) / i.factor - i.end;
    return this.min + a * (this.max - this.min);
  }
  _getLabelSize(e) {
    const i = this.options.ticks, a = this.ctx.measureText(e).width, o = Xs(this.isHorizontal() ? i.maxRotation : i.minRotation), c = Math.cos(o), u = Math.sin(o), h = this._resolveTickFontOptions(0).size;
    return {
      w: a * c + h * u,
      h: a * u + h * c
    };
  }
  _getLabelCapacity(e) {
    const i = this.options.time, a = i.displayFormats, o = a[i.unit] || a.millisecond, c = this._tickFormatFunction(e, 0, KA(this, [
      e
    ], this._majorUnit), o), u = this._getLabelSize(c), h = Math.floor(this.isHorizontal() ? this.width / u.w : this.height / u.h) - 1;
    return h > 0 ? h : 1;
  }
  getDataTimestamps() {
    let e = this._cache.data || [], i, a;
    if (e.length)
      return e;
    const o = this.getMatchingVisibleMetas();
    if (this._normalized && o.length)
      return this._cache.data = o[0].controller.getAllParsedValues(this);
    for (i = 0, a = o.length; i < a; ++i)
      e = e.concat(o[i].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(e);
  }
  getLabelTimestamps() {
    const e = this._cache.labels || [];
    let i, a;
    if (e.length)
      return e;
    const o = this.getLabels();
    for (i = 0, a = o.length; i < a; ++i)
      e.push(WA(this, o[i]));
    return this._cache.labels = this._normalized ? e : this.normalize(e);
  }
  normalize(e) {
    return mL(e.sort($A));
  }
}
Ve(yv, "id", "time"), Ve(yv, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function qb(t, e, i) {
  let a = 0, o = t.length - 1, c, u, h, m;
  i ? (e >= t[a].pos && e <= t[o].pos && ({ lo: a, hi: o } = Wl(t, "pos", e)), { pos: c, time: h } = t[a], { pos: u, time: m } = t[o]) : (e >= t[a].time && e <= t[o].time && ({ lo: a, hi: o } = Wl(t, "time", e)), { time: c, pos: h } = t[a], { time: u, pos: m } = t[o]);
  const v = u - c;
  return v ? h + (m - h) * (e - c) / v : h;
}
class YT extends yv {
  constructor(e) {
    super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const e = this._getTimestampsForTable(), i = this._table = this.buildLookupTable(e);
    this._minPos = qb(i, this.min), this._tableRange = qb(i, this.max) - this._minPos, super.initOffsets(e);
  }
  buildLookupTable(e) {
    const { min: i, max: a } = this, o = [], c = [];
    let u, h, m, v, b;
    for (u = 0, h = e.length; u < h; ++u)
      v = e[u], v >= i && v <= a && o.push(v);
    if (o.length < 2)
      return [
        {
          time: i,
          pos: 0
        },
        {
          time: a,
          pos: 1
        }
      ];
    for (u = 0, h = o.length; u < h; ++u)
      b = o[u + 1], m = o[u - 1], v = o[u], Math.round((b + m) / 2) !== v && c.push({
        time: v,
        pos: u / (h - 1)
      });
    return c;
  }
  _generate() {
    const e = this.min, i = this.max;
    let a = super.getDataTimestamps();
    return (!a.includes(e) || !a.length) && a.splice(0, 0, e), (!a.includes(i) || a.length === 1) && a.push(i), a.sort((o, c) => o - c);
  }
  _getTimestampsForTable() {
    let e = this._cache.all || [];
    if (e.length)
      return e;
    const i = this.getDataTimestamps(), a = this.getLabelTimestamps();
    return i.length && a.length ? e = this.normalize(i.concat(a)) : e = i.length ? i : a, e = this._cache.all = e, e;
  }
  getDecimalForValue(e) {
    return (qb(this._table, e) - this._minPos) / this._tableRange;
  }
  getValueForPixel(e) {
    const i = this._offsets, a = this.getDecimalForPixel(e) / i.factor - i.end;
    return qb(this._table, a * this._tableRange + this._minPos, !0);
  }
}
Ve(YT, "id", "timeseries"), Ve(YT, "defaults", yv.defaults);
var G4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: UT,
  LinearScale: IT,
  LogarithmicScale: $T,
  RadialLinearScale: Qg,
  TimeScale: yv,
  TimeSeriesScale: YT
});
const K4 = [
  J$,
  k5,
  C4,
  G4
];
Fo.register(...K4);
const vQ = ({
  data: t,
  backgroundColor: e,
  borderColor: i,
  borderWidth: a,
  barThickness: o,
  labelFillStyle: c,
  xTicksColor: u,
  yTicksColor: h,
  className: m = "",
  style: v = {}
}) => {
  const b = xn(null), S = xn(null);
  return Xn(() => {
    var M;
    S.current && S.current.destroy();
    const w = (M = b.current) == null ? void 0 : M.getContext("2d"), E = Math.max(...t.map((A) => A.value)), R = Math.ceil(E / 100) * 100 + 50;
    if (w)
      return S.current = new Fo(w, {
        type: "bar",
        data: {
          labels: t.map((A) => A.label),
          datasets: [
            {
              data: t.map((A) => A.value),
              backgroundColor: e || Array.from({ length: t.length }, (A, P) => P % 2 === 0 ? "#4CAF50" : "#2196F3"),
              borderColor: i || Array.from({ length: t.length }, (A, P) => P % 2 === 0 ? "#45a049" : "#1e88e5"),
              borderWidth: a || 1,
              barThickness: o || 20
            }
          ]
        },
        options: {
          responsive: !0,
          maintainAspectRatio: !1,
          plugins: {
            legend: {
              display: !1
            },
            tooltip: {
              enabled: !0,
              callbacks: {
                label: (A) => `${A.parsed.y}`
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: u || "#000"
              }
            },
            y: {
              beginAtZero: !0,
              max: R,
              ticks: {
                stepSize: R / 4,
                // Adjusted step size
                callback: (A) => A.toLocaleString(),
                color: h || "#000"
              }
            }
          },
          animation: {
            duration: 1e3,
            easing: "easeInOutQuart"
          },
          layout: {
            padding: {
              top: 20,
              // Increased top padding
              right: 10,
              bottom: 10,
              left: 10
            }
          }
        },
        plugins: [{
          id: "data-labels",
          afterDraw: (A) => {
            const P = A.ctx;
            A.data.datasets.forEach((z, B) => {
              A.getDatasetMeta(B).data.forEach((F, $) => {
                const I = z.data[$] + "";
                P.fillStyle = c || "#000000", P.textAlign = "center", P.textBaseline = "bottom", P.font = "10px Arial", P.fillText(I, F.x, F.y - 5);
              });
            });
          }
        }]
      }), () => {
        S.current && S.current.destroy();
      };
  }, [t]), /* @__PURE__ */ Ae.jsx("canvas", { ref: b, className: m, style: v });
}, Tn = (t) => {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      t();
    });
  });
}, KE = (t, e, i, a) => e + i > a ? {
  top: "auto",
  bottom: `${a - t}px`,
  marginBottom: "-1px"
} : {
  top: `${e}px`,
  bottom: "auto",
  marginTop: "-1px"
}, XE = (t, e, i, a, o) => e + i - o > a ? {
  left: "auto",
  right: `${a - e}px`
} : {
  left: `${t}px`,
  right: "auto"
};
function ms(t) {
  const [e, i, a] = t.split(".").map((c) => parseInt(c, 10)), o = new Date(e, i - 1, a);
  return o && o.getFullYear() === e && o.getMonth() === i - 1 && o.getDate() === a;
}
function Yh(t = 0) {
  const e = /* @__PURE__ */ new Date();
  e.setDate(e.getDate() + t);
  const i = e.getFullYear(), a = String(e.getMonth() + 1).padStart(2, "0"), o = String(e.getDate()).padStart(2, "0");
  return `${i}.${a}.${o}`;
}
var iN = /* @__PURE__ */ ((t) => (t.DEFAULT = "default", t.TYPE1 = "type1", t))(iN || {}), bv = /* @__PURE__ */ ((t) => (t.START_DATE = "startDate", t.END_DATE = "endDate", t))(bv || {});
const rN = Wo(void 0), X4 = ({
  children: t,
  selectedValue: e = [Yh(), Yh()],
  updateSelectedValue: i,
  afterUpdate: a,
  className: o = "",
  style: c = {},
  ...u
}) => {
  const [h, m] = En(e[0]), [v, b] = En(e[1]);
  Xn(() => {
    m(e[0]), b(e[1]);
  }, [e]);
  const S = [h, v], w = [`${v}~`], E = [`~${h}`], R = (z) => {
    i(z);
  }, P = {
    setStartDateRange: (z) => {
      m(z), R([z, v]), a == null || a([z, v], "START");
    },
    setEndDateRange: (z) => {
      b(z), R([h, z]), a == null || a([h, z], "END");
    },
    selectedRange: S
  };
  return /* @__PURE__ */ Ae.jsx(rN.Provider, { value: P, children: /* @__PURE__ */ Ae.jsx("div", { className: `h_single_datepicker_range_area ${o}`, style: c, ...u, children: t({
    startDate: h,
    setStartDate: m,
    endDate: v,
    setEndDate: b,
    startDisableDatesRange: w,
    endDisabledDatesRange: E
  }) }) });
};
X4.displayName = "HSingleDatePickerRangeArea";
const aN = () => Oi(rN) || {
  setStartDateRange: () => {
  },
  setEndDateRange: () => {
  },
  selectedRange: []
};
var Zb = { exports: {} }, ba = {}, Jb = { exports: {} }, lT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XA;
function Q4() {
  return XA || (XA = 1, function(t) {
    function e(ae, me) {
      var pe = ae.length;
      ae.push(me);
      e: for (; 0 < pe; ) {
        var Ce = pe - 1 >>> 1, oe = ae[Ce];
        if (0 < o(oe, me)) ae[Ce] = me, ae[pe] = oe, pe = Ce;
        else break e;
      }
    }
    function i(ae) {
      return ae.length === 0 ? null : ae[0];
    }
    function a(ae) {
      if (ae.length === 0) return null;
      var me = ae[0], pe = ae.pop();
      if (pe !== me) {
        ae[0] = pe;
        e: for (var Ce = 0, oe = ae.length, Me = oe >>> 1; Ce < Me; ) {
          var Pe = 2 * (Ce + 1) - 1, fe = ae[Pe], Le = Pe + 1, Te = ae[Le];
          if (0 > o(fe, pe)) Le < oe && 0 > o(Te, fe) ? (ae[Ce] = Te, ae[Le] = pe, Ce = Le) : (ae[Ce] = fe, ae[Pe] = pe, Ce = Pe);
          else if (Le < oe && 0 > o(Te, pe)) ae[Ce] = Te, ae[Le] = pe, Ce = Le;
          else break e;
        }
      }
      return me;
    }
    function o(ae, me) {
      var pe = ae.sortIndex - me.sortIndex;
      return pe !== 0 ? pe : ae.id - me.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var c = performance;
      t.unstable_now = function() {
        return c.now();
      };
    } else {
      var u = Date, h = u.now();
      t.unstable_now = function() {
        return u.now() - h;
      };
    }
    var m = [], v = [], b = 1, S = null, w = 3, E = !1, R = !1, M = !1, A = typeof setTimeout == "function" ? setTimeout : null, P = typeof clearTimeout == "function" ? clearTimeout : null, z = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function B(ae) {
      for (var me = i(v); me !== null; ) {
        if (me.callback === null) a(v);
        else if (me.startTime <= ae) a(v), me.sortIndex = me.expirationTime, e(m, me);
        else break;
        me = i(v);
      }
    }
    function j(ae) {
      if (M = !1, B(ae), !R) if (i(m) !== null) R = !0, we(F);
      else {
        var me = i(v);
        me !== null && Oe(j, me.startTime - ae);
      }
    }
    function F(ae, me) {
      R = !1, M && (M = !1, P(K), K = -1), E = !0;
      var pe = w;
      try {
        for (B(me), S = i(m); S !== null && (!(S.expirationTime > me) || ae && !le()); ) {
          var Ce = S.callback;
          if (typeof Ce == "function") {
            S.callback = null, w = S.priorityLevel;
            var oe = Ce(S.expirationTime <= me);
            me = t.unstable_now(), typeof oe == "function" ? S.callback = oe : S === i(m) && a(m), B(me);
          } else a(m);
          S = i(m);
        }
        if (S !== null) var Me = !0;
        else {
          var Pe = i(v);
          Pe !== null && Oe(j, Pe.startTime - me), Me = !1;
        }
        return Me;
      } finally {
        S = null, w = pe, E = !1;
      }
    }
    var $ = !1, I = null, K = -1, ee = 5, ne = -1;
    function le() {
      return !(t.unstable_now() - ne < ee);
    }
    function re() {
      if (I !== null) {
        var ae = t.unstable_now();
        ne = ae;
        var me = !0;
        try {
          me = I(!0, ae);
        } finally {
          me ? se() : ($ = !1, I = null);
        }
      } else $ = !1;
    }
    var se;
    if (typeof z == "function") se = function() {
      z(re);
    };
    else if (typeof MessageChannel < "u") {
      var Ne = new MessageChannel(), Ee = Ne.port2;
      Ne.port1.onmessage = re, se = function() {
        Ee.postMessage(null);
      };
    } else se = function() {
      A(re, 0);
    };
    function we(ae) {
      I = ae, $ || ($ = !0, se());
    }
    function Oe(ae, me) {
      K = A(function() {
        ae(t.unstable_now());
      }, me);
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(ae) {
      ae.callback = null;
    }, t.unstable_continueExecution = function() {
      R || E || (R = !0, we(F));
    }, t.unstable_forceFrameRate = function(ae) {
      0 > ae || 125 < ae ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ee = 0 < ae ? Math.floor(1e3 / ae) : 5;
    }, t.unstable_getCurrentPriorityLevel = function() {
      return w;
    }, t.unstable_getFirstCallbackNode = function() {
      return i(m);
    }, t.unstable_next = function(ae) {
      switch (w) {
        case 1:
        case 2:
        case 3:
          var me = 3;
          break;
        default:
          me = w;
      }
      var pe = w;
      w = me;
      try {
        return ae();
      } finally {
        w = pe;
      }
    }, t.unstable_pauseExecution = function() {
    }, t.unstable_requestPaint = function() {
    }, t.unstable_runWithPriority = function(ae, me) {
      switch (ae) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ae = 3;
      }
      var pe = w;
      w = ae;
      try {
        return me();
      } finally {
        w = pe;
      }
    }, t.unstable_scheduleCallback = function(ae, me, pe) {
      var Ce = t.unstable_now();
      switch (typeof pe == "object" && pe !== null ? (pe = pe.delay, pe = typeof pe == "number" && 0 < pe ? Ce + pe : Ce) : pe = Ce, ae) {
        case 1:
          var oe = -1;
          break;
        case 2:
          oe = 250;
          break;
        case 5:
          oe = 1073741823;
          break;
        case 4:
          oe = 1e4;
          break;
        default:
          oe = 5e3;
      }
      return oe = pe + oe, ae = { id: b++, callback: me, priorityLevel: ae, startTime: pe, expirationTime: oe, sortIndex: -1 }, pe > Ce ? (ae.sortIndex = pe, e(v, ae), i(m) === null && ae === i(v) && (M ? (P(K), K = -1) : M = !0, Oe(j, pe - Ce))) : (ae.sortIndex = oe, e(m, ae), R || E || (R = !0, we(F))), ae;
    }, t.unstable_shouldYield = le, t.unstable_wrapCallback = function(ae) {
      var me = w;
      return function() {
        var pe = w;
        w = me;
        try {
          return ae.apply(this, arguments);
        } finally {
          w = pe;
        }
      };
    };
  }(lT)), lT;
}
var uT = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QA;
function q4() {
  return QA || (QA = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, i = 5;
      function a(ze, tt) {
        var Et = ze.length;
        ze.push(tt), u(ze, tt, Et);
      }
      function o(ze) {
        return ze.length === 0 ? null : ze[0];
      }
      function c(ze) {
        if (ze.length === 0)
          return null;
        var tt = ze[0], Et = ze.pop();
        return Et !== tt && (ze[0] = Et, h(ze, Et, 0)), tt;
      }
      function u(ze, tt, Et) {
        for (var Xt = Et; Xt > 0; ) {
          var ln = Xt - 1 >>> 1, dn = ze[ln];
          if (m(dn, tt) > 0)
            ze[ln] = tt, ze[Xt] = dn, Xt = ln;
          else
            return;
        }
      }
      function h(ze, tt, Et) {
        for (var Xt = Et, ln = ze.length, dn = ln >>> 1; Xt < dn; ) {
          var gn = (Xt + 1) * 2 - 1, zn = ze[gn], on = gn + 1, jt = ze[on];
          if (m(zn, tt) < 0)
            on < ln && m(jt, zn) < 0 ? (ze[Xt] = jt, ze[on] = tt, Xt = on) : (ze[Xt] = zn, ze[gn] = tt, Xt = gn);
          else if (on < ln && m(jt, tt) < 0)
            ze[Xt] = jt, ze[on] = tt, Xt = on;
          else
            return;
        }
      }
      function m(ze, tt) {
        var Et = ze.sortIndex - tt.sortIndex;
        return Et !== 0 ? Et : ze.id - tt.id;
      }
      var v = 1, b = 2, S = 3, w = 4, E = 5;
      function R(ze, tt) {
      }
      var M = typeof performance == "object" && typeof performance.now == "function";
      if (M) {
        var A = performance;
        t.unstable_now = function() {
          return A.now();
        };
      } else {
        var P = Date, z = P.now();
        t.unstable_now = function() {
          return P.now() - z;
        };
      }
      var B = 1073741823, j = -1, F = 250, $ = 5e3, I = 1e4, K = B, ee = [], ne = [], le = 1, re = null, se = S, Ne = !1, Ee = !1, we = !1, Oe = typeof setTimeout == "function" ? setTimeout : null, ae = typeof clearTimeout == "function" ? clearTimeout : null, me = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function pe(ze) {
        for (var tt = o(ne); tt !== null; ) {
          if (tt.callback === null)
            c(ne);
          else if (tt.startTime <= ze)
            c(ne), tt.sortIndex = tt.expirationTime, a(ee, tt);
          else
            return;
          tt = o(ne);
        }
      }
      function Ce(ze) {
        if (we = !1, pe(ze), !Ee)
          if (o(ee) !== null)
            Ee = !0, Mn(oe);
          else {
            var tt = o(ne);
            tt !== null && oi(Ce, tt.startTime - ze);
          }
      }
      function oe(ze, tt) {
        Ee = !1, we && (we = !1, Pi()), Ne = !0;
        var Et = se;
        try {
          var Xt;
          if (!e) return Me(ze, tt);
        } finally {
          re = null, se = Et, Ne = !1;
        }
      }
      function Me(ze, tt) {
        var Et = tt;
        for (pe(Et), re = o(ee); re !== null && !(re.expirationTime > Et && (!ze || sn())); ) {
          var Xt = re.callback;
          if (typeof Xt == "function") {
            re.callback = null, se = re.priorityLevel;
            var ln = re.expirationTime <= Et, dn = Xt(ln);
            Et = t.unstable_now(), typeof dn == "function" ? re.callback = dn : re === o(ee) && c(ee), pe(Et);
          } else
            c(ee);
          re = o(ee);
        }
        if (re !== null)
          return !0;
        var gn = o(ne);
        return gn !== null && oi(Ce, gn.startTime - Et), !1;
      }
      function Pe(ze, tt) {
        switch (ze) {
          case v:
          case b:
          case S:
          case w:
          case E:
            break;
          default:
            ze = S;
        }
        var Et = se;
        se = ze;
        try {
          return tt();
        } finally {
          se = Et;
        }
      }
      function fe(ze) {
        var tt;
        switch (se) {
          case v:
          case b:
          case S:
            tt = S;
            break;
          default:
            tt = se;
            break;
        }
        var Et = se;
        se = tt;
        try {
          return ze();
        } finally {
          se = Et;
        }
      }
      function Le(ze) {
        var tt = se;
        return function() {
          var Et = se;
          se = tt;
          try {
            return ze.apply(this, arguments);
          } finally {
            se = Et;
          }
        };
      }
      function Te(ze, tt, Et) {
        var Xt = t.unstable_now(), ln;
        if (typeof Et == "object" && Et !== null) {
          var dn = Et.delay;
          typeof dn == "number" && dn > 0 ? ln = Xt + dn : ln = Xt;
        } else
          ln = Xt;
        var gn;
        switch (ze) {
          case v:
            gn = j;
            break;
          case b:
            gn = F;
            break;
          case E:
            gn = K;
            break;
          case w:
            gn = I;
            break;
          case S:
          default:
            gn = $;
            break;
        }
        var zn = ln + gn, on = {
          id: le++,
          callback: tt,
          priorityLevel: ze,
          startTime: ln,
          expirationTime: zn,
          sortIndex: -1
        };
        return ln > Xt ? (on.sortIndex = ln, a(ne, on), o(ee) === null && on === o(ne) && (we ? Pi() : we = !0, oi(Ce, ln - Xt))) : (on.sortIndex = zn, a(ee, on), !Ee && !Ne && (Ee = !0, Mn(oe))), on;
      }
      function xe() {
      }
      function it() {
        !Ee && !Ne && (Ee = !0, Mn(oe));
      }
      function dt() {
        return o(ee);
      }
      function lt(ze) {
        ze.callback = null;
      }
      function St() {
        return se;
      }
      var _t = !1, rt = null, xt = -1, Wt = i, an = -1;
      function sn() {
        var ze = t.unstable_now() - an;
        return !(ze < Wt);
      }
      function Yt() {
      }
      function Gt(ze) {
        if (ze < 0 || ze > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ze > 0 ? Wt = Math.floor(1e3 / ze) : Wt = i;
      }
      var Ot = function() {
        if (rt !== null) {
          var ze = t.unstable_now();
          an = ze;
          var tt = !0, Et = !0;
          try {
            Et = rt(tt, ze);
          } finally {
            Et ? wt() : (_t = !1, rt = null);
          }
        } else
          _t = !1;
      }, wt;
      if (typeof me == "function")
        wt = function() {
          me(Ot);
        };
      else if (typeof MessageChannel < "u") {
        var Kt = new MessageChannel(), wn = Kt.port2;
        Kt.port1.onmessage = Ot, wt = function() {
          wn.postMessage(null);
        };
      } else
        wt = function() {
          Oe(Ot, 0);
        };
      function Mn(ze) {
        rt = ze, _t || (_t = !0, wt());
      }
      function oi(ze, tt) {
        xt = Oe(function() {
          ze(t.unstable_now());
        }, tt);
      }
      function Pi() {
        ae(xt), xt = -1;
      }
      var er = Yt, Ei = null;
      t.unstable_IdlePriority = E, t.unstable_ImmediatePriority = v, t.unstable_LowPriority = w, t.unstable_NormalPriority = S, t.unstable_Profiling = Ei, t.unstable_UserBlockingPriority = b, t.unstable_cancelCallback = lt, t.unstable_continueExecution = it, t.unstable_forceFrameRate = Gt, t.unstable_getCurrentPriorityLevel = St, t.unstable_getFirstCallbackNode = dt, t.unstable_next = fe, t.unstable_pauseExecution = xe, t.unstable_requestPaint = er, t.unstable_runWithPriority = Pe, t.unstable_scheduleCallback = Te, t.unstable_shouldYield = sn, t.unstable_wrapCallback = Le, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(uT)), uT;
}
var qA;
function sN() {
  return qA || (qA = 1, process.env.NODE_ENV === "production" ? Jb.exports = Q4() : Jb.exports = q4()), Jb.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZA;
function Z4() {
  if (ZA) return ba;
  ZA = 1;
  var t = rp, e = sN();
  function i(s) {
    for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, p = 1; p < arguments.length; p++) l += "&args[]=" + encodeURIComponent(arguments[p]);
    return "Minified React error #" + s + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var a = /* @__PURE__ */ new Set(), o = {};
  function c(s, l) {
    u(s, l), u(s + "Capture", l);
  }
  function u(s, l) {
    for (o[s] = l, s = 0; s < l.length; s++) a.add(l[s]);
  }
  var h = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), m = Object.prototype.hasOwnProperty, v = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, b = {}, S = {};
  function w(s) {
    return m.call(S, s) ? !0 : m.call(b, s) ? !1 : v.test(s) ? S[s] = !0 : (b[s] = !0, !1);
  }
  function E(s, l, p, y) {
    if (p !== null && p.type === 0) return !1;
    switch (typeof l) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return y ? !1 : p !== null ? !p.acceptsBooleans : (s = s.toLowerCase().slice(0, 5), s !== "data-" && s !== "aria-");
      default:
        return !1;
    }
  }
  function R(s, l, p, y) {
    if (l === null || typeof l > "u" || E(s, l, p, y)) return !0;
    if (y) return !1;
    if (p !== null) switch (p.type) {
      case 3:
        return !l;
      case 4:
        return l === !1;
      case 5:
        return isNaN(l);
      case 6:
        return isNaN(l) || 1 > l;
    }
    return !1;
  }
  function M(s, l, p, y, _, T, O) {
    this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = y, this.attributeNamespace = _, this.mustUseProperty = p, this.propertyName = s, this.type = l, this.sanitizeURL = T, this.removeEmptyString = O;
  }
  var A = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s) {
    A[s] = new M(s, 0, !1, s, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
    var l = s[0];
    A[l] = new M(l, 1, !1, s[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
    A[s] = new M(s, 2, !1, s.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
    A[s] = new M(s, 2, !1, s, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s) {
    A[s] = new M(s, 3, !1, s.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(s) {
    A[s] = new M(s, 3, !0, s, null, !1, !1);
  }), ["capture", "download"].forEach(function(s) {
    A[s] = new M(s, 4, !1, s, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(s) {
    A[s] = new M(s, 6, !1, s, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(s) {
    A[s] = new M(s, 5, !1, s.toLowerCase(), null, !1, !1);
  });
  var P = /[\-:]([a-z])/g;
  function z(s) {
    return s[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s) {
    var l = s.replace(
      P,
      z
    );
    A[l] = new M(l, 1, !1, s, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s) {
    var l = s.replace(P, z);
    A[l] = new M(l, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(s) {
    var l = s.replace(P, z);
    A[l] = new M(l, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(s) {
    A[s] = new M(s, 1, !1, s.toLowerCase(), null, !1, !1);
  }), A.xlinkHref = new M("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(s) {
    A[s] = new M(s, 1, !1, s.toLowerCase(), null, !0, !0);
  });
  function B(s, l, p, y) {
    var _ = A.hasOwnProperty(l) ? A[l] : null;
    (_ !== null ? _.type !== 0 : y || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (R(l, p, _, y) && (p = null), y || _ === null ? w(l) && (p === null ? s.removeAttribute(l) : s.setAttribute(l, "" + p)) : _.mustUseProperty ? s[_.propertyName] = p === null ? _.type === 3 ? !1 : "" : p : (l = _.attributeName, y = _.attributeNamespace, p === null ? s.removeAttribute(l) : (_ = _.type, p = _ === 3 || _ === 4 && p === !0 ? "" : "" + p, y ? s.setAttributeNS(y, l, p) : s.setAttribute(l, p))));
  }
  var j = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, F = Symbol.for("react.element"), $ = Symbol.for("react.portal"), I = Symbol.for("react.fragment"), K = Symbol.for("react.strict_mode"), ee = Symbol.for("react.profiler"), ne = Symbol.for("react.provider"), le = Symbol.for("react.context"), re = Symbol.for("react.forward_ref"), se = Symbol.for("react.suspense"), Ne = Symbol.for("react.suspense_list"), Ee = Symbol.for("react.memo"), we = Symbol.for("react.lazy"), Oe = Symbol.for("react.offscreen"), ae = Symbol.iterator;
  function me(s) {
    return s === null || typeof s != "object" ? null : (s = ae && s[ae] || s["@@iterator"], typeof s == "function" ? s : null);
  }
  var pe = Object.assign, Ce;
  function oe(s) {
    if (Ce === void 0) try {
      throw Error();
    } catch (p) {
      var l = p.stack.trim().match(/\n( *(at )?)/);
      Ce = l && l[1] || "";
    }
    return `
` + Ce + s;
  }
  var Me = !1;
  function Pe(s, l) {
    if (!s || Me) return "";
    Me = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (l) if (l = function() {
        throw Error();
      }, Object.defineProperty(l.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(l, []);
        } catch (te) {
          var y = te;
        }
        Reflect.construct(s, [], l);
      } else {
        try {
          l.call();
        } catch (te) {
          y = te;
        }
        s.call(l.prototype);
      }
      else {
        try {
          throw Error();
        } catch (te) {
          y = te;
        }
        s();
      }
    } catch (te) {
      if (te && y && typeof te.stack == "string") {
        for (var _ = te.stack.split(`
`), T = y.stack.split(`
`), O = _.length - 1, V = T.length - 1; 1 <= O && 0 <= V && _[O] !== T[V]; ) V--;
        for (; 1 <= O && 0 <= V; O--, V--) if (_[O] !== T[V]) {
          if (O !== 1 || V !== 1)
            do
              if (O--, V--, 0 > V || _[O] !== T[V]) {
                var U = `
` + _[O].replace(" at new ", " at ");
                return s.displayName && U.includes("<anonymous>") && (U = U.replace("<anonymous>", s.displayName)), U;
              }
            while (1 <= O && 0 <= V);
          break;
        }
      }
    } finally {
      Me = !1, Error.prepareStackTrace = p;
    }
    return (s = s ? s.displayName || s.name : "") ? oe(s) : "";
  }
  function fe(s) {
    switch (s.tag) {
      case 5:
        return oe(s.type);
      case 16:
        return oe("Lazy");
      case 13:
        return oe("Suspense");
      case 19:
        return oe("SuspenseList");
      case 0:
      case 2:
      case 15:
        return s = Pe(s.type, !1), s;
      case 11:
        return s = Pe(s.type.render, !1), s;
      case 1:
        return s = Pe(s.type, !0), s;
      default:
        return "";
    }
  }
  function Le(s) {
    if (s == null) return null;
    if (typeof s == "function") return s.displayName || s.name || null;
    if (typeof s == "string") return s;
    switch (s) {
      case I:
        return "Fragment";
      case $:
        return "Portal";
      case ee:
        return "Profiler";
      case K:
        return "StrictMode";
      case se:
        return "Suspense";
      case Ne:
        return "SuspenseList";
    }
    if (typeof s == "object") switch (s.$$typeof) {
      case le:
        return (s.displayName || "Context") + ".Consumer";
      case ne:
        return (s._context.displayName || "Context") + ".Provider";
      case re:
        var l = s.render;
        return s = s.displayName, s || (s = l.displayName || l.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
      case Ee:
        return l = s.displayName || null, l !== null ? l : Le(s.type) || "Memo";
      case we:
        l = s._payload, s = s._init;
        try {
          return Le(s(l));
        } catch {
        }
    }
    return null;
  }
  function Te(s) {
    var l = s.type;
    switch (s.tag) {
      case 24:
        return "Cache";
      case 9:
        return (l.displayName || "Context") + ".Consumer";
      case 10:
        return (l._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return s = l.render, s = s.displayName || s.name || "", l.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return l;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Le(l);
      case 8:
        return l === K ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof l == "function") return l.displayName || l.name || null;
        if (typeof l == "string") return l;
    }
    return null;
  }
  function xe(s) {
    switch (typeof s) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return s;
      case "object":
        return s;
      default:
        return "";
    }
  }
  function it(s) {
    var l = s.type;
    return (s = s.nodeName) && s.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function dt(s) {
    var l = it(s) ? "checked" : "value", p = Object.getOwnPropertyDescriptor(s.constructor.prototype, l), y = "" + s[l];
    if (!s.hasOwnProperty(l) && typeof p < "u" && typeof p.get == "function" && typeof p.set == "function") {
      var _ = p.get, T = p.set;
      return Object.defineProperty(s, l, { configurable: !0, get: function() {
        return _.call(this);
      }, set: function(O) {
        y = "" + O, T.call(this, O);
      } }), Object.defineProperty(s, l, { enumerable: p.enumerable }), { getValue: function() {
        return y;
      }, setValue: function(O) {
        y = "" + O;
      }, stopTracking: function() {
        s._valueTracker = null, delete s[l];
      } };
    }
  }
  function lt(s) {
    s._valueTracker || (s._valueTracker = dt(s));
  }
  function St(s) {
    if (!s) return !1;
    var l = s._valueTracker;
    if (!l) return !0;
    var p = l.getValue(), y = "";
    return s && (y = it(s) ? s.checked ? "true" : "false" : s.value), s = y, s !== p ? (l.setValue(s), !0) : !1;
  }
  function _t(s) {
    if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
    try {
      return s.activeElement || s.body;
    } catch {
      return s.body;
    }
  }
  function rt(s, l) {
    var p = l.checked;
    return pe({}, l, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: p ?? s._wrapperState.initialChecked });
  }
  function xt(s, l) {
    var p = l.defaultValue == null ? "" : l.defaultValue, y = l.checked != null ? l.checked : l.defaultChecked;
    p = xe(l.value != null ? l.value : p), s._wrapperState = { initialChecked: y, initialValue: p, controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null };
  }
  function Wt(s, l) {
    l = l.checked, l != null && B(s, "checked", l, !1);
  }
  function an(s, l) {
    Wt(s, l);
    var p = xe(l.value), y = l.type;
    if (p != null) y === "number" ? (p === 0 && s.value === "" || s.value != p) && (s.value = "" + p) : s.value !== "" + p && (s.value = "" + p);
    else if (y === "submit" || y === "reset") {
      s.removeAttribute("value");
      return;
    }
    l.hasOwnProperty("value") ? Yt(s, l.type, p) : l.hasOwnProperty("defaultValue") && Yt(s, l.type, xe(l.defaultValue)), l.checked == null && l.defaultChecked != null && (s.defaultChecked = !!l.defaultChecked);
  }
  function sn(s, l, p) {
    if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
      var y = l.type;
      if (!(y !== "submit" && y !== "reset" || l.value !== void 0 && l.value !== null)) return;
      l = "" + s._wrapperState.initialValue, p || l === s.value || (s.value = l), s.defaultValue = l;
    }
    p = s.name, p !== "" && (s.name = ""), s.defaultChecked = !!s._wrapperState.initialChecked, p !== "" && (s.name = p);
  }
  function Yt(s, l, p) {
    (l !== "number" || _t(s.ownerDocument) !== s) && (p == null ? s.defaultValue = "" + s._wrapperState.initialValue : s.defaultValue !== "" + p && (s.defaultValue = "" + p));
  }
  var Gt = Array.isArray;
  function Ot(s, l, p, y) {
    if (s = s.options, l) {
      l = {};
      for (var _ = 0; _ < p.length; _++) l["$" + p[_]] = !0;
      for (p = 0; p < s.length; p++) _ = l.hasOwnProperty("$" + s[p].value), s[p].selected !== _ && (s[p].selected = _), _ && y && (s[p].defaultSelected = !0);
    } else {
      for (p = "" + xe(p), l = null, _ = 0; _ < s.length; _++) {
        if (s[_].value === p) {
          s[_].selected = !0, y && (s[_].defaultSelected = !0);
          return;
        }
        l !== null || s[_].disabled || (l = s[_]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function wt(s, l) {
    if (l.dangerouslySetInnerHTML != null) throw Error(i(91));
    return pe({}, l, { value: void 0, defaultValue: void 0, children: "" + s._wrapperState.initialValue });
  }
  function Kt(s, l) {
    var p = l.value;
    if (p == null) {
      if (p = l.children, l = l.defaultValue, p != null) {
        if (l != null) throw Error(i(92));
        if (Gt(p)) {
          if (1 < p.length) throw Error(i(93));
          p = p[0];
        }
        l = p;
      }
      l == null && (l = ""), p = l;
    }
    s._wrapperState = { initialValue: xe(p) };
  }
  function wn(s, l) {
    var p = xe(l.value), y = xe(l.defaultValue);
    p != null && (p = "" + p, p !== s.value && (s.value = p), l.defaultValue == null && s.defaultValue !== p && (s.defaultValue = p)), y != null && (s.defaultValue = "" + y);
  }
  function Mn(s) {
    var l = s.textContent;
    l === s._wrapperState.initialValue && l !== "" && l !== null && (s.value = l);
  }
  function oi(s) {
    switch (s) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Pi(s, l) {
    return s == null || s === "http://www.w3.org/1999/xhtml" ? oi(l) : s === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s;
  }
  var er, Ei = function(s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, p, y, _) {
      MSApp.execUnsafeLocalFunction(function() {
        return s(l, p, y, _);
      });
    } : s;
  }(function(s, l) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s) s.innerHTML = l;
    else {
      for (er = er || document.createElement("div"), er.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = er.firstChild; s.firstChild; ) s.removeChild(s.firstChild);
      for (; l.firstChild; ) s.appendChild(l.firstChild);
    }
  });
  function ze(s, l) {
    if (l) {
      var p = s.firstChild;
      if (p && p === s.lastChild && p.nodeType === 3) {
        p.nodeValue = l;
        return;
      }
    }
    s.textContent = l;
  }
  var tt = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Et = ["Webkit", "ms", "Moz", "O"];
  Object.keys(tt).forEach(function(s) {
    Et.forEach(function(l) {
      l = l + s.charAt(0).toUpperCase() + s.substring(1), tt[l] = tt[s];
    });
  });
  function Xt(s, l, p) {
    return l == null || typeof l == "boolean" || l === "" ? "" : p || typeof l != "number" || l === 0 || tt.hasOwnProperty(s) && tt[s] ? ("" + l).trim() : l + "px";
  }
  function ln(s, l) {
    s = s.style;
    for (var p in l) if (l.hasOwnProperty(p)) {
      var y = p.indexOf("--") === 0, _ = Xt(p, l[p], y);
      p === "float" && (p = "cssFloat"), y ? s.setProperty(p, _) : s[p] = _;
    }
  }
  var dn = pe({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function gn(s, l) {
    if (l) {
      if (dn[s] && (l.children != null || l.dangerouslySetInnerHTML != null)) throw Error(i(137, s));
      if (l.dangerouslySetInnerHTML != null) {
        if (l.children != null) throw Error(i(60));
        if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML)) throw Error(i(61));
      }
      if (l.style != null && typeof l.style != "object") throw Error(i(62));
    }
  }
  function zn(s, l) {
    if (s.indexOf("-") === -1) return typeof l.is == "string";
    switch (s) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var on = null;
  function jt(s) {
    return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s;
  }
  var Qt = null, Di = null, yi = null;
  function He(s) {
    if (s = st(s)) {
      if (typeof Qt != "function") throw Error(i(280));
      var l = s.stateNode;
      l && (l = qn(l), Qt(s.stateNode, s.type, l));
    }
  }
  function Fe(s) {
    Di ? yi ? yi.push(s) : yi = [s] : Di = s;
  }
  function Qe() {
    if (Di) {
      var s = Di, l = yi;
      if (yi = Di = null, He(s), l) for (s = 0; s < l.length; s++) He(l[s]);
    }
  }
  function mt(s, l) {
    return s(l);
  }
  function de() {
  }
  var ve = !1;
  function ke(s, l, p) {
    if (ve) return s(l, p);
    ve = !0;
    try {
      return mt(s, l, p);
    } finally {
      ve = !1, (Di !== null || yi !== null) && (de(), Qe());
    }
  }
  function $e(s, l) {
    var p = s.stateNode;
    if (p === null) return null;
    var y = qn(p);
    if (y === null) return null;
    p = y[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (y = !y.disabled) || (s = s.type, y = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !y;
        break e;
      default:
        s = !1;
    }
    if (s) return null;
    if (p && typeof p != "function") throw Error(i(231, l, typeof p));
    return p;
  }
  var hn = !1;
  if (h) try {
    var An = {};
    Object.defineProperty(An, "passive", { get: function() {
      hn = !0;
    } }), window.addEventListener("test", An, An), window.removeEventListener("test", An, An);
  } catch {
    hn = !1;
  }
  function yr(s, l, p, y, _, T, O, V, U) {
    var te = Array.prototype.slice.call(arguments, 3);
    try {
      l.apply(p, te);
    } catch (Se) {
      this.onError(Se);
    }
  }
  var Hr = !1, Da = null, Ra = !1, H = null, ge = { onError: function(s) {
    Hr = !0, Da = s;
  } };
  function Be(s, l, p, y, _, T, O, V, U) {
    Hr = !1, Da = null, yr.apply(ge, arguments);
  }
  function ut(s, l, p, y, _, T, O, V, U) {
    if (Be.apply(this, arguments), Hr) {
      if (Hr) {
        var te = Da;
        Hr = !1, Da = null;
      } else throw Error(i(198));
      Ra || (Ra = !0, H = te);
    }
  }
  function ct(s) {
    var l = s, p = s;
    if (s.alternate) for (; l.return; ) l = l.return;
    else {
      s = l;
      do
        l = s, l.flags & 4098 && (p = l.return), s = l.return;
      while (s);
    }
    return l.tag === 3 ? p : null;
  }
  function Dt(s) {
    if (s.tag === 13) {
      var l = s.memoizedState;
      if (l === null && (s = s.alternate, s !== null && (l = s.memoizedState)), l !== null) return l.dehydrated;
    }
    return null;
  }
  function Pt(s) {
    if (ct(s) !== s) throw Error(i(188));
  }
  function Ft(s) {
    var l = s.alternate;
    if (!l) {
      if (l = ct(s), l === null) throw Error(i(188));
      return l !== s ? null : s;
    }
    for (var p = s, y = l; ; ) {
      var _ = p.return;
      if (_ === null) break;
      var T = _.alternate;
      if (T === null) {
        if (y = _.return, y !== null) {
          p = y;
          continue;
        }
        break;
      }
      if (_.child === T.child) {
        for (T = _.child; T; ) {
          if (T === p) return Pt(_), s;
          if (T === y) return Pt(_), l;
          T = T.sibling;
        }
        throw Error(i(188));
      }
      if (p.return !== y.return) p = _, y = T;
      else {
        for (var O = !1, V = _.child; V; ) {
          if (V === p) {
            O = !0, p = _, y = T;
            break;
          }
          if (V === y) {
            O = !0, y = _, p = T;
            break;
          }
          V = V.sibling;
        }
        if (!O) {
          for (V = T.child; V; ) {
            if (V === p) {
              O = !0, p = T, y = _;
              break;
            }
            if (V === y) {
              O = !0, y = T, p = _;
              break;
            }
            V = V.sibling;
          }
          if (!O) throw Error(i(189));
        }
      }
      if (p.alternate !== y) throw Error(i(190));
    }
    if (p.tag !== 3) throw Error(i(188));
    return p.stateNode.current === p ? s : l;
  }
  function bi(s) {
    return s = Ft(s), s !== null ? On(s) : null;
  }
  function On(s) {
    if (s.tag === 5 || s.tag === 6) return s;
    for (s = s.child; s !== null; ) {
      var l = On(s);
      if (l !== null) return l;
      s = s.sibling;
    }
    return null;
  }
  var Fn = e.unstable_scheduleCallback, tr = e.unstable_cancelCallback, bs = e.unstable_shouldYield, xs = e.unstable_requestPaint, At = e.unstable_now, Lt = e.unstable_getCurrentPriorityLevel, Ss = e.unstable_ImmediatePriority, lc = e.unstable_UserBlockingPriority, uc = e.unstable_NormalPriority, Hv = e.unstable_LowPriority, xp = e.unstable_IdlePriority, cc = null, ka = null;
  function Uv(s) {
    if (ka && typeof ka.onCommitFiberRoot == "function") try {
      ka.onCommitFiberRoot(cc, s, void 0, (s.current.flags & 128) === 128);
    } catch {
    }
  }
  var ea = Math.clz32 ? Math.clz32 : Sp, wS = Math.log, CS = Math.LN2;
  function Sp(s) {
    return s >>>= 0, s === 0 ? 32 : 31 - (wS(s) / CS | 0) | 0;
  }
  var Jl = 64, Ma = 4194304;
  function Go(s) {
    switch (s & -s) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return s & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return s;
    }
  }
  function Ko(s, l) {
    var p = s.pendingLanes;
    if (p === 0) return 0;
    var y = 0, _ = s.suspendedLanes, T = s.pingedLanes, O = p & 268435455;
    if (O !== 0) {
      var V = O & ~_;
      V !== 0 ? y = Go(V) : (T &= O, T !== 0 && (y = Go(T)));
    } else O = p & ~_, O !== 0 ? y = Go(O) : T !== 0 && (y = Go(T));
    if (y === 0) return 0;
    if (l !== 0 && l !== y && !(l & _) && (_ = y & -y, T = l & -l, _ >= T || _ === 16 && (T & 4194240) !== 0)) return l;
    if (y & 4 && (y |= p & 16), l = s.entangledLanes, l !== 0) for (s = s.entanglements, l &= y; 0 < l; ) p = 31 - ea(l), _ = 1 << p, y |= s[p], l &= ~_;
    return y;
  }
  function TS(s, l) {
    switch (s) {
      case 1:
      case 2:
      case 4:
        return l + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function _p(s, l) {
    for (var p = s.suspendedLanes, y = s.pingedLanes, _ = s.expirationTimes, T = s.pendingLanes; 0 < T; ) {
      var O = 31 - ea(T), V = 1 << O, U = _[O];
      U === -1 ? (!(V & p) || V & y) && (_[O] = TS(V, l)) : U <= l && (s.expiredLanes |= V), T &= ~V;
    }
  }
  function wp(s) {
    return s = s.pendingLanes & -1073741825, s !== 0 ? s : s & 1073741824 ? 1073741824 : 0;
  }
  function qf() {
    var s = Jl;
    return Jl <<= 1, !(Jl & 4194240) && (Jl = 64), s;
  }
  function Cp(s) {
    for (var l = [], p = 0; 31 > p; p++) l.push(s);
    return l;
  }
  function Xo(s, l, p) {
    s.pendingLanes |= l, l !== 536870912 && (s.suspendedLanes = 0, s.pingedLanes = 0), s = s.eventTimes, l = 31 - ea(l), s[l] = p;
  }
  function ES(s, l) {
    var p = s.pendingLanes & ~l;
    s.pendingLanes = l, s.suspendedLanes = 0, s.pingedLanes = 0, s.expiredLanes &= l, s.mutableReadLanes &= l, s.entangledLanes &= l, l = s.entanglements;
    var y = s.eventTimes;
    for (s = s.expirationTimes; 0 < p; ) {
      var _ = 31 - ea(p), T = 1 << _;
      l[_] = 0, y[_] = -1, s[_] = -1, p &= ~T;
    }
  }
  function Zf(s, l) {
    var p = s.entangledLanes |= l;
    for (s = s.entanglements; p; ) {
      var y = 31 - ea(p), _ = 1 << y;
      _ & l | s[y] & l && (s[y] |= l), p &= ~_;
    }
  }
  var pn = 0;
  function Tp(s) {
    return s &= -s, 1 < s ? 4 < s ? s & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var mn, Ep, Dp, kt, Rp, nr = !1, eo = [], ta = null, to = null, Wn = null, Rn = /* @__PURE__ */ new Map(), fc = /* @__PURE__ */ new Map(), Li = [], na = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function _s(s, l) {
    switch (s) {
      case "focusin":
      case "focusout":
        ta = null;
        break;
      case "dragenter":
      case "dragleave":
        to = null;
        break;
      case "mouseover":
      case "mouseout":
        Wn = null;
        break;
      case "pointerover":
      case "pointerout":
        Rn.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        fc.delete(l.pointerId);
    }
  }
  function dc(s, l, p, y, _, T) {
    return s === null || s.nativeEvent !== T ? (s = { blockedOn: l, domEventName: p, eventSystemFlags: y, nativeEvent: T, targetContainers: [_] }, l !== null && (l = st(l), l !== null && Ep(l)), s) : (s.eventSystemFlags |= y, l = s.targetContainers, _ !== null && l.indexOf(_) === -1 && l.push(_), s);
  }
  function kp(s, l, p, y, _) {
    switch (l) {
      case "focusin":
        return ta = dc(ta, s, l, p, y, _), !0;
      case "dragenter":
        return to = dc(to, s, l, p, y, _), !0;
      case "mouseover":
        return Wn = dc(Wn, s, l, p, y, _), !0;
      case "pointerover":
        var T = _.pointerId;
        return Rn.set(T, dc(Rn.get(T) || null, s, l, p, y, _)), !0;
      case "gotpointercapture":
        return T = _.pointerId, fc.set(T, dc(fc.get(T) || null, s, l, p, y, _)), !0;
    }
    return !1;
  }
  function Mp(s) {
    var l = al(s.target);
    if (l !== null) {
      var p = ct(l);
      if (p !== null) {
        if (l = p.tag, l === 13) {
          if (l = Dt(p), l !== null) {
            s.blockedOn = l, Rp(s.priority, function() {
              Dp(p);
            });
            return;
          }
        } else if (l === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          s.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    s.blockedOn = null;
  }
  function hc(s) {
    if (s.blockedOn !== null) return !1;
    for (var l = s.targetContainers; 0 < l.length; ) {
      var p = ed(s.domEventName, s.eventSystemFlags, l[0], s.nativeEvent);
      if (p === null) {
        p = s.nativeEvent;
        var y = new p.constructor(p.type, p);
        on = y, p.target.dispatchEvent(y), on = null;
      } else return l = st(p), l !== null && Ep(l), s.blockedOn = p, !1;
      l.shift();
    }
    return !0;
  }
  function Iv(s, l, p) {
    hc(s) && p.delete(l);
  }
  function DS() {
    nr = !1, ta !== null && hc(ta) && (ta = null), to !== null && hc(to) && (to = null), Wn !== null && hc(Wn) && (Wn = null), Rn.forEach(Iv), fc.forEach(Iv);
  }
  function pc(s, l) {
    s.blockedOn === l && (s.blockedOn = null, nr || (nr = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, DS)));
  }
  function no(s) {
    function l(_) {
      return pc(_, s);
    }
    if (0 < eo.length) {
      pc(eo[0], s);
      for (var p = 1; p < eo.length; p++) {
        var y = eo[p];
        y.blockedOn === s && (y.blockedOn = null);
      }
    }
    for (ta !== null && pc(ta, s), to !== null && pc(to, s), Wn !== null && pc(Wn, s), Rn.forEach(l), fc.forEach(l), p = 0; p < Li.length; p++) y = Li[p], y.blockedOn === s && (y.blockedOn = null);
    for (; 0 < Li.length && (p = Li[0], p.blockedOn === null); ) Mp(p), p.blockedOn === null && Li.shift();
  }
  var Qo = j.ReactCurrentBatchConfig, qo = !0;
  function $v(s, l, p, y) {
    var _ = pn, T = Qo.transition;
    Qo.transition = null;
    try {
      pn = 1, Jf(s, l, p, y);
    } finally {
      pn = _, Qo.transition = T;
    }
  }
  function Wv(s, l, p, y) {
    var _ = pn, T = Qo.transition;
    Qo.transition = null;
    try {
      pn = 4, Jf(s, l, p, y);
    } finally {
      pn = _, Qo.transition = T;
    }
  }
  function Jf(s, l, p, y) {
    if (qo) {
      var _ = ed(s, l, p, y);
      if (_ === null) yd(s, l, y, mc, p), _s(s, y);
      else if (kp(_, s, l, p, y)) y.stopPropagation();
      else if (_s(s, y), l & 4 && -1 < na.indexOf(s)) {
        for (; _ !== null; ) {
          var T = st(_);
          if (T !== null && mn(T), T = ed(s, l, p, y), T === null && yd(s, l, y, mc, p), T === _) break;
          _ = T;
        }
        _ !== null && y.stopPropagation();
      } else yd(s, l, y, null, p);
    }
  }
  var mc = null;
  function ed(s, l, p, y) {
    if (mc = null, s = jt(y), s = al(s), s !== null) if (l = ct(s), l === null) s = null;
    else if (p = l.tag, p === 13) {
      if (s = Dt(l), s !== null) return s;
      s = null;
    } else if (p === 3) {
      if (l.stateNode.current.memoizedState.isDehydrated) return l.tag === 3 ? l.stateNode.containerInfo : null;
      s = null;
    } else l !== s && (s = null);
    return mc = s, null;
  }
  function td(s) {
    switch (s) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Lt()) {
          case Ss:
            return 1;
          case lc:
            return 4;
          case uc:
          case Hv:
            return 16;
          case xp:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var ws = null, nd = null, eu = null;
  function Ap() {
    if (eu) return eu;
    var s, l = nd, p = l.length, y, _ = "value" in ws ? ws.value : ws.textContent, T = _.length;
    for (s = 0; s < p && l[s] === _[s]; s++) ;
    var O = p - s;
    for (y = 1; y <= O && l[p - y] === _[T - y]; y++) ;
    return eu = _.slice(s, 1 < y ? 1 - y : void 0);
  }
  function id(s) {
    var l = s.keyCode;
    return "charCode" in s ? (s = s.charCode, s === 0 && l === 13 && (s = 13)) : s = l, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0;
  }
  function rd() {
    return !0;
  }
  function ad() {
    return !1;
  }
  function br(s) {
    function l(p, y, _, T, O) {
      this._reactName = p, this._targetInst = _, this.type = y, this.nativeEvent = T, this.target = O, this.currentTarget = null;
      for (var V in s) s.hasOwnProperty(V) && (p = s[V], this[V] = p ? p(T) : T[V]);
      return this.isDefaultPrevented = (T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1) ? rd : ad, this.isPropagationStopped = ad, this;
    }
    return pe(l.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var p = this.nativeEvent;
      p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = rd);
    }, stopPropagation: function() {
      var p = this.nativeEvent;
      p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = rd);
    }, persist: function() {
    }, isPersistent: rd }), l;
  }
  var Zo = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(s) {
    return s.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, sd = br(Zo), tu = pe({}, Zo, { view: 0, detail: 0 }), RS = br(tu), Op, Ni, Jo, gc = pe({}, tu, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Fp, button: 0, buttons: 0, relatedTarget: function(s) {
    return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget;
  }, movementX: function(s) {
    return "movementX" in s ? s.movementX : (s !== Jo && (Jo && s.type === "mousemove" ? (Op = s.screenX - Jo.screenX, Ni = s.screenY - Jo.screenY) : Ni = Op = 0, Jo = s), Op);
  }, movementY: function(s) {
    return "movementY" in s ? s.movementY : Ni;
  } }), Pp = br(gc), kS = pe({}, gc, { dataTransfer: 0 }), nu = br(kS), Lp = pe({}, tu, { relatedTarget: 0 }), od = br(Lp), MS = pe({}, Zo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), AS = br(MS), OS = pe({}, Zo, { clipboardData: function(s) {
    return "clipboardData" in s ? s.clipboardData : window.clipboardData;
  } }), Yv = br(OS), Np = pe({}, Zo, { data: 0 }), zp = br(Np), Gv = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Kv = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, PS = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Cs(s) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(s) : (s = PS[s]) ? !!l[s] : !1;
  }
  function Fp() {
    return Cs;
  }
  var Vp = pe({}, tu, { key: function(s) {
    if (s.key) {
      var l = Gv[s.key] || s.key;
      if (l !== "Unidentified") return l;
    }
    return s.type === "keypress" ? (s = id(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? Kv[s.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Fp, charCode: function(s) {
    return s.type === "keypress" ? id(s) : 0;
  }, keyCode: function(s) {
    return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
  }, which: function(s) {
    return s.type === "keypress" ? id(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
  } }), jp = br(Vp), Bp = pe({}, gc, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Xv = br(Bp), ld = pe({}, tu, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Fp }), Qv = br(ld), xr = pe({}, Zo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ts = br(xr), li = pe({}, gc, {
    deltaX: function(s) {
      return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
    },
    deltaY: function(s) {
      return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Es = br(li), Hp = [9, 13, 27, 32], iu = h && "CompositionEvent" in window, vc = null;
  h && "documentMode" in document && (vc = document.documentMode);
  var yc = h && "TextEvent" in window && !vc, qv = h && (!iu || vc && 8 < vc && 11 >= vc), Zv = " ", ud = !1;
  function Jv(s, l) {
    switch (s) {
      case "keyup":
        return Hp.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function ey(s) {
    return s = s.detail, typeof s == "object" && "data" in s ? s.data : null;
  }
  var ru = !1;
  function ty(s, l) {
    switch (s) {
      case "compositionend":
        return ey(l);
      case "keypress":
        return l.which !== 32 ? null : (ud = !0, Zv);
      case "textInput":
        return s = l.data, s === Zv && ud ? null : s;
      default:
        return null;
    }
  }
  function LS(s, l) {
    if (ru) return s === "compositionend" || !iu && Jv(s, l) ? (s = Ap(), eu = nd = ws = null, ru = !1, s) : null;
    switch (s) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length) return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return qv && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var NS = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function ny(s) {
    var l = s && s.nodeName && s.nodeName.toLowerCase();
    return l === "input" ? !!NS[s.type] : l === "textarea";
  }
  function Up(s, l, p, y) {
    Fe(y), l = Cc(l, "onChange"), 0 < l.length && (p = new sd("onChange", "change", null, p, y), s.push({ event: p, listeners: l }));
  }
  var Ka = null, el = null;
  function iy(s) {
    il(s, 0);
  }
  function bc(s) {
    var l = Oa(s);
    if (St(l)) return s;
  }
  function zS(s, l) {
    if (s === "change") return l;
  }
  var ry = !1;
  if (h) {
    var Ip;
    if (h) {
      var $p = "oninput" in document;
      if (!$p) {
        var ay = document.createElement("div");
        ay.setAttribute("oninput", "return;"), $p = typeof ay.oninput == "function";
      }
      Ip = $p;
    } else Ip = !1;
    ry = Ip && (!document.documentMode || 9 < document.documentMode);
  }
  function sy() {
    Ka && (Ka.detachEvent("onpropertychange", oy), el = Ka = null);
  }
  function oy(s) {
    if (s.propertyName === "value" && bc(el)) {
      var l = [];
      Up(l, el, s, jt(s)), ke(iy, l);
    }
  }
  function FS(s, l, p) {
    s === "focusin" ? (sy(), Ka = l, el = p, Ka.attachEvent("onpropertychange", oy)) : s === "focusout" && sy();
  }
  function ly(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown") return bc(el);
  }
  function VS(s, l) {
    if (s === "click") return bc(l);
  }
  function uy(s, l) {
    if (s === "input" || s === "change") return bc(l);
  }
  function jS(s, l) {
    return s === l && (s !== 0 || 1 / s === 1 / l) || s !== s && l !== l;
  }
  var Aa = typeof Object.is == "function" ? Object.is : jS;
  function xc(s, l) {
    if (Aa(s, l)) return !0;
    if (typeof s != "object" || s === null || typeof l != "object" || l === null) return !1;
    var p = Object.keys(s), y = Object.keys(l);
    if (p.length !== y.length) return !1;
    for (y = 0; y < p.length; y++) {
      var _ = p[y];
      if (!m.call(l, _) || !Aa(s[_], l[_])) return !1;
    }
    return !0;
  }
  function cy(s) {
    for (; s && s.firstChild; ) s = s.firstChild;
    return s;
  }
  function cd(s, l) {
    var p = cy(s);
    s = 0;
    for (var y; p; ) {
      if (p.nodeType === 3) {
        if (y = s + p.textContent.length, s <= l && y >= l) return { node: p, offset: l - s };
        s = y;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = cy(p);
    }
  }
  function io(s, l) {
    return s && l ? s === l ? !0 : s && s.nodeType === 3 ? !1 : l && l.nodeType === 3 ? io(s, l.parentNode) : "contains" in s ? s.contains(l) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function Sc() {
    for (var s = window, l = _t(); l instanceof s.HTMLIFrameElement; ) {
      try {
        var p = typeof l.contentWindow.location.href == "string";
      } catch {
        p = !1;
      }
      if (p) s = l.contentWindow;
      else break;
      l = _t(s.document);
    }
    return l;
  }
  function fd(s) {
    var l = s && s.nodeName && s.nodeName.toLowerCase();
    return l && (l === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || l === "textarea" || s.contentEditable === "true");
  }
  function au(s) {
    var l = Sc(), p = s.focusedElem, y = s.selectionRange;
    if (l !== p && p && p.ownerDocument && io(p.ownerDocument.documentElement, p)) {
      if (y !== null && fd(p)) {
        if (l = y.start, s = y.end, s === void 0 && (s = l), "selectionStart" in p) p.selectionStart = l, p.selectionEnd = Math.min(s, p.value.length);
        else if (s = (l = p.ownerDocument || document) && l.defaultView || window, s.getSelection) {
          s = s.getSelection();
          var _ = p.textContent.length, T = Math.min(y.start, _);
          y = y.end === void 0 ? T : Math.min(y.end, _), !s.extend && T > y && (_ = y, y = T, T = _), _ = cd(p, T);
          var O = cd(
            p,
            y
          );
          _ && O && (s.rangeCount !== 1 || s.anchorNode !== _.node || s.anchorOffset !== _.offset || s.focusNode !== O.node || s.focusOffset !== O.offset) && (l = l.createRange(), l.setStart(_.node, _.offset), s.removeAllRanges(), T > y ? (s.addRange(l), s.extend(O.node, O.offset)) : (l.setEnd(O.node, O.offset), s.addRange(l)));
        }
      }
      for (l = [], s = p; s = s.parentNode; ) s.nodeType === 1 && l.push({ element: s, left: s.scrollLeft, top: s.scrollTop });
      for (typeof p.focus == "function" && p.focus(), p = 0; p < l.length; p++) s = l[p], s.element.scrollLeft = s.left, s.element.scrollTop = s.top;
    }
  }
  var BS = h && "documentMode" in document && 11 >= document.documentMode, su = null, Wp = null, _c = null, Yp = !1;
  function Gp(s, l, p) {
    var y = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    Yp || su == null || su !== _t(y) || (y = su, "selectionStart" in y && fd(y) ? y = { start: y.selectionStart, end: y.selectionEnd } : (y = (y.ownerDocument && y.ownerDocument.defaultView || window).getSelection(), y = { anchorNode: y.anchorNode, anchorOffset: y.anchorOffset, focusNode: y.focusNode, focusOffset: y.focusOffset }), _c && xc(_c, y) || (_c = y, y = Cc(Wp, "onSelect"), 0 < y.length && (l = new sd("onSelect", "select", null, l, p), s.push({ event: l, listeners: y }), l.target = su)));
  }
  function dd(s, l) {
    var p = {};
    return p[s.toLowerCase()] = l.toLowerCase(), p["Webkit" + s] = "webkit" + l, p["Moz" + s] = "moz" + l, p;
  }
  var tl = { animationend: dd("Animation", "AnimationEnd"), animationiteration: dd("Animation", "AnimationIteration"), animationstart: dd("Animation", "AnimationStart"), transitionend: dd("Transition", "TransitionEnd") }, zi = {}, Kp = {};
  h && (Kp = document.createElement("div").style, "AnimationEvent" in window || (delete tl.animationend.animation, delete tl.animationiteration.animation, delete tl.animationstart.animation), "TransitionEvent" in window || delete tl.transitionend.transition);
  function hd(s) {
    if (zi[s]) return zi[s];
    if (!tl[s]) return s;
    var l = tl[s], p;
    for (p in l) if (l.hasOwnProperty(p) && p in Kp) return zi[s] = l[p];
    return s;
  }
  var fy = hd("animationend"), dy = hd("animationiteration"), hy = hd("animationstart"), py = hd("transitionend"), Xp = /* @__PURE__ */ new Map(), pd = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ia(s, l) {
    Xp.set(s, l), c(l, [s]);
  }
  for (var Qp = 0; Qp < pd.length; Qp++) {
    var nl = pd[Qp], HS = nl.toLowerCase(), US = nl[0].toUpperCase() + nl.slice(1);
    ia(HS, "on" + US);
  }
  ia(fy, "onAnimationEnd"), ia(dy, "onAnimationIteration"), ia(hy, "onAnimationStart"), ia("dblclick", "onDoubleClick"), ia("focusin", "onFocus"), ia("focusout", "onBlur"), ia(py, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), c("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), c("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), c("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), c("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var wc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), qp = new Set("cancel close invalid load scroll toggle".split(" ").concat(wc));
  function md(s, l, p) {
    var y = s.type || "unknown-event";
    s.currentTarget = p, ut(y, l, void 0, s), s.currentTarget = null;
  }
  function il(s, l) {
    l = (l & 4) !== 0;
    for (var p = 0; p < s.length; p++) {
      var y = s[p], _ = y.event;
      y = y.listeners;
      e: {
        var T = void 0;
        if (l) for (var O = y.length - 1; 0 <= O; O--) {
          var V = y[O], U = V.instance, te = V.currentTarget;
          if (V = V.listener, U !== T && _.isPropagationStopped()) break e;
          md(_, V, te), T = U;
        }
        else for (O = 0; O < y.length; O++) {
          if (V = y[O], U = V.instance, te = V.currentTarget, V = V.listener, U !== T && _.isPropagationStopped()) break e;
          md(_, V, te), T = U;
        }
      }
    }
    if (Ra) throw s = H, Ra = !1, H = null, s;
  }
  function un(s, l) {
    var p = l[Dc];
    p === void 0 && (p = l[Dc] = /* @__PURE__ */ new Set());
    var y = s + "__bubble";
    p.has(y) || (my(l, s, 2, !1), p.add(y));
  }
  function gd(s, l, p) {
    var y = 0;
    l && (y |= 4), my(p, s, y, l);
  }
  var vd = "_reactListening" + Math.random().toString(36).slice(2);
  function ou(s) {
    if (!s[vd]) {
      s[vd] = !0, a.forEach(function(p) {
        p !== "selectionchange" && (qp.has(p) || gd(p, !1, s), gd(p, !0, s));
      });
      var l = s.nodeType === 9 ? s : s.ownerDocument;
      l === null || l[vd] || (l[vd] = !0, gd("selectionchange", !1, l));
    }
  }
  function my(s, l, p, y) {
    switch (td(l)) {
      case 1:
        var _ = $v;
        break;
      case 4:
        _ = Wv;
        break;
      default:
        _ = Jf;
    }
    p = _.bind(null, l, p, s), _ = void 0, !hn || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (_ = !0), y ? _ !== void 0 ? s.addEventListener(l, p, { capture: !0, passive: _ }) : s.addEventListener(l, p, !0) : _ !== void 0 ? s.addEventListener(l, p, { passive: _ }) : s.addEventListener(l, p, !1);
  }
  function yd(s, l, p, y, _) {
    var T = y;
    if (!(l & 1) && !(l & 2) && y !== null) e: for (; ; ) {
      if (y === null) return;
      var O = y.tag;
      if (O === 3 || O === 4) {
        var V = y.stateNode.containerInfo;
        if (V === _ || V.nodeType === 8 && V.parentNode === _) break;
        if (O === 4) for (O = y.return; O !== null; ) {
          var U = O.tag;
          if ((U === 3 || U === 4) && (U = O.stateNode.containerInfo, U === _ || U.nodeType === 8 && U.parentNode === _)) return;
          O = O.return;
        }
        for (; V !== null; ) {
          if (O = al(V), O === null) return;
          if (U = O.tag, U === 5 || U === 6) {
            y = T = O;
            continue e;
          }
          V = V.parentNode;
        }
      }
      y = y.return;
    }
    ke(function() {
      var te = T, Se = jt(p), De = [];
      e: {
        var be = Xp.get(s);
        if (be !== void 0) {
          var Ye = sd, qe = s;
          switch (s) {
            case "keypress":
              if (id(p) === 0) break e;
            case "keydown":
            case "keyup":
              Ye = jp;
              break;
            case "focusin":
              qe = "focus", Ye = od;
              break;
            case "focusout":
              qe = "blur", Ye = od;
              break;
            case "beforeblur":
            case "afterblur":
              Ye = od;
              break;
            case "click":
              if (p.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Ye = Pp;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Ye = nu;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Ye = Qv;
              break;
            case fy:
            case dy:
            case hy:
              Ye = AS;
              break;
            case py:
              Ye = Ts;
              break;
            case "scroll":
              Ye = RS;
              break;
            case "wheel":
              Ye = Es;
              break;
            case "copy":
            case "cut":
            case "paste":
              Ye = Yv;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Ye = Xv;
          }
          var et = (l & 4) !== 0, ni = !et && s === "scroll", X = et ? be !== null ? be + "Capture" : null : be;
          et = [];
          for (var Y = te, Z; Y !== null; ) {
            Z = Y;
            var _e = Z.stateNode;
            if (Z.tag === 5 && _e !== null && (Z = _e, X !== null && (_e = $e(Y, X), _e != null && et.push(lu(Y, _e, Z)))), ni) break;
            Y = Y.return;
          }
          0 < et.length && (be = new Ye(be, qe, null, p, Se), De.push({ event: be, listeners: et }));
        }
      }
      if (!(l & 7)) {
        e: {
          if (be = s === "mouseover" || s === "pointerover", Ye = s === "mouseout" || s === "pointerout", be && p !== on && (qe = p.relatedTarget || p.fromElement) && (al(qe) || qe[Ds])) break e;
          if ((Ye || be) && (be = Se.window === Se ? Se : (be = Se.ownerDocument) ? be.defaultView || be.parentWindow : window, Ye ? (qe = p.relatedTarget || p.toElement, Ye = te, qe = qe ? al(qe) : null, qe !== null && (ni = ct(qe), qe !== ni || qe.tag !== 5 && qe.tag !== 6) && (qe = null)) : (Ye = null, qe = te), Ye !== qe)) {
            if (et = Pp, _e = "onMouseLeave", X = "onMouseEnter", Y = "mouse", (s === "pointerout" || s === "pointerover") && (et = Xv, _e = "onPointerLeave", X = "onPointerEnter", Y = "pointer"), ni = Ye == null ? be : Oa(Ye), Z = qe == null ? be : Oa(qe), be = new et(_e, Y + "leave", Ye, p, Se), be.target = ni, be.relatedTarget = Z, _e = null, al(Se) === te && (et = new et(X, Y + "enter", qe, p, Se), et.target = Z, et.relatedTarget = ni, _e = et), ni = _e, Ye && qe) t: {
              for (et = Ye, X = qe, Y = 0, Z = et; Z; Z = ro(Z)) Y++;
              for (Z = 0, _e = X; _e; _e = ro(_e)) Z++;
              for (; 0 < Y - Z; ) et = ro(et), Y--;
              for (; 0 < Z - Y; ) X = ro(X), Z--;
              for (; Y--; ) {
                if (et === X || X !== null && et === X.alternate) break t;
                et = ro(et), X = ro(X);
              }
              et = null;
            }
            else et = null;
            Ye !== null && gy(De, be, Ye, et, !1), qe !== null && ni !== null && gy(De, ni, qe, et, !0);
          }
        }
        e: {
          if (be = te ? Oa(te) : window, Ye = be.nodeName && be.nodeName.toLowerCase(), Ye === "select" || Ye === "input" && be.type === "file") var Ze = zS;
          else if (ny(be)) if (ry) Ze = uy;
          else {
            Ze = ly;
            var ht = FS;
          }
          else (Ye = be.nodeName) && Ye.toLowerCase() === "input" && (be.type === "checkbox" || be.type === "radio") && (Ze = VS);
          if (Ze && (Ze = Ze(s, te))) {
            Up(De, Ze, p, Se);
            break e;
          }
          ht && ht(s, be, te), s === "focusout" && (ht = be._wrapperState) && ht.controlled && be.type === "number" && Yt(be, "number", be.value);
        }
        switch (ht = te ? Oa(te) : window, s) {
          case "focusin":
            (ny(ht) || ht.contentEditable === "true") && (su = ht, Wp = te, _c = null);
            break;
          case "focusout":
            _c = Wp = su = null;
            break;
          case "mousedown":
            Yp = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Yp = !1, Gp(De, p, Se);
            break;
          case "selectionchange":
            if (BS) break;
          case "keydown":
          case "keyup":
            Gp(De, p, Se);
        }
        var pt;
        if (iu) e: {
          switch (s) {
            case "compositionstart":
              var yt = "onCompositionStart";
              break e;
            case "compositionend":
              yt = "onCompositionEnd";
              break e;
            case "compositionupdate":
              yt = "onCompositionUpdate";
              break e;
          }
          yt = void 0;
        }
        else ru ? Jv(s, p) && (yt = "onCompositionEnd") : s === "keydown" && p.keyCode === 229 && (yt = "onCompositionStart");
        yt && (qv && p.locale !== "ko" && (ru || yt !== "onCompositionStart" ? yt === "onCompositionEnd" && ru && (pt = Ap()) : (ws = Se, nd = "value" in ws ? ws.value : ws.textContent, ru = !0)), ht = Cc(te, yt), 0 < ht.length && (yt = new zp(yt, s, null, p, Se), De.push({ event: yt, listeners: ht }), pt ? yt.data = pt : (pt = ey(p), pt !== null && (yt.data = pt)))), (pt = yc ? ty(s, p) : LS(s, p)) && (te = Cc(te, "onBeforeInput"), 0 < te.length && (Se = new zp("onBeforeInput", "beforeinput", null, p, Se), De.push({ event: Se, listeners: te }), Se.data = pt));
      }
      il(De, l);
    });
  }
  function lu(s, l, p) {
    return { instance: s, listener: l, currentTarget: p };
  }
  function Cc(s, l) {
    for (var p = l + "Capture", y = []; s !== null; ) {
      var _ = s, T = _.stateNode;
      _.tag === 5 && T !== null && (_ = T, T = $e(s, p), T != null && y.unshift(lu(s, T, _)), T = $e(s, l), T != null && y.push(lu(s, T, _))), s = s.return;
    }
    return y;
  }
  function ro(s) {
    if (s === null) return null;
    do
      s = s.return;
    while (s && s.tag !== 5);
    return s || null;
  }
  function gy(s, l, p, y, _) {
    for (var T = l._reactName, O = []; p !== null && p !== y; ) {
      var V = p, U = V.alternate, te = V.stateNode;
      if (U !== null && U === y) break;
      V.tag === 5 && te !== null && (V = te, _ ? (U = $e(p, T), U != null && O.unshift(lu(p, U, V))) : _ || (U = $e(p, T), U != null && O.push(lu(p, U, V)))), p = p.return;
    }
    O.length !== 0 && s.push({ event: l, listeners: O });
  }
  var vy = /\r\n?/g, IS = /\u0000|\uFFFD/g;
  function yy(s) {
    return (typeof s == "string" ? s : "" + s).replace(vy, `
`).replace(IS, "");
  }
  function bd(s, l, p) {
    if (l = yy(l), yy(s) !== l && p) throw Error(i(425));
  }
  function ao() {
  }
  var Tc = null, rl = null;
  function xd(s, l) {
    return s === "textarea" || s === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var Sd = typeof setTimeout == "function" ? setTimeout : void 0, Zp = typeof clearTimeout == "function" ? clearTimeout : void 0, by = typeof Promise == "function" ? Promise : void 0, uu = typeof queueMicrotask == "function" ? queueMicrotask : typeof by < "u" ? function(s) {
    return by.resolve(null).then(s).catch(_d);
  } : Sd;
  function _d(s) {
    setTimeout(function() {
      throw s;
    });
  }
  function cu(s, l) {
    var p = l, y = 0;
    do {
      var _ = p.nextSibling;
      if (s.removeChild(p), _ && _.nodeType === 8) if (p = _.data, p === "/$") {
        if (y === 0) {
          s.removeChild(_), no(l);
          return;
        }
        y--;
      } else p !== "$" && p !== "$?" && p !== "$!" || y++;
      p = _;
    } while (p);
    no(l);
  }
  function Xa(s) {
    for (; s != null; s = s.nextSibling) {
      var l = s.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (l = s.data, l === "$" || l === "$!" || l === "$?") break;
        if (l === "/$") return null;
      }
    }
    return s;
  }
  function xy(s) {
    s = s.previousSibling;
    for (var l = 0; s; ) {
      if (s.nodeType === 8) {
        var p = s.data;
        if (p === "$" || p === "$!" || p === "$?") {
          if (l === 0) return s;
          l--;
        } else p === "/$" && l++;
      }
      s = s.previousSibling;
    }
    return null;
  }
  var so = Math.random().toString(36).slice(2), Qa = "__reactFiber$" + so, Ec = "__reactProps$" + so, Ds = "__reactContainer$" + so, Dc = "__reactEvents$" + so, fu = "__reactListeners$" + so, $S = "__reactHandles$" + so;
  function al(s) {
    var l = s[Qa];
    if (l) return l;
    for (var p = s.parentNode; p; ) {
      if (l = p[Ds] || p[Qa]) {
        if (p = l.alternate, l.child !== null || p !== null && p.child !== null) for (s = xy(s); s !== null; ) {
          if (p = s[Qa]) return p;
          s = xy(s);
        }
        return l;
      }
      s = p, p = s.parentNode;
    }
    return null;
  }
  function st(s) {
    return s = s[Qa] || s[Ds], !s || s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3 ? null : s;
  }
  function Oa(s) {
    if (s.tag === 5 || s.tag === 6) return s.stateNode;
    throw Error(i(33));
  }
  function qn(s) {
    return s[Ec] || null;
  }
  var Bt = [], ra = -1;
  function Pa(s) {
    return { current: s };
  }
  function Cn(s) {
    0 > ra || (s.current = Bt[ra], Bt[ra] = null, ra--);
  }
  function at(s, l) {
    ra++, Bt[ra] = s.current, s.current = l;
  }
  var Sr = {}, Yn = Pa(Sr), xi = Pa(!1), _r = Sr;
  function aa(s, l) {
    var p = s.type.contextTypes;
    if (!p) return Sr;
    var y = s.stateNode;
    if (y && y.__reactInternalMemoizedUnmaskedChildContext === l) return y.__reactInternalMemoizedMaskedChildContext;
    var _ = {}, T;
    for (T in p) _[T] = l[T];
    return y && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = l, s.__reactInternalMemoizedMaskedChildContext = _), _;
  }
  function ui(s) {
    return s = s.childContextTypes, s != null;
  }
  function du() {
    Cn(xi), Cn(Yn);
  }
  function Sy(s, l, p) {
    if (Yn.current !== Sr) throw Error(i(168));
    at(Yn, l), at(xi, p);
  }
  function Rc(s, l, p) {
    var y = s.stateNode;
    if (l = l.childContextTypes, typeof y.getChildContext != "function") return p;
    y = y.getChildContext();
    for (var _ in y) if (!(_ in l)) throw Error(i(108, Te(s) || "Unknown", _));
    return pe({}, p, y);
  }
  function wr(s) {
    return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || Sr, _r = Yn.current, at(Yn, s), at(xi, xi.current), !0;
  }
  function wd(s, l, p) {
    var y = s.stateNode;
    if (!y) throw Error(i(169));
    p ? (s = Rc(s, l, _r), y.__reactInternalMemoizedMergedChildContext = s, Cn(xi), Cn(Yn), at(Yn, s)) : Cn(xi), at(xi, p);
  }
  var qa = null, hu = !1, Rs = !1;
  function Cd(s) {
    qa === null ? qa = [s] : qa.push(s);
  }
  function oo(s) {
    hu = !0, Cd(s);
  }
  function Za() {
    if (!Rs && qa !== null) {
      Rs = !0;
      var s = 0, l = pn;
      try {
        var p = qa;
        for (pn = 1; s < p.length; s++) {
          var y = p[s];
          do
            y = y(!0);
          while (y !== null);
        }
        qa = null, hu = !1;
      } catch (_) {
        throw qa !== null && (qa = qa.slice(s + 1)), Fn(Ss, Za), _;
      } finally {
        pn = l, Rs = !1;
      }
    }
    return null;
  }
  var lo = [], uo = 0, co = null, ks = 0, ci = [], sa = 0, Ur = null, Ja = 1, es = "";
  function sl(s, l) {
    lo[uo++] = ks, lo[uo++] = co, co = s, ks = l;
  }
  function _y(s, l, p) {
    ci[sa++] = Ja, ci[sa++] = es, ci[sa++] = Ur, Ur = s;
    var y = Ja;
    s = es;
    var _ = 32 - ea(y) - 1;
    y &= ~(1 << _), p += 1;
    var T = 32 - ea(l) + _;
    if (30 < T) {
      var O = _ - _ % 5;
      T = (y & (1 << O) - 1).toString(32), y >>= O, _ -= O, Ja = 1 << 32 - ea(l) + _ | p << _ | y, es = T + s;
    } else Ja = 1 << T | p << _ | y, es = s;
  }
  function Td(s) {
    s.return !== null && (sl(s, 1), _y(s, 1, 0));
  }
  function Ed(s) {
    for (; s === co; ) co = lo[--uo], lo[uo] = null, ks = lo[--uo], lo[uo] = null;
    for (; s === Ur; ) Ur = ci[--sa], ci[sa] = null, es = ci[--sa], ci[sa] = null, Ja = ci[--sa], ci[sa] = null;
  }
  var Cr = null, Tr = null, Pn = !1, oa = null;
  function Jp(s, l) {
    var p = da(5, null, null, 0);
    p.elementType = "DELETED", p.stateNode = l, p.return = s, l = s.deletions, l === null ? (s.deletions = [p], s.flags |= 16) : l.push(p);
  }
  function wy(s, l) {
    switch (s.tag) {
      case 5:
        var p = s.type;
        return l = l.nodeType !== 1 || p.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (s.stateNode = l, Cr = s, Tr = Xa(l.firstChild), !0) : !1;
      case 6:
        return l = s.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (s.stateNode = l, Cr = s, Tr = null, !0) : !1;
      case 13:
        return l = l.nodeType !== 8 ? null : l, l !== null ? (p = Ur !== null ? { id: Ja, overflow: es } : null, s.memoizedState = { dehydrated: l, treeContext: p, retryLane: 1073741824 }, p = da(18, null, null, 0), p.stateNode = l, p.return = s, s.child = p, Cr = s, Tr = null, !0) : !1;
      default:
        return !1;
    }
  }
  function em(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0;
  }
  function tm(s) {
    if (Pn) {
      var l = Tr;
      if (l) {
        var p = l;
        if (!wy(s, l)) {
          if (em(s)) throw Error(i(418));
          l = Xa(p.nextSibling);
          var y = Cr;
          l && wy(s, l) ? Jp(y, p) : (s.flags = s.flags & -4097 | 2, Pn = !1, Cr = s);
        }
      } else {
        if (em(s)) throw Error(i(418));
        s.flags = s.flags & -4097 | 2, Pn = !1, Cr = s;
      }
    }
  }
  function Si(s) {
    for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; ) s = s.return;
    Cr = s;
  }
  function Dd(s) {
    if (s !== Cr) return !1;
    if (!Pn) return Si(s), Pn = !0, !1;
    var l;
    if ((l = s.tag !== 3) && !(l = s.tag !== 5) && (l = s.type, l = l !== "head" && l !== "body" && !xd(s.type, s.memoizedProps)), l && (l = Tr)) {
      if (em(s)) throw kc(), Error(i(418));
      for (; l; ) Jp(s, l), l = Xa(l.nextSibling);
    }
    if (Si(s), s.tag === 13) {
      if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(i(317));
      e: {
        for (s = s.nextSibling, l = 0; s; ) {
          if (s.nodeType === 8) {
            var p = s.data;
            if (p === "/$") {
              if (l === 0) {
                Tr = Xa(s.nextSibling);
                break e;
              }
              l--;
            } else p !== "$" && p !== "$!" && p !== "$?" || l++;
          }
          s = s.nextSibling;
        }
        Tr = null;
      }
    } else Tr = Cr ? Xa(s.stateNode.nextSibling) : null;
    return !0;
  }
  function kc() {
    for (var s = Tr; s; ) s = Xa(s.nextSibling);
  }
  function fo() {
    Tr = Cr = null, Pn = !1;
  }
  function Ms(s) {
    oa === null ? oa = [s] : oa.push(s);
  }
  var WS = j.ReactCurrentBatchConfig;
  function ol(s, l, p) {
    if (s = p.ref, s !== null && typeof s != "function" && typeof s != "object") {
      if (p._owner) {
        if (p = p._owner, p) {
          if (p.tag !== 1) throw Error(i(309));
          var y = p.stateNode;
        }
        if (!y) throw Error(i(147, s));
        var _ = y, T = "" + s;
        return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === T ? l.ref : (l = function(O) {
          var V = _.refs;
          O === null ? delete V[T] : V[T] = O;
        }, l._stringRef = T, l);
      }
      if (typeof s != "string") throw Error(i(284));
      if (!p._owner) throw Error(i(290, s));
    }
    return s;
  }
  function Rd(s, l) {
    throw s = Object.prototype.toString.call(l), Error(i(31, s === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : s));
  }
  function Cy(s) {
    var l = s._init;
    return l(s._payload);
  }
  function ll(s) {
    function l(X, Y) {
      if (s) {
        var Z = X.deletions;
        Z === null ? (X.deletions = [Y], X.flags |= 16) : Z.push(Y);
      }
    }
    function p(X, Y) {
      if (!s) return null;
      for (; Y !== null; ) l(X, Y), Y = Y.sibling;
      return null;
    }
    function y(X, Y) {
      for (X = /* @__PURE__ */ new Map(); Y !== null; ) Y.key !== null ? X.set(Y.key, Y) : X.set(Y.index, Y), Y = Y.sibling;
      return X;
    }
    function _(X, Y) {
      return X = xo(X, Y), X.index = 0, X.sibling = null, X;
    }
    function T(X, Y, Z) {
      return X.index = Z, s ? (Z = X.alternate, Z !== null ? (Z = Z.index, Z < Y ? (X.flags |= 2, Y) : Z) : (X.flags |= 2, Y)) : (X.flags |= 1048576, Y);
    }
    function O(X) {
      return s && X.alternate === null && (X.flags |= 2), X;
    }
    function V(X, Y, Z, _e) {
      return Y === null || Y.tag !== 6 ? (Y = Om(Z, X.mode, _e), Y.return = X, Y) : (Y = _(Y, Z), Y.return = X, Y);
    }
    function U(X, Y, Z, _e) {
      var Ze = Z.type;
      return Ze === I ? Se(X, Y, Z.props.children, _e, Z.key) : Y !== null && (Y.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === we && Cy(Ze) === Y.type) ? (_e = _(Y, Z.props), _e.ref = ol(X, Y, Z), _e.return = X, _e) : (_e = sf(Z.type, Z.key, Z.props, null, X.mode, _e), _e.ref = ol(X, Y, Z), _e.return = X, _e);
    }
    function te(X, Y, Z, _e) {
      return Y === null || Y.tag !== 4 || Y.stateNode.containerInfo !== Z.containerInfo || Y.stateNode.implementation !== Z.implementation ? (Y = oh(Z, X.mode, _e), Y.return = X, Y) : (Y = _(Y, Z.children || []), Y.return = X, Y);
    }
    function Se(X, Y, Z, _e, Ze) {
      return Y === null || Y.tag !== 7 ? (Y = zs(Z, X.mode, _e, Ze), Y.return = X, Y) : (Y = _(Y, Z), Y.return = X, Y);
    }
    function De(X, Y, Z) {
      if (typeof Y == "string" && Y !== "" || typeof Y == "number") return Y = Om("" + Y, X.mode, Z), Y.return = X, Y;
      if (typeof Y == "object" && Y !== null) {
        switch (Y.$$typeof) {
          case F:
            return Z = sf(Y.type, Y.key, Y.props, null, X.mode, Z), Z.ref = ol(X, null, Y), Z.return = X, Z;
          case $:
            return Y = oh(Y, X.mode, Z), Y.return = X, Y;
          case we:
            var _e = Y._init;
            return De(X, _e(Y._payload), Z);
        }
        if (Gt(Y) || me(Y)) return Y = zs(Y, X.mode, Z, null), Y.return = X, Y;
        Rd(X, Y);
      }
      return null;
    }
    function be(X, Y, Z, _e) {
      var Ze = Y !== null ? Y.key : null;
      if (typeof Z == "string" && Z !== "" || typeof Z == "number") return Ze !== null ? null : V(X, Y, "" + Z, _e);
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case F:
            return Z.key === Ze ? U(X, Y, Z, _e) : null;
          case $:
            return Z.key === Ze ? te(X, Y, Z, _e) : null;
          case we:
            return Ze = Z._init, be(
              X,
              Y,
              Ze(Z._payload),
              _e
            );
        }
        if (Gt(Z) || me(Z)) return Ze !== null ? null : Se(X, Y, Z, _e, null);
        Rd(X, Z);
      }
      return null;
    }
    function Ye(X, Y, Z, _e, Ze) {
      if (typeof _e == "string" && _e !== "" || typeof _e == "number") return X = X.get(Z) || null, V(Y, X, "" + _e, Ze);
      if (typeof _e == "object" && _e !== null) {
        switch (_e.$$typeof) {
          case F:
            return X = X.get(_e.key === null ? Z : _e.key) || null, U(Y, X, _e, Ze);
          case $:
            return X = X.get(_e.key === null ? Z : _e.key) || null, te(Y, X, _e, Ze);
          case we:
            var ht = _e._init;
            return Ye(X, Y, Z, ht(_e._payload), Ze);
        }
        if (Gt(_e) || me(_e)) return X = X.get(Z) || null, Se(Y, X, _e, Ze, null);
        Rd(Y, _e);
      }
      return null;
    }
    function qe(X, Y, Z, _e) {
      for (var Ze = null, ht = null, pt = Y, yt = Y = 0, Mi = null; pt !== null && yt < Z.length; yt++) {
        pt.index > yt ? (Mi = pt, pt = null) : Mi = pt.sibling;
        var tn = be(X, pt, Z[yt], _e);
        if (tn === null) {
          pt === null && (pt = Mi);
          break;
        }
        s && pt && tn.alternate === null && l(X, pt), Y = T(tn, Y, yt), ht === null ? Ze = tn : ht.sibling = tn, ht = tn, pt = Mi;
      }
      if (yt === Z.length) return p(X, pt), Pn && sl(X, yt), Ze;
      if (pt === null) {
        for (; yt < Z.length; yt++) pt = De(X, Z[yt], _e), pt !== null && (Y = T(pt, Y, yt), ht === null ? Ze = pt : ht.sibling = pt, ht = pt);
        return Pn && sl(X, yt), Ze;
      }
      for (pt = y(X, pt); yt < Z.length; yt++) Mi = Ye(pt, X, yt, Z[yt], _e), Mi !== null && (s && Mi.alternate !== null && pt.delete(Mi.key === null ? yt : Mi.key), Y = T(Mi, Y, yt), ht === null ? Ze = Mi : ht.sibling = Mi, ht = Mi);
      return s && pt.forEach(function(wo) {
        return l(X, wo);
      }), Pn && sl(X, yt), Ze;
    }
    function et(X, Y, Z, _e) {
      var Ze = me(Z);
      if (typeof Ze != "function") throw Error(i(150));
      if (Z = Ze.call(Z), Z == null) throw Error(i(151));
      for (var ht = Ze = null, pt = Y, yt = Y = 0, Mi = null, tn = Z.next(); pt !== null && !tn.done; yt++, tn = Z.next()) {
        pt.index > yt ? (Mi = pt, pt = null) : Mi = pt.sibling;
        var wo = be(X, pt, tn.value, _e);
        if (wo === null) {
          pt === null && (pt = Mi);
          break;
        }
        s && pt && wo.alternate === null && l(X, pt), Y = T(wo, Y, yt), ht === null ? Ze = wo : ht.sibling = wo, ht = wo, pt = Mi;
      }
      if (tn.done) return p(
        X,
        pt
      ), Pn && sl(X, yt), Ze;
      if (pt === null) {
        for (; !tn.done; yt++, tn = Z.next()) tn = De(X, tn.value, _e), tn !== null && (Y = T(tn, Y, yt), ht === null ? Ze = tn : ht.sibling = tn, ht = tn);
        return Pn && sl(X, yt), Ze;
      }
      for (pt = y(X, pt); !tn.done; yt++, tn = Z.next()) tn = Ye(pt, X, yt, tn.value, _e), tn !== null && (s && tn.alternate !== null && pt.delete(tn.key === null ? yt : tn.key), Y = T(tn, Y, yt), ht === null ? Ze = tn : ht.sibling = tn, ht = tn);
      return s && pt.forEach(function(s0) {
        return l(X, s0);
      }), Pn && sl(X, yt), Ze;
    }
    function ni(X, Y, Z, _e) {
      if (typeof Z == "object" && Z !== null && Z.type === I && Z.key === null && (Z = Z.props.children), typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case F:
            e: {
              for (var Ze = Z.key, ht = Y; ht !== null; ) {
                if (ht.key === Ze) {
                  if (Ze = Z.type, Ze === I) {
                    if (ht.tag === 7) {
                      p(X, ht.sibling), Y = _(ht, Z.props.children), Y.return = X, X = Y;
                      break e;
                    }
                  } else if (ht.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === we && Cy(Ze) === ht.type) {
                    p(X, ht.sibling), Y = _(ht, Z.props), Y.ref = ol(X, ht, Z), Y.return = X, X = Y;
                    break e;
                  }
                  p(X, ht);
                  break;
                } else l(X, ht);
                ht = ht.sibling;
              }
              Z.type === I ? (Y = zs(Z.props.children, X.mode, _e, Z.key), Y.return = X, X = Y) : (_e = sf(Z.type, Z.key, Z.props, null, X.mode, _e), _e.ref = ol(X, Y, Z), _e.return = X, X = _e);
            }
            return O(X);
          case $:
            e: {
              for (ht = Z.key; Y !== null; ) {
                if (Y.key === ht) if (Y.tag === 4 && Y.stateNode.containerInfo === Z.containerInfo && Y.stateNode.implementation === Z.implementation) {
                  p(X, Y.sibling), Y = _(Y, Z.children || []), Y.return = X, X = Y;
                  break e;
                } else {
                  p(X, Y);
                  break;
                }
                else l(X, Y);
                Y = Y.sibling;
              }
              Y = oh(Z, X.mode, _e), Y.return = X, X = Y;
            }
            return O(X);
          case we:
            return ht = Z._init, ni(X, Y, ht(Z._payload), _e);
        }
        if (Gt(Z)) return qe(X, Y, Z, _e);
        if (me(Z)) return et(X, Y, Z, _e);
        Rd(X, Z);
      }
      return typeof Z == "string" && Z !== "" || typeof Z == "number" ? (Z = "" + Z, Y !== null && Y.tag === 6 ? (p(X, Y.sibling), Y = _(Y, Z), Y.return = X, X = Y) : (p(X, Y), Y = Om(Z, X.mode, _e), Y.return = X, X = Y), O(X)) : p(X, Y);
    }
    return ni;
  }
  var Zn = ll(!0), Ue = ll(!1), Ir = Pa(null), Er = null, pu = null, nm = null;
  function im() {
    nm = pu = Er = null;
  }
  function rm(s) {
    var l = Ir.current;
    Cn(Ir), s._currentValue = l;
  }
  function am(s, l, p) {
    for (; s !== null; ) {
      var y = s.alternate;
      if ((s.childLanes & l) !== l ? (s.childLanes |= l, y !== null && (y.childLanes |= l)) : y !== null && (y.childLanes & l) !== l && (y.childLanes |= l), s === p) break;
      s = s.return;
    }
  }
  function Vn(s, l) {
    Er = s, nm = pu = null, s = s.dependencies, s !== null && s.firstContext !== null && (s.lanes & l && (di = !0), s.firstContext = null);
  }
  function la(s) {
    var l = s._currentValue;
    if (nm !== s) if (s = { context: s, memoizedValue: l, next: null }, pu === null) {
      if (Er === null) throw Error(i(308));
      pu = s, Er.dependencies = { lanes: 0, firstContext: s };
    } else pu = pu.next = s;
    return l;
  }
  var ul = null;
  function sm(s) {
    ul === null ? ul = [s] : ul.push(s);
  }
  function om(s, l, p, y) {
    var _ = l.interleaved;
    return _ === null ? (p.next = p, sm(l)) : (p.next = _.next, _.next = p), l.interleaved = p, $r(s, y);
  }
  function $r(s, l) {
    s.lanes |= l;
    var p = s.alternate;
    for (p !== null && (p.lanes |= l), p = s, s = s.return; s !== null; ) s.childLanes |= l, p = s.alternate, p !== null && (p.childLanes |= l), p = s, s = s.return;
    return p.tag === 3 ? p.stateNode : null;
  }
  var Wr = !1;
  function lm(s) {
    s.updateQueue = { baseState: s.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Ty(s, l) {
    s = s.updateQueue, l.updateQueue === s && (l.updateQueue = { baseState: s.baseState, firstBaseUpdate: s.firstBaseUpdate, lastBaseUpdate: s.lastBaseUpdate, shared: s.shared, effects: s.effects });
  }
  function As(s, l) {
    return { eventTime: s, lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function ho(s, l, p) {
    var y = s.updateQueue;
    if (y === null) return null;
    if (y = y.shared, Ht & 2) {
      var _ = y.pending;
      return _ === null ? l.next = l : (l.next = _.next, _.next = l), y.pending = l, $r(s, p);
    }
    return _ = y.interleaved, _ === null ? (l.next = l, sm(y)) : (l.next = _.next, _.next = l), y.interleaved = l, $r(s, p);
  }
  function kd(s, l, p) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (p & 4194240) !== 0)) {
      var y = l.lanes;
      y &= s.pendingLanes, p |= y, l.lanes = p, Zf(s, p);
    }
  }
  function Ey(s, l) {
    var p = s.updateQueue, y = s.alternate;
    if (y !== null && (y = y.updateQueue, p === y)) {
      var _ = null, T = null;
      if (p = p.firstBaseUpdate, p !== null) {
        do {
          var O = { eventTime: p.eventTime, lane: p.lane, tag: p.tag, payload: p.payload, callback: p.callback, next: null };
          T === null ? _ = T = O : T = T.next = O, p = p.next;
        } while (p !== null);
        T === null ? _ = T = l : T = T.next = l;
      } else _ = T = l;
      p = { baseState: y.baseState, firstBaseUpdate: _, lastBaseUpdate: T, shared: y.shared, effects: y.effects }, s.updateQueue = p;
      return;
    }
    s = p.lastBaseUpdate, s === null ? p.firstBaseUpdate = l : s.next = l, p.lastBaseUpdate = l;
  }
  function Mc(s, l, p, y) {
    var _ = s.updateQueue;
    Wr = !1;
    var T = _.firstBaseUpdate, O = _.lastBaseUpdate, V = _.shared.pending;
    if (V !== null) {
      _.shared.pending = null;
      var U = V, te = U.next;
      U.next = null, O === null ? T = te : O.next = te, O = U;
      var Se = s.alternate;
      Se !== null && (Se = Se.updateQueue, V = Se.lastBaseUpdate, V !== O && (V === null ? Se.firstBaseUpdate = te : V.next = te, Se.lastBaseUpdate = U));
    }
    if (T !== null) {
      var De = _.baseState;
      O = 0, Se = te = U = null, V = T;
      do {
        var be = V.lane, Ye = V.eventTime;
        if ((y & be) === be) {
          Se !== null && (Se = Se.next = {
            eventTime: Ye,
            lane: 0,
            tag: V.tag,
            payload: V.payload,
            callback: V.callback,
            next: null
          });
          e: {
            var qe = s, et = V;
            switch (be = l, Ye = p, et.tag) {
              case 1:
                if (qe = et.payload, typeof qe == "function") {
                  De = qe.call(Ye, De, be);
                  break e;
                }
                De = qe;
                break e;
              case 3:
                qe.flags = qe.flags & -65537 | 128;
              case 0:
                if (qe = et.payload, be = typeof qe == "function" ? qe.call(Ye, De, be) : qe, be == null) break e;
                De = pe({}, De, be);
                break e;
              case 2:
                Wr = !0;
            }
          }
          V.callback !== null && V.lane !== 0 && (s.flags |= 64, be = _.effects, be === null ? _.effects = [V] : be.push(V));
        } else Ye = { eventTime: Ye, lane: be, tag: V.tag, payload: V.payload, callback: V.callback, next: null }, Se === null ? (te = Se = Ye, U = De) : Se = Se.next = Ye, O |= be;
        if (V = V.next, V === null) {
          if (V = _.shared.pending, V === null) break;
          be = V, V = be.next, be.next = null, _.lastBaseUpdate = be, _.shared.pending = null;
        }
      } while (!0);
      if (Se === null && (U = De), _.baseState = U, _.firstBaseUpdate = te, _.lastBaseUpdate = Se, l = _.shared.interleaved, l !== null) {
        _ = l;
        do
          O |= _.lane, _ = _.next;
        while (_ !== l);
      } else T === null && (_.shared.lanes = 0);
      as |= O, s.lanes = O, s.memoizedState = De;
    }
  }
  function um(s, l, p) {
    if (s = l.effects, l.effects = null, s !== null) for (l = 0; l < s.length; l++) {
      var y = s[l], _ = y.callback;
      if (_ !== null) {
        if (y.callback = null, y = p, typeof _ != "function") throw Error(i(191, _));
        _.call(y);
      }
    }
  }
  var Ac = {}, ts = Pa(Ac), Oc = Pa(Ac), Pc = Pa(Ac);
  function cl(s) {
    if (s === Ac) throw Error(i(174));
    return s;
  }
  function cm(s, l) {
    switch (at(Pc, l), at(Oc, s), at(ts, Ac), s = l.nodeType, s) {
      case 9:
      case 11:
        l = (l = l.documentElement) ? l.namespaceURI : Pi(null, "");
        break;
      default:
        s = s === 8 ? l.parentNode : l, l = s.namespaceURI || null, s = s.tagName, l = Pi(l, s);
    }
    Cn(ts), at(ts, l);
  }
  function fl() {
    Cn(ts), Cn(Oc), Cn(Pc);
  }
  function Dy(s) {
    cl(Pc.current);
    var l = cl(ts.current), p = Pi(l, s.type);
    l !== p && (at(Oc, s), at(ts, p));
  }
  function Md(s) {
    Oc.current === s && (Cn(ts), Cn(Oc));
  }
  var jn = Pa(0);
  function Ad(s) {
    for (var l = s; l !== null; ) {
      if (l.tag === 13) {
        var p = l.memoizedState;
        if (p !== null && (p = p.dehydrated, p === null || p.data === "$?" || p.data === "$!")) return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if (l.flags & 128) return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === s) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === s) return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  var Lc = [];
  function ot() {
    for (var s = 0; s < Lc.length; s++) Lc[s]._workInProgressVersionPrimary = null;
    Lc.length = 0;
  }
  var Nt = j.ReactCurrentDispatcher, Jt = j.ReactCurrentBatchConfig, vn = 0, en = null, fi = null, Ri = null, Od = !1, Nc = !1, dl = 0, ye = 0;
  function Zt() {
    throw Error(i(321));
  }
  function gt(s, l) {
    if (l === null) return !1;
    for (var p = 0; p < l.length && p < s.length; p++) if (!Aa(s[p], l[p])) return !1;
    return !0;
  }
  function po(s, l, p, y, _, T) {
    if (vn = T, en = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, Nt.current = s === null || s.memoizedState === null ? Gd : Hc, s = p(y, _), Nc) {
      T = 0;
      do {
        if (Nc = !1, dl = 0, 25 <= T) throw Error(i(301));
        T += 1, Ri = fi = null, l.updateQueue = null, Nt.current = Kd, s = p(y, _);
      } while (Nc);
    }
    if (Nt.current = vl, l = fi !== null && fi.next !== null, vn = 0, Ri = fi = en = null, Od = !1, l) throw Error(i(300));
    return s;
  }
  function La() {
    var s = dl !== 0;
    return dl = 0, s;
  }
  function Qi() {
    var s = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Ri === null ? en.memoizedState = Ri = s : Ri = Ri.next = s, Ri;
  }
  function Jn() {
    if (fi === null) {
      var s = en.alternate;
      s = s !== null ? s.memoizedState : null;
    } else s = fi.next;
    var l = Ri === null ? en.memoizedState : Ri.next;
    if (l !== null) Ri = l, fi = s;
    else {
      if (s === null) throw Error(i(310));
      fi = s, s = { memoizedState: fi.memoizedState, baseState: fi.baseState, baseQueue: fi.baseQueue, queue: fi.queue, next: null }, Ri === null ? en.memoizedState = Ri = s : Ri = Ri.next = s;
    }
    return Ri;
  }
  function Os(s, l) {
    return typeof l == "function" ? l(s) : l;
  }
  function mo(s) {
    var l = Jn(), p = l.queue;
    if (p === null) throw Error(i(311));
    p.lastRenderedReducer = s;
    var y = fi, _ = y.baseQueue, T = p.pending;
    if (T !== null) {
      if (_ !== null) {
        var O = _.next;
        _.next = T.next, T.next = O;
      }
      y.baseQueue = _ = T, p.pending = null;
    }
    if (_ !== null) {
      T = _.next, y = y.baseState;
      var V = O = null, U = null, te = T;
      do {
        var Se = te.lane;
        if ((vn & Se) === Se) U !== null && (U = U.next = { lane: 0, action: te.action, hasEagerState: te.hasEagerState, eagerState: te.eagerState, next: null }), y = te.hasEagerState ? te.eagerState : s(y, te.action);
        else {
          var De = {
            lane: Se,
            action: te.action,
            hasEagerState: te.hasEagerState,
            eagerState: te.eagerState,
            next: null
          };
          U === null ? (V = U = De, O = y) : U = U.next = De, en.lanes |= Se, as |= Se;
        }
        te = te.next;
      } while (te !== null && te !== T);
      U === null ? O = y : U.next = V, Aa(y, l.memoizedState) || (di = !0), l.memoizedState = y, l.baseState = O, l.baseQueue = U, p.lastRenderedState = y;
    }
    if (s = p.interleaved, s !== null) {
      _ = s;
      do
        T = _.lane, en.lanes |= T, as |= T, _ = _.next;
      while (_ !== s);
    } else _ === null && (p.lanes = 0);
    return [l.memoizedState, p.dispatch];
  }
  function hl(s) {
    var l = Jn(), p = l.queue;
    if (p === null) throw Error(i(311));
    p.lastRenderedReducer = s;
    var y = p.dispatch, _ = p.pending, T = l.memoizedState;
    if (_ !== null) {
      p.pending = null;
      var O = _ = _.next;
      do
        T = s(T, O.action), O = O.next;
      while (O !== _);
      Aa(T, l.memoizedState) || (di = !0), l.memoizedState = T, l.baseQueue === null && (l.baseState = T), p.lastRenderedState = T;
    }
    return [T, y];
  }
  function Pd() {
  }
  function Ld(s, l) {
    var p = en, y = Jn(), _ = l(), T = !Aa(y.memoizedState, _);
    if (T && (y.memoizedState = _, di = !0), y = y.queue, zc(Fd.bind(null, p, y, s), [s]), y.getSnapshot !== l || T || Ri !== null && Ri.memoizedState.tag & 1) {
      if (p.flags |= 2048, pl(9, zd.bind(null, p, y, _, l), void 0, null), _i === null) throw Error(i(349));
      vn & 30 || Nd(p, l, _);
    }
    return _;
  }
  function Nd(s, l, p) {
    s.flags |= 16384, s = { getSnapshot: l, value: p }, l = en.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, en.updateQueue = l, l.stores = [s]) : (p = l.stores, p === null ? l.stores = [s] : p.push(s));
  }
  function zd(s, l, p, y) {
    l.value = p, l.getSnapshot = y, Vd(l) && jd(s);
  }
  function Fd(s, l, p) {
    return p(function() {
      Vd(l) && jd(s);
    });
  }
  function Vd(s) {
    var l = s.getSnapshot;
    s = s.value;
    try {
      var p = l();
      return !Aa(s, p);
    } catch {
      return !0;
    }
  }
  function jd(s) {
    var l = $r(s, 1);
    l !== null && sr(l, s, 1, -1);
  }
  function Bd(s) {
    var l = Qi();
    return typeof s == "function" && (s = s()), l.memoizedState = l.baseState = s, s = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Os, lastRenderedState: s }, l.queue = s, s = s.dispatch = gl.bind(null, en, s), [l.memoizedState, s];
  }
  function pl(s, l, p, y) {
    return s = { tag: s, create: l, destroy: p, deps: y, next: null }, l = en.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, en.updateQueue = l, l.lastEffect = s.next = s) : (p = l.lastEffect, p === null ? l.lastEffect = s.next = s : (y = p.next, p.next = s, s.next = y, l.lastEffect = s)), s;
  }
  function Hd() {
    return Jn().memoizedState;
  }
  function mu(s, l, p, y) {
    var _ = Qi();
    en.flags |= s, _.memoizedState = pl(1 | l, p, void 0, y === void 0 ? null : y);
  }
  function gu(s, l, p, y) {
    var _ = Jn();
    y = y === void 0 ? null : y;
    var T = void 0;
    if (fi !== null) {
      var O = fi.memoizedState;
      if (T = O.destroy, y !== null && gt(y, O.deps)) {
        _.memoizedState = pl(l, p, T, y);
        return;
      }
    }
    en.flags |= s, _.memoizedState = pl(1 | l, p, T, y);
  }
  function Ud(s, l) {
    return mu(8390656, 8, s, l);
  }
  function zc(s, l) {
    return gu(2048, 8, s, l);
  }
  function Id(s, l) {
    return gu(4, 2, s, l);
  }
  function Fc(s, l) {
    return gu(4, 4, s, l);
  }
  function ml(s, l) {
    if (typeof l == "function") return s = s(), l(s), function() {
      l(null);
    };
    if (l != null) return s = s(), l.current = s, function() {
      l.current = null;
    };
  }
  function $d(s, l, p) {
    return p = p != null ? p.concat([s]) : null, gu(4, 4, ml.bind(null, l, s), p);
  }
  function Vc() {
  }
  function Wd(s, l) {
    var p = Jn();
    l = l === void 0 ? null : l;
    var y = p.memoizedState;
    return y !== null && l !== null && gt(l, y[1]) ? y[0] : (p.memoizedState = [s, l], s);
  }
  function Yd(s, l) {
    var p = Jn();
    l = l === void 0 ? null : l;
    var y = p.memoizedState;
    return y !== null && l !== null && gt(l, y[1]) ? y[0] : (s = s(), p.memoizedState = [s, l], s);
  }
  function fm(s, l, p) {
    return vn & 21 ? (Aa(p, l) || (p = qf(), en.lanes |= p, as |= p, s.baseState = !0), l) : (s.baseState && (s.baseState = !1, di = !0), s.memoizedState = p);
  }
  function jc(s, l) {
    var p = pn;
    pn = p !== 0 && 4 > p ? p : 4, s(!0);
    var y = Jt.transition;
    Jt.transition = {};
    try {
      s(!1), l();
    } finally {
      pn = p, Jt.transition = y;
    }
  }
  function dm() {
    return Jn().memoizedState;
  }
  function Bc(s, l, p) {
    var y = ss(s);
    if (p = { lane: y, action: p, hasEagerState: !1, eagerState: null, next: null }, Yr(s)) Ry(l, p);
    else if (p = om(s, l, p, y), p !== null) {
      var _ = mi();
      sr(p, s, y, _), Sn(p, l, y);
    }
  }
  function gl(s, l, p) {
    var y = ss(s), _ = { lane: y, action: p, hasEagerState: !1, eagerState: null, next: null };
    if (Yr(s)) Ry(l, _);
    else {
      var T = s.alternate;
      if (s.lanes === 0 && (T === null || T.lanes === 0) && (T = l.lastRenderedReducer, T !== null)) try {
        var O = l.lastRenderedState, V = T(O, p);
        if (_.hasEagerState = !0, _.eagerState = V, Aa(V, O)) {
          var U = l.interleaved;
          U === null ? (_.next = _, sm(l)) : (_.next = U.next, U.next = _), l.interleaved = _;
          return;
        }
      } catch {
      } finally {
      }
      p = om(s, l, _, y), p !== null && (_ = mi(), sr(p, s, y, _), Sn(p, l, y));
    }
  }
  function Yr(s) {
    var l = s.alternate;
    return s === en || l !== null && l === en;
  }
  function Ry(s, l) {
    Nc = Od = !0;
    var p = s.pending;
    p === null ? l.next = l : (l.next = p.next, p.next = l), s.pending = l;
  }
  function Sn(s, l, p) {
    if (p & 4194240) {
      var y = l.lanes;
      y &= s.pendingLanes, p |= y, l.lanes = p, Zf(s, p);
    }
  }
  var vl = { readContext: la, useCallback: Zt, useContext: Zt, useEffect: Zt, useImperativeHandle: Zt, useInsertionEffect: Zt, useLayoutEffect: Zt, useMemo: Zt, useReducer: Zt, useRef: Zt, useState: Zt, useDebugValue: Zt, useDeferredValue: Zt, useTransition: Zt, useMutableSource: Zt, useSyncExternalStore: Zt, useId: Zt, unstable_isNewReconciler: !1 }, Gd = { readContext: la, useCallback: function(s, l) {
    return Qi().memoizedState = [s, l === void 0 ? null : l], s;
  }, useContext: la, useEffect: Ud, useImperativeHandle: function(s, l, p) {
    return p = p != null ? p.concat([s]) : null, mu(
      4194308,
      4,
      ml.bind(null, l, s),
      p
    );
  }, useLayoutEffect: function(s, l) {
    return mu(4194308, 4, s, l);
  }, useInsertionEffect: function(s, l) {
    return mu(4, 2, s, l);
  }, useMemo: function(s, l) {
    var p = Qi();
    return l = l === void 0 ? null : l, s = s(), p.memoizedState = [s, l], s;
  }, useReducer: function(s, l, p) {
    var y = Qi();
    return l = p !== void 0 ? p(l) : l, y.memoizedState = y.baseState = l, s = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: s, lastRenderedState: l }, y.queue = s, s = s.dispatch = Bc.bind(null, en, s), [y.memoizedState, s];
  }, useRef: function(s) {
    var l = Qi();
    return s = { current: s }, l.memoizedState = s;
  }, useState: Bd, useDebugValue: Vc, useDeferredValue: function(s) {
    return Qi().memoizedState = s;
  }, useTransition: function() {
    var s = Bd(!1), l = s[0];
    return s = jc.bind(null, s[1]), Qi().memoizedState = s, [l, s];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(s, l, p) {
    var y = en, _ = Qi();
    if (Pn) {
      if (p === void 0) throw Error(i(407));
      p = p();
    } else {
      if (p = l(), _i === null) throw Error(i(349));
      vn & 30 || Nd(y, l, p);
    }
    _.memoizedState = p;
    var T = { value: p, getSnapshot: l };
    return _.queue = T, Ud(Fd.bind(
      null,
      y,
      T,
      s
    ), [s]), y.flags |= 2048, pl(9, zd.bind(null, y, T, p, l), void 0, null), p;
  }, useId: function() {
    var s = Qi(), l = _i.identifierPrefix;
    if (Pn) {
      var p = es, y = Ja;
      p = (y & ~(1 << 32 - ea(y) - 1)).toString(32) + p, l = ":" + l + "R" + p, p = dl++, 0 < p && (l += "H" + p.toString(32)), l += ":";
    } else p = ye++, l = ":" + l + "r" + p.toString(32) + ":";
    return s.memoizedState = l;
  }, unstable_isNewReconciler: !1 }, Hc = {
    readContext: la,
    useCallback: Wd,
    useContext: la,
    useEffect: zc,
    useImperativeHandle: $d,
    useInsertionEffect: Id,
    useLayoutEffect: Fc,
    useMemo: Yd,
    useReducer: mo,
    useRef: Hd,
    useState: function() {
      return mo(Os);
    },
    useDebugValue: Vc,
    useDeferredValue: function(s) {
      var l = Jn();
      return fm(l, fi.memoizedState, s);
    },
    useTransition: function() {
      var s = mo(Os)[0], l = Jn().memoizedState;
      return [s, l];
    },
    useMutableSource: Pd,
    useSyncExternalStore: Ld,
    useId: dm,
    unstable_isNewReconciler: !1
  }, Kd = { readContext: la, useCallback: Wd, useContext: la, useEffect: zc, useImperativeHandle: $d, useInsertionEffect: Id, useLayoutEffect: Fc, useMemo: Yd, useReducer: hl, useRef: Hd, useState: function() {
    return hl(Os);
  }, useDebugValue: Vc, useDeferredValue: function(s) {
    var l = Jn();
    return fi === null ? l.memoizedState = s : fm(l, fi.memoizedState, s);
  }, useTransition: function() {
    var s = hl(Os)[0], l = Jn().memoizedState;
    return [s, l];
  }, useMutableSource: Pd, useSyncExternalStore: Ld, useId: dm, unstable_isNewReconciler: !1 };
  function Na(s, l) {
    if (s && s.defaultProps) {
      l = pe({}, l), s = s.defaultProps;
      for (var p in s) l[p] === void 0 && (l[p] = s[p]);
      return l;
    }
    return l;
  }
  function hm(s, l, p, y) {
    l = s.memoizedState, p = p(y, l), p = p == null ? l : pe({}, l, p), s.memoizedState = p, s.lanes === 0 && (s.updateQueue.baseState = p);
  }
  var Xd = { isMounted: function(s) {
    return (s = s._reactInternals) ? ct(s) === s : !1;
  }, enqueueSetState: function(s, l, p) {
    s = s._reactInternals;
    var y = mi(), _ = ss(s), T = As(y, _);
    T.payload = l, p != null && (T.callback = p), l = ho(s, T, _), l !== null && (sr(l, s, _, y), kd(l, s, _));
  }, enqueueReplaceState: function(s, l, p) {
    s = s._reactInternals;
    var y = mi(), _ = ss(s), T = As(y, _);
    T.tag = 1, T.payload = l, p != null && (T.callback = p), l = ho(s, T, _), l !== null && (sr(l, s, _, y), kd(l, s, _));
  }, enqueueForceUpdate: function(s, l) {
    s = s._reactInternals;
    var p = mi(), y = ss(s), _ = As(p, y);
    _.tag = 2, l != null && (_.callback = l), l = ho(s, _, y), l !== null && (sr(l, s, y, p), kd(l, s, y));
  } };
  function ky(s, l, p, y, _, T, O) {
    return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(y, T, O) : l.prototype && l.prototype.isPureReactComponent ? !xc(p, y) || !xc(_, T) : !0;
  }
  function Qd(s, l, p) {
    var y = !1, _ = Sr, T = l.contextType;
    return typeof T == "object" && T !== null ? T = la(T) : (_ = ui(l) ? _r : Yn.current, y = l.contextTypes, T = (y = y != null) ? aa(s, _) : Sr), l = new l(p, T), s.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = Xd, s.stateNode = l, l._reactInternals = s, y && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = _, s.__reactInternalMemoizedMaskedChildContext = T), l;
  }
  function My(s, l, p, y) {
    s = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(p, y), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(p, y), l.state !== s && Xd.enqueueReplaceState(l, l.state, null);
  }
  function Uc(s, l, p, y) {
    var _ = s.stateNode;
    _.props = p, _.state = s.memoizedState, _.refs = {}, lm(s);
    var T = l.contextType;
    typeof T == "object" && T !== null ? _.context = la(T) : (T = ui(l) ? _r : Yn.current, _.context = aa(s, T)), _.state = s.memoizedState, T = l.getDerivedStateFromProps, typeof T == "function" && (hm(s, l, T, p), _.state = s.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof _.getSnapshotBeforeUpdate == "function" || typeof _.UNSAFE_componentWillMount != "function" && typeof _.componentWillMount != "function" || (l = _.state, typeof _.componentWillMount == "function" && _.componentWillMount(), typeof _.UNSAFE_componentWillMount == "function" && _.UNSAFE_componentWillMount(), l !== _.state && Xd.enqueueReplaceState(_, _.state, null), Mc(s, p, _, y), _.state = s.memoizedState), typeof _.componentDidMount == "function" && (s.flags |= 4194308);
  }
  function yl(s, l) {
    try {
      var p = "", y = l;
      do
        p += fe(y), y = y.return;
      while (y);
      var _ = p;
    } catch (T) {
      _ = `
Error generating stack: ` + T.message + `
` + T.stack;
    }
    return { value: s, source: l, stack: _, digest: null };
  }
  function pm(s, l, p) {
    return { value: s, source: null, stack: p ?? null, digest: l ?? null };
  }
  function mm(s, l) {
    try {
      console.error(l.value);
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  var qd = typeof WeakMap == "function" ? WeakMap : Map;
  function Ay(s, l, p) {
    p = As(-1, p), p.tag = 3, p.payload = { element: null };
    var y = l.value;
    return p.callback = function() {
      _u || (_u = !0, Sl = y), mm(s, l);
    }, p;
  }
  function gm(s, l, p) {
    p = As(-1, p), p.tag = 3;
    var y = s.type.getDerivedStateFromError;
    if (typeof y == "function") {
      var _ = l.value;
      p.payload = function() {
        return y(_);
      }, p.callback = function() {
        mm(s, l);
      };
    }
    var T = s.stateNode;
    return T !== null && typeof T.componentDidCatch == "function" && (p.callback = function() {
      mm(s, l), typeof y != "function" && (yo === null ? yo = /* @__PURE__ */ new Set([this]) : yo.add(this));
      var O = l.stack;
      this.componentDidCatch(l.value, { componentStack: O !== null ? O : "" });
    }), p;
  }
  function vm(s, l, p) {
    var y = s.pingCache;
    if (y === null) {
      y = s.pingCache = new qd();
      var _ = /* @__PURE__ */ new Set();
      y.set(l, _);
    } else _ = y.get(l), _ === void 0 && (_ = /* @__PURE__ */ new Set(), y.set(l, _));
    _.has(p) || (_.add(p), s = ZS.bind(null, s, l, p), l.then(s, s));
  }
  function Oy(s) {
    do {
      var l;
      if ((l = s.tag === 13) && (l = s.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l) return s;
      s = s.return;
    } while (s !== null);
    return null;
  }
  function go(s, l, p, y, _) {
    return s.mode & 1 ? (s.flags |= 65536, s.lanes = _, s) : (s === l ? s.flags |= 65536 : (s.flags |= 128, p.flags |= 131072, p.flags &= -52805, p.tag === 1 && (p.alternate === null ? p.tag = 17 : (l = As(-1, 1), l.tag = 2, ho(p, l, 1))), p.lanes |= 1), s);
  }
  var Ic = j.ReactCurrentOwner, di = !1;
  function Fi(s, l, p, y) {
    l.child = s === null ? Ue(l, null, p, y) : Zn(l, s.child, p, y);
  }
  function Dr(s, l, p, y, _) {
    p = p.render;
    var T = l.ref;
    return Vn(l, _), y = po(s, l, p, y, T, _), p = La(), s !== null && !di ? (l.updateQueue = s.updateQueue, l.flags &= -2053, s.lanes &= ~_, ca(s, l, _)) : (Pn && p && Td(l), l.flags |= 1, Fi(s, l, y, _), l.child);
  }
  function bl(s, l, p, y, _) {
    if (s === null) {
      var T = p.type;
      return typeof T == "function" && !Am(T) && T.defaultProps === void 0 && p.compare === null && p.defaultProps === void 0 ? (l.tag = 15, l.type = T, Mt(s, l, T, y, _)) : (s = sf(p.type, null, y, l, l.mode, _), s.ref = l.ref, s.return = l, l.child = s);
    }
    if (T = s.child, !(s.lanes & _)) {
      var O = T.memoizedProps;
      if (p = p.compare, p = p !== null ? p : xc, p(O, y) && s.ref === l.ref) return ca(s, l, _);
    }
    return l.flags |= 1, s = xo(T, y), s.ref = l.ref, s.return = l, l.child = s;
  }
  function Mt(s, l, p, y, _) {
    if (s !== null) {
      var T = s.memoizedProps;
      if (xc(T, y) && s.ref === l.ref) if (di = !1, l.pendingProps = y = T, (s.lanes & _) !== 0) s.flags & 131072 && (di = !0);
      else return l.lanes = s.lanes, ca(s, l, _);
    }
    return Py(s, l, p, y, _);
  }
  function $c(s, l, p) {
    var y = l.pendingProps, _ = y.children, T = s !== null ? s.memoizedState : null;
    if (y.mode === "hidden") if (!(l.mode & 1)) l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, at(bu, Gr), Gr |= p;
    else {
      if (!(p & 1073741824)) return s = T !== null ? T.baseLanes | p : p, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: s, cachePool: null, transitions: null }, l.updateQueue = null, at(bu, Gr), Gr |= s, null;
      l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, y = T !== null ? T.baseLanes : p, at(bu, Gr), Gr |= y;
    }
    else T !== null ? (y = T.baseLanes | p, l.memoizedState = null) : y = p, at(bu, Gr), Gr |= y;
    return Fi(s, l, _, p), l.child;
  }
  function ym(s, l) {
    var p = l.ref;
    (s === null && p !== null || s !== null && s.ref !== p) && (l.flags |= 512, l.flags |= 2097152);
  }
  function Py(s, l, p, y, _) {
    var T = ui(p) ? _r : Yn.current;
    return T = aa(l, T), Vn(l, _), p = po(s, l, p, y, T, _), y = La(), s !== null && !di ? (l.updateQueue = s.updateQueue, l.flags &= -2053, s.lanes &= ~_, ca(s, l, _)) : (Pn && y && Td(l), l.flags |= 1, Fi(s, l, p, _), l.child);
  }
  function Ly(s, l, p, y, _) {
    if (ui(p)) {
      var T = !0;
      wr(l);
    } else T = !1;
    if (Vn(l, _), l.stateNode === null) ua(s, l), Qd(l, p, y), Uc(l, p, y, _), y = !0;
    else if (s === null) {
      var O = l.stateNode, V = l.memoizedProps;
      O.props = V;
      var U = O.context, te = p.contextType;
      typeof te == "object" && te !== null ? te = la(te) : (te = ui(p) ? _r : Yn.current, te = aa(l, te));
      var Se = p.getDerivedStateFromProps, De = typeof Se == "function" || typeof O.getSnapshotBeforeUpdate == "function";
      De || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (V !== y || U !== te) && My(l, O, y, te), Wr = !1;
      var be = l.memoizedState;
      O.state = be, Mc(l, y, O, _), U = l.memoizedState, V !== y || be !== U || xi.current || Wr ? (typeof Se == "function" && (hm(l, p, Se, y), U = l.memoizedState), (V = Wr || ky(l, p, V, y, be, U, te)) ? (De || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (typeof O.componentWillMount == "function" && O.componentWillMount(), typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount()), typeof O.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof O.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = y, l.memoizedState = U), O.props = y, O.state = U, O.context = te, y = V) : (typeof O.componentDidMount == "function" && (l.flags |= 4194308), y = !1);
    } else {
      O = l.stateNode, Ty(s, l), V = l.memoizedProps, te = l.type === l.elementType ? V : Na(l.type, V), O.props = te, De = l.pendingProps, be = O.context, U = p.contextType, typeof U == "object" && U !== null ? U = la(U) : (U = ui(p) ? _r : Yn.current, U = aa(l, U));
      var Ye = p.getDerivedStateFromProps;
      (Se = typeof Ye == "function" || typeof O.getSnapshotBeforeUpdate == "function") || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (V !== De || be !== U) && My(l, O, y, U), Wr = !1, be = l.memoizedState, O.state = be, Mc(l, y, O, _);
      var qe = l.memoizedState;
      V !== De || be !== qe || xi.current || Wr ? (typeof Ye == "function" && (hm(l, p, Ye, y), qe = l.memoizedState), (te = Wr || ky(l, p, te, y, be, qe, U) || !1) ? (Se || typeof O.UNSAFE_componentWillUpdate != "function" && typeof O.componentWillUpdate != "function" || (typeof O.componentWillUpdate == "function" && O.componentWillUpdate(y, qe, U), typeof O.UNSAFE_componentWillUpdate == "function" && O.UNSAFE_componentWillUpdate(y, qe, U)), typeof O.componentDidUpdate == "function" && (l.flags |= 4), typeof O.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof O.componentDidUpdate != "function" || V === s.memoizedProps && be === s.memoizedState || (l.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || V === s.memoizedProps && be === s.memoizedState || (l.flags |= 1024), l.memoizedProps = y, l.memoizedState = qe), O.props = y, O.state = qe, O.context = U, y = te) : (typeof O.componentDidUpdate != "function" || V === s.memoizedProps && be === s.memoizedState || (l.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || V === s.memoizedProps && be === s.memoizedState || (l.flags |= 1024), y = !1);
    }
    return Wc(s, l, p, y, T, _);
  }
  function Wc(s, l, p, y, _, T) {
    ym(s, l);
    var O = (l.flags & 128) !== 0;
    if (!y && !O) return _ && wd(l, p, !1), ca(s, l, T);
    y = l.stateNode, Ic.current = l;
    var V = O && typeof p.getDerivedStateFromError != "function" ? null : y.render();
    return l.flags |= 1, s !== null && O ? (l.child = Zn(l, s.child, null, T), l.child = Zn(l, null, V, T)) : Fi(s, l, V, T), l.memoizedState = y.state, _ && wd(l, p, !0), l.child;
  }
  function vu(s) {
    var l = s.stateNode;
    l.pendingContext ? Sy(s, l.pendingContext, l.pendingContext !== l.context) : l.context && Sy(s, l.context, !1), cm(s, l.containerInfo);
  }
  function Ny(s, l, p, y, _) {
    return fo(), Ms(_), l.flags |= 256, Fi(s, l, p, y), l.child;
  }
  var Zd = { dehydrated: null, treeContext: null, retryLane: 0 };
  function bm(s) {
    return { baseLanes: s, cachePool: null, transitions: null };
  }
  function Jd(s, l, p) {
    var y = l.pendingProps, _ = jn.current, T = !1, O = (l.flags & 128) !== 0, V;
    if ((V = O) || (V = s !== null && s.memoizedState === null ? !1 : (_ & 2) !== 0), V ? (T = !0, l.flags &= -129) : (s === null || s.memoizedState !== null) && (_ |= 1), at(jn, _ & 1), s === null)
      return tm(l), s = l.memoizedState, s !== null && (s = s.dehydrated, s !== null) ? (l.mode & 1 ? s.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (O = y.children, s = y.fallback, T ? (y = l.mode, T = l.child, O = { mode: "hidden", children: O }, !(y & 1) && T !== null ? (T.childLanes = 0, T.pendingProps = O) : T = So(O, y, 0, null), s = zs(s, y, p, null), T.return = l, s.return = l, T.sibling = s, l.child = T, l.child.memoizedState = bm(p), l.memoizedState = Zd, s) : xm(l, O));
    if (_ = s.memoizedState, _ !== null && (V = _.dehydrated, V !== null)) return zy(s, l, O, y, V, _, p);
    if (T) {
      T = y.fallback, O = l.mode, _ = s.child, V = _.sibling;
      var U = { mode: "hidden", children: y.children };
      return !(O & 1) && l.child !== _ ? (y = l.child, y.childLanes = 0, y.pendingProps = U, l.deletions = null) : (y = xo(_, U), y.subtreeFlags = _.subtreeFlags & 14680064), V !== null ? T = xo(V, T) : (T = zs(T, O, p, null), T.flags |= 2), T.return = l, y.return = l, y.sibling = T, l.child = y, y = T, T = l.child, O = s.child.memoizedState, O = O === null ? bm(p) : { baseLanes: O.baseLanes | p, cachePool: null, transitions: O.transitions }, T.memoizedState = O, T.childLanes = s.childLanes & ~p, l.memoizedState = Zd, y;
    }
    return T = s.child, s = T.sibling, y = xo(T, { mode: "visible", children: y.children }), !(l.mode & 1) && (y.lanes = p), y.return = l, y.sibling = null, s !== null && (p = l.deletions, p === null ? (l.deletions = [s], l.flags |= 16) : p.push(s)), l.child = y, l.memoizedState = null, y;
  }
  function xm(s, l) {
    return l = So({ mode: "visible", children: l }, s.mode, 0, null), l.return = s, s.child = l;
  }
  function Yc(s, l, p, y) {
    return y !== null && Ms(y), Zn(l, s.child, null, p), s = xm(l, l.pendingProps.children), s.flags |= 2, l.memoizedState = null, s;
  }
  function zy(s, l, p, y, _, T, O) {
    if (p)
      return l.flags & 256 ? (l.flags &= -257, y = pm(Error(i(422))), Yc(s, l, O, y)) : l.memoizedState !== null ? (l.child = s.child, l.flags |= 128, null) : (T = y.fallback, _ = l.mode, y = So({ mode: "visible", children: y.children }, _, 0, null), T = zs(T, _, O, null), T.flags |= 2, y.return = l, T.return = l, y.sibling = T, l.child = y, l.mode & 1 && Zn(l, s.child, null, O), l.child.memoizedState = bm(O), l.memoizedState = Zd, T);
    if (!(l.mode & 1)) return Yc(s, l, O, null);
    if (_.data === "$!") {
      if (y = _.nextSibling && _.nextSibling.dataset, y) var V = y.dgst;
      return y = V, T = Error(i(419)), y = pm(T, y, void 0), Yc(s, l, O, y);
    }
    if (V = (O & s.childLanes) !== 0, di || V) {
      if (y = _i, y !== null) {
        switch (O & -O) {
          case 4:
            _ = 2;
            break;
          case 16:
            _ = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            _ = 32;
            break;
          case 536870912:
            _ = 268435456;
            break;
          default:
            _ = 0;
        }
        _ = _ & (y.suspendedLanes | O) ? 0 : _, _ !== 0 && _ !== T.retryLane && (T.retryLane = _, $r(s, _), sr(y, s, _, -1));
      }
      return Mm(), y = pm(Error(i(421))), Yc(s, l, O, y);
    }
    return _.data === "$?" ? (l.flags |= 128, l.child = s.child, l = JS.bind(null, s), _._reactRetry = l, null) : (s = T.treeContext, Tr = Xa(_.nextSibling), Cr = l, Pn = !0, oa = null, s !== null && (ci[sa++] = Ja, ci[sa++] = es, ci[sa++] = Ur, Ja = s.id, es = s.overflow, Ur = l), l = xm(l, y.children), l.flags |= 4096, l);
  }
  function Sm(s, l, p) {
    s.lanes |= l;
    var y = s.alternate;
    y !== null && (y.lanes |= l), am(s.return, l, p);
  }
  function ir(s, l, p, y, _) {
    var T = s.memoizedState;
    T === null ? s.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: y, tail: p, tailMode: _ } : (T.isBackwards = l, T.rendering = null, T.renderingStartTime = 0, T.last = y, T.tail = p, T.tailMode = _);
  }
  function ns(s, l, p) {
    var y = l.pendingProps, _ = y.revealOrder, T = y.tail;
    if (Fi(s, l, y.children, p), y = jn.current, y & 2) y = y & 1 | 2, l.flags |= 128;
    else {
      if (s !== null && s.flags & 128) e: for (s = l.child; s !== null; ) {
        if (s.tag === 13) s.memoizedState !== null && Sm(s, p, l);
        else if (s.tag === 19) Sm(s, p, l);
        else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === l) break e;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === l) break e;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      y &= 1;
    }
    if (at(jn, y), !(l.mode & 1)) l.memoizedState = null;
    else switch (_) {
      case "forwards":
        for (p = l.child, _ = null; p !== null; ) s = p.alternate, s !== null && Ad(s) === null && (_ = p), p = p.sibling;
        p = _, p === null ? (_ = l.child, l.child = null) : (_ = p.sibling, p.sibling = null), ir(l, !1, _, p, T);
        break;
      case "backwards":
        for (p = null, _ = l.child, l.child = null; _ !== null; ) {
          if (s = _.alternate, s !== null && Ad(s) === null) {
            l.child = _;
            break;
          }
          s = _.sibling, _.sibling = p, p = _, _ = s;
        }
        ir(l, !0, p, null, T);
        break;
      case "together":
        ir(l, !1, null, null, void 0);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function ua(s, l) {
    !(l.mode & 1) && s !== null && (s.alternate = null, l.alternate = null, l.flags |= 2);
  }
  function ca(s, l, p) {
    if (s !== null && (l.dependencies = s.dependencies), as |= l.lanes, !(p & l.childLanes)) return null;
    if (s !== null && l.child !== s.child) throw Error(i(153));
    if (l.child !== null) {
      for (s = l.child, p = xo(s, s.pendingProps), l.child = p, p.return = l; s.sibling !== null; ) s = s.sibling, p = p.sibling = xo(s, s.pendingProps), p.return = l;
      p.sibling = null;
    }
    return l.child;
  }
  function Gc(s, l, p) {
    switch (l.tag) {
      case 3:
        vu(l), fo();
        break;
      case 5:
        Dy(l);
        break;
      case 1:
        ui(l.type) && wr(l);
        break;
      case 4:
        cm(l, l.stateNode.containerInfo);
        break;
      case 10:
        var y = l.type._context, _ = l.memoizedProps.value;
        at(Ir, y._currentValue), y._currentValue = _;
        break;
      case 13:
        if (y = l.memoizedState, y !== null)
          return y.dehydrated !== null ? (at(jn, jn.current & 1), l.flags |= 128, null) : p & l.child.childLanes ? Jd(s, l, p) : (at(jn, jn.current & 1), s = ca(s, l, p), s !== null ? s.sibling : null);
        at(jn, jn.current & 1);
        break;
      case 19:
        if (y = (p & l.childLanes) !== 0, s.flags & 128) {
          if (y) return ns(s, l, p);
          l.flags |= 128;
        }
        if (_ = l.memoizedState, _ !== null && (_.rendering = null, _.tail = null, _.lastEffect = null), at(jn, jn.current), y) break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, $c(s, l, p);
    }
    return ca(s, l, p);
  }
  var fa, hi, Fy, Vy;
  fa = function(s, l) {
    for (var p = l.child; p !== null; ) {
      if (p.tag === 5 || p.tag === 6) s.appendChild(p.stateNode);
      else if (p.tag !== 4 && p.child !== null) {
        p.child.return = p, p = p.child;
        continue;
      }
      if (p === l) break;
      for (; p.sibling === null; ) {
        if (p.return === null || p.return === l) return;
        p = p.return;
      }
      p.sibling.return = p.return, p = p.sibling;
    }
  }, hi = function() {
  }, Fy = function(s, l, p, y) {
    var _ = s.memoizedProps;
    if (_ !== y) {
      s = l.stateNode, cl(ts.current);
      var T = null;
      switch (p) {
        case "input":
          _ = rt(s, _), y = rt(s, y), T = [];
          break;
        case "select":
          _ = pe({}, _, { value: void 0 }), y = pe({}, y, { value: void 0 }), T = [];
          break;
        case "textarea":
          _ = wt(s, _), y = wt(s, y), T = [];
          break;
        default:
          typeof _.onClick != "function" && typeof y.onClick == "function" && (s.onclick = ao);
      }
      gn(p, y);
      var O;
      p = null;
      for (te in _) if (!y.hasOwnProperty(te) && _.hasOwnProperty(te) && _[te] != null) if (te === "style") {
        var V = _[te];
        for (O in V) V.hasOwnProperty(O) && (p || (p = {}), p[O] = "");
      } else te !== "dangerouslySetInnerHTML" && te !== "children" && te !== "suppressContentEditableWarning" && te !== "suppressHydrationWarning" && te !== "autoFocus" && (o.hasOwnProperty(te) ? T || (T = []) : (T = T || []).push(te, null));
      for (te in y) {
        var U = y[te];
        if (V = _ != null ? _[te] : void 0, y.hasOwnProperty(te) && U !== V && (U != null || V != null)) if (te === "style") if (V) {
          for (O in V) !V.hasOwnProperty(O) || U && U.hasOwnProperty(O) || (p || (p = {}), p[O] = "");
          for (O in U) U.hasOwnProperty(O) && V[O] !== U[O] && (p || (p = {}), p[O] = U[O]);
        } else p || (T || (T = []), T.push(
          te,
          p
        )), p = U;
        else te === "dangerouslySetInnerHTML" ? (U = U ? U.__html : void 0, V = V ? V.__html : void 0, U != null && V !== U && (T = T || []).push(te, U)) : te === "children" ? typeof U != "string" && typeof U != "number" || (T = T || []).push(te, "" + U) : te !== "suppressContentEditableWarning" && te !== "suppressHydrationWarning" && (o.hasOwnProperty(te) ? (U != null && te === "onScroll" && un("scroll", s), T || V === U || (T = [])) : (T = T || []).push(te, U));
      }
      p && (T = T || []).push("style", p);
      var te = T;
      (l.updateQueue = te) && (l.flags |= 4);
    }
  }, Vy = function(s, l, p, y) {
    p !== y && (l.flags |= 4);
  };
  function Kc(s, l) {
    if (!Pn) switch (s.tailMode) {
      case "hidden":
        l = s.tail;
        for (var p = null; l !== null; ) l.alternate !== null && (p = l), l = l.sibling;
        p === null ? s.tail = null : p.sibling = null;
        break;
      case "collapsed":
        p = s.tail;
        for (var y = null; p !== null; ) p.alternate !== null && (y = p), p = p.sibling;
        y === null ? l || s.tail === null ? s.tail = null : s.tail.sibling = null : y.sibling = null;
    }
  }
  function ki(s) {
    var l = s.alternate !== null && s.alternate.child === s.child, p = 0, y = 0;
    if (l) for (var _ = s.child; _ !== null; ) p |= _.lanes | _.childLanes, y |= _.subtreeFlags & 14680064, y |= _.flags & 14680064, _.return = s, _ = _.sibling;
    else for (_ = s.child; _ !== null; ) p |= _.lanes | _.childLanes, y |= _.subtreeFlags, y |= _.flags, _.return = s, _ = _.sibling;
    return s.subtreeFlags |= y, s.childLanes = p, l;
  }
  function jy(s, l, p) {
    var y = l.pendingProps;
    switch (Ed(l), l.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ki(l), null;
      case 1:
        return ui(l.type) && du(), ki(l), null;
      case 3:
        return y = l.stateNode, fl(), Cn(xi), Cn(Yn), ot(), y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), (s === null || s.child === null) && (Dd(l) ? l.flags |= 4 : s === null || s.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, oa !== null && (_l(oa), oa = null))), hi(s, l), ki(l), null;
      case 5:
        Md(l);
        var _ = cl(Pc.current);
        if (p = l.type, s !== null && l.stateNode != null) Fy(s, l, p, y, _), s.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
        else {
          if (!y) {
            if (l.stateNode === null) throw Error(i(166));
            return ki(l), null;
          }
          if (s = cl(ts.current), Dd(l)) {
            y = l.stateNode, p = l.type;
            var T = l.memoizedProps;
            switch (y[Qa] = l, y[Ec] = T, s = (l.mode & 1) !== 0, p) {
              case "dialog":
                un("cancel", y), un("close", y);
                break;
              case "iframe":
              case "object":
              case "embed":
                un("load", y);
                break;
              case "video":
              case "audio":
                for (_ = 0; _ < wc.length; _++) un(wc[_], y);
                break;
              case "source":
                un("error", y);
                break;
              case "img":
              case "image":
              case "link":
                un(
                  "error",
                  y
                ), un("load", y);
                break;
              case "details":
                un("toggle", y);
                break;
              case "input":
                xt(y, T), un("invalid", y);
                break;
              case "select":
                y._wrapperState = { wasMultiple: !!T.multiple }, un("invalid", y);
                break;
              case "textarea":
                Kt(y, T), un("invalid", y);
            }
            gn(p, T), _ = null;
            for (var O in T) if (T.hasOwnProperty(O)) {
              var V = T[O];
              O === "children" ? typeof V == "string" ? y.textContent !== V && (T.suppressHydrationWarning !== !0 && bd(y.textContent, V, s), _ = ["children", V]) : typeof V == "number" && y.textContent !== "" + V && (T.suppressHydrationWarning !== !0 && bd(
                y.textContent,
                V,
                s
              ), _ = ["children", "" + V]) : o.hasOwnProperty(O) && V != null && O === "onScroll" && un("scroll", y);
            }
            switch (p) {
              case "input":
                lt(y), sn(y, T, !0);
                break;
              case "textarea":
                lt(y), Mn(y);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof T.onClick == "function" && (y.onclick = ao);
            }
            y = _, l.updateQueue = y, y !== null && (l.flags |= 4);
          } else {
            O = _.nodeType === 9 ? _ : _.ownerDocument, s === "http://www.w3.org/1999/xhtml" && (s = oi(p)), s === "http://www.w3.org/1999/xhtml" ? p === "script" ? (s = O.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild)) : typeof y.is == "string" ? s = O.createElement(p, { is: y.is }) : (s = O.createElement(p), p === "select" && (O = s, y.multiple ? O.multiple = !0 : y.size && (O.size = y.size))) : s = O.createElementNS(s, p), s[Qa] = l, s[Ec] = y, fa(s, l, !1, !1), l.stateNode = s;
            e: {
              switch (O = zn(p, y), p) {
                case "dialog":
                  un("cancel", s), un("close", s), _ = y;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  un("load", s), _ = y;
                  break;
                case "video":
                case "audio":
                  for (_ = 0; _ < wc.length; _++) un(wc[_], s);
                  _ = y;
                  break;
                case "source":
                  un("error", s), _ = y;
                  break;
                case "img":
                case "image":
                case "link":
                  un(
                    "error",
                    s
                  ), un("load", s), _ = y;
                  break;
                case "details":
                  un("toggle", s), _ = y;
                  break;
                case "input":
                  xt(s, y), _ = rt(s, y), un("invalid", s);
                  break;
                case "option":
                  _ = y;
                  break;
                case "select":
                  s._wrapperState = { wasMultiple: !!y.multiple }, _ = pe({}, y, { value: void 0 }), un("invalid", s);
                  break;
                case "textarea":
                  Kt(s, y), _ = wt(s, y), un("invalid", s);
                  break;
                default:
                  _ = y;
              }
              gn(p, _), V = _;
              for (T in V) if (V.hasOwnProperty(T)) {
                var U = V[T];
                T === "style" ? ln(s, U) : T === "dangerouslySetInnerHTML" ? (U = U ? U.__html : void 0, U != null && Ei(s, U)) : T === "children" ? typeof U == "string" ? (p !== "textarea" || U !== "") && ze(s, U) : typeof U == "number" && ze(s, "" + U) : T !== "suppressContentEditableWarning" && T !== "suppressHydrationWarning" && T !== "autoFocus" && (o.hasOwnProperty(T) ? U != null && T === "onScroll" && un("scroll", s) : U != null && B(s, T, U, O));
              }
              switch (p) {
                case "input":
                  lt(s), sn(s, y, !1);
                  break;
                case "textarea":
                  lt(s), Mn(s);
                  break;
                case "option":
                  y.value != null && s.setAttribute("value", "" + xe(y.value));
                  break;
                case "select":
                  s.multiple = !!y.multiple, T = y.value, T != null ? Ot(s, !!y.multiple, T, !1) : y.defaultValue != null && Ot(
                    s,
                    !!y.multiple,
                    y.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof _.onClick == "function" && (s.onclick = ao);
              }
              switch (p) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  y = !!y.autoFocus;
                  break e;
                case "img":
                  y = !0;
                  break e;
                default:
                  y = !1;
              }
            }
            y && (l.flags |= 4);
          }
          l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
        }
        return ki(l), null;
      case 6:
        if (s && l.stateNode != null) Vy(s, l, s.memoizedProps, y);
        else {
          if (typeof y != "string" && l.stateNode === null) throw Error(i(166));
          if (p = cl(Pc.current), cl(ts.current), Dd(l)) {
            if (y = l.stateNode, p = l.memoizedProps, y[Qa] = l, (T = y.nodeValue !== p) && (s = Cr, s !== null)) switch (s.tag) {
              case 3:
                bd(y.nodeValue, p, (s.mode & 1) !== 0);
                break;
              case 5:
                s.memoizedProps.suppressHydrationWarning !== !0 && bd(y.nodeValue, p, (s.mode & 1) !== 0);
            }
            T && (l.flags |= 4);
          } else y = (p.nodeType === 9 ? p : p.ownerDocument).createTextNode(y), y[Qa] = l, l.stateNode = y;
        }
        return ki(l), null;
      case 13:
        if (Cn(jn), y = l.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
          if (Pn && Tr !== null && l.mode & 1 && !(l.flags & 128)) kc(), fo(), l.flags |= 98560, T = !1;
          else if (T = Dd(l), y !== null && y.dehydrated !== null) {
            if (s === null) {
              if (!T) throw Error(i(318));
              if (T = l.memoizedState, T = T !== null ? T.dehydrated : null, !T) throw Error(i(317));
              T[Qa] = l;
            } else fo(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            ki(l), T = !1;
          } else oa !== null && (_l(oa), oa = null), T = !0;
          if (!T) return l.flags & 65536 ? l : null;
        }
        return l.flags & 128 ? (l.lanes = p, l) : (y = y !== null, y !== (s !== null && s.memoizedState !== null) && y && (l.child.flags |= 8192, l.mode & 1 && (s === null || jn.current & 1 ? ti === 0 && (ti = 3) : Mm())), l.updateQueue !== null && (l.flags |= 4), ki(l), null);
      case 4:
        return fl(), hi(s, l), s === null && ou(l.stateNode.containerInfo), ki(l), null;
      case 10:
        return rm(l.type._context), ki(l), null;
      case 17:
        return ui(l.type) && du(), ki(l), null;
      case 19:
        if (Cn(jn), T = l.memoizedState, T === null) return ki(l), null;
        if (y = (l.flags & 128) !== 0, O = T.rendering, O === null) if (y) Kc(T, !1);
        else {
          if (ti !== 0 || s !== null && s.flags & 128) for (s = l.child; s !== null; ) {
            if (O = Ad(s), O !== null) {
              for (l.flags |= 128, Kc(T, !1), y = O.updateQueue, y !== null && (l.updateQueue = y, l.flags |= 4), l.subtreeFlags = 0, y = p, p = l.child; p !== null; ) T = p, s = y, T.flags &= 14680066, O = T.alternate, O === null ? (T.childLanes = 0, T.lanes = s, T.child = null, T.subtreeFlags = 0, T.memoizedProps = null, T.memoizedState = null, T.updateQueue = null, T.dependencies = null, T.stateNode = null) : (T.childLanes = O.childLanes, T.lanes = O.lanes, T.child = O.child, T.subtreeFlags = 0, T.deletions = null, T.memoizedProps = O.memoizedProps, T.memoizedState = O.memoizedState, T.updateQueue = O.updateQueue, T.type = O.type, s = O.dependencies, T.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }), p = p.sibling;
              return at(jn, jn.current & 1 | 2), l.child;
            }
            s = s.sibling;
          }
          T.tail !== null && At() > Su && (l.flags |= 128, y = !0, Kc(T, !1), l.lanes = 4194304);
        }
        else {
          if (!y) if (s = Ad(O), s !== null) {
            if (l.flags |= 128, y = !0, p = s.updateQueue, p !== null && (l.updateQueue = p, l.flags |= 4), Kc(T, !0), T.tail === null && T.tailMode === "hidden" && !O.alternate && !Pn) return ki(l), null;
          } else 2 * At() - T.renderingStartTime > Su && p !== 1073741824 && (l.flags |= 128, y = !0, Kc(T, !1), l.lanes = 4194304);
          T.isBackwards ? (O.sibling = l.child, l.child = O) : (p = T.last, p !== null ? p.sibling = O : l.child = O, T.last = O);
        }
        return T.tail !== null ? (l = T.tail, T.rendering = l, T.tail = l.sibling, T.renderingStartTime = At(), l.sibling = null, p = jn.current, at(jn, y ? p & 1 | 2 : p & 1), l) : (ki(l), null);
      case 22:
      case 23:
        return km(), y = l.memoizedState !== null, s !== null && s.memoizedState !== null !== y && (l.flags |= 8192), y && l.mode & 1 ? Gr & 1073741824 && (ki(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : ki(l), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(i(156, l.tag));
  }
  function eh(s, l) {
    switch (Ed(l), l.tag) {
      case 1:
        return ui(l.type) && du(), s = l.flags, s & 65536 ? (l.flags = s & -65537 | 128, l) : null;
      case 3:
        return fl(), Cn(xi), Cn(Yn), ot(), s = l.flags, s & 65536 && !(s & 128) ? (l.flags = s & -65537 | 128, l) : null;
      case 5:
        return Md(l), null;
      case 13:
        if (Cn(jn), s = l.memoizedState, s !== null && s.dehydrated !== null) {
          if (l.alternate === null) throw Error(i(340));
          fo();
        }
        return s = l.flags, s & 65536 ? (l.flags = s & -65537 | 128, l) : null;
      case 19:
        return Cn(jn), null;
      case 4:
        return fl(), null;
      case 10:
        return rm(l.type._context), null;
      case 22:
      case 23:
        return km(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Xc = !1, qi = !1, YS = typeof WeakSet == "function" ? WeakSet : Set, Xe = null;
  function yu(s, l) {
    var p = s.ref;
    if (p !== null) if (typeof p == "function") try {
      p(null);
    } catch (y) {
      Ln(s, l, y);
    }
    else p.current = null;
  }
  function th(s, l, p) {
    try {
      p();
    } catch (y) {
      Ln(s, l, y);
    }
  }
  var By = !1;
  function Hy(s, l) {
    if (Tc = qo, s = Sc(), fd(s)) {
      if ("selectionStart" in s) var p = { start: s.selectionStart, end: s.selectionEnd };
      else e: {
        p = (p = s.ownerDocument) && p.defaultView || window;
        var y = p.getSelection && p.getSelection();
        if (y && y.rangeCount !== 0) {
          p = y.anchorNode;
          var _ = y.anchorOffset, T = y.focusNode;
          y = y.focusOffset;
          try {
            p.nodeType, T.nodeType;
          } catch {
            p = null;
            break e;
          }
          var O = 0, V = -1, U = -1, te = 0, Se = 0, De = s, be = null;
          t: for (; ; ) {
            for (var Ye; De !== p || _ !== 0 && De.nodeType !== 3 || (V = O + _), De !== T || y !== 0 && De.nodeType !== 3 || (U = O + y), De.nodeType === 3 && (O += De.nodeValue.length), (Ye = De.firstChild) !== null; )
              be = De, De = Ye;
            for (; ; ) {
              if (De === s) break t;
              if (be === p && ++te === _ && (V = O), be === T && ++Se === y && (U = O), (Ye = De.nextSibling) !== null) break;
              De = be, be = De.parentNode;
            }
            De = Ye;
          }
          p = V === -1 || U === -1 ? null : { start: V, end: U };
        } else p = null;
      }
      p = p || { start: 0, end: 0 };
    } else p = null;
    for (rl = { focusedElem: s, selectionRange: p }, qo = !1, Xe = l; Xe !== null; ) if (l = Xe, s = l.child, (l.subtreeFlags & 1028) !== 0 && s !== null) s.return = l, Xe = s;
    else for (; Xe !== null; ) {
      l = Xe;
      try {
        var qe = l.alternate;
        if (l.flags & 1024) switch (l.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (qe !== null) {
              var et = qe.memoizedProps, ni = qe.memoizedState, X = l.stateNode, Y = X.getSnapshotBeforeUpdate(l.elementType === l.type ? et : Na(l.type, et), ni);
              X.__reactInternalSnapshotBeforeUpdate = Y;
            }
            break;
          case 3:
            var Z = l.stateNode.containerInfo;
            Z.nodeType === 1 ? Z.textContent = "" : Z.nodeType === 9 && Z.documentElement && Z.removeChild(Z.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(i(163));
        }
      } catch (_e) {
        Ln(l, l.return, _e);
      }
      if (s = l.sibling, s !== null) {
        s.return = l.return, Xe = s;
        break;
      }
      Xe = l.return;
    }
    return qe = By, By = !1, qe;
  }
  function Qc(s, l, p) {
    var y = l.updateQueue;
    if (y = y !== null ? y.lastEffect : null, y !== null) {
      var _ = y = y.next;
      do {
        if ((_.tag & s) === s) {
          var T = _.destroy;
          _.destroy = void 0, T !== void 0 && th(l, p, T);
        }
        _ = _.next;
      } while (_ !== y);
    }
  }
  function qc(s, l) {
    if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
      var p = l = l.next;
      do {
        if ((p.tag & s) === s) {
          var y = p.create;
          p.destroy = y();
        }
        p = p.next;
      } while (p !== l);
    }
  }
  function _m(s) {
    var l = s.ref;
    if (l !== null) {
      var p = s.stateNode;
      switch (s.tag) {
        case 5:
          s = p;
          break;
        default:
          s = p;
      }
      typeof l == "function" ? l(s) : l.current = s;
    }
  }
  function nh(s) {
    var l = s.alternate;
    l !== null && (s.alternate = null, nh(l)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (l = s.stateNode, l !== null && (delete l[Qa], delete l[Ec], delete l[Dc], delete l[fu], delete l[$S])), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
  }
  function Zc(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4;
  }
  function Ps(s) {
    e: for (; ; ) {
      for (; s.sibling === null; ) {
        if (s.return === null || Zc(s.return)) return null;
        s = s.return;
      }
      for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18; ) {
        if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
        s.child.return = s, s = s.child;
      }
      if (!(s.flags & 2)) return s.stateNode;
    }
  }
  function is(s, l, p) {
    var y = s.tag;
    if (y === 5 || y === 6) s = s.stateNode, l ? p.nodeType === 8 ? p.parentNode.insertBefore(s, l) : p.insertBefore(s, l) : (p.nodeType === 8 ? (l = p.parentNode, l.insertBefore(s, p)) : (l = p, l.appendChild(s)), p = p._reactRootContainer, p != null || l.onclick !== null || (l.onclick = ao));
    else if (y !== 4 && (s = s.child, s !== null)) for (is(s, l, p), s = s.sibling; s !== null; ) is(s, l, p), s = s.sibling;
  }
  function rs(s, l, p) {
    var y = s.tag;
    if (y === 5 || y === 6) s = s.stateNode, l ? p.insertBefore(s, l) : p.appendChild(s);
    else if (y !== 4 && (s = s.child, s !== null)) for (rs(s, l, p), s = s.sibling; s !== null; ) rs(s, l, p), s = s.sibling;
  }
  var ei = null, rr = !1;
  function ar(s, l, p) {
    for (p = p.child; p !== null; ) Uy(s, l, p), p = p.sibling;
  }
  function Uy(s, l, p) {
    if (ka && typeof ka.onCommitFiberUnmount == "function") try {
      ka.onCommitFiberUnmount(cc, p);
    } catch {
    }
    switch (p.tag) {
      case 5:
        qi || yu(p, l);
      case 6:
        var y = ei, _ = rr;
        ei = null, ar(s, l, p), ei = y, rr = _, ei !== null && (rr ? (s = ei, p = p.stateNode, s.nodeType === 8 ? s.parentNode.removeChild(p) : s.removeChild(p)) : ei.removeChild(p.stateNode));
        break;
      case 18:
        ei !== null && (rr ? (s = ei, p = p.stateNode, s.nodeType === 8 ? cu(s.parentNode, p) : s.nodeType === 1 && cu(s, p), no(s)) : cu(ei, p.stateNode));
        break;
      case 4:
        y = ei, _ = rr, ei = p.stateNode.containerInfo, rr = !0, ar(s, l, p), ei = y, rr = _;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!qi && (y = p.updateQueue, y !== null && (y = y.lastEffect, y !== null))) {
          _ = y = y.next;
          do {
            var T = _, O = T.destroy;
            T = T.tag, O !== void 0 && (T & 2 || T & 4) && th(p, l, O), _ = _.next;
          } while (_ !== y);
        }
        ar(s, l, p);
        break;
      case 1:
        if (!qi && (yu(p, l), y = p.stateNode, typeof y.componentWillUnmount == "function")) try {
          y.props = p.memoizedProps, y.state = p.memoizedState, y.componentWillUnmount();
        } catch (V) {
          Ln(p, l, V);
        }
        ar(s, l, p);
        break;
      case 21:
        ar(s, l, p);
        break;
      case 22:
        p.mode & 1 ? (qi = (y = qi) || p.memoizedState !== null, ar(s, l, p), qi = y) : ar(s, l, p);
        break;
      default:
        ar(s, l, p);
    }
  }
  function Iy(s) {
    var l = s.updateQueue;
    if (l !== null) {
      s.updateQueue = null;
      var p = s.stateNode;
      p === null && (p = s.stateNode = new YS()), l.forEach(function(y) {
        var _ = Zy.bind(null, s, y);
        p.has(y) || (p.add(y), y.then(_, _));
      });
    }
  }
  function za(s, l) {
    var p = l.deletions;
    if (p !== null) for (var y = 0; y < p.length; y++) {
      var _ = p[y];
      try {
        var T = s, O = l, V = O;
        e: for (; V !== null; ) {
          switch (V.tag) {
            case 5:
              ei = V.stateNode, rr = !1;
              break e;
            case 3:
              ei = V.stateNode.containerInfo, rr = !0;
              break e;
            case 4:
              ei = V.stateNode.containerInfo, rr = !0;
              break e;
          }
          V = V.return;
        }
        if (ei === null) throw Error(i(160));
        Uy(T, O, _), ei = null, rr = !1;
        var U = _.alternate;
        U !== null && (U.return = null), _.return = null;
      } catch (te) {
        Ln(_, l, te);
      }
    }
    if (l.subtreeFlags & 12854) for (l = l.child; l !== null; ) wm(l, s), l = l.sibling;
  }
  function wm(s, l) {
    var p = s.alternate, y = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (za(l, s), Rr(s), y & 4) {
          try {
            Qc(3, s, s.return), qc(3, s);
          } catch (et) {
            Ln(s, s.return, et);
          }
          try {
            Qc(5, s, s.return);
          } catch (et) {
            Ln(s, s.return, et);
          }
        }
        break;
      case 1:
        za(l, s), Rr(s), y & 512 && p !== null && yu(p, p.return);
        break;
      case 5:
        if (za(l, s), Rr(s), y & 512 && p !== null && yu(p, p.return), s.flags & 32) {
          var _ = s.stateNode;
          try {
            ze(_, "");
          } catch (et) {
            Ln(s, s.return, et);
          }
        }
        if (y & 4 && (_ = s.stateNode, _ != null)) {
          var T = s.memoizedProps, O = p !== null ? p.memoizedProps : T, V = s.type, U = s.updateQueue;
          if (s.updateQueue = null, U !== null) try {
            V === "input" && T.type === "radio" && T.name != null && Wt(_, T), zn(V, O);
            var te = zn(V, T);
            for (O = 0; O < U.length; O += 2) {
              var Se = U[O], De = U[O + 1];
              Se === "style" ? ln(_, De) : Se === "dangerouslySetInnerHTML" ? Ei(_, De) : Se === "children" ? ze(_, De) : B(_, Se, De, te);
            }
            switch (V) {
              case "input":
                an(_, T);
                break;
              case "textarea":
                wn(_, T);
                break;
              case "select":
                var be = _._wrapperState.wasMultiple;
                _._wrapperState.wasMultiple = !!T.multiple;
                var Ye = T.value;
                Ye != null ? Ot(_, !!T.multiple, Ye, !1) : be !== !!T.multiple && (T.defaultValue != null ? Ot(
                  _,
                  !!T.multiple,
                  T.defaultValue,
                  !0
                ) : Ot(_, !!T.multiple, T.multiple ? [] : "", !1));
            }
            _[Ec] = T;
          } catch (et) {
            Ln(s, s.return, et);
          }
        }
        break;
      case 6:
        if (za(l, s), Rr(s), y & 4) {
          if (s.stateNode === null) throw Error(i(162));
          _ = s.stateNode, T = s.memoizedProps;
          try {
            _.nodeValue = T;
          } catch (et) {
            Ln(s, s.return, et);
          }
        }
        break;
      case 3:
        if (za(l, s), Rr(s), y & 4 && p !== null && p.memoizedState.isDehydrated) try {
          no(l.containerInfo);
        } catch (et) {
          Ln(s, s.return, et);
        }
        break;
      case 4:
        za(l, s), Rr(s);
        break;
      case 13:
        za(l, s), Rr(s), _ = s.child, _.flags & 8192 && (T = _.memoizedState !== null, _.stateNode.isHidden = T, !T || _.alternate !== null && _.alternate.memoizedState !== null || (Em = At())), y & 4 && Iy(s);
        break;
      case 22:
        if (Se = p !== null && p.memoizedState !== null, s.mode & 1 ? (qi = (te = qi) || Se, za(l, s), qi = te) : za(l, s), Rr(s), y & 8192) {
          if (te = s.memoizedState !== null, (s.stateNode.isHidden = te) && !Se && s.mode & 1) for (Xe = s, Se = s.child; Se !== null; ) {
            for (De = Xe = Se; Xe !== null; ) {
              switch (be = Xe, Ye = be.child, be.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qc(4, be, be.return);
                  break;
                case 1:
                  yu(be, be.return);
                  var qe = be.stateNode;
                  if (typeof qe.componentWillUnmount == "function") {
                    y = be, p = be.return;
                    try {
                      l = y, qe.props = l.memoizedProps, qe.state = l.memoizedState, qe.componentWillUnmount();
                    } catch (et) {
                      Ln(y, p, et);
                    }
                  }
                  break;
                case 5:
                  yu(be, be.return);
                  break;
                case 22:
                  if (be.memoizedState !== null) {
                    Jc(De);
                    continue;
                  }
              }
              Ye !== null ? (Ye.return = be, Xe = Ye) : Jc(De);
            }
            Se = Se.sibling;
          }
          e: for (Se = null, De = s; ; ) {
            if (De.tag === 5) {
              if (Se === null) {
                Se = De;
                try {
                  _ = De.stateNode, te ? (T = _.style, typeof T.setProperty == "function" ? T.setProperty("display", "none", "important") : T.display = "none") : (V = De.stateNode, U = De.memoizedProps.style, O = U != null && U.hasOwnProperty("display") ? U.display : null, V.style.display = Xt("display", O));
                } catch (et) {
                  Ln(s, s.return, et);
                }
              }
            } else if (De.tag === 6) {
              if (Se === null) try {
                De.stateNode.nodeValue = te ? "" : De.memoizedProps;
              } catch (et) {
                Ln(s, s.return, et);
              }
            } else if ((De.tag !== 22 && De.tag !== 23 || De.memoizedState === null || De === s) && De.child !== null) {
              De.child.return = De, De = De.child;
              continue;
            }
            if (De === s) break e;
            for (; De.sibling === null; ) {
              if (De.return === null || De.return === s) break e;
              Se === De && (Se = null), De = De.return;
            }
            Se === De && (Se = null), De.sibling.return = De.return, De = De.sibling;
          }
        }
        break;
      case 19:
        za(l, s), Rr(s), y & 4 && Iy(s);
        break;
      case 21:
        break;
      default:
        za(
          l,
          s
        ), Rr(s);
    }
  }
  function Rr(s) {
    var l = s.flags;
    if (l & 2) {
      try {
        e: {
          for (var p = s.return; p !== null; ) {
            if (Zc(p)) {
              var y = p;
              break e;
            }
            p = p.return;
          }
          throw Error(i(160));
        }
        switch (y.tag) {
          case 5:
            var _ = y.stateNode;
            y.flags & 32 && (ze(_, ""), y.flags &= -33);
            var T = Ps(s);
            rs(s, T, _);
            break;
          case 3:
          case 4:
            var O = y.stateNode.containerInfo, V = Ps(s);
            is(s, V, O);
            break;
          default:
            throw Error(i(161));
        }
      } catch (U) {
        Ln(s, s.return, U);
      }
      s.flags &= -3;
    }
    l & 4096 && (s.flags &= -4097);
  }
  function GS(s, l, p) {
    Xe = s, Cm(s);
  }
  function Cm(s, l, p) {
    for (var y = (s.mode & 1) !== 0; Xe !== null; ) {
      var _ = Xe, T = _.child;
      if (_.tag === 22 && y) {
        var O = _.memoizedState !== null || Xc;
        if (!O) {
          var V = _.alternate, U = V !== null && V.memoizedState !== null || qi;
          V = Xc;
          var te = qi;
          if (Xc = O, (qi = U) && !te) for (Xe = _; Xe !== null; ) O = Xe, U = O.child, O.tag === 22 && O.memoizedState !== null ? Tm(_) : U !== null ? (U.return = O, Xe = U) : Tm(_);
          for (; T !== null; ) Xe = T, Cm(T), T = T.sibling;
          Xe = _, Xc = V, qi = te;
        }
        $y(s);
      } else _.subtreeFlags & 8772 && T !== null ? (T.return = _, Xe = T) : $y(s);
    }
  }
  function $y(s) {
    for (; Xe !== null; ) {
      var l = Xe;
      if (l.flags & 8772) {
        var p = l.alternate;
        try {
          if (l.flags & 8772) switch (l.tag) {
            case 0:
            case 11:
            case 15:
              qi || qc(5, l);
              break;
            case 1:
              var y = l.stateNode;
              if (l.flags & 4 && !qi) if (p === null) y.componentDidMount();
              else {
                var _ = l.elementType === l.type ? p.memoizedProps : Na(l.type, p.memoizedProps);
                y.componentDidUpdate(_, p.memoizedState, y.__reactInternalSnapshotBeforeUpdate);
              }
              var T = l.updateQueue;
              T !== null && um(l, T, y);
              break;
            case 3:
              var O = l.updateQueue;
              if (O !== null) {
                if (p = null, l.child !== null) switch (l.child.tag) {
                  case 5:
                    p = l.child.stateNode;
                    break;
                  case 1:
                    p = l.child.stateNode;
                }
                um(l, O, p);
              }
              break;
            case 5:
              var V = l.stateNode;
              if (p === null && l.flags & 4) {
                p = V;
                var U = l.memoizedProps;
                switch (l.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    U.autoFocus && p.focus();
                    break;
                  case "img":
                    U.src && (p.src = U.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (l.memoizedState === null) {
                var te = l.alternate;
                if (te !== null) {
                  var Se = te.memoizedState;
                  if (Se !== null) {
                    var De = Se.dehydrated;
                    De !== null && no(De);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(i(163));
          }
          qi || l.flags & 512 && _m(l);
        } catch (be) {
          Ln(l, l.return, be);
        }
      }
      if (l === s) {
        Xe = null;
        break;
      }
      if (p = l.sibling, p !== null) {
        p.return = l.return, Xe = p;
        break;
      }
      Xe = l.return;
    }
  }
  function Jc(s) {
    for (; Xe !== null; ) {
      var l = Xe;
      if (l === s) {
        Xe = null;
        break;
      }
      var p = l.sibling;
      if (p !== null) {
        p.return = l.return, Xe = p;
        break;
      }
      Xe = l.return;
    }
  }
  function Tm(s) {
    for (; Xe !== null; ) {
      var l = Xe;
      try {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            var p = l.return;
            try {
              qc(4, l);
            } catch (U) {
              Ln(l, p, U);
            }
            break;
          case 1:
            var y = l.stateNode;
            if (typeof y.componentDidMount == "function") {
              var _ = l.return;
              try {
                y.componentDidMount();
              } catch (U) {
                Ln(l, _, U);
              }
            }
            var T = l.return;
            try {
              _m(l);
            } catch (U) {
              Ln(l, T, U);
            }
            break;
          case 5:
            var O = l.return;
            try {
              _m(l);
            } catch (U) {
              Ln(l, O, U);
            }
        }
      } catch (U) {
        Ln(l, l.return, U);
      }
      if (l === s) {
        Xe = null;
        break;
      }
      var V = l.sibling;
      if (V !== null) {
        V.return = l.return, Xe = V;
        break;
      }
      Xe = l.return;
    }
  }
  var KS = Math.ceil, vo = j.ReactCurrentDispatcher, xl = j.ReactCurrentOwner, Vi = j.ReactCurrentBatchConfig, Ht = 0, _i = null, pi = null, ji = 0, Gr = 0, bu = Pa(0), ti = 0, ef = null, as = 0, xu = 0, ih = 0, tf = null, kr = null, Em = 0, Su = 1 / 0, Kr = null, _u = !1, Sl = null, yo = null, rh = !1, Ls = null, nf = 0, bo = 0, wu = null, rf = -1, Zi = 0;
  function mi() {
    return Ht & 6 ? At() : rf !== -1 ? rf : rf = At();
  }
  function ss(s) {
    return s.mode & 1 ? Ht & 2 && ji !== 0 ? ji & -ji : WS.transition !== null ? (Zi === 0 && (Zi = qf()), Zi) : (s = pn, s !== 0 || (s = window.event, s = s === void 0 ? 16 : td(s.type)), s) : 1;
  }
  function sr(s, l, p, y) {
    if (50 < bo) throw bo = 0, wu = null, Error(i(185));
    Xo(s, p, y), (!(Ht & 2) || s !== _i) && (s === _i && (!(Ht & 2) && (xu |= p), ti === 4 && Fa(s, ji)), Mr(s, y), p === 1 && Ht === 0 && !(l.mode & 1) && (Su = At() + 500, hu && Za()));
  }
  function Mr(s, l) {
    var p = s.callbackNode;
    _p(s, l);
    var y = Ko(s, s === _i ? ji : 0);
    if (y === 0) p !== null && tr(p), s.callbackNode = null, s.callbackPriority = 0;
    else if (l = y & -y, s.callbackPriority !== l) {
      if (p != null && tr(p), l === 1) s.tag === 0 ? oo(Dm.bind(null, s)) : Cd(Dm.bind(null, s)), uu(function() {
        !(Ht & 6) && Za();
      }), p = null;
      else {
        switch (Tp(y)) {
          case 1:
            p = Ss;
            break;
          case 4:
            p = lc;
            break;
          case 16:
            p = uc;
            break;
          case 536870912:
            p = xp;
            break;
          default:
            p = uc;
        }
        p = e0(p, ah.bind(null, s));
      }
      s.callbackPriority = l, s.callbackNode = p;
    }
  }
  function ah(s, l) {
    if (rf = -1, Zi = 0, Ht & 6) throw Error(i(327));
    var p = s.callbackNode;
    if (Cu() && s.callbackNode !== p) return null;
    var y = Ko(s, s === _i ? ji : 0);
    if (y === 0) return null;
    if (y & 30 || y & s.expiredLanes || l) l = sh(s, y);
    else {
      l = y;
      var _ = Ht;
      Ht |= 2;
      var T = Yy();
      (_i !== s || ji !== l) && (Kr = null, Su = At() + 500, Ns(s, l));
      do
        try {
          Gy();
          break;
        } catch (V) {
          Wy(s, V);
        }
      while (!0);
      im(), vo.current = T, Ht = _, pi !== null ? l = 0 : (_i = null, ji = 0, l = ti);
    }
    if (l !== 0) {
      if (l === 2 && (_ = wp(s), _ !== 0 && (y = _, l = af(s, _))), l === 1) throw p = ef, Ns(s, 0), Fa(s, y), Mr(s, At()), p;
      if (l === 6) Fa(s, y);
      else {
        if (_ = s.current.alternate, !(y & 30) && !XS(_) && (l = sh(s, y), l === 2 && (T = wp(s), T !== 0 && (y = T, l = af(s, T))), l === 1)) throw p = ef, Ns(s, 0), Fa(s, y), Mr(s, At()), p;
        switch (s.finishedWork = _, s.finishedLanes = y, l) {
          case 0:
          case 1:
            throw Error(i(345));
          case 2:
            Cl(s, kr, Kr);
            break;
          case 3:
            if (Fa(s, y), (y & 130023424) === y && (l = Em + 500 - At(), 10 < l)) {
              if (Ko(s, 0) !== 0) break;
              if (_ = s.suspendedLanes, (_ & y) !== y) {
                mi(), s.pingedLanes |= s.suspendedLanes & _;
                break;
              }
              s.timeoutHandle = Sd(Cl.bind(null, s, kr, Kr), l);
              break;
            }
            Cl(s, kr, Kr);
            break;
          case 4:
            if (Fa(s, y), (y & 4194240) === y) break;
            for (l = s.eventTimes, _ = -1; 0 < y; ) {
              var O = 31 - ea(y);
              T = 1 << O, O = l[O], O > _ && (_ = O), y &= ~T;
            }
            if (y = _, y = At() - y, y = (120 > y ? 120 : 480 > y ? 480 : 1080 > y ? 1080 : 1920 > y ? 1920 : 3e3 > y ? 3e3 : 4320 > y ? 4320 : 1960 * KS(y / 1960)) - y, 10 < y) {
              s.timeoutHandle = Sd(Cl.bind(null, s, kr, Kr), y);
              break;
            }
            Cl(s, kr, Kr);
            break;
          case 5:
            Cl(s, kr, Kr);
            break;
          default:
            throw Error(i(329));
        }
      }
    }
    return Mr(s, At()), s.callbackNode === p ? ah.bind(null, s) : null;
  }
  function af(s, l) {
    var p = tf;
    return s.current.memoizedState.isDehydrated && (Ns(s, l).flags |= 256), s = sh(s, l), s !== 2 && (l = kr, kr = p, l !== null && _l(l)), s;
  }
  function _l(s) {
    kr === null ? kr = s : kr.push.apply(kr, s);
  }
  function XS(s) {
    for (var l = s; ; ) {
      if (l.flags & 16384) {
        var p = l.updateQueue;
        if (p !== null && (p = p.stores, p !== null)) for (var y = 0; y < p.length; y++) {
          var _ = p[y], T = _.getSnapshot;
          _ = _.value;
          try {
            if (!Aa(T(), _)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (p = l.child, l.subtreeFlags & 16384 && p !== null) p.return = l, l = p;
      else {
        if (l === s) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === s) return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function Fa(s, l) {
    for (l &= ~ih, l &= ~xu, s.suspendedLanes |= l, s.pingedLanes &= ~l, s = s.expirationTimes; 0 < l; ) {
      var p = 31 - ea(l), y = 1 << p;
      s[p] = -1, l &= ~y;
    }
  }
  function Dm(s) {
    if (Ht & 6) throw Error(i(327));
    Cu();
    var l = Ko(s, 0);
    if (!(l & 1)) return Mr(s, At()), null;
    var p = sh(s, l);
    if (s.tag !== 0 && p === 2) {
      var y = wp(s);
      y !== 0 && (l = y, p = af(s, y));
    }
    if (p === 1) throw p = ef, Ns(s, 0), Fa(s, l), Mr(s, At()), p;
    if (p === 6) throw Error(i(345));
    return s.finishedWork = s.current.alternate, s.finishedLanes = l, Cl(s, kr, Kr), Mr(s, At()), null;
  }
  function Rm(s, l) {
    var p = Ht;
    Ht |= 1;
    try {
      return s(l);
    } finally {
      Ht = p, Ht === 0 && (Su = At() + 500, hu && Za());
    }
  }
  function wl(s) {
    Ls !== null && Ls.tag === 0 && !(Ht & 6) && Cu();
    var l = Ht;
    Ht |= 1;
    var p = Vi.transition, y = pn;
    try {
      if (Vi.transition = null, pn = 1, s) return s();
    } finally {
      pn = y, Vi.transition = p, Ht = l, !(Ht & 6) && Za();
    }
  }
  function km() {
    Gr = bu.current, Cn(bu);
  }
  function Ns(s, l) {
    s.finishedWork = null, s.finishedLanes = 0;
    var p = s.timeoutHandle;
    if (p !== -1 && (s.timeoutHandle = -1, Zp(p)), pi !== null) for (p = pi.return; p !== null; ) {
      var y = p;
      switch (Ed(y), y.tag) {
        case 1:
          y = y.type.childContextTypes, y != null && du();
          break;
        case 3:
          fl(), Cn(xi), Cn(Yn), ot();
          break;
        case 5:
          Md(y);
          break;
        case 4:
          fl();
          break;
        case 13:
          Cn(jn);
          break;
        case 19:
          Cn(jn);
          break;
        case 10:
          rm(y.type._context);
          break;
        case 22:
        case 23:
          km();
      }
      p = p.return;
    }
    if (_i = s, pi = s = xo(s.current, null), ji = Gr = l, ti = 0, ef = null, ih = xu = as = 0, kr = tf = null, ul !== null) {
      for (l = 0; l < ul.length; l++) if (p = ul[l], y = p.interleaved, y !== null) {
        p.interleaved = null;
        var _ = y.next, T = p.pending;
        if (T !== null) {
          var O = T.next;
          T.next = _, y.next = O;
        }
        p.pending = y;
      }
      ul = null;
    }
    return s;
  }
  function Wy(s, l) {
    do {
      var p = pi;
      try {
        if (im(), Nt.current = vl, Od) {
          for (var y = en.memoizedState; y !== null; ) {
            var _ = y.queue;
            _ !== null && (_.pending = null), y = y.next;
          }
          Od = !1;
        }
        if (vn = 0, Ri = fi = en = null, Nc = !1, dl = 0, xl.current = null, p === null || p.return === null) {
          ti = 1, ef = l, pi = null;
          break;
        }
        e: {
          var T = s, O = p.return, V = p, U = l;
          if (l = ji, V.flags |= 32768, U !== null && typeof U == "object" && typeof U.then == "function") {
            var te = U, Se = V, De = Se.tag;
            if (!(Se.mode & 1) && (De === 0 || De === 11 || De === 15)) {
              var be = Se.alternate;
              be ? (Se.updateQueue = be.updateQueue, Se.memoizedState = be.memoizedState, Se.lanes = be.lanes) : (Se.updateQueue = null, Se.memoizedState = null);
            }
            var Ye = Oy(O);
            if (Ye !== null) {
              Ye.flags &= -257, go(Ye, O, V, T, l), Ye.mode & 1 && vm(T, te, l), l = Ye, U = te;
              var qe = l.updateQueue;
              if (qe === null) {
                var et = /* @__PURE__ */ new Set();
                et.add(U), l.updateQueue = et;
              } else qe.add(U);
              break e;
            } else {
              if (!(l & 1)) {
                vm(T, te, l), Mm();
                break e;
              }
              U = Error(i(426));
            }
          } else if (Pn && V.mode & 1) {
            var ni = Oy(O);
            if (ni !== null) {
              !(ni.flags & 65536) && (ni.flags |= 256), go(ni, O, V, T, l), Ms(yl(U, V));
              break e;
            }
          }
          T = U = yl(U, V), ti !== 4 && (ti = 2), tf === null ? tf = [T] : tf.push(T), T = O;
          do {
            switch (T.tag) {
              case 3:
                T.flags |= 65536, l &= -l, T.lanes |= l;
                var X = Ay(T, U, l);
                Ey(T, X);
                break e;
              case 1:
                V = U;
                var Y = T.type, Z = T.stateNode;
                if (!(T.flags & 128) && (typeof Y.getDerivedStateFromError == "function" || Z !== null && typeof Z.componentDidCatch == "function" && (yo === null || !yo.has(Z)))) {
                  T.flags |= 65536, l &= -l, T.lanes |= l;
                  var _e = gm(T, V, l);
                  Ey(T, _e);
                  break e;
                }
            }
            T = T.return;
          } while (T !== null);
        }
        Xy(p);
      } catch (Ze) {
        l = Ze, pi === p && p !== null && (pi = p = p.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Yy() {
    var s = vo.current;
    return vo.current = vl, s === null ? vl : s;
  }
  function Mm() {
    (ti === 0 || ti === 3 || ti === 2) && (ti = 4), _i === null || !(as & 268435455) && !(xu & 268435455) || Fa(_i, ji);
  }
  function sh(s, l) {
    var p = Ht;
    Ht |= 2;
    var y = Yy();
    (_i !== s || ji !== l) && (Kr = null, Ns(s, l));
    do
      try {
        QS();
        break;
      } catch (_) {
        Wy(s, _);
      }
    while (!0);
    if (im(), Ht = p, vo.current = y, pi !== null) throw Error(i(261));
    return _i = null, ji = 0, ti;
  }
  function QS() {
    for (; pi !== null; ) Ky(pi);
  }
  function Gy() {
    for (; pi !== null && !bs(); ) Ky(pi);
  }
  function Ky(s) {
    var l = Jy(s.alternate, s, Gr);
    s.memoizedProps = s.pendingProps, l === null ? Xy(s) : pi = l, xl.current = null;
  }
  function Xy(s) {
    var l = s;
    do {
      var p = l.alternate;
      if (s = l.return, l.flags & 32768) {
        if (p = eh(p, l), p !== null) {
          p.flags &= 32767, pi = p;
          return;
        }
        if (s !== null) s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null;
        else {
          ti = 6, pi = null;
          return;
        }
      } else if (p = jy(p, l, Gr), p !== null) {
        pi = p;
        return;
      }
      if (l = l.sibling, l !== null) {
        pi = l;
        return;
      }
      pi = l = s;
    } while (l !== null);
    ti === 0 && (ti = 5);
  }
  function Cl(s, l, p) {
    var y = pn, _ = Vi.transition;
    try {
      Vi.transition = null, pn = 1, qS(s, l, p, y);
    } finally {
      Vi.transition = _, pn = y;
    }
    return null;
  }
  function qS(s, l, p, y) {
    do
      Cu();
    while (Ls !== null);
    if (Ht & 6) throw Error(i(327));
    p = s.finishedWork;
    var _ = s.finishedLanes;
    if (p === null) return null;
    if (s.finishedWork = null, s.finishedLanes = 0, p === s.current) throw Error(i(177));
    s.callbackNode = null, s.callbackPriority = 0;
    var T = p.lanes | p.childLanes;
    if (ES(s, T), s === _i && (pi = _i = null, ji = 0), !(p.subtreeFlags & 2064) && !(p.flags & 2064) || rh || (rh = !0, e0(uc, function() {
      return Cu(), null;
    })), T = (p.flags & 15990) !== 0, p.subtreeFlags & 15990 || T) {
      T = Vi.transition, Vi.transition = null;
      var O = pn;
      pn = 1;
      var V = Ht;
      Ht |= 4, xl.current = null, Hy(s, p), wm(p, s), au(rl), qo = !!Tc, rl = Tc = null, s.current = p, GS(p), xs(), Ht = V, pn = O, Vi.transition = T;
    } else s.current = p;
    if (rh && (rh = !1, Ls = s, nf = _), T = s.pendingLanes, T === 0 && (yo = null), Uv(p.stateNode), Mr(s, At()), l !== null) for (y = s.onRecoverableError, p = 0; p < l.length; p++) _ = l[p], y(_.value, { componentStack: _.stack, digest: _.digest });
    if (_u) throw _u = !1, s = Sl, Sl = null, s;
    return nf & 1 && s.tag !== 0 && Cu(), T = s.pendingLanes, T & 1 ? s === wu ? bo++ : (bo = 0, wu = s) : bo = 0, Za(), null;
  }
  function Cu() {
    if (Ls !== null) {
      var s = Tp(nf), l = Vi.transition, p = pn;
      try {
        if (Vi.transition = null, pn = 16 > s ? 16 : s, Ls === null) var y = !1;
        else {
          if (s = Ls, Ls = null, nf = 0, Ht & 6) throw Error(i(331));
          var _ = Ht;
          for (Ht |= 4, Xe = s.current; Xe !== null; ) {
            var T = Xe, O = T.child;
            if (Xe.flags & 16) {
              var V = T.deletions;
              if (V !== null) {
                for (var U = 0; U < V.length; U++) {
                  var te = V[U];
                  for (Xe = te; Xe !== null; ) {
                    var Se = Xe;
                    switch (Se.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qc(8, Se, T);
                    }
                    var De = Se.child;
                    if (De !== null) De.return = Se, Xe = De;
                    else for (; Xe !== null; ) {
                      Se = Xe;
                      var be = Se.sibling, Ye = Se.return;
                      if (nh(Se), Se === te) {
                        Xe = null;
                        break;
                      }
                      if (be !== null) {
                        be.return = Ye, Xe = be;
                        break;
                      }
                      Xe = Ye;
                    }
                  }
                }
                var qe = T.alternate;
                if (qe !== null) {
                  var et = qe.child;
                  if (et !== null) {
                    qe.child = null;
                    do {
                      var ni = et.sibling;
                      et.sibling = null, et = ni;
                    } while (et !== null);
                  }
                }
                Xe = T;
              }
            }
            if (T.subtreeFlags & 2064 && O !== null) O.return = T, Xe = O;
            else e: for (; Xe !== null; ) {
              if (T = Xe, T.flags & 2048) switch (T.tag) {
                case 0:
                case 11:
                case 15:
                  Qc(9, T, T.return);
              }
              var X = T.sibling;
              if (X !== null) {
                X.return = T.return, Xe = X;
                break e;
              }
              Xe = T.return;
            }
          }
          var Y = s.current;
          for (Xe = Y; Xe !== null; ) {
            O = Xe;
            var Z = O.child;
            if (O.subtreeFlags & 2064 && Z !== null) Z.return = O, Xe = Z;
            else e: for (O = Y; Xe !== null; ) {
              if (V = Xe, V.flags & 2048) try {
                switch (V.tag) {
                  case 0:
                  case 11:
                  case 15:
                    qc(9, V);
                }
              } catch (Ze) {
                Ln(V, V.return, Ze);
              }
              if (V === O) {
                Xe = null;
                break e;
              }
              var _e = V.sibling;
              if (_e !== null) {
                _e.return = V.return, Xe = _e;
                break e;
              }
              Xe = V.return;
            }
          }
          if (Ht = _, Za(), ka && typeof ka.onPostCommitFiberRoot == "function") try {
            ka.onPostCommitFiberRoot(cc, s);
          } catch {
          }
          y = !0;
        }
        return y;
      } finally {
        pn = p, Vi.transition = l;
      }
    }
    return !1;
  }
  function Qy(s, l, p) {
    l = yl(p, l), l = Ay(s, l, 1), s = ho(s, l, 1), l = mi(), s !== null && (Xo(s, 1, l), Mr(s, l));
  }
  function Ln(s, l, p) {
    if (s.tag === 3) Qy(s, s, p);
    else for (; l !== null; ) {
      if (l.tag === 3) {
        Qy(l, s, p);
        break;
      } else if (l.tag === 1) {
        var y = l.stateNode;
        if (typeof l.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (yo === null || !yo.has(y))) {
          s = yl(p, s), s = gm(l, s, 1), l = ho(l, s, 1), s = mi(), l !== null && (Xo(l, 1, s), Mr(l, s));
          break;
        }
      }
      l = l.return;
    }
  }
  function ZS(s, l, p) {
    var y = s.pingCache;
    y !== null && y.delete(l), l = mi(), s.pingedLanes |= s.suspendedLanes & p, _i === s && (ji & p) === p && (ti === 4 || ti === 3 && (ji & 130023424) === ji && 500 > At() - Em ? Ns(s, 0) : ih |= p), Mr(s, l);
  }
  function qy(s, l) {
    l === 0 && (s.mode & 1 ? (l = Ma, Ma <<= 1, !(Ma & 130023424) && (Ma = 4194304)) : l = 1);
    var p = mi();
    s = $r(s, l), s !== null && (Xo(s, l, p), Mr(s, p));
  }
  function JS(s) {
    var l = s.memoizedState, p = 0;
    l !== null && (p = l.retryLane), qy(s, p);
  }
  function Zy(s, l) {
    var p = 0;
    switch (s.tag) {
      case 13:
        var y = s.stateNode, _ = s.memoizedState;
        _ !== null && (p = _.retryLane);
        break;
      case 19:
        y = s.stateNode;
        break;
      default:
        throw Error(i(314));
    }
    y !== null && y.delete(l), qy(s, p);
  }
  var Jy;
  Jy = function(s, l, p) {
    if (s !== null) if (s.memoizedProps !== l.pendingProps || xi.current) di = !0;
    else {
      if (!(s.lanes & p) && !(l.flags & 128)) return di = !1, Gc(s, l, p);
      di = !!(s.flags & 131072);
    }
    else di = !1, Pn && l.flags & 1048576 && _y(l, ks, l.index);
    switch (l.lanes = 0, l.tag) {
      case 2:
        var y = l.type;
        ua(s, l), s = l.pendingProps;
        var _ = aa(l, Yn.current);
        Vn(l, p), _ = po(null, l, y, s, _, p);
        var T = La();
        return l.flags |= 1, typeof _ == "object" && _ !== null && typeof _.render == "function" && _.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, ui(y) ? (T = !0, wr(l)) : T = !1, l.memoizedState = _.state !== null && _.state !== void 0 ? _.state : null, lm(l), _.updater = Xd, l.stateNode = _, _._reactInternals = l, Uc(l, y, s, p), l = Wc(null, l, y, !0, T, p)) : (l.tag = 0, Pn && T && Td(l), Fi(null, l, _, p), l = l.child), l;
      case 16:
        y = l.elementType;
        e: {
          switch (ua(s, l), s = l.pendingProps, _ = y._init, y = _(y._payload), l.type = y, _ = l.tag = t_(y), s = Na(y, s), _) {
            case 0:
              l = Py(null, l, y, s, p);
              break e;
            case 1:
              l = Ly(null, l, y, s, p);
              break e;
            case 11:
              l = Dr(null, l, y, s, p);
              break e;
            case 14:
              l = bl(null, l, y, Na(y.type, s), p);
              break e;
          }
          throw Error(i(
            306,
            y,
            ""
          ));
        }
        return l;
      case 0:
        return y = l.type, _ = l.pendingProps, _ = l.elementType === y ? _ : Na(y, _), Py(s, l, y, _, p);
      case 1:
        return y = l.type, _ = l.pendingProps, _ = l.elementType === y ? _ : Na(y, _), Ly(s, l, y, _, p);
      case 3:
        e: {
          if (vu(l), s === null) throw Error(i(387));
          y = l.pendingProps, T = l.memoizedState, _ = T.element, Ty(s, l), Mc(l, y, null, p);
          var O = l.memoizedState;
          if (y = O.element, T.isDehydrated) if (T = { element: y, isDehydrated: !1, cache: O.cache, pendingSuspenseBoundaries: O.pendingSuspenseBoundaries, transitions: O.transitions }, l.updateQueue.baseState = T, l.memoizedState = T, l.flags & 256) {
            _ = yl(Error(i(423)), l), l = Ny(s, l, y, p, _);
            break e;
          } else if (y !== _) {
            _ = yl(Error(i(424)), l), l = Ny(s, l, y, p, _);
            break e;
          } else for (Tr = Xa(l.stateNode.containerInfo.firstChild), Cr = l, Pn = !0, oa = null, p = Ue(l, null, y, p), l.child = p; p; ) p.flags = p.flags & -3 | 4096, p = p.sibling;
          else {
            if (fo(), y === _) {
              l = ca(s, l, p);
              break e;
            }
            Fi(s, l, y, p);
          }
          l = l.child;
        }
        return l;
      case 5:
        return Dy(l), s === null && tm(l), y = l.type, _ = l.pendingProps, T = s !== null ? s.memoizedProps : null, O = _.children, xd(y, _) ? O = null : T !== null && xd(y, T) && (l.flags |= 32), ym(s, l), Fi(s, l, O, p), l.child;
      case 6:
        return s === null && tm(l), null;
      case 13:
        return Jd(s, l, p);
      case 4:
        return cm(l, l.stateNode.containerInfo), y = l.pendingProps, s === null ? l.child = Zn(l, null, y, p) : Fi(s, l, y, p), l.child;
      case 11:
        return y = l.type, _ = l.pendingProps, _ = l.elementType === y ? _ : Na(y, _), Dr(s, l, y, _, p);
      case 7:
        return Fi(s, l, l.pendingProps, p), l.child;
      case 8:
        return Fi(s, l, l.pendingProps.children, p), l.child;
      case 12:
        return Fi(s, l, l.pendingProps.children, p), l.child;
      case 10:
        e: {
          if (y = l.type._context, _ = l.pendingProps, T = l.memoizedProps, O = _.value, at(Ir, y._currentValue), y._currentValue = O, T !== null) if (Aa(T.value, O)) {
            if (T.children === _.children && !xi.current) {
              l = ca(s, l, p);
              break e;
            }
          } else for (T = l.child, T !== null && (T.return = l); T !== null; ) {
            var V = T.dependencies;
            if (V !== null) {
              O = T.child;
              for (var U = V.firstContext; U !== null; ) {
                if (U.context === y) {
                  if (T.tag === 1) {
                    U = As(-1, p & -p), U.tag = 2;
                    var te = T.updateQueue;
                    if (te !== null) {
                      te = te.shared;
                      var Se = te.pending;
                      Se === null ? U.next = U : (U.next = Se.next, Se.next = U), te.pending = U;
                    }
                  }
                  T.lanes |= p, U = T.alternate, U !== null && (U.lanes |= p), am(
                    T.return,
                    p,
                    l
                  ), V.lanes |= p;
                  break;
                }
                U = U.next;
              }
            } else if (T.tag === 10) O = T.type === l.type ? null : T.child;
            else if (T.tag === 18) {
              if (O = T.return, O === null) throw Error(i(341));
              O.lanes |= p, V = O.alternate, V !== null && (V.lanes |= p), am(O, p, l), O = T.sibling;
            } else O = T.child;
            if (O !== null) O.return = T;
            else for (O = T; O !== null; ) {
              if (O === l) {
                O = null;
                break;
              }
              if (T = O.sibling, T !== null) {
                T.return = O.return, O = T;
                break;
              }
              O = O.return;
            }
            T = O;
          }
          Fi(s, l, _.children, p), l = l.child;
        }
        return l;
      case 9:
        return _ = l.type, y = l.pendingProps.children, Vn(l, p), _ = la(_), y = y(_), l.flags |= 1, Fi(s, l, y, p), l.child;
      case 14:
        return y = l.type, _ = Na(y, l.pendingProps), _ = Na(y.type, _), bl(s, l, y, _, p);
      case 15:
        return Mt(s, l, l.type, l.pendingProps, p);
      case 17:
        return y = l.type, _ = l.pendingProps, _ = l.elementType === y ? _ : Na(y, _), ua(s, l), l.tag = 1, ui(y) ? (s = !0, wr(l)) : s = !1, Vn(l, p), Qd(l, y, _), Uc(l, y, _, p), Wc(null, l, y, !0, s, p);
      case 19:
        return ns(s, l, p);
      case 22:
        return $c(s, l, p);
    }
    throw Error(i(156, l.tag));
  };
  function e0(s, l) {
    return Fn(s, l);
  }
  function e_(s, l, p, y) {
    this.tag = s, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function da(s, l, p, y) {
    return new e_(s, l, p, y);
  }
  function Am(s) {
    return s = s.prototype, !(!s || !s.isReactComponent);
  }
  function t_(s) {
    if (typeof s == "function") return Am(s) ? 1 : 0;
    if (s != null) {
      if (s = s.$$typeof, s === re) return 11;
      if (s === Ee) return 14;
    }
    return 2;
  }
  function xo(s, l) {
    var p = s.alternate;
    return p === null ? (p = da(s.tag, l, s.key, s.mode), p.elementType = s.elementType, p.type = s.type, p.stateNode = s.stateNode, p.alternate = s, s.alternate = p) : (p.pendingProps = l, p.type = s.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = s.flags & 14680064, p.childLanes = s.childLanes, p.lanes = s.lanes, p.child = s.child, p.memoizedProps = s.memoizedProps, p.memoizedState = s.memoizedState, p.updateQueue = s.updateQueue, l = s.dependencies, p.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, p.sibling = s.sibling, p.index = s.index, p.ref = s.ref, p;
  }
  function sf(s, l, p, y, _, T) {
    var O = 2;
    if (y = s, typeof s == "function") Am(s) && (O = 1);
    else if (typeof s == "string") O = 5;
    else e: switch (s) {
      case I:
        return zs(p.children, _, T, l);
      case K:
        O = 8, _ |= 8;
        break;
      case ee:
        return s = da(12, p, l, _ | 2), s.elementType = ee, s.lanes = T, s;
      case se:
        return s = da(13, p, l, _), s.elementType = se, s.lanes = T, s;
      case Ne:
        return s = da(19, p, l, _), s.elementType = Ne, s.lanes = T, s;
      case Oe:
        return So(p, _, T, l);
      default:
        if (typeof s == "object" && s !== null) switch (s.$$typeof) {
          case ne:
            O = 10;
            break e;
          case le:
            O = 9;
            break e;
          case re:
            O = 11;
            break e;
          case Ee:
            O = 14;
            break e;
          case we:
            O = 16, y = null;
            break e;
        }
        throw Error(i(130, s == null ? s : typeof s, ""));
    }
    return l = da(O, p, l, _), l.elementType = s, l.type = y, l.lanes = T, l;
  }
  function zs(s, l, p, y) {
    return s = da(7, s, y, l), s.lanes = p, s;
  }
  function So(s, l, p, y) {
    return s = da(22, s, y, l), s.elementType = Oe, s.lanes = p, s.stateNode = { isHidden: !1 }, s;
  }
  function Om(s, l, p) {
    return s = da(6, s, null, l), s.lanes = p, s;
  }
  function oh(s, l, p) {
    return l = da(4, s.children !== null ? s.children : [], s.key, l), l.lanes = p, l.stateNode = { containerInfo: s.containerInfo, pendingChildren: null, implementation: s.implementation }, l;
  }
  function t0(s, l, p, y, _) {
    this.tag = l, this.containerInfo = s, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Cp(0), this.expirationTimes = Cp(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Cp(0), this.identifierPrefix = y, this.onRecoverableError = _, this.mutableSourceEagerHydrationData = null;
  }
  function lh(s, l, p, y, _, T, O, V, U) {
    return s = new t0(s, l, p, V, U), l === 1 ? (l = 1, T === !0 && (l |= 8)) : l = 0, T = da(3, null, null, l), s.current = T, T.stateNode = s, T.memoizedState = { element: y, isDehydrated: p, cache: null, transitions: null, pendingSuspenseBoundaries: null }, lm(T), s;
  }
  function n_(s, l, p) {
    var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: $, key: y == null ? null : "" + y, children: s, containerInfo: l, implementation: p };
  }
  function Pm(s) {
    if (!s) return Sr;
    s = s._reactInternals;
    e: {
      if (ct(s) !== s || s.tag !== 1) throw Error(i(170));
      var l = s;
      do {
        switch (l.tag) {
          case 3:
            l = l.stateNode.context;
            break e;
          case 1:
            if (ui(l.type)) {
              l = l.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        l = l.return;
      } while (l !== null);
      throw Error(i(171));
    }
    if (s.tag === 1) {
      var p = s.type;
      if (ui(p)) return Rc(s, p, l);
    }
    return l;
  }
  function n0(s, l, p, y, _, T, O, V, U) {
    return s = lh(p, y, !0, s, _, T, O, V, U), s.context = Pm(null), p = s.current, y = mi(), _ = ss(p), T = As(y, _), T.callback = l ?? null, ho(p, T, _), s.current.lanes = _, Xo(s, _, y), Mr(s, y), s;
  }
  function uh(s, l, p, y) {
    var _ = l.current, T = mi(), O = ss(_);
    return p = Pm(p), l.context === null ? l.context = p : l.pendingContext = p, l = As(T, O), l.payload = { element: s }, y = y === void 0 ? null : y, y !== null && (l.callback = y), s = ho(_, l, O), s !== null && (sr(s, _, O, T), kd(s, _, O)), O;
  }
  function ch(s) {
    if (s = s.current, !s.child) return null;
    switch (s.child.tag) {
      case 5:
        return s.child.stateNode;
      default:
        return s.child.stateNode;
    }
  }
  function Lm(s, l) {
    if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
      var p = s.retryLane;
      s.retryLane = p !== 0 && p < l ? p : l;
    }
  }
  function fh(s, l) {
    Lm(s, l), (s = s.alternate) && Lm(s, l);
  }
  function i0() {
    return null;
  }
  var Tl = typeof reportError == "function" ? reportError : function(s) {
    console.error(s);
  };
  function Nm(s) {
    this._internalRoot = s;
  }
  dh.prototype.render = Nm.prototype.render = function(s) {
    var l = this._internalRoot;
    if (l === null) throw Error(i(409));
    uh(s, l, null, null);
  }, dh.prototype.unmount = Nm.prototype.unmount = function() {
    var s = this._internalRoot;
    if (s !== null) {
      this._internalRoot = null;
      var l = s.containerInfo;
      wl(function() {
        uh(null, s, null, null);
      }), l[Ds] = null;
    }
  };
  function dh(s) {
    this._internalRoot = s;
  }
  dh.prototype.unstable_scheduleHydration = function(s) {
    if (s) {
      var l = kt();
      s = { blockedOn: null, target: s, priority: l };
      for (var p = 0; p < Li.length && l !== 0 && l < Li[p].priority; p++) ;
      Li.splice(p, 0, s), p === 0 && Mp(s);
    }
  };
  function zm(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11);
  }
  function hh(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11 && (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "));
  }
  function r0() {
  }
  function i_(s, l, p, y, _) {
    if (_) {
      if (typeof y == "function") {
        var T = y;
        y = function() {
          var te = ch(O);
          T.call(te);
        };
      }
      var O = n0(l, y, s, 0, null, !1, !1, "", r0);
      return s._reactRootContainer = O, s[Ds] = O.current, ou(s.nodeType === 8 ? s.parentNode : s), wl(), O;
    }
    for (; _ = s.lastChild; ) s.removeChild(_);
    if (typeof y == "function") {
      var V = y;
      y = function() {
        var te = ch(U);
        V.call(te);
      };
    }
    var U = lh(s, 0, !1, null, null, !1, !1, "", r0);
    return s._reactRootContainer = U, s[Ds] = U.current, ou(s.nodeType === 8 ? s.parentNode : s), wl(function() {
      uh(l, U, p, y);
    }), U;
  }
  function of(s, l, p, y, _) {
    var T = p._reactRootContainer;
    if (T) {
      var O = T;
      if (typeof _ == "function") {
        var V = _;
        _ = function() {
          var U = ch(O);
          V.call(U);
        };
      }
      uh(l, O, s, _);
    } else O = i_(p, l, s, _, y);
    return ch(O);
  }
  mn = function(s) {
    switch (s.tag) {
      case 3:
        var l = s.stateNode;
        if (l.current.memoizedState.isDehydrated) {
          var p = Go(l.pendingLanes);
          p !== 0 && (Zf(l, p | 1), Mr(l, At()), !(Ht & 6) && (Su = At() + 500, Za()));
        }
        break;
      case 13:
        wl(function() {
          var y = $r(s, 1);
          if (y !== null) {
            var _ = mi();
            sr(y, s, 1, _);
          }
        }), fh(s, 1);
    }
  }, Ep = function(s) {
    if (s.tag === 13) {
      var l = $r(s, 134217728);
      if (l !== null) {
        var p = mi();
        sr(l, s, 134217728, p);
      }
      fh(s, 134217728);
    }
  }, Dp = function(s) {
    if (s.tag === 13) {
      var l = ss(s), p = $r(s, l);
      if (p !== null) {
        var y = mi();
        sr(p, s, l, y);
      }
      fh(s, l);
    }
  }, kt = function() {
    return pn;
  }, Rp = function(s, l) {
    var p = pn;
    try {
      return pn = s, l();
    } finally {
      pn = p;
    }
  }, Qt = function(s, l, p) {
    switch (l) {
      case "input":
        if (an(s, p), l = p.name, p.type === "radio" && l != null) {
          for (p = s; p.parentNode; ) p = p.parentNode;
          for (p = p.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < p.length; l++) {
            var y = p[l];
            if (y !== s && y.form === s.form) {
              var _ = qn(y);
              if (!_) throw Error(i(90));
              St(y), an(y, _);
            }
          }
        }
        break;
      case "textarea":
        wn(s, p);
        break;
      case "select":
        l = p.value, l != null && Ot(s, !!p.multiple, l, !1);
    }
  }, mt = Rm, de = wl;
  var r_ = { usingClientEntryPoint: !1, Events: [st, Oa, qn, Fe, Qe, Rm] }, lf = { findFiberByHostInstance: al, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, a0 = { bundleType: lf.bundleType, version: lf.version, rendererPackageName: lf.rendererPackageName, rendererConfig: lf.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: j.ReactCurrentDispatcher, findHostInstanceByFiber: function(s) {
    return s = bi(s), s === null ? null : s.stateNode;
  }, findFiberByHostInstance: lf.findFiberByHostInstance || i0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var _o = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!_o.isDisabled && _o.supportsFiber) try {
      cc = _o.inject(a0), ka = _o;
    } catch {
    }
  }
  return ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = r_, ba.createPortal = function(s, l) {
    var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!zm(l)) throw Error(i(200));
    return n_(s, l, null, p);
  }, ba.createRoot = function(s, l) {
    if (!zm(s)) throw Error(i(299));
    var p = !1, y = "", _ = Tl;
    return l != null && (l.unstable_strictMode === !0 && (p = !0), l.identifierPrefix !== void 0 && (y = l.identifierPrefix), l.onRecoverableError !== void 0 && (_ = l.onRecoverableError)), l = lh(s, 1, !1, null, null, p, !1, y, _), s[Ds] = l.current, ou(s.nodeType === 8 ? s.parentNode : s), new Nm(l);
  }, ba.findDOMNode = function(s) {
    if (s == null) return null;
    if (s.nodeType === 1) return s;
    var l = s._reactInternals;
    if (l === void 0)
      throw typeof s.render == "function" ? Error(i(188)) : (s = Object.keys(s).join(","), Error(i(268, s)));
    return s = bi(l), s = s === null ? null : s.stateNode, s;
  }, ba.flushSync = function(s) {
    return wl(s);
  }, ba.hydrate = function(s, l, p) {
    if (!hh(l)) throw Error(i(200));
    return of(null, s, l, !0, p);
  }, ba.hydrateRoot = function(s, l, p) {
    if (!zm(s)) throw Error(i(405));
    var y = p != null && p.hydratedSources || null, _ = !1, T = "", O = Tl;
    if (p != null && (p.unstable_strictMode === !0 && (_ = !0), p.identifierPrefix !== void 0 && (T = p.identifierPrefix), p.onRecoverableError !== void 0 && (O = p.onRecoverableError)), l = n0(l, null, s, 1, p ?? null, _, !1, T, O), s[Ds] = l.current, ou(s), y) for (s = 0; s < y.length; s++) p = y[s], _ = p._getVersion, _ = _(p._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [p, _] : l.mutableSourceEagerHydrationData.push(
      p,
      _
    );
    return new dh(l);
  }, ba.render = function(s, l, p) {
    if (!hh(l)) throw Error(i(200));
    return of(null, s, l, !1, p);
  }, ba.unmountComponentAtNode = function(s) {
    if (!hh(s)) throw Error(i(40));
    return s._reactRootContainer ? (wl(function() {
      of(null, null, s, !1, function() {
        s._reactRootContainer = null, s[Ds] = null;
      });
    }), !0) : !1;
  }, ba.unstable_batchedUpdates = Rm, ba.unstable_renderSubtreeIntoContainer = function(s, l, p, y) {
    if (!hh(p)) throw Error(i(200));
    if (s == null || s._reactInternals === void 0) throw Error(i(38));
    return of(s, l, p, !1, y);
  }, ba.version = "18.3.1-next-f1338f8080-20240426", ba;
}
var xa = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JA;
function J4() {
  return JA || (JA = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = rp, e = sN(), i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, a = !1;
    function o(n) {
      a = n;
    }
    function c(n) {
      if (!a) {
        for (var r = arguments.length, f = new Array(r > 1 ? r - 1 : 0), d = 1; d < r; d++)
          f[d - 1] = arguments[d];
        h("warn", n, f);
      }
    }
    function u(n) {
      if (!a) {
        for (var r = arguments.length, f = new Array(r > 1 ? r - 1 : 0), d = 1; d < r; d++)
          f[d - 1] = arguments[d];
        h("error", n, f);
      }
    }
    function h(n, r, f) {
      {
        var d = i.ReactDebugCurrentFrame, g = d.getStackAddendum();
        g !== "" && (r += "%s", f = f.concat([g]));
        var x = f.map(function(C) {
          return String(C);
        });
        x.unshift("Warning: " + r), Function.prototype.apply.call(console[n], console, x);
      }
    }
    var m = 0, v = 1, b = 2, S = 3, w = 4, E = 5, R = 6, M = 7, A = 8, P = 9, z = 10, B = 11, j = 12, F = 13, $ = 14, I = 15, K = 16, ee = 17, ne = 18, le = 19, re = 21, se = 22, Ne = 23, Ee = 24, we = 25, Oe = !0, ae = !1, me = !1, pe = !1, Ce = !1, oe = !0, Me = !0, Pe = !0, fe = !0, Le = /* @__PURE__ */ new Set(), Te = {}, xe = {};
    function it(n, r) {
      dt(n, r), dt(n + "Capture", r);
    }
    function dt(n, r) {
      Te[n] && u("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", n), Te[n] = r;
      {
        var f = n.toLowerCase();
        xe[f] = n, n === "onDoubleClick" && (xe.ondblclick = n);
      }
      for (var d = 0; d < r.length; d++)
        Le.add(r[d]);
    }
    var lt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", St = Object.prototype.hasOwnProperty;
    function _t(n) {
      {
        var r = typeof Symbol == "function" && Symbol.toStringTag, f = r && n[Symbol.toStringTag] || n.constructor.name || "Object";
        return f;
      }
    }
    function rt(n) {
      try {
        return xt(n), !1;
      } catch {
        return !0;
      }
    }
    function xt(n) {
      return "" + n;
    }
    function Wt(n, r) {
      if (rt(n))
        return u("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", r, _t(n)), xt(n);
    }
    function an(n) {
      if (rt(n))
        return u("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", _t(n)), xt(n);
    }
    function sn(n, r) {
      if (rt(n))
        return u("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", r, _t(n)), xt(n);
    }
    function Yt(n, r) {
      if (rt(n))
        return u("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", r, _t(n)), xt(n);
    }
    function Gt(n) {
      if (rt(n))
        return u("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", _t(n)), xt(n);
    }
    function Ot(n) {
      if (rt(n))
        return u("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", _t(n)), xt(n);
    }
    var wt = 0, Kt = 1, wn = 2, Mn = 3, oi = 4, Pi = 5, er = 6, Ei = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ze = Ei + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", tt = new RegExp("^[" + Ei + "][" + ze + "]*$"), Et = {}, Xt = {};
    function ln(n) {
      return St.call(Xt, n) ? !0 : St.call(Et, n) ? !1 : tt.test(n) ? (Xt[n] = !0, !0) : (Et[n] = !0, u("Invalid attribute name: `%s`", n), !1);
    }
    function dn(n, r, f) {
      return r !== null ? r.type === wt : f ? !1 : n.length > 2 && (n[0] === "o" || n[0] === "O") && (n[1] === "n" || n[1] === "N");
    }
    function gn(n, r, f, d) {
      if (f !== null && f.type === wt)
        return !1;
      switch (typeof r) {
        case "function":
        // $FlowIssue symbol is perfectly valid here
        case "symbol":
          return !0;
        case "boolean": {
          if (d)
            return !1;
          if (f !== null)
            return !f.acceptsBooleans;
          var g = n.toLowerCase().slice(0, 5);
          return g !== "data-" && g !== "aria-";
        }
        default:
          return !1;
      }
    }
    function zn(n, r, f, d) {
      if (r === null || typeof r > "u" || gn(n, r, f, d))
        return !0;
      if (d)
        return !1;
      if (f !== null)
        switch (f.type) {
          case Mn:
            return !r;
          case oi:
            return r === !1;
          case Pi:
            return isNaN(r);
          case er:
            return isNaN(r) || r < 1;
        }
      return !1;
    }
    function on(n) {
      return Qt.hasOwnProperty(n) ? Qt[n] : null;
    }
    function jt(n, r, f, d, g, x, C) {
      this.acceptsBooleans = r === wn || r === Mn || r === oi, this.attributeName = d, this.attributeNamespace = g, this.mustUseProperty = f, this.propertyName = n, this.type = r, this.sanitizeURL = x, this.removeEmptyString = C;
    }
    var Qt = {}, Di = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Di.forEach(function(n) {
      Qt[n] = new jt(
        n,
        wt,
        !1,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
      var r = n[0], f = n[1];
      Qt[r] = new jt(
        r,
        Kt,
        !1,
        // mustUseProperty
        f,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
      Qt[n] = new jt(
        n,
        wn,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
      Qt[n] = new jt(
        n,
        wn,
        !1,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(n) {
      Qt[n] = new jt(
        n,
        Mn,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      Qt[n] = new jt(
        n,
        Mn,
        !0,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      Qt[n] = new jt(
        n,
        oi,
        !1,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      Qt[n] = new jt(
        n,
        er,
        !1,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(n) {
      Qt[n] = new jt(
        n,
        Pi,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var yi = /[\-\:]([a-z])/g, He = function(n) {
      return n[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      var r = n.replace(yi, He);
      Qt[r] = new jt(
        r,
        Kt,
        !1,
        // mustUseProperty
        n,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      var r = n.replace(yi, He);
      Qt[r] = new jt(
        r,
        Kt,
        !1,
        // mustUseProperty
        n,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      var r = n.replace(yi, He);
      Qt[r] = new jt(
        r,
        Kt,
        !1,
        // mustUseProperty
        n,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(n) {
      Qt[n] = new jt(
        n,
        Kt,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Fe = "xlinkHref";
    Qt[Fe] = new jt(
      "xlinkHref",
      Kt,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(n) {
      Qt[n] = new jt(
        n,
        Kt,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Qe = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, mt = !1;
    function de(n) {
      !mt && Qe.test(n) && (mt = !0, u("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(n)));
    }
    function ve(n, r, f, d) {
      if (d.mustUseProperty) {
        var g = d.propertyName;
        return n[g];
      } else {
        Wt(f, r), d.sanitizeURL && de("" + f);
        var x = d.attributeName, C = null;
        if (d.type === oi) {
          if (n.hasAttribute(x)) {
            var D = n.getAttribute(x);
            return D === "" ? !0 : zn(r, f, d, !1) ? D : D === "" + f ? f : D;
          }
        } else if (n.hasAttribute(x)) {
          if (zn(r, f, d, !1))
            return n.getAttribute(x);
          if (d.type === Mn)
            return f;
          C = n.getAttribute(x);
        }
        return zn(r, f, d, !1) ? C === null ? f : C : C === "" + f ? f : C;
      }
    }
    function ke(n, r, f, d) {
      {
        if (!ln(r))
          return;
        if (!n.hasAttribute(r))
          return f === void 0 ? void 0 : null;
        var g = n.getAttribute(r);
        return Wt(f, r), g === "" + f ? f : g;
      }
    }
    function $e(n, r, f, d) {
      var g = on(r);
      if (!dn(r, g, d)) {
        if (zn(r, f, g, d) && (f = null), d || g === null) {
          if (ln(r)) {
            var x = r;
            f === null ? n.removeAttribute(x) : (Wt(f, r), n.setAttribute(x, "" + f));
          }
          return;
        }
        var C = g.mustUseProperty;
        if (C) {
          var D = g.propertyName;
          if (f === null) {
            var k = g.type;
            n[D] = k === Mn ? !1 : "";
          } else
            n[D] = f;
          return;
        }
        var L = g.attributeName, N = g.attributeNamespace;
        if (f === null)
          n.removeAttribute(L);
        else {
          var G = g.type, W;
          G === Mn || G === oi && f === !0 ? W = "" : (Wt(f, L), W = "" + f, g.sanitizeURL && de(W.toString())), N ? n.setAttributeNS(N, L, W) : n.setAttribute(L, W);
        }
      }
    }
    var hn = Symbol.for("react.element"), An = Symbol.for("react.portal"), yr = Symbol.for("react.fragment"), Hr = Symbol.for("react.strict_mode"), Da = Symbol.for("react.profiler"), Ra = Symbol.for("react.provider"), H = Symbol.for("react.context"), ge = Symbol.for("react.forward_ref"), Be = Symbol.for("react.suspense"), ut = Symbol.for("react.suspense_list"), ct = Symbol.for("react.memo"), Dt = Symbol.for("react.lazy"), Pt = Symbol.for("react.scope"), Ft = Symbol.for("react.debug_trace_mode"), bi = Symbol.for("react.offscreen"), On = Symbol.for("react.legacy_hidden"), Fn = Symbol.for("react.cache"), tr = Symbol.for("react.tracing_marker"), bs = Symbol.iterator, xs = "@@iterator";
    function At(n) {
      if (n === null || typeof n != "object")
        return null;
      var r = bs && n[bs] || n[xs];
      return typeof r == "function" ? r : null;
    }
    var Lt = Object.assign, Ss = 0, lc, uc, Hv, xp, cc, ka, Uv;
    function ea() {
    }
    ea.__reactDisabledLog = !0;
    function wS() {
      {
        if (Ss === 0) {
          lc = console.log, uc = console.info, Hv = console.warn, xp = console.error, cc = console.group, ka = console.groupCollapsed, Uv = console.groupEnd;
          var n = {
            configurable: !0,
            enumerable: !0,
            value: ea,
            writable: !0
          };
          Object.defineProperties(console, {
            info: n,
            log: n,
            warn: n,
            error: n,
            group: n,
            groupCollapsed: n,
            groupEnd: n
          });
        }
        Ss++;
      }
    }
    function CS() {
      {
        if (Ss--, Ss === 0) {
          var n = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Lt({}, n, {
              value: lc
            }),
            info: Lt({}, n, {
              value: uc
            }),
            warn: Lt({}, n, {
              value: Hv
            }),
            error: Lt({}, n, {
              value: xp
            }),
            group: Lt({}, n, {
              value: cc
            }),
            groupCollapsed: Lt({}, n, {
              value: ka
            }),
            groupEnd: Lt({}, n, {
              value: Uv
            })
          });
        }
        Ss < 0 && u("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Sp = i.ReactCurrentDispatcher, Jl;
    function Ma(n, r, f) {
      {
        if (Jl === void 0)
          try {
            throw Error();
          } catch (g) {
            var d = g.stack.trim().match(/\n( *(at )?)/);
            Jl = d && d[1] || "";
          }
        return `
` + Jl + n;
      }
    }
    var Go = !1, Ko;
    {
      var TS = typeof WeakMap == "function" ? WeakMap : Map;
      Ko = new TS();
    }
    function _p(n, r) {
      if (!n || Go)
        return "";
      {
        var f = Ko.get(n);
        if (f !== void 0)
          return f;
      }
      var d;
      Go = !0;
      var g = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var x;
      x = Sp.current, Sp.current = null, wS();
      try {
        if (r) {
          var C = function() {
            throw Error();
          };
          if (Object.defineProperty(C.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(C, []);
            } catch (ie) {
              d = ie;
            }
            Reflect.construct(n, [], C);
          } else {
            try {
              C.call();
            } catch (ie) {
              d = ie;
            }
            n.call(C.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ie) {
            d = ie;
          }
          n();
        }
      } catch (ie) {
        if (ie && d && typeof ie.stack == "string") {
          for (var D = ie.stack.split(`
`), k = d.stack.split(`
`), L = D.length - 1, N = k.length - 1; L >= 1 && N >= 0 && D[L] !== k[N]; )
            N--;
          for (; L >= 1 && N >= 0; L--, N--)
            if (D[L] !== k[N]) {
              if (L !== 1 || N !== 1)
                do
                  if (L--, N--, N < 0 || D[L] !== k[N]) {
                    var G = `
` + D[L].replace(" at new ", " at ");
                    return n.displayName && G.includes("<anonymous>") && (G = G.replace("<anonymous>", n.displayName)), typeof n == "function" && Ko.set(n, G), G;
                  }
                while (L >= 1 && N >= 0);
              break;
            }
        }
      } finally {
        Go = !1, Sp.current = x, CS(), Error.prepareStackTrace = g;
      }
      var W = n ? n.displayName || n.name : "", J = W ? Ma(W) : "";
      return typeof n == "function" && Ko.set(n, J), J;
    }
    function wp(n, r, f) {
      return _p(n, !0);
    }
    function qf(n, r, f) {
      return _p(n, !1);
    }
    function Cp(n) {
      var r = n.prototype;
      return !!(r && r.isReactComponent);
    }
    function Xo(n, r, f) {
      if (n == null)
        return "";
      if (typeof n == "function")
        return _p(n, Cp(n));
      if (typeof n == "string")
        return Ma(n);
      switch (n) {
        case Be:
          return Ma("Suspense");
        case ut:
          return Ma("SuspenseList");
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case ge:
            return qf(n.render);
          case ct:
            return Xo(n.type, r, f);
          case Dt: {
            var d = n, g = d._payload, x = d._init;
            try {
              return Xo(x(g), r, f);
            } catch {
            }
          }
        }
      return "";
    }
    function ES(n) {
      switch (n._debugOwner && n._debugOwner.type, n._debugSource, n.tag) {
        case E:
          return Ma(n.type);
        case K:
          return Ma("Lazy");
        case F:
          return Ma("Suspense");
        case le:
          return Ma("SuspenseList");
        case m:
        case b:
        case I:
          return qf(n.type);
        case B:
          return qf(n.type.render);
        case v:
          return wp(n.type);
        default:
          return "";
      }
    }
    function Zf(n) {
      try {
        var r = "", f = n;
        do
          r += ES(f), f = f.return;
        while (f);
        return r;
      } catch (d) {
        return `
Error generating stack: ` + d.message + `
` + d.stack;
      }
    }
    function pn(n, r, f) {
      var d = n.displayName;
      if (d)
        return d;
      var g = r.displayName || r.name || "";
      return g !== "" ? f + "(" + g + ")" : f;
    }
    function Tp(n) {
      return n.displayName || "Context";
    }
    function mn(n) {
      if (n == null)
        return null;
      if (typeof n.tag == "number" && u("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof n == "function")
        return n.displayName || n.name || null;
      if (typeof n == "string")
        return n;
      switch (n) {
        case yr:
          return "Fragment";
        case An:
          return "Portal";
        case Da:
          return "Profiler";
        case Hr:
          return "StrictMode";
        case Be:
          return "Suspense";
        case ut:
          return "SuspenseList";
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case H:
            var r = n;
            return Tp(r) + ".Consumer";
          case Ra:
            var f = n;
            return Tp(f._context) + ".Provider";
          case ge:
            return pn(n, n.render, "ForwardRef");
          case ct:
            var d = n.displayName || null;
            return d !== null ? d : mn(n.type) || "Memo";
          case Dt: {
            var g = n, x = g._payload, C = g._init;
            try {
              return mn(C(x));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Ep(n, r, f) {
      var d = r.displayName || r.name || "";
      return n.displayName || (d !== "" ? f + "(" + d + ")" : f);
    }
    function Dp(n) {
      return n.displayName || "Context";
    }
    function kt(n) {
      var r = n.tag, f = n.type;
      switch (r) {
        case Ee:
          return "Cache";
        case P:
          var d = f;
          return Dp(d) + ".Consumer";
        case z:
          var g = f;
          return Dp(g._context) + ".Provider";
        case ne:
          return "DehydratedFragment";
        case B:
          return Ep(f, f.render, "ForwardRef");
        case M:
          return "Fragment";
        case E:
          return f;
        case w:
          return "Portal";
        case S:
          return "Root";
        case R:
          return "Text";
        case K:
          return mn(f);
        case A:
          return f === Hr ? "StrictMode" : "Mode";
        case se:
          return "Offscreen";
        case j:
          return "Profiler";
        case re:
          return "Scope";
        case F:
          return "Suspense";
        case le:
          return "SuspenseList";
        case we:
          return "TracingMarker";
        // The display name for this tags come from the user-provided type:
        case v:
        case m:
        case ee:
        case b:
        case $:
        case I:
          if (typeof f == "function")
            return f.displayName || f.name || null;
          if (typeof f == "string")
            return f;
          break;
      }
      return null;
    }
    var Rp = i.ReactDebugCurrentFrame, nr = null, eo = !1;
    function ta() {
      {
        if (nr === null)
          return null;
        var n = nr._debugOwner;
        if (n !== null && typeof n < "u")
          return kt(n);
      }
      return null;
    }
    function to() {
      return nr === null ? "" : Zf(nr);
    }
    function Wn() {
      Rp.getCurrentStack = null, nr = null, eo = !1;
    }
    function Rn(n) {
      Rp.getCurrentStack = n === null ? null : to, nr = n, eo = !1;
    }
    function fc() {
      return nr;
    }
    function Li(n) {
      eo = n;
    }
    function na(n) {
      return "" + n;
    }
    function _s(n) {
      switch (typeof n) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return n;
        case "object":
          return Ot(n), n;
        default:
          return "";
      }
    }
    var dc = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function kp(n, r) {
      dc[r.type] || r.onChange || r.onInput || r.readOnly || r.disabled || r.value == null || u("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), r.onChange || r.readOnly || r.disabled || r.checked == null || u("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Mp(n) {
      var r = n.type, f = n.nodeName;
      return f && f.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
    }
    function hc(n) {
      return n._valueTracker;
    }
    function Iv(n) {
      n._valueTracker = null;
    }
    function DS(n) {
      var r = "";
      return n && (Mp(n) ? r = n.checked ? "true" : "false" : r = n.value), r;
    }
    function pc(n) {
      var r = Mp(n) ? "checked" : "value", f = Object.getOwnPropertyDescriptor(n.constructor.prototype, r);
      Ot(n[r]);
      var d = "" + n[r];
      if (!(n.hasOwnProperty(r) || typeof f > "u" || typeof f.get != "function" || typeof f.set != "function")) {
        var g = f.get, x = f.set;
        Object.defineProperty(n, r, {
          configurable: !0,
          get: function() {
            return g.call(this);
          },
          set: function(D) {
            Ot(D), d = "" + D, x.call(this, D);
          }
        }), Object.defineProperty(n, r, {
          enumerable: f.enumerable
        });
        var C = {
          getValue: function() {
            return d;
          },
          setValue: function(D) {
            Ot(D), d = "" + D;
          },
          stopTracking: function() {
            Iv(n), delete n[r];
          }
        };
        return C;
      }
    }
    function no(n) {
      hc(n) || (n._valueTracker = pc(n));
    }
    function Qo(n) {
      if (!n)
        return !1;
      var r = hc(n);
      if (!r)
        return !0;
      var f = r.getValue(), d = DS(n);
      return d !== f ? (r.setValue(d), !0) : !1;
    }
    function qo(n) {
      if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u")
        return null;
      try {
        return n.activeElement || n.body;
      } catch {
        return n.body;
      }
    }
    var $v = !1, Wv = !1, Jf = !1, mc = !1;
    function ed(n) {
      var r = n.type === "checkbox" || n.type === "radio";
      return r ? n.checked != null : n.value != null;
    }
    function td(n, r) {
      var f = n, d = r.checked, g = Lt({}, r, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: d ?? f._wrapperState.initialChecked
      });
      return g;
    }
    function ws(n, r) {
      kp("input", r), r.checked !== void 0 && r.defaultChecked !== void 0 && !Wv && (u("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ta() || "A component", r.type), Wv = !0), r.value !== void 0 && r.defaultValue !== void 0 && !$v && (u("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ta() || "A component", r.type), $v = !0);
      var f = n, d = r.defaultValue == null ? "" : r.defaultValue;
      f._wrapperState = {
        initialChecked: r.checked != null ? r.checked : r.defaultChecked,
        initialValue: _s(r.value != null ? r.value : d),
        controlled: ed(r)
      };
    }
    function nd(n, r) {
      var f = n, d = r.checked;
      d != null && $e(f, "checked", d, !1);
    }
    function eu(n, r) {
      var f = n;
      {
        var d = ed(r);
        !f._wrapperState.controlled && d && !mc && (u("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), mc = !0), f._wrapperState.controlled && !d && !Jf && (u("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Jf = !0);
      }
      nd(n, r);
      var g = _s(r.value), x = r.type;
      if (g != null)
        x === "number" ? (g === 0 && f.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        f.value != g) && (f.value = na(g)) : f.value !== na(g) && (f.value = na(g));
      else if (x === "submit" || x === "reset") {
        f.removeAttribute("value");
        return;
      }
      r.hasOwnProperty("value") ? ad(f, r.type, g) : r.hasOwnProperty("defaultValue") && ad(f, r.type, _s(r.defaultValue)), r.checked == null && r.defaultChecked != null && (f.defaultChecked = !!r.defaultChecked);
    }
    function Ap(n, r, f) {
      var d = n;
      if (r.hasOwnProperty("value") || r.hasOwnProperty("defaultValue")) {
        var g = r.type, x = g === "submit" || g === "reset";
        if (x && (r.value === void 0 || r.value === null))
          return;
        var C = na(d._wrapperState.initialValue);
        f || C !== d.value && (d.value = C), d.defaultValue = C;
      }
      var D = d.name;
      D !== "" && (d.name = ""), d.defaultChecked = !d.defaultChecked, d.defaultChecked = !!d._wrapperState.initialChecked, D !== "" && (d.name = D);
    }
    function id(n, r) {
      var f = n;
      eu(f, r), rd(f, r);
    }
    function rd(n, r) {
      var f = r.name;
      if (r.type === "radio" && f != null) {
        for (var d = n; d.parentNode; )
          d = d.parentNode;
        Wt(f, "name");
        for (var g = d.querySelectorAll("input[name=" + JSON.stringify("" + f) + '][type="radio"]'), x = 0; x < g.length; x++) {
          var C = g[x];
          if (!(C === n || C.form !== n.form)) {
            var D = w0(C);
            if (!D)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Qo(C), eu(C, D);
          }
        }
      }
    }
    function ad(n, r, f) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (r !== "number" || qo(n.ownerDocument) !== n) && (f == null ? n.defaultValue = na(n._wrapperState.initialValue) : n.defaultValue !== na(f) && (n.defaultValue = na(f)));
    }
    var br = !1, Zo = !1, sd = !1;
    function tu(n, r) {
      r.value == null && (typeof r.children == "object" && r.children !== null ? t.Children.forEach(r.children, function(f) {
        f != null && (typeof f == "string" || typeof f == "number" || Zo || (Zo = !0, u("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : r.dangerouslySetInnerHTML != null && (sd || (sd = !0, u("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), r.selected != null && !br && (u("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), br = !0);
    }
    function RS(n, r) {
      r.value != null && n.setAttribute("value", na(_s(r.value)));
    }
    var Op = Array.isArray;
    function Ni(n) {
      return Op(n);
    }
    var Jo;
    Jo = !1;
    function gc() {
      var n = ta();
      return n ? `

Check the render method of \`` + n + "`." : "";
    }
    var Pp = ["value", "defaultValue"];
    function kS(n) {
      {
        kp("select", n);
        for (var r = 0; r < Pp.length; r++) {
          var f = Pp[r];
          if (n[f] != null) {
            var d = Ni(n[f]);
            n.multiple && !d ? u("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", f, gc()) : !n.multiple && d && u("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", f, gc());
          }
        }
      }
    }
    function nu(n, r, f, d) {
      var g = n.options;
      if (r) {
        for (var x = f, C = {}, D = 0; D < x.length; D++)
          C["$" + x[D]] = !0;
        for (var k = 0; k < g.length; k++) {
          var L = C.hasOwnProperty("$" + g[k].value);
          g[k].selected !== L && (g[k].selected = L), L && d && (g[k].defaultSelected = !0);
        }
      } else {
        for (var N = na(_s(f)), G = null, W = 0; W < g.length; W++) {
          if (g[W].value === N) {
            g[W].selected = !0, d && (g[W].defaultSelected = !0);
            return;
          }
          G === null && !g[W].disabled && (G = g[W]);
        }
        G !== null && (G.selected = !0);
      }
    }
    function Lp(n, r) {
      return Lt({}, r, {
        value: void 0
      });
    }
    function od(n, r) {
      var f = n;
      kS(r), f._wrapperState = {
        wasMultiple: !!r.multiple
      }, r.value !== void 0 && r.defaultValue !== void 0 && !Jo && (u("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Jo = !0);
    }
    function MS(n, r) {
      var f = n;
      f.multiple = !!r.multiple;
      var d = r.value;
      d != null ? nu(f, !!r.multiple, d, !1) : r.defaultValue != null && nu(f, !!r.multiple, r.defaultValue, !0);
    }
    function AS(n, r) {
      var f = n, d = f._wrapperState.wasMultiple;
      f._wrapperState.wasMultiple = !!r.multiple;
      var g = r.value;
      g != null ? nu(f, !!r.multiple, g, !1) : d !== !!r.multiple && (r.defaultValue != null ? nu(f, !!r.multiple, r.defaultValue, !0) : nu(f, !!r.multiple, r.multiple ? [] : "", !1));
    }
    function OS(n, r) {
      var f = n, d = r.value;
      d != null && nu(f, !!r.multiple, d, !1);
    }
    var Yv = !1;
    function Np(n, r) {
      var f = n;
      if (r.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var d = Lt({}, r, {
        value: void 0,
        defaultValue: void 0,
        children: na(f._wrapperState.initialValue)
      });
      return d;
    }
    function zp(n, r) {
      var f = n;
      kp("textarea", r), r.value !== void 0 && r.defaultValue !== void 0 && !Yv && (u("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", ta() || "A component"), Yv = !0);
      var d = r.value;
      if (d == null) {
        var g = r.children, x = r.defaultValue;
        if (g != null) {
          u("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (x != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Ni(g)) {
              if (g.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              g = g[0];
            }
            x = g;
          }
        }
        x == null && (x = ""), d = x;
      }
      f._wrapperState = {
        initialValue: _s(d)
      };
    }
    function Gv(n, r) {
      var f = n, d = _s(r.value), g = _s(r.defaultValue);
      if (d != null) {
        var x = na(d);
        x !== f.value && (f.value = x), r.defaultValue == null && f.defaultValue !== x && (f.defaultValue = x);
      }
      g != null && (f.defaultValue = na(g));
    }
    function Kv(n, r) {
      var f = n, d = f.textContent;
      d === f._wrapperState.initialValue && d !== "" && d !== null && (f.value = d);
    }
    function PS(n, r) {
      Gv(n, r);
    }
    var Cs = "http://www.w3.org/1999/xhtml", Fp = "http://www.w3.org/1998/Math/MathML", Vp = "http://www.w3.org/2000/svg";
    function jp(n) {
      switch (n) {
        case "svg":
          return Vp;
        case "math":
          return Fp;
        default:
          return Cs;
      }
    }
    function Bp(n, r) {
      return n == null || n === Cs ? jp(r) : n === Vp && r === "foreignObject" ? Cs : n;
    }
    var Xv = function(n) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(r, f, d, g) {
        MSApp.execUnsafeLocalFunction(function() {
          return n(r, f, d, g);
        });
      } : n;
    }, ld, Qv = Xv(function(n, r) {
      if (n.namespaceURI === Vp && !("innerHTML" in n)) {
        ld = ld || document.createElement("div"), ld.innerHTML = "<svg>" + r.valueOf().toString() + "</svg>";
        for (var f = ld.firstChild; n.firstChild; )
          n.removeChild(n.firstChild);
        for (; f.firstChild; )
          n.appendChild(f.firstChild);
        return;
      }
      n.innerHTML = r;
    }), xr = 1, Ts = 3, li = 8, Es = 9, Hp = 11, iu = function(n, r) {
      if (r) {
        var f = n.firstChild;
        if (f && f === n.lastChild && f.nodeType === Ts) {
          f.nodeValue = r;
          return;
        }
      }
      n.textContent = r;
    }, vc = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, yc = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function qv(n, r) {
      return n + r.charAt(0).toUpperCase() + r.substring(1);
    }
    var Zv = ["Webkit", "ms", "Moz", "O"];
    Object.keys(yc).forEach(function(n) {
      Zv.forEach(function(r) {
        yc[qv(r, n)] = yc[n];
      });
    });
    function ud(n, r, f) {
      var d = r == null || typeof r == "boolean" || r === "";
      return d ? "" : !f && typeof r == "number" && r !== 0 && !(yc.hasOwnProperty(n) && yc[n]) ? r + "px" : (Yt(r, n), ("" + r).trim());
    }
    var Jv = /([A-Z])/g, ey = /^ms-/;
    function ru(n) {
      return n.replace(Jv, "-$1").toLowerCase().replace(ey, "-ms-");
    }
    var ty = function() {
    };
    {
      var LS = /^(?:webkit|moz|o)[A-Z]/, NS = /^-ms-/, ny = /-(.)/g, Up = /;\s*$/, Ka = {}, el = {}, iy = !1, bc = !1, zS = function(n) {
        return n.replace(ny, function(r, f) {
          return f.toUpperCase();
        });
      }, ry = function(n) {
        Ka.hasOwnProperty(n) && Ka[n] || (Ka[n] = !0, u(
          "Unsupported style property %s. Did you mean %s?",
          n,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          zS(n.replace(NS, "ms-"))
        ));
      }, Ip = function(n) {
        Ka.hasOwnProperty(n) && Ka[n] || (Ka[n] = !0, u("Unsupported vendor-prefixed style property %s. Did you mean %s?", n, n.charAt(0).toUpperCase() + n.slice(1)));
      }, $p = function(n, r) {
        el.hasOwnProperty(r) && el[r] || (el[r] = !0, u(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, n, r.replace(Up, "")));
      }, ay = function(n, r) {
        iy || (iy = !0, u("`NaN` is an invalid value for the `%s` css style property.", n));
      }, sy = function(n, r) {
        bc || (bc = !0, u("`Infinity` is an invalid value for the `%s` css style property.", n));
      };
      ty = function(n, r) {
        n.indexOf("-") > -1 ? ry(n) : LS.test(n) ? Ip(n) : Up.test(r) && $p(n, r), typeof r == "number" && (isNaN(r) ? ay(n, r) : isFinite(r) || sy(n, r));
      };
    }
    var oy = ty;
    function FS(n) {
      {
        var r = "", f = "";
        for (var d in n)
          if (n.hasOwnProperty(d)) {
            var g = n[d];
            if (g != null) {
              var x = d.indexOf("--") === 0;
              r += f + (x ? d : ru(d)) + ":", r += ud(d, g, x), f = ";";
            }
          }
        return r || null;
      }
    }
    function ly(n, r) {
      var f = n.style;
      for (var d in r)
        if (r.hasOwnProperty(d)) {
          var g = d.indexOf("--") === 0;
          g || oy(d, r[d]);
          var x = ud(d, r[d], g);
          d === "float" && (d = "cssFloat"), g ? f.setProperty(d, x) : f[d] = x;
        }
    }
    function VS(n) {
      return n == null || typeof n == "boolean" || n === "";
    }
    function uy(n) {
      var r = {};
      for (var f in n)
        for (var d = vc[f] || [f], g = 0; g < d.length; g++)
          r[d[g]] = f;
      return r;
    }
    function jS(n, r) {
      {
        if (!r)
          return;
        var f = uy(n), d = uy(r), g = {};
        for (var x in f) {
          var C = f[x], D = d[x];
          if (D && C !== D) {
            var k = C + "," + D;
            if (g[k])
              continue;
            g[k] = !0, u("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", VS(n[C]) ? "Removing" : "Updating", C, D);
          }
        }
      }
    }
    var Aa = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, xc = Lt({
      menuitem: !0
    }, Aa), cy = "__html";
    function cd(n, r) {
      if (r) {
        if (xc[n] && (r.children != null || r.dangerouslySetInnerHTML != null))
          throw new Error(n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (r.dangerouslySetInnerHTML != null) {
          if (r.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof r.dangerouslySetInnerHTML != "object" || !(cy in r.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!r.suppressContentEditableWarning && r.contentEditable && r.children != null && u("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), r.style != null && typeof r.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function io(n, r) {
      if (n.indexOf("-") === -1)
        return typeof r.is == "string";
      switch (n) {
        // These are reserved SVG and MathML elements.
        // We don't mind this list too much because we expect it to never grow.
        // The alternative is to track the namespace in a few places which is convoluted.
        // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Sc = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, fd = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, au = {}, BS = new RegExp("^(aria)-[" + ze + "]*$"), su = new RegExp("^(aria)[A-Z][" + ze + "]*$");
    function Wp(n, r) {
      {
        if (St.call(au, r) && au[r])
          return !0;
        if (su.test(r)) {
          var f = "aria-" + r.slice(4).toLowerCase(), d = fd.hasOwnProperty(f) ? f : null;
          if (d == null)
            return u("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", r), au[r] = !0, !0;
          if (r !== d)
            return u("Invalid ARIA attribute `%s`. Did you mean `%s`?", r, d), au[r] = !0, !0;
        }
        if (BS.test(r)) {
          var g = r.toLowerCase(), x = fd.hasOwnProperty(g) ? g : null;
          if (x == null)
            return au[r] = !0, !1;
          if (r !== x)
            return u("Unknown ARIA attribute `%s`. Did you mean `%s`?", r, x), au[r] = !0, !0;
        }
      }
      return !0;
    }
    function _c(n, r) {
      {
        var f = [];
        for (var d in r) {
          var g = Wp(n, d);
          g || f.push(d);
        }
        var x = f.map(function(C) {
          return "`" + C + "`";
        }).join(", ");
        f.length === 1 ? u("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", x, n) : f.length > 1 && u("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", x, n);
      }
    }
    function Yp(n, r) {
      io(n, r) || _c(n, r);
    }
    var Gp = !1;
    function dd(n, r) {
      {
        if (n !== "input" && n !== "textarea" && n !== "select")
          return;
        r != null && r.value === null && !Gp && (Gp = !0, n === "select" && r.multiple ? u("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", n) : u("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", n));
      }
    }
    var tl = function() {
    };
    {
      var zi = {}, Kp = /^on./, hd = /^on[^A-Z]/, fy = new RegExp("^(aria)-[" + ze + "]*$"), dy = new RegExp("^(aria)[A-Z][" + ze + "]*$");
      tl = function(n, r, f, d) {
        if (St.call(zi, r) && zi[r])
          return !0;
        var g = r.toLowerCase();
        if (g === "onfocusin" || g === "onfocusout")
          return u("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), zi[r] = !0, !0;
        if (d != null) {
          var x = d.registrationNameDependencies, C = d.possibleRegistrationNames;
          if (x.hasOwnProperty(r))
            return !0;
          var D = C.hasOwnProperty(g) ? C[g] : null;
          if (D != null)
            return u("Invalid event handler property `%s`. Did you mean `%s`?", r, D), zi[r] = !0, !0;
          if (Kp.test(r))
            return u("Unknown event handler property `%s`. It will be ignored.", r), zi[r] = !0, !0;
        } else if (Kp.test(r))
          return hd.test(r) && u("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", r), zi[r] = !0, !0;
        if (fy.test(r) || dy.test(r))
          return !0;
        if (g === "innerhtml")
          return u("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), zi[r] = !0, !0;
        if (g === "aria")
          return u("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), zi[r] = !0, !0;
        if (g === "is" && f !== null && f !== void 0 && typeof f != "string")
          return u("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof f), zi[r] = !0, !0;
        if (typeof f == "number" && isNaN(f))
          return u("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", r), zi[r] = !0, !0;
        var k = on(r), L = k !== null && k.type === wt;
        if (Sc.hasOwnProperty(g)) {
          var N = Sc[g];
          if (N !== r)
            return u("Invalid DOM property `%s`. Did you mean `%s`?", r, N), zi[r] = !0, !0;
        } else if (!L && r !== g)
          return u("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", r, g), zi[r] = !0, !0;
        return typeof f == "boolean" && gn(r, f, k, !1) ? (f ? u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', f, r, r, f, r) : u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', f, r, r, f, r, r, r), zi[r] = !0, !0) : L ? !0 : gn(r, f, k, !1) ? (zi[r] = !0, !1) : ((f === "false" || f === "true") && k !== null && k.type === Mn && (u("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", f, r, f === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', r, f), zi[r] = !0), !0);
      };
    }
    var hy = function(n, r, f) {
      {
        var d = [];
        for (var g in r) {
          var x = tl(n, g, r[g], f);
          x || d.push(g);
        }
        var C = d.map(function(D) {
          return "`" + D + "`";
        }).join(", ");
        d.length === 1 ? u("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", C, n) : d.length > 1 && u("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", C, n);
      }
    };
    function py(n, r, f) {
      io(n, r) || hy(n, r, f);
    }
    var Xp = 1, pd = 2, ia = 4, Qp = Xp | pd | ia, nl = null;
    function HS(n) {
      nl !== null && u("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), nl = n;
    }
    function US() {
      nl === null && u("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), nl = null;
    }
    function wc(n) {
      return n === nl;
    }
    function qp(n) {
      var r = n.target || n.srcElement || window;
      return r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === Ts ? r.parentNode : r;
    }
    var md = null, il = null, un = null;
    function gd(n) {
      var r = Du(n);
      if (r) {
        if (typeof md != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var f = r.stateNode;
        if (f) {
          var d = w0(f);
          md(r.stateNode, r.type, d);
        }
      }
    }
    function vd(n) {
      md = n;
    }
    function ou(n) {
      il ? un ? un.push(n) : un = [n] : il = n;
    }
    function my() {
      return il !== null || un !== null;
    }
    function yd() {
      if (il) {
        var n = il, r = un;
        if (il = null, un = null, gd(n), r)
          for (var f = 0; f < r.length; f++)
            gd(r[f]);
      }
    }
    var lu = function(n, r) {
      return n(r);
    }, Cc = function() {
    }, ro = !1;
    function gy() {
      var n = my();
      n && (Cc(), yd());
    }
    function vy(n, r, f) {
      if (ro)
        return n(r, f);
      ro = !0;
      try {
        return lu(n, r, f);
      } finally {
        ro = !1, gy();
      }
    }
    function IS(n, r, f) {
      lu = n, Cc = f;
    }
    function yy(n) {
      return n === "button" || n === "input" || n === "select" || n === "textarea";
    }
    function bd(n, r, f) {
      switch (n) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(f.disabled && yy(r));
        default:
          return !1;
      }
    }
    function ao(n, r) {
      var f = n.stateNode;
      if (f === null)
        return null;
      var d = w0(f);
      if (d === null)
        return null;
      var g = d[r];
      if (bd(r, n.type, d))
        return null;
      if (g && typeof g != "function")
        throw new Error("Expected `" + r + "` listener to be a function, instead got a value of `" + typeof g + "` type.");
      return g;
    }
    var Tc = !1;
    if (lt)
      try {
        var rl = {};
        Object.defineProperty(rl, "passive", {
          get: function() {
            Tc = !0;
          }
        }), window.addEventListener("test", rl, rl), window.removeEventListener("test", rl, rl);
      } catch {
        Tc = !1;
      }
    function xd(n, r, f, d, g, x, C, D, k) {
      var L = Array.prototype.slice.call(arguments, 3);
      try {
        r.apply(f, L);
      } catch (N) {
        this.onError(N);
      }
    }
    var Sd = xd;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Zp = document.createElement("react");
      Sd = function(r, f, d, g, x, C, D, k, L) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var N = document.createEvent("Event"), G = !1, W = !0, J = window.event, ie = Object.getOwnPropertyDescriptor(window, "event");
        function ue() {
          Zp.removeEventListener(ce, ft, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = J);
        }
        var Ie = Array.prototype.slice.call(arguments, 3);
        function ft() {
          G = !0, ue(), f.apply(d, Ie), W = !1;
        }
        var nt, It = !1, Vt = !1;
        function Q(q) {
          if (nt = q.error, It = !0, nt === null && q.colno === 0 && q.lineno === 0 && (Vt = !0), q.defaultPrevented && nt != null && typeof nt == "object")
            try {
              nt._suppressLogging = !0;
            } catch {
            }
        }
        var ce = "react-" + (r || "invokeguardedcallback");
        if (window.addEventListener("error", Q), Zp.addEventListener(ce, ft, !1), N.initEvent(ce, !1, !1), Zp.dispatchEvent(N), ie && Object.defineProperty(window, "event", ie), G && W && (It ? Vt && (nt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : nt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(nt)), window.removeEventListener("error", Q), !G)
          return ue(), xd.apply(this, arguments);
      };
    }
    var by = Sd, uu = !1, _d = null, cu = !1, Xa = null, xy = {
      onError: function(n) {
        uu = !0, _d = n;
      }
    };
    function so(n, r, f, d, g, x, C, D, k) {
      uu = !1, _d = null, by.apply(xy, arguments);
    }
    function Qa(n, r, f, d, g, x, C, D, k) {
      if (so.apply(this, arguments), uu) {
        var L = Dc();
        cu || (cu = !0, Xa = L);
      }
    }
    function Ec() {
      if (cu) {
        var n = Xa;
        throw cu = !1, Xa = null, n;
      }
    }
    function Ds() {
      return uu;
    }
    function Dc() {
      if (uu) {
        var n = _d;
        return uu = !1, _d = null, n;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function fu(n) {
      return n._reactInternals;
    }
    function $S(n) {
      return n._reactInternals !== void 0;
    }
    function al(n, r) {
      n._reactInternals = r;
    }
    var st = (
      /*                      */
      0
    ), Oa = (
      /*                */
      1
    ), qn = (
      /*                    */
      2
    ), Bt = (
      /*                       */
      4
    ), ra = (
      /*                */
      16
    ), Pa = (
      /*                 */
      32
    ), Cn = (
      /*                     */
      64
    ), at = (
      /*                   */
      128
    ), Sr = (
      /*            */
      256
    ), Yn = (
      /*                          */
      512
    ), xi = (
      /*                     */
      1024
    ), _r = (
      /*                      */
      2048
    ), aa = (
      /*                    */
      4096
    ), ui = (
      /*                   */
      8192
    ), du = (
      /*             */
      16384
    ), Sy = (
      /*               */
      32767
    ), Rc = (
      /*                   */
      32768
    ), wr = (
      /*                */
      65536
    ), wd = (
      /* */
      131072
    ), qa = (
      /*                       */
      1048576
    ), hu = (
      /*                    */
      2097152
    ), Rs = (
      /*                 */
      4194304
    ), Cd = (
      /*                */
      8388608
    ), oo = (
      /*               */
      16777216
    ), Za = (
      /*              */
      33554432
    ), lo = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Bt | xi | 0
    ), uo = qn | Bt | ra | Pa | Yn | aa | ui, co = Bt | Cn | Yn | ui, ks = _r | ra, ci = Rs | Cd | hu, sa = i.ReactCurrentOwner;
    function Ur(n) {
      var r = n, f = n;
      if (n.alternate)
        for (; r.return; )
          r = r.return;
      else {
        var d = r;
        do
          r = d, (r.flags & (qn | aa)) !== st && (f = r.return), d = r.return;
        while (d);
      }
      return r.tag === S ? f : null;
    }
    function Ja(n) {
      if (n.tag === F) {
        var r = n.memoizedState;
        if (r === null) {
          var f = n.alternate;
          f !== null && (r = f.memoizedState);
        }
        if (r !== null)
          return r.dehydrated;
      }
      return null;
    }
    function es(n) {
      return n.tag === S ? n.stateNode.containerInfo : null;
    }
    function sl(n) {
      return Ur(n) === n;
    }
    function _y(n) {
      {
        var r = sa.current;
        if (r !== null && r.tag === v) {
          var f = r, d = f.stateNode;
          d._warnedAboutRefsInRender || u("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", kt(f) || "A component"), d._warnedAboutRefsInRender = !0;
        }
      }
      var g = fu(n);
      return g ? Ur(g) === g : !1;
    }
    function Td(n) {
      if (Ur(n) !== n)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Ed(n) {
      var r = n.alternate;
      if (!r) {
        var f = Ur(n);
        if (f === null)
          throw new Error("Unable to find node on an unmounted component.");
        return f !== n ? null : n;
      }
      for (var d = n, g = r; ; ) {
        var x = d.return;
        if (x === null)
          break;
        var C = x.alternate;
        if (C === null) {
          var D = x.return;
          if (D !== null) {
            d = g = D;
            continue;
          }
          break;
        }
        if (x.child === C.child) {
          for (var k = x.child; k; ) {
            if (k === d)
              return Td(x), n;
            if (k === g)
              return Td(x), r;
            k = k.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (d.return !== g.return)
          d = x, g = C;
        else {
          for (var L = !1, N = x.child; N; ) {
            if (N === d) {
              L = !0, d = x, g = C;
              break;
            }
            if (N === g) {
              L = !0, g = x, d = C;
              break;
            }
            N = N.sibling;
          }
          if (!L) {
            for (N = C.child; N; ) {
              if (N === d) {
                L = !0, d = C, g = x;
                break;
              }
              if (N === g) {
                L = !0, g = C, d = x;
                break;
              }
              N = N.sibling;
            }
            if (!L)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (d.alternate !== g)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (d.tag !== S)
        throw new Error("Unable to find node on an unmounted component.");
      return d.stateNode.current === d ? n : r;
    }
    function Cr(n) {
      var r = Ed(n);
      return r !== null ? Tr(r) : null;
    }
    function Tr(n) {
      if (n.tag === E || n.tag === R)
        return n;
      for (var r = n.child; r !== null; ) {
        var f = Tr(r);
        if (f !== null)
          return f;
        r = r.sibling;
      }
      return null;
    }
    function Pn(n) {
      var r = Ed(n);
      return r !== null ? oa(r) : null;
    }
    function oa(n) {
      if (n.tag === E || n.tag === R)
        return n;
      for (var r = n.child; r !== null; ) {
        if (r.tag !== w) {
          var f = oa(r);
          if (f !== null)
            return f;
        }
        r = r.sibling;
      }
      return null;
    }
    var Jp = e.unstable_scheduleCallback, wy = e.unstable_cancelCallback, em = e.unstable_shouldYield, tm = e.unstable_requestPaint, Si = e.unstable_now, Dd = e.unstable_getCurrentPriorityLevel, kc = e.unstable_ImmediatePriority, fo = e.unstable_UserBlockingPriority, Ms = e.unstable_NormalPriority, WS = e.unstable_LowPriority, ol = e.unstable_IdlePriority, Rd = e.unstable_yieldValue, Cy = e.unstable_setDisableYieldValue, ll = null, Zn = null, Ue = null, Ir = !1, Er = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function pu(n) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var r = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (r.isDisabled)
        return !0;
      if (!r.supportsFiber)
        return u("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Me && (n = Lt({}, n, {
          getLaneLabelMap: ul,
          injectProfilingHooks: la
        })), ll = r.inject(n), Zn = r;
      } catch (f) {
        u("React instrumentation encountered an error: %s.", f);
      }
      return !!r.checkDCE;
    }
    function nm(n, r) {
      if (Zn && typeof Zn.onScheduleFiberRoot == "function")
        try {
          Zn.onScheduleFiberRoot(ll, n, r);
        } catch (f) {
          Ir || (Ir = !0, u("React instrumentation encountered an error: %s", f));
        }
    }
    function im(n, r) {
      if (Zn && typeof Zn.onCommitFiberRoot == "function")
        try {
          var f = (n.current.flags & at) === at;
          if (Pe) {
            var d;
            switch (r) {
              case ir:
                d = kc;
                break;
              case ns:
                d = fo;
                break;
              case ua:
                d = Ms;
                break;
              case ca:
                d = ol;
                break;
              default:
                d = Ms;
                break;
            }
            Zn.onCommitFiberRoot(ll, n, d, f);
          }
        } catch (g) {
          Ir || (Ir = !0, u("React instrumentation encountered an error: %s", g));
        }
    }
    function rm(n) {
      if (Zn && typeof Zn.onPostCommitFiberRoot == "function")
        try {
          Zn.onPostCommitFiberRoot(ll, n);
        } catch (r) {
          Ir || (Ir = !0, u("React instrumentation encountered an error: %s", r));
        }
    }
    function am(n) {
      if (Zn && typeof Zn.onCommitFiberUnmount == "function")
        try {
          Zn.onCommitFiberUnmount(ll, n);
        } catch (r) {
          Ir || (Ir = !0, u("React instrumentation encountered an error: %s", r));
        }
    }
    function Vn(n) {
      if (typeof Rd == "function" && (Cy(n), o(n)), Zn && typeof Zn.setStrictMode == "function")
        try {
          Zn.setStrictMode(ll, n);
        } catch (r) {
          Ir || (Ir = !0, u("React instrumentation encountered an error: %s", r));
        }
    }
    function la(n) {
      Ue = n;
    }
    function ul() {
      {
        for (var n = /* @__PURE__ */ new Map(), r = 1, f = 0; f < dl; f++) {
          var d = Ry(r);
          n.set(r, d), r *= 2;
        }
        return n;
      }
    }
    function sm(n) {
      Ue !== null && typeof Ue.markCommitStarted == "function" && Ue.markCommitStarted(n);
    }
    function om() {
      Ue !== null && typeof Ue.markCommitStopped == "function" && Ue.markCommitStopped();
    }
    function $r(n) {
      Ue !== null && typeof Ue.markComponentRenderStarted == "function" && Ue.markComponentRenderStarted(n);
    }
    function Wr() {
      Ue !== null && typeof Ue.markComponentRenderStopped == "function" && Ue.markComponentRenderStopped();
    }
    function lm(n) {
      Ue !== null && typeof Ue.markComponentPassiveEffectMountStarted == "function" && Ue.markComponentPassiveEffectMountStarted(n);
    }
    function Ty() {
      Ue !== null && typeof Ue.markComponentPassiveEffectMountStopped == "function" && Ue.markComponentPassiveEffectMountStopped();
    }
    function As(n) {
      Ue !== null && typeof Ue.markComponentPassiveEffectUnmountStarted == "function" && Ue.markComponentPassiveEffectUnmountStarted(n);
    }
    function ho() {
      Ue !== null && typeof Ue.markComponentPassiveEffectUnmountStopped == "function" && Ue.markComponentPassiveEffectUnmountStopped();
    }
    function kd(n) {
      Ue !== null && typeof Ue.markComponentLayoutEffectMountStarted == "function" && Ue.markComponentLayoutEffectMountStarted(n);
    }
    function Ey() {
      Ue !== null && typeof Ue.markComponentLayoutEffectMountStopped == "function" && Ue.markComponentLayoutEffectMountStopped();
    }
    function Mc(n) {
      Ue !== null && typeof Ue.markComponentLayoutEffectUnmountStarted == "function" && Ue.markComponentLayoutEffectUnmountStarted(n);
    }
    function um() {
      Ue !== null && typeof Ue.markComponentLayoutEffectUnmountStopped == "function" && Ue.markComponentLayoutEffectUnmountStopped();
    }
    function Ac(n, r, f) {
      Ue !== null && typeof Ue.markComponentErrored == "function" && Ue.markComponentErrored(n, r, f);
    }
    function ts(n, r, f) {
      Ue !== null && typeof Ue.markComponentSuspended == "function" && Ue.markComponentSuspended(n, r, f);
    }
    function Oc(n) {
      Ue !== null && typeof Ue.markLayoutEffectsStarted == "function" && Ue.markLayoutEffectsStarted(n);
    }
    function Pc() {
      Ue !== null && typeof Ue.markLayoutEffectsStopped == "function" && Ue.markLayoutEffectsStopped();
    }
    function cl(n) {
      Ue !== null && typeof Ue.markPassiveEffectsStarted == "function" && Ue.markPassiveEffectsStarted(n);
    }
    function cm() {
      Ue !== null && typeof Ue.markPassiveEffectsStopped == "function" && Ue.markPassiveEffectsStopped();
    }
    function fl(n) {
      Ue !== null && typeof Ue.markRenderStarted == "function" && Ue.markRenderStarted(n);
    }
    function Dy() {
      Ue !== null && typeof Ue.markRenderYielded == "function" && Ue.markRenderYielded();
    }
    function Md() {
      Ue !== null && typeof Ue.markRenderStopped == "function" && Ue.markRenderStopped();
    }
    function jn(n) {
      Ue !== null && typeof Ue.markRenderScheduled == "function" && Ue.markRenderScheduled(n);
    }
    function Ad(n, r) {
      Ue !== null && typeof Ue.markForceUpdateScheduled == "function" && Ue.markForceUpdateScheduled(n, r);
    }
    function Lc(n, r) {
      Ue !== null && typeof Ue.markStateUpdateScheduled == "function" && Ue.markStateUpdateScheduled(n, r);
    }
    var ot = (
      /*                         */
      0
    ), Nt = (
      /*                 */
      1
    ), Jt = (
      /*                    */
      2
    ), vn = (
      /*               */
      8
    ), en = (
      /*              */
      16
    ), fi = Math.clz32 ? Math.clz32 : Nc, Ri = Math.log, Od = Math.LN2;
    function Nc(n) {
      var r = n >>> 0;
      return r === 0 ? 32 : 31 - (Ri(r) / Od | 0) | 0;
    }
    var dl = 31, ye = (
      /*                        */
      0
    ), Zt = (
      /*                          */
      0
    ), gt = (
      /*                        */
      1
    ), po = (
      /*    */
      2
    ), La = (
      /*             */
      4
    ), Qi = (
      /*            */
      8
    ), Jn = (
      /*                     */
      16
    ), Os = (
      /*                */
      32
    ), mo = (
      /*                       */
      4194240
    ), hl = (
      /*                        */
      64
    ), Pd = (
      /*                        */
      128
    ), Ld = (
      /*                        */
      256
    ), Nd = (
      /*                        */
      512
    ), zd = (
      /*                        */
      1024
    ), Fd = (
      /*                        */
      2048
    ), Vd = (
      /*                        */
      4096
    ), jd = (
      /*                        */
      8192
    ), Bd = (
      /*                        */
      16384
    ), pl = (
      /*                       */
      32768
    ), Hd = (
      /*                       */
      65536
    ), mu = (
      /*                       */
      131072
    ), gu = (
      /*                       */
      262144
    ), Ud = (
      /*                       */
      524288
    ), zc = (
      /*                       */
      1048576
    ), Id = (
      /*                       */
      2097152
    ), Fc = (
      /*                            */
      130023424
    ), ml = (
      /*                             */
      4194304
    ), $d = (
      /*                             */
      8388608
    ), Vc = (
      /*                             */
      16777216
    ), Wd = (
      /*                             */
      33554432
    ), Yd = (
      /*                             */
      67108864
    ), fm = ml, jc = (
      /*          */
      134217728
    ), dm = (
      /*                          */
      268435455
    ), Bc = (
      /*               */
      268435456
    ), gl = (
      /*                        */
      536870912
    ), Yr = (
      /*                   */
      1073741824
    );
    function Ry(n) {
      {
        if (n & gt)
          return "Sync";
        if (n & po)
          return "InputContinuousHydration";
        if (n & La)
          return "InputContinuous";
        if (n & Qi)
          return "DefaultHydration";
        if (n & Jn)
          return "Default";
        if (n & Os)
          return "TransitionHydration";
        if (n & mo)
          return "Transition";
        if (n & Fc)
          return "Retry";
        if (n & jc)
          return "SelectiveHydration";
        if (n & Bc)
          return "IdleHydration";
        if (n & gl)
          return "Idle";
        if (n & Yr)
          return "Offscreen";
      }
    }
    var Sn = -1, vl = hl, Gd = ml;
    function Hc(n) {
      switch (go(n)) {
        case gt:
          return gt;
        case po:
          return po;
        case La:
          return La;
        case Qi:
          return Qi;
        case Jn:
          return Jn;
        case Os:
          return Os;
        case hl:
        case Pd:
        case Ld:
        case Nd:
        case zd:
        case Fd:
        case Vd:
        case jd:
        case Bd:
        case pl:
        case Hd:
        case mu:
        case gu:
        case Ud:
        case zc:
        case Id:
          return n & mo;
        case ml:
        case $d:
        case Vc:
        case Wd:
        case Yd:
          return n & Fc;
        case jc:
          return jc;
        case Bc:
          return Bc;
        case gl:
          return gl;
        case Yr:
          return Yr;
        default:
          return u("Should have found matching lanes. This is a bug in React."), n;
      }
    }
    function Kd(n, r) {
      var f = n.pendingLanes;
      if (f === ye)
        return ye;
      var d = ye, g = n.suspendedLanes, x = n.pingedLanes, C = f & dm;
      if (C !== ye) {
        var D = C & ~g;
        if (D !== ye)
          d = Hc(D);
        else {
          var k = C & x;
          k !== ye && (d = Hc(k));
        }
      } else {
        var L = f & ~g;
        L !== ye ? d = Hc(L) : x !== ye && (d = Hc(x));
      }
      if (d === ye)
        return ye;
      if (r !== ye && r !== d && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (r & g) === ye) {
        var N = go(d), G = go(r);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          N >= G || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          N === Jn && (G & mo) !== ye
        )
          return r;
      }
      (d & La) !== ye && (d |= f & Jn);
      var W = n.entangledLanes;
      if (W !== ye)
        for (var J = n.entanglements, ie = d & W; ie > 0; ) {
          var ue = di(ie), Ie = 1 << ue;
          d |= J[ue], ie &= ~Ie;
        }
      return d;
    }
    function Na(n, r) {
      for (var f = n.eventTimes, d = Sn; r > 0; ) {
        var g = di(r), x = 1 << g, C = f[g];
        C > d && (d = C), r &= ~x;
      }
      return d;
    }
    function hm(n, r) {
      switch (n) {
        case gt:
        case po:
        case La:
          return r + 250;
        case Qi:
        case Jn:
        case Os:
        case hl:
        case Pd:
        case Ld:
        case Nd:
        case zd:
        case Fd:
        case Vd:
        case jd:
        case Bd:
        case pl:
        case Hd:
        case mu:
        case gu:
        case Ud:
        case zc:
        case Id:
          return r + 5e3;
        case ml:
        case $d:
        case Vc:
        case Wd:
        case Yd:
          return Sn;
        case jc:
        case Bc:
        case gl:
        case Yr:
          return Sn;
        default:
          return u("Should have found matching lanes. This is a bug in React."), Sn;
      }
    }
    function Xd(n, r) {
      for (var f = n.pendingLanes, d = n.suspendedLanes, g = n.pingedLanes, x = n.expirationTimes, C = f; C > 0; ) {
        var D = di(C), k = 1 << D, L = x[D];
        L === Sn ? ((k & d) === ye || (k & g) !== ye) && (x[D] = hm(k, r)) : L <= r && (n.expiredLanes |= k), C &= ~k;
      }
    }
    function ky(n) {
      return Hc(n.pendingLanes);
    }
    function Qd(n) {
      var r = n.pendingLanes & -1073741825;
      return r !== ye ? r : r & Yr ? Yr : ye;
    }
    function My(n) {
      return (n & gt) !== ye;
    }
    function Uc(n) {
      return (n & dm) !== ye;
    }
    function yl(n) {
      return (n & Fc) === n;
    }
    function pm(n) {
      var r = gt | La | Jn;
      return (n & r) === ye;
    }
    function mm(n) {
      return (n & mo) === n;
    }
    function qd(n, r) {
      var f = po | La | Qi | Jn;
      return (r & f) !== ye;
    }
    function Ay(n, r) {
      return (r & n.expiredLanes) !== ye;
    }
    function gm(n) {
      return (n & mo) !== ye;
    }
    function vm() {
      var n = vl;
      return vl <<= 1, (vl & mo) === ye && (vl = hl), n;
    }
    function Oy() {
      var n = Gd;
      return Gd <<= 1, (Gd & Fc) === ye && (Gd = ml), n;
    }
    function go(n) {
      return n & -n;
    }
    function Ic(n) {
      return go(n);
    }
    function di(n) {
      return 31 - fi(n);
    }
    function Fi(n) {
      return di(n);
    }
    function Dr(n, r) {
      return (n & r) !== ye;
    }
    function bl(n, r) {
      return (n & r) === r;
    }
    function Mt(n, r) {
      return n | r;
    }
    function $c(n, r) {
      return n & ~r;
    }
    function ym(n, r) {
      return n & r;
    }
    function Py(n) {
      return n;
    }
    function Ly(n, r) {
      return n !== Zt && n < r ? n : r;
    }
    function Wc(n) {
      for (var r = [], f = 0; f < dl; f++)
        r.push(n);
      return r;
    }
    function vu(n, r, f) {
      n.pendingLanes |= r, r !== gl && (n.suspendedLanes = ye, n.pingedLanes = ye);
      var d = n.eventTimes, g = Fi(r);
      d[g] = f;
    }
    function Ny(n, r) {
      n.suspendedLanes |= r, n.pingedLanes &= ~r;
      for (var f = n.expirationTimes, d = r; d > 0; ) {
        var g = di(d), x = 1 << g;
        f[g] = Sn, d &= ~x;
      }
    }
    function Zd(n, r, f) {
      n.pingedLanes |= n.suspendedLanes & r;
    }
    function bm(n, r) {
      var f = n.pendingLanes & ~r;
      n.pendingLanes = r, n.suspendedLanes = ye, n.pingedLanes = ye, n.expiredLanes &= r, n.mutableReadLanes &= r, n.entangledLanes &= r;
      for (var d = n.entanglements, g = n.eventTimes, x = n.expirationTimes, C = f; C > 0; ) {
        var D = di(C), k = 1 << D;
        d[D] = ye, g[D] = Sn, x[D] = Sn, C &= ~k;
      }
    }
    function Jd(n, r) {
      for (var f = n.entangledLanes |= r, d = n.entanglements, g = f; g; ) {
        var x = di(g), C = 1 << x;
        // Is this one of the newly entangled lanes?
        C & r | // Is this lane transitively entangled with the newly entangled lanes?
        d[x] & r && (d[x] |= r), g &= ~C;
      }
    }
    function xm(n, r) {
      var f = go(r), d;
      switch (f) {
        case La:
          d = po;
          break;
        case Jn:
          d = Qi;
          break;
        case hl:
        case Pd:
        case Ld:
        case Nd:
        case zd:
        case Fd:
        case Vd:
        case jd:
        case Bd:
        case pl:
        case Hd:
        case mu:
        case gu:
        case Ud:
        case zc:
        case Id:
        case ml:
        case $d:
        case Vc:
        case Wd:
        case Yd:
          d = Os;
          break;
        case gl:
          d = Bc;
          break;
        default:
          d = Zt;
          break;
      }
      return (d & (n.suspendedLanes | r)) !== Zt ? Zt : d;
    }
    function Yc(n, r, f) {
      if (Er)
        for (var d = n.pendingUpdatersLaneMap; f > 0; ) {
          var g = Fi(f), x = 1 << g, C = d[g];
          C.add(r), f &= ~x;
        }
    }
    function zy(n, r) {
      if (Er)
        for (var f = n.pendingUpdatersLaneMap, d = n.memoizedUpdaters; r > 0; ) {
          var g = Fi(r), x = 1 << g, C = f[g];
          C.size > 0 && (C.forEach(function(D) {
            var k = D.alternate;
            (k === null || !d.has(k)) && d.add(D);
          }), C.clear()), r &= ~x;
        }
    }
    function Sm(n, r) {
      return null;
    }
    var ir = gt, ns = La, ua = Jn, ca = gl, Gc = Zt;
    function fa() {
      return Gc;
    }
    function hi(n) {
      Gc = n;
    }
    function Fy(n, r) {
      var f = Gc;
      try {
        return Gc = n, r();
      } finally {
        Gc = f;
      }
    }
    function Vy(n, r) {
      return n !== 0 && n < r ? n : r;
    }
    function Kc(n, r) {
      return n > r ? n : r;
    }
    function ki(n, r) {
      return n !== 0 && n < r;
    }
    function jy(n) {
      var r = go(n);
      return ki(ir, r) ? ki(ns, r) ? Uc(r) ? ua : ca : ns : ir;
    }
    function eh(n) {
      var r = n.current.memoizedState;
      return r.isDehydrated;
    }
    var Xc;
    function qi(n) {
      Xc = n;
    }
    function YS(n) {
      Xc(n);
    }
    var Xe;
    function yu(n) {
      Xe = n;
    }
    var th;
    function By(n) {
      th = n;
    }
    var Hy;
    function Qc(n) {
      Hy = n;
    }
    var qc;
    function _m(n) {
      qc = n;
    }
    var nh = !1, Zc = [], Ps = null, is = null, rs = null, ei = /* @__PURE__ */ new Map(), rr = /* @__PURE__ */ new Map(), ar = [], Uy = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Iy(n) {
      return Uy.indexOf(n) > -1;
    }
    function za(n, r, f, d, g) {
      return {
        blockedOn: n,
        domEventName: r,
        eventSystemFlags: f,
        nativeEvent: g,
        targetContainers: [d]
      };
    }
    function wm(n, r) {
      switch (n) {
        case "focusin":
        case "focusout":
          Ps = null;
          break;
        case "dragenter":
        case "dragleave":
          is = null;
          break;
        case "mouseover":
        case "mouseout":
          rs = null;
          break;
        case "pointerover":
        case "pointerout": {
          var f = r.pointerId;
          ei.delete(f);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var d = r.pointerId;
          rr.delete(d);
          break;
        }
      }
    }
    function Rr(n, r, f, d, g, x) {
      if (n === null || n.nativeEvent !== x) {
        var C = za(r, f, d, g, x);
        if (r !== null) {
          var D = Du(r);
          D !== null && Xe(D);
        }
        return C;
      }
      n.eventSystemFlags |= d;
      var k = n.targetContainers;
      return g !== null && k.indexOf(g) === -1 && k.push(g), n;
    }
    function GS(n, r, f, d, g) {
      switch (r) {
        case "focusin": {
          var x = g;
          return Ps = Rr(Ps, n, r, f, d, x), !0;
        }
        case "dragenter": {
          var C = g;
          return is = Rr(is, n, r, f, d, C), !0;
        }
        case "mouseover": {
          var D = g;
          return rs = Rr(rs, n, r, f, d, D), !0;
        }
        case "pointerover": {
          var k = g, L = k.pointerId;
          return ei.set(L, Rr(ei.get(L) || null, n, r, f, d, k)), !0;
        }
        case "gotpointercapture": {
          var N = g, G = N.pointerId;
          return rr.set(G, Rr(rr.get(G) || null, n, r, f, d, N)), !0;
        }
      }
      return !1;
    }
    function Cm(n) {
      var r = ff(n.target);
      if (r !== null) {
        var f = Ur(r);
        if (f !== null) {
          var d = f.tag;
          if (d === F) {
            var g = Ja(f);
            if (g !== null) {
              n.blockedOn = g, qc(n.priority, function() {
                th(f);
              });
              return;
            }
          } else if (d === S) {
            var x = f.stateNode;
            if (eh(x)) {
              n.blockedOn = es(f);
              return;
            }
          }
        }
      }
      n.blockedOn = null;
    }
    function $y(n) {
      for (var r = Hy(), f = {
        blockedOn: null,
        target: n,
        priority: r
      }, d = 0; d < ar.length && ki(r, ar[d].priority); d++)
        ;
      ar.splice(d, 0, f), d === 0 && Cm(f);
    }
    function Jc(n) {
      if (n.blockedOn !== null)
        return !1;
      for (var r = n.targetContainers; r.length > 0; ) {
        var f = r[0], d = xu(n.domEventName, n.eventSystemFlags, f, n.nativeEvent);
        if (d === null) {
          var g = n.nativeEvent, x = new g.constructor(g.type, g);
          HS(x), g.target.dispatchEvent(x), US();
        } else {
          var C = Du(d);
          return C !== null && Xe(C), n.blockedOn = d, !1;
        }
        r.shift();
      }
      return !0;
    }
    function Tm(n, r, f) {
      Jc(n) && f.delete(r);
    }
    function KS() {
      nh = !1, Ps !== null && Jc(Ps) && (Ps = null), is !== null && Jc(is) && (is = null), rs !== null && Jc(rs) && (rs = null), ei.forEach(Tm), rr.forEach(Tm);
    }
    function vo(n, r) {
      n.blockedOn === r && (n.blockedOn = null, nh || (nh = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, KS)));
    }
    function xl(n) {
      if (Zc.length > 0) {
        vo(Zc[0], n);
        for (var r = 1; r < Zc.length; r++) {
          var f = Zc[r];
          f.blockedOn === n && (f.blockedOn = null);
        }
      }
      Ps !== null && vo(Ps, n), is !== null && vo(is, n), rs !== null && vo(rs, n);
      var d = function(D) {
        return vo(D, n);
      };
      ei.forEach(d), rr.forEach(d);
      for (var g = 0; g < ar.length; g++) {
        var x = ar[g];
        x.blockedOn === n && (x.blockedOn = null);
      }
      for (; ar.length > 0; ) {
        var C = ar[0];
        if (C.blockedOn !== null)
          break;
        Cm(C), C.blockedOn === null && ar.shift();
      }
    }
    var Vi = i.ReactCurrentBatchConfig, Ht = !0;
    function _i(n) {
      Ht = !!n;
    }
    function pi() {
      return Ht;
    }
    function ji(n, r, f) {
      var d = ih(r), g;
      switch (d) {
        case ir:
          g = Gr;
          break;
        case ns:
          g = bu;
          break;
        case ua:
        default:
          g = ti;
          break;
      }
      return g.bind(null, r, f, n);
    }
    function Gr(n, r, f, d) {
      var g = fa(), x = Vi.transition;
      Vi.transition = null;
      try {
        hi(ir), ti(n, r, f, d);
      } finally {
        hi(g), Vi.transition = x;
      }
    }
    function bu(n, r, f, d) {
      var g = fa(), x = Vi.transition;
      Vi.transition = null;
      try {
        hi(ns), ti(n, r, f, d);
      } finally {
        hi(g), Vi.transition = x;
      }
    }
    function ti(n, r, f, d) {
      Ht && ef(n, r, f, d);
    }
    function ef(n, r, f, d) {
      var g = xu(n, r, f, d);
      if (g === null) {
        f_(n, r, d, as, f), wm(n, d);
        return;
      }
      if (GS(g, n, r, f, d)) {
        d.stopPropagation();
        return;
      }
      if (wm(n, d), r & ia && Iy(n)) {
        for (; g !== null; ) {
          var x = Du(g);
          x !== null && YS(x);
          var C = xu(n, r, f, d);
          if (C === null && f_(n, r, d, as, f), C === g)
            break;
          g = C;
        }
        g !== null && d.stopPropagation();
        return;
      }
      f_(n, r, d, null, f);
    }
    var as = null;
    function xu(n, r, f, d) {
      as = null;
      var g = qp(d), x = ff(g);
      if (x !== null) {
        var C = Ur(x);
        if (C === null)
          x = null;
        else {
          var D = C.tag;
          if (D === F) {
            var k = Ja(C);
            if (k !== null)
              return k;
            x = null;
          } else if (D === S) {
            var L = C.stateNode;
            if (eh(L))
              return es(C);
            x = null;
          } else C !== x && (x = null);
        }
      }
      return as = x, null;
    }
    function ih(n) {
      switch (n) {
        // Used by SimpleEventPlugin:
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        // Used by polyfills:
        // eslint-disable-next-line no-fallthrough
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        // Only enableCreateEventHandleAPI:
        // eslint-disable-next-line no-fallthrough
        case "beforeblur":
        case "afterblur":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ir;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ns;
        case "message": {
          var r = Dd();
          switch (r) {
            case kc:
              return ir;
            case fo:
              return ns;
            case Ms:
            case WS:
              return ua;
            case ol:
              return ca;
            default:
              return ua;
          }
        }
        default:
          return ua;
      }
    }
    function tf(n, r, f) {
      return n.addEventListener(r, f, !1), f;
    }
    function kr(n, r, f) {
      return n.addEventListener(r, f, !0), f;
    }
    function Em(n, r, f, d) {
      return n.addEventListener(r, f, {
        capture: !0,
        passive: d
      }), f;
    }
    function Su(n, r, f, d) {
      return n.addEventListener(r, f, {
        passive: d
      }), f;
    }
    var Kr = null, _u = null, Sl = null;
    function yo(n) {
      return Kr = n, _u = nf(), !0;
    }
    function rh() {
      Kr = null, _u = null, Sl = null;
    }
    function Ls() {
      if (Sl)
        return Sl;
      var n, r = _u, f = r.length, d, g = nf(), x = g.length;
      for (n = 0; n < f && r[n] === g[n]; n++)
        ;
      var C = f - n;
      for (d = 1; d <= C && r[f - d] === g[x - d]; d++)
        ;
      var D = d > 1 ? 1 - d : void 0;
      return Sl = g.slice(n, D), Sl;
    }
    function nf() {
      return "value" in Kr ? Kr.value : Kr.textContent;
    }
    function bo(n) {
      var r, f = n.keyCode;
      return "charCode" in n ? (r = n.charCode, r === 0 && f === 13 && (r = 13)) : r = f, r === 10 && (r = 13), r >= 32 || r === 13 ? r : 0;
    }
    function wu() {
      return !0;
    }
    function rf() {
      return !1;
    }
    function Zi(n) {
      function r(f, d, g, x, C) {
        this._reactName = f, this._targetInst = g, this.type = d, this.nativeEvent = x, this.target = C, this.currentTarget = null;
        for (var D in n)
          if (n.hasOwnProperty(D)) {
            var k = n[D];
            k ? this[D] = k(x) : this[D] = x[D];
          }
        var L = x.defaultPrevented != null ? x.defaultPrevented : x.returnValue === !1;
        return L ? this.isDefaultPrevented = wu : this.isDefaultPrevented = rf, this.isPropagationStopped = rf, this;
      }
      return Lt(r.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var f = this.nativeEvent;
          f && (f.preventDefault ? f.preventDefault() : typeof f.returnValue != "unknown" && (f.returnValue = !1), this.isDefaultPrevented = wu);
        },
        stopPropagation: function() {
          var f = this.nativeEvent;
          f && (f.stopPropagation ? f.stopPropagation() : typeof f.cancelBubble != "unknown" && (f.cancelBubble = !0), this.isPropagationStopped = wu);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: wu
      }), r;
    }
    var mi = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(n) {
        return n.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, ss = Zi(mi), sr = Lt({}, mi, {
      view: 0,
      detail: 0
    }), Mr = Zi(sr), ah, af, _l;
    function XS(n) {
      n !== _l && (_l && n.type === "mousemove" ? (ah = n.screenX - _l.screenX, af = n.screenY - _l.screenY) : (ah = 0, af = 0), _l = n);
    }
    var Fa = Lt({}, sr, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Ln,
      button: 0,
      buttons: 0,
      relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
      },
      movementX: function(n) {
        return "movementX" in n ? n.movementX : (XS(n), ah);
      },
      movementY: function(n) {
        return "movementY" in n ? n.movementY : af;
      }
    }), Dm = Zi(Fa), Rm = Lt({}, Fa, {
      dataTransfer: 0
    }), wl = Zi(Rm), km = Lt({}, sr, {
      relatedTarget: 0
    }), Ns = Zi(km), Wy = Lt({}, mi, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Yy = Zi(Wy), Mm = Lt({}, mi, {
      clipboardData: function(n) {
        return "clipboardData" in n ? n.clipboardData : window.clipboardData;
      }
    }), sh = Zi(Mm), QS = Lt({}, mi, {
      data: 0
    }), Gy = Zi(QS), Ky = Gy, Xy = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Cl = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function qS(n) {
      if (n.key) {
        var r = Xy[n.key] || n.key;
        if (r !== "Unidentified")
          return r;
      }
      if (n.type === "keypress") {
        var f = bo(n);
        return f === 13 ? "Enter" : String.fromCharCode(f);
      }
      return n.type === "keydown" || n.type === "keyup" ? Cl[n.keyCode] || "Unidentified" : "";
    }
    var Cu = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Qy(n) {
      var r = this, f = r.nativeEvent;
      if (f.getModifierState)
        return f.getModifierState(n);
      var d = Cu[n];
      return d ? !!f[d] : !1;
    }
    function Ln(n) {
      return Qy;
    }
    var ZS = Lt({}, sr, {
      key: qS,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Ln,
      // Legacy Interface
      charCode: function(n) {
        return n.type === "keypress" ? bo(n) : 0;
      },
      keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      },
      which: function(n) {
        return n.type === "keypress" ? bo(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      }
    }), qy = Zi(ZS), JS = Lt({}, Fa, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Zy = Zi(JS), Jy = Lt({}, sr, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Ln
    }), e0 = Zi(Jy), e_ = Lt({}, mi, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), da = Zi(e_), Am = Lt({}, Fa, {
      deltaX: function(n) {
        return "deltaX" in n ? n.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in n ? -n.wheelDeltaX : 0
        );
      },
      deltaY: function(n) {
        return "deltaY" in n ? n.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in n ? -n.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in n ? -n.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), t_ = Zi(Am), xo = [9, 13, 27, 32], sf = 229, zs = lt && "CompositionEvent" in window, So = null;
    lt && "documentMode" in document && (So = document.documentMode);
    var Om = lt && "TextEvent" in window && !So, oh = lt && (!zs || So && So > 8 && So <= 11), t0 = 32, lh = String.fromCharCode(t0);
    function n_() {
      it("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), it("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), it("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), it("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Pm = !1;
    function n0(n) {
      return (n.ctrlKey || n.altKey || n.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(n.ctrlKey && n.altKey);
    }
    function uh(n) {
      switch (n) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function ch(n, r) {
      return n === "keydown" && r.keyCode === sf;
    }
    function Lm(n, r) {
      switch (n) {
        case "keyup":
          return xo.indexOf(r.keyCode) !== -1;
        case "keydown":
          return r.keyCode !== sf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function fh(n) {
      var r = n.detail;
      return typeof r == "object" && "data" in r ? r.data : null;
    }
    function i0(n) {
      return n.locale === "ko";
    }
    var Tl = !1;
    function Nm(n, r, f, d, g) {
      var x, C;
      if (zs ? x = uh(r) : Tl ? Lm(r, d) && (x = "onCompositionEnd") : ch(r, d) && (x = "onCompositionStart"), !x)
        return null;
      oh && !i0(d) && (!Tl && x === "onCompositionStart" ? Tl = yo(g) : x === "onCompositionEnd" && Tl && (C = Ls()));
      var D = c0(f, x);
      if (D.length > 0) {
        var k = new Gy(x, r, null, d, g);
        if (n.push({
          event: k,
          listeners: D
        }), C)
          k.data = C;
        else {
          var L = fh(d);
          L !== null && (k.data = L);
        }
      }
    }
    function dh(n, r) {
      switch (n) {
        case "compositionend":
          return fh(r);
        case "keypress":
          var f = r.which;
          return f !== t0 ? null : (Pm = !0, lh);
        case "textInput":
          var d = r.data;
          return d === lh && Pm ? null : d;
        default:
          return null;
      }
    }
    function zm(n, r) {
      if (Tl) {
        if (n === "compositionend" || !zs && Lm(n, r)) {
          var f = Ls();
          return rh(), Tl = !1, f;
        }
        return null;
      }
      switch (n) {
        case "paste":
          return null;
        case "keypress":
          if (!n0(r)) {
            if (r.char && r.char.length > 1)
              return r.char;
            if (r.which)
              return String.fromCharCode(r.which);
          }
          return null;
        case "compositionend":
          return oh && !i0(r) ? null : r.data;
        default:
          return null;
      }
    }
    function hh(n, r, f, d, g) {
      var x;
      if (Om ? x = dh(r, d) : x = zm(r, d), !x)
        return null;
      var C = c0(f, "onBeforeInput");
      if (C.length > 0) {
        var D = new Ky("onBeforeInput", "beforeinput", null, d, g);
        n.push({
          event: D,
          listeners: C
        }), D.data = x;
      }
    }
    function r0(n, r, f, d, g, x, C) {
      Nm(n, r, f, d, g), hh(n, r, f, d, g);
    }
    var i_ = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function of(n) {
      var r = n && n.nodeName && n.nodeName.toLowerCase();
      return r === "input" ? !!i_[n.type] : r === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function r_(n) {
      if (!lt)
        return !1;
      var r = "on" + n, f = r in document;
      if (!f) {
        var d = document.createElement("div");
        d.setAttribute(r, "return;"), f = typeof d[r] == "function";
      }
      return f;
    }
    function lf() {
      it("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function a0(n, r, f, d) {
      ou(d);
      var g = c0(r, "onChange");
      if (g.length > 0) {
        var x = new ss("onChange", "change", null, f, d);
        n.push({
          event: x,
          listeners: g
        });
      }
    }
    var _o = null, s = null;
    function l(n) {
      var r = n.nodeName && n.nodeName.toLowerCase();
      return r === "select" || r === "input" && n.type === "file";
    }
    function p(n) {
      var r = [];
      a0(r, s, n, qp(n)), vy(y, r);
    }
    function y(n) {
      tD(n, 0);
    }
    function _(n) {
      var r = bh(n);
      if (Qo(r))
        return n;
    }
    function T(n, r) {
      if (n === "change")
        return r;
    }
    var O = !1;
    lt && (O = r_("input") && (!document.documentMode || document.documentMode > 9));
    function V(n, r) {
      _o = n, s = r, _o.attachEvent("onpropertychange", te);
    }
    function U() {
      _o && (_o.detachEvent("onpropertychange", te), _o = null, s = null);
    }
    function te(n) {
      n.propertyName === "value" && _(s) && p(n);
    }
    function Se(n, r, f) {
      n === "focusin" ? (U(), V(r, f)) : n === "focusout" && U();
    }
    function De(n, r) {
      if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return _(s);
    }
    function be(n) {
      var r = n.nodeName;
      return r && r.toLowerCase() === "input" && (n.type === "checkbox" || n.type === "radio");
    }
    function Ye(n, r) {
      if (n === "click")
        return _(r);
    }
    function qe(n, r) {
      if (n === "input" || n === "change")
        return _(r);
    }
    function et(n) {
      var r = n._wrapperState;
      !r || !r.controlled || n.type !== "number" || ad(n, "number", n.value);
    }
    function ni(n, r, f, d, g, x, C) {
      var D = f ? bh(f) : window, k, L;
      if (l(D) ? k = T : of(D) ? O ? k = qe : (k = De, L = Se) : be(D) && (k = Ye), k) {
        var N = k(r, f);
        if (N) {
          a0(n, N, d, g);
          return;
        }
      }
      L && L(r, D, f), r === "focusout" && et(D);
    }
    function X() {
      dt("onMouseEnter", ["mouseout", "mouseover"]), dt("onMouseLeave", ["mouseout", "mouseover"]), dt("onPointerEnter", ["pointerout", "pointerover"]), dt("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Y(n, r, f, d, g, x, C) {
      var D = r === "mouseover" || r === "pointerover", k = r === "mouseout" || r === "pointerout";
      if (D && !wc(d)) {
        var L = d.relatedTarget || d.fromElement;
        if (L && (ff(L) || Qm(L)))
          return;
      }
      if (!(!k && !D)) {
        var N;
        if (g.window === g)
          N = g;
        else {
          var G = g.ownerDocument;
          G ? N = G.defaultView || G.parentWindow : N = window;
        }
        var W, J;
        if (k) {
          var ie = d.relatedTarget || d.toElement;
          if (W = f, J = ie ? ff(ie) : null, J !== null) {
            var ue = Ur(J);
            (J !== ue || J.tag !== E && J.tag !== R) && (J = null);
          }
        } else
          W = null, J = f;
        if (W !== J) {
          var Ie = Dm, ft = "onMouseLeave", nt = "onMouseEnter", It = "mouse";
          (r === "pointerout" || r === "pointerover") && (Ie = Zy, ft = "onPointerLeave", nt = "onPointerEnter", It = "pointer");
          var Vt = W == null ? N : bh(W), Q = J == null ? N : bh(J), ce = new Ie(ft, It + "leave", W, d, g);
          ce.target = Vt, ce.relatedTarget = Q;
          var q = null, Re = ff(g);
          if (Re === f) {
            var Ke = new Ie(nt, It + "enter", J, d, g);
            Ke.target = Q, Ke.relatedTarget = Vt, q = Ke;
          }
          cF(n, ce, q, W, J);
        }
      }
    }
    function Z(n, r) {
      return n === r && (n !== 0 || 1 / n === 1 / r) || n !== n && r !== r;
    }
    var _e = typeof Object.is == "function" ? Object.is : Z;
    function Ze(n, r) {
      if (_e(n, r))
        return !0;
      if (typeof n != "object" || n === null || typeof r != "object" || r === null)
        return !1;
      var f = Object.keys(n), d = Object.keys(r);
      if (f.length !== d.length)
        return !1;
      for (var g = 0; g < f.length; g++) {
        var x = f[g];
        if (!St.call(r, x) || !_e(n[x], r[x]))
          return !1;
      }
      return !0;
    }
    function ht(n) {
      for (; n && n.firstChild; )
        n = n.firstChild;
      return n;
    }
    function pt(n) {
      for (; n; ) {
        if (n.nextSibling)
          return n.nextSibling;
        n = n.parentNode;
      }
    }
    function yt(n, r) {
      for (var f = ht(n), d = 0, g = 0; f; ) {
        if (f.nodeType === Ts) {
          if (g = d + f.textContent.length, d <= r && g >= r)
            return {
              node: f,
              offset: r - d
            };
          d = g;
        }
        f = ht(pt(f));
      }
    }
    function Mi(n) {
      var r = n.ownerDocument, f = r && r.defaultView || window, d = f.getSelection && f.getSelection();
      if (!d || d.rangeCount === 0)
        return null;
      var g = d.anchorNode, x = d.anchorOffset, C = d.focusNode, D = d.focusOffset;
      try {
        g.nodeType, C.nodeType;
      } catch {
        return null;
      }
      return tn(n, g, x, C, D);
    }
    function tn(n, r, f, d, g) {
      var x = 0, C = -1, D = -1, k = 0, L = 0, N = n, G = null;
      e: for (; ; ) {
        for (var W = null; N === r && (f === 0 || N.nodeType === Ts) && (C = x + f), N === d && (g === 0 || N.nodeType === Ts) && (D = x + g), N.nodeType === Ts && (x += N.nodeValue.length), (W = N.firstChild) !== null; )
          G = N, N = W;
        for (; ; ) {
          if (N === n)
            break e;
          if (G === r && ++k === f && (C = x), G === d && ++L === g && (D = x), (W = N.nextSibling) !== null)
            break;
          N = G, G = N.parentNode;
        }
        N = W;
      }
      return C === -1 || D === -1 ? null : {
        start: C,
        end: D
      };
    }
    function wo(n, r) {
      var f = n.ownerDocument || document, d = f && f.defaultView || window;
      if (d.getSelection) {
        var g = d.getSelection(), x = n.textContent.length, C = Math.min(r.start, x), D = r.end === void 0 ? C : Math.min(r.end, x);
        if (!g.extend && C > D) {
          var k = D;
          D = C, C = k;
        }
        var L = yt(n, C), N = yt(n, D);
        if (L && N) {
          if (g.rangeCount === 1 && g.anchorNode === L.node && g.anchorOffset === L.offset && g.focusNode === N.node && g.focusOffset === N.offset)
            return;
          var G = f.createRange();
          G.setStart(L.node, L.offset), g.removeAllRanges(), C > D ? (g.addRange(G), g.extend(N.node, N.offset)) : (G.setEnd(N.node, N.offset), g.addRange(G));
        }
      }
    }
    function s0(n) {
      return n && n.nodeType === Ts;
    }
    function $1(n, r) {
      return !n || !r ? !1 : n === r ? !0 : s0(n) ? !1 : s0(r) ? $1(n, r.parentNode) : "contains" in n ? n.contains(r) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(r) & 16) : !1;
    }
    function Yz(n) {
      return n && n.ownerDocument && $1(n.ownerDocument.documentElement, n);
    }
    function Gz(n) {
      try {
        return typeof n.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function W1() {
      for (var n = window, r = qo(); r instanceof n.HTMLIFrameElement; ) {
        if (Gz(r))
          n = r.contentWindow;
        else
          return r;
        r = qo(n.document);
      }
      return r;
    }
    function a_(n) {
      var r = n && n.nodeName && n.nodeName.toLowerCase();
      return r && (r === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || r === "textarea" || n.contentEditable === "true");
    }
    function Kz() {
      var n = W1();
      return {
        focusedElem: n,
        selectionRange: a_(n) ? Qz(n) : null
      };
    }
    function Xz(n) {
      var r = W1(), f = n.focusedElem, d = n.selectionRange;
      if (r !== f && Yz(f)) {
        d !== null && a_(f) && qz(f, d);
        for (var g = [], x = f; x = x.parentNode; )
          x.nodeType === xr && g.push({
            element: x,
            left: x.scrollLeft,
            top: x.scrollTop
          });
        typeof f.focus == "function" && f.focus();
        for (var C = 0; C < g.length; C++) {
          var D = g[C];
          D.element.scrollLeft = D.left, D.element.scrollTop = D.top;
        }
      }
    }
    function Qz(n) {
      var r;
      return "selectionStart" in n ? r = {
        start: n.selectionStart,
        end: n.selectionEnd
      } : r = Mi(n), r || {
        start: 0,
        end: 0
      };
    }
    function qz(n, r) {
      var f = r.start, d = r.end;
      d === void 0 && (d = f), "selectionStart" in n ? (n.selectionStart = f, n.selectionEnd = Math.min(d, n.value.length)) : wo(n, r);
    }
    var Zz = lt && "documentMode" in document && document.documentMode <= 11;
    function Jz() {
      it("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var ph = null, s_ = null, Fm = null, o_ = !1;
    function eF(n) {
      if ("selectionStart" in n && a_(n))
        return {
          start: n.selectionStart,
          end: n.selectionEnd
        };
      var r = n.ownerDocument && n.ownerDocument.defaultView || window, f = r.getSelection();
      return {
        anchorNode: f.anchorNode,
        anchorOffset: f.anchorOffset,
        focusNode: f.focusNode,
        focusOffset: f.focusOffset
      };
    }
    function tF(n) {
      return n.window === n ? n.document : n.nodeType === Es ? n : n.ownerDocument;
    }
    function Y1(n, r, f) {
      var d = tF(f);
      if (!(o_ || ph == null || ph !== qo(d))) {
        var g = eF(ph);
        if (!Fm || !Ze(Fm, g)) {
          Fm = g;
          var x = c0(s_, "onSelect");
          if (x.length > 0) {
            var C = new ss("onSelect", "select", null, r, f);
            n.push({
              event: C,
              listeners: x
            }), C.target = ph;
          }
        }
      }
    }
    function nF(n, r, f, d, g, x, C) {
      var D = f ? bh(f) : window;
      switch (r) {
        // Track the input node that has focus.
        case "focusin":
          (of(D) || D.contentEditable === "true") && (ph = D, s_ = f, Fm = null);
          break;
        case "focusout":
          ph = null, s_ = null, Fm = null;
          break;
        // Don't fire the event while the user is dragging. This matches the
        // semantics of the native select event.
        case "mousedown":
          o_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          o_ = !1, Y1(n, d, g);
          break;
        // Chrome and IE fire non-standard event when selection is changed (and
        // sometimes when it hasn't). IE's event fires out of order with respect
        // to key and input events on deletion, so we discard it.
        //
        // Firefox doesn't support selectionchange, so check selection status
        // after each key entry. The selection changes after keydown and before
        // keyup, but we check on keydown as well in the case of holding down a
        // key, when multiple keydown events are fired but only one keyup is.
        // This is also our approach for IE handling, for the reason above.
        case "selectionchange":
          if (Zz)
            break;
        // falls through
        case "keydown":
        case "keyup":
          Y1(n, d, g);
      }
    }
    function o0(n, r) {
      var f = {};
      return f[n.toLowerCase()] = r.toLowerCase(), f["Webkit" + n] = "webkit" + r, f["Moz" + n] = "moz" + r, f;
    }
    var mh = {
      animationend: o0("Animation", "AnimationEnd"),
      animationiteration: o0("Animation", "AnimationIteration"),
      animationstart: o0("Animation", "AnimationStart"),
      transitionend: o0("Transition", "TransitionEnd")
    }, l_ = {}, G1 = {};
    lt && (G1 = document.createElement("div").style, "AnimationEvent" in window || (delete mh.animationend.animation, delete mh.animationiteration.animation, delete mh.animationstart.animation), "TransitionEvent" in window || delete mh.transitionend.transition);
    function l0(n) {
      if (l_[n])
        return l_[n];
      if (!mh[n])
        return n;
      var r = mh[n];
      for (var f in r)
        if (r.hasOwnProperty(f) && f in G1)
          return l_[n] = r[f];
      return n;
    }
    var K1 = l0("animationend"), X1 = l0("animationiteration"), Q1 = l0("animationstart"), q1 = l0("transitionend"), Z1 = /* @__PURE__ */ new Map(), J1 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Tu(n, r) {
      Z1.set(n, r), it(r, [n]);
    }
    function iF() {
      for (var n = 0; n < J1.length; n++) {
        var r = J1[n], f = r.toLowerCase(), d = r[0].toUpperCase() + r.slice(1);
        Tu(f, "on" + d);
      }
      Tu(K1, "onAnimationEnd"), Tu(X1, "onAnimationIteration"), Tu(Q1, "onAnimationStart"), Tu("dblclick", "onDoubleClick"), Tu("focusin", "onFocus"), Tu("focusout", "onBlur"), Tu(q1, "onTransitionEnd");
    }
    function rF(n, r, f, d, g, x, C) {
      var D = Z1.get(r);
      if (D !== void 0) {
        var k = ss, L = r;
        switch (r) {
          case "keypress":
            if (bo(d) === 0)
              return;
          /* falls through */
          case "keydown":
          case "keyup":
            k = qy;
            break;
          case "focusin":
            L = "focus", k = Ns;
            break;
          case "focusout":
            L = "blur", k = Ns;
            break;
          case "beforeblur":
          case "afterblur":
            k = Ns;
            break;
          case "click":
            if (d.button === 2)
              return;
          /* falls through */
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          // TODO: Disabled elements should not respond to mouse events
          /* falls through */
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k = Dm;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k = wl;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k = e0;
            break;
          case K1:
          case X1:
          case Q1:
            k = Yy;
            break;
          case q1:
            k = da;
            break;
          case "scroll":
            k = Mr;
            break;
          case "wheel":
            k = t_;
            break;
          case "copy":
          case "cut":
          case "paste":
            k = sh;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k = Zy;
            break;
        }
        var N = (x & ia) !== 0;
        {
          var G = !N && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          r === "scroll", W = lF(f, D, d.type, N, G);
          if (W.length > 0) {
            var J = new k(D, L, null, d, g);
            n.push({
              event: J,
              listeners: W
            });
          }
        }
      }
    }
    iF(), X(), lf(), Jz(), n_();
    function aF(n, r, f, d, g, x, C) {
      rF(n, r, f, d, g, x);
      var D = (x & Qp) === 0;
      D && (Y(n, r, f, d, g), ni(n, r, f, d, g), nF(n, r, f, d, g), r0(n, r, f, d, g));
    }
    var Vm = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], u_ = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Vm));
    function eD(n, r, f) {
      var d = n.type || "unknown-event";
      n.currentTarget = f, Qa(d, r, void 0, n), n.currentTarget = null;
    }
    function sF(n, r, f) {
      var d;
      if (f)
        for (var g = r.length - 1; g >= 0; g--) {
          var x = r[g], C = x.instance, D = x.currentTarget, k = x.listener;
          if (C !== d && n.isPropagationStopped())
            return;
          eD(n, k, D), d = C;
        }
      else
        for (var L = 0; L < r.length; L++) {
          var N = r[L], G = N.instance, W = N.currentTarget, J = N.listener;
          if (G !== d && n.isPropagationStopped())
            return;
          eD(n, J, W), d = G;
        }
    }
    function tD(n, r) {
      for (var f = (r & ia) !== 0, d = 0; d < n.length; d++) {
        var g = n[d], x = g.event, C = g.listeners;
        sF(x, C, f);
      }
      Ec();
    }
    function oF(n, r, f, d, g) {
      var x = qp(f), C = [];
      aF(C, n, d, f, x, r), tD(C, r);
    }
    function Bn(n, r) {
      u_.has(n) || u('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', n);
      var f = !1, d = FV(r), g = fF(n);
      d.has(g) || (nD(r, n, pd, f), d.add(g));
    }
    function c_(n, r, f) {
      u_.has(n) && !r && u('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', n);
      var d = 0;
      r && (d |= ia), nD(f, n, d, r);
    }
    var u0 = "_reactListening" + Math.random().toString(36).slice(2);
    function jm(n) {
      if (!n[u0]) {
        n[u0] = !0, Le.forEach(function(f) {
          f !== "selectionchange" && (u_.has(f) || c_(f, !1, n), c_(f, !0, n));
        });
        var r = n.nodeType === Es ? n : n.ownerDocument;
        r !== null && (r[u0] || (r[u0] = !0, c_("selectionchange", !1, r)));
      }
    }
    function nD(n, r, f, d, g) {
      var x = ji(n, r, f), C = void 0;
      Tc && (r === "touchstart" || r === "touchmove" || r === "wheel") && (C = !0), n = n, d ? C !== void 0 ? Em(n, r, x, C) : kr(n, r, x) : C !== void 0 ? Su(n, r, x, C) : tf(n, r, x);
    }
    function iD(n, r) {
      return n === r || n.nodeType === li && n.parentNode === r;
    }
    function f_(n, r, f, d, g) {
      var x = d;
      if (!(r & Xp) && !(r & pd)) {
        var C = g;
        if (d !== null) {
          var D = d;
          e: for (; ; ) {
            if (D === null)
              return;
            var k = D.tag;
            if (k === S || k === w) {
              var L = D.stateNode.containerInfo;
              if (iD(L, C))
                break;
              if (k === w)
                for (var N = D.return; N !== null; ) {
                  var G = N.tag;
                  if (G === S || G === w) {
                    var W = N.stateNode.containerInfo;
                    if (iD(W, C))
                      return;
                  }
                  N = N.return;
                }
              for (; L !== null; ) {
                var J = ff(L);
                if (J === null)
                  return;
                var ie = J.tag;
                if (ie === E || ie === R) {
                  D = x = J;
                  continue e;
                }
                L = L.parentNode;
              }
            }
            D = D.return;
          }
        }
      }
      vy(function() {
        return oF(n, r, f, x);
      });
    }
    function Bm(n, r, f) {
      return {
        instance: n,
        listener: r,
        currentTarget: f
      };
    }
    function lF(n, r, f, d, g, x) {
      for (var C = r !== null ? r + "Capture" : null, D = d ? C : r, k = [], L = n, N = null; L !== null; ) {
        var G = L, W = G.stateNode, J = G.tag;
        if (J === E && W !== null && (N = W, D !== null)) {
          var ie = ao(L, D);
          ie != null && k.push(Bm(L, ie, N));
        }
        if (g)
          break;
        L = L.return;
      }
      return k;
    }
    function c0(n, r) {
      for (var f = r + "Capture", d = [], g = n; g !== null; ) {
        var x = g, C = x.stateNode, D = x.tag;
        if (D === E && C !== null) {
          var k = C, L = ao(g, f);
          L != null && d.unshift(Bm(g, L, k));
          var N = ao(g, r);
          N != null && d.push(Bm(g, N, k));
        }
        g = g.return;
      }
      return d;
    }
    function gh(n) {
      if (n === null)
        return null;
      do
        n = n.return;
      while (n && n.tag !== E);
      return n || null;
    }
    function uF(n, r) {
      for (var f = n, d = r, g = 0, x = f; x; x = gh(x))
        g++;
      for (var C = 0, D = d; D; D = gh(D))
        C++;
      for (; g - C > 0; )
        f = gh(f), g--;
      for (; C - g > 0; )
        d = gh(d), C--;
      for (var k = g; k--; ) {
        if (f === d || d !== null && f === d.alternate)
          return f;
        f = gh(f), d = gh(d);
      }
      return null;
    }
    function rD(n, r, f, d, g) {
      for (var x = r._reactName, C = [], D = f; D !== null && D !== d; ) {
        var k = D, L = k.alternate, N = k.stateNode, G = k.tag;
        if (L !== null && L === d)
          break;
        if (G === E && N !== null) {
          var W = N;
          if (g) {
            var J = ao(D, x);
            J != null && C.unshift(Bm(D, J, W));
          } else if (!g) {
            var ie = ao(D, x);
            ie != null && C.push(Bm(D, ie, W));
          }
        }
        D = D.return;
      }
      C.length !== 0 && n.push({
        event: r,
        listeners: C
      });
    }
    function cF(n, r, f, d, g) {
      var x = d && g ? uF(d, g) : null;
      d !== null && rD(n, r, d, x, !1), g !== null && f !== null && rD(n, f, g, x, !0);
    }
    function fF(n, r) {
      return n + "__bubble";
    }
    var ha = !1, Hm = "dangerouslySetInnerHTML", f0 = "suppressContentEditableWarning", Eu = "suppressHydrationWarning", aD = "autoFocus", uf = "children", cf = "style", d0 = "__html", d_, h0, Um, sD, p0, oD, lD;
    d_ = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, h0 = function(n, r) {
      Yp(n, r), dd(n, r), py(n, r, {
        registrationNameDependencies: Te,
        possibleRegistrationNames: xe
      });
    }, oD = lt && !document.documentMode, Um = function(n, r, f) {
      if (!ha) {
        var d = m0(f), g = m0(r);
        g !== d && (ha = !0, u("Prop `%s` did not match. Server: %s Client: %s", n, JSON.stringify(g), JSON.stringify(d)));
      }
    }, sD = function(n) {
      if (!ha) {
        ha = !0;
        var r = [];
        n.forEach(function(f) {
          r.push(f);
        }), u("Extra attributes from the server: %s", r);
      }
    }, p0 = function(n, r) {
      r === !1 ? u("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", n, n, n) : u("Expected `%s` listener to be a function, instead got a value of `%s` type.", n, typeof r);
    }, lD = function(n, r) {
      var f = n.namespaceURI === Cs ? n.ownerDocument.createElement(n.tagName) : n.ownerDocument.createElementNS(n.namespaceURI, n.tagName);
      return f.innerHTML = r, f.innerHTML;
    };
    var dF = /\r\n?/g, hF = /\u0000|\uFFFD/g;
    function m0(n) {
      Gt(n);
      var r = typeof n == "string" ? n : "" + n;
      return r.replace(dF, `
`).replace(hF, "");
    }
    function g0(n, r, f, d) {
      var g = m0(r), x = m0(n);
      if (x !== g && (d && (ha || (ha = !0, u('Text content did not match. Server: "%s" Client: "%s"', x, g))), f && Oe))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function uD(n) {
      return n.nodeType === Es ? n : n.ownerDocument;
    }
    function pF() {
    }
    function v0(n) {
      n.onclick = pF;
    }
    function mF(n, r, f, d, g) {
      for (var x in d)
        if (d.hasOwnProperty(x)) {
          var C = d[x];
          if (x === cf)
            C && Object.freeze(C), ly(r, C);
          else if (x === Hm) {
            var D = C ? C[d0] : void 0;
            D != null && Qv(r, D);
          } else if (x === uf)
            if (typeof C == "string") {
              var k = n !== "textarea" || C !== "";
              k && iu(r, C);
            } else typeof C == "number" && iu(r, "" + C);
          else x === f0 || x === Eu || x === aD || (Te.hasOwnProperty(x) ? C != null && (typeof C != "function" && p0(x, C), x === "onScroll" && Bn("scroll", r)) : C != null && $e(r, x, C, g));
        }
    }
    function gF(n, r, f, d) {
      for (var g = 0; g < r.length; g += 2) {
        var x = r[g], C = r[g + 1];
        x === cf ? ly(n, C) : x === Hm ? Qv(n, C) : x === uf ? iu(n, C) : $e(n, x, C, d);
      }
    }
    function vF(n, r, f, d) {
      var g, x = uD(f), C, D = d;
      if (D === Cs && (D = jp(n)), D === Cs) {
        if (g = io(n, r), !g && n !== n.toLowerCase() && u("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", n), n === "script") {
          var k = x.createElement("div");
          k.innerHTML = "<script><\/script>";
          var L = k.firstChild;
          C = k.removeChild(L);
        } else if (typeof r.is == "string")
          C = x.createElement(n, {
            is: r.is
          });
        else if (C = x.createElement(n), n === "select") {
          var N = C;
          r.multiple ? N.multiple = !0 : r.size && (N.size = r.size);
        }
      } else
        C = x.createElementNS(D, n);
      return D === Cs && !g && Object.prototype.toString.call(C) === "[object HTMLUnknownElement]" && !St.call(d_, n) && (d_[n] = !0, u("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", n)), C;
    }
    function yF(n, r) {
      return uD(r).createTextNode(n);
    }
    function bF(n, r, f, d) {
      var g = io(r, f);
      h0(r, f);
      var x;
      switch (r) {
        case "dialog":
          Bn("cancel", n), Bn("close", n), x = f;
          break;
        case "iframe":
        case "object":
        case "embed":
          Bn("load", n), x = f;
          break;
        case "video":
        case "audio":
          for (var C = 0; C < Vm.length; C++)
            Bn(Vm[C], n);
          x = f;
          break;
        case "source":
          Bn("error", n), x = f;
          break;
        case "img":
        case "image":
        case "link":
          Bn("error", n), Bn("load", n), x = f;
          break;
        case "details":
          Bn("toggle", n), x = f;
          break;
        case "input":
          ws(n, f), x = td(n, f), Bn("invalid", n);
          break;
        case "option":
          tu(n, f), x = f;
          break;
        case "select":
          od(n, f), x = Lp(n, f), Bn("invalid", n);
          break;
        case "textarea":
          zp(n, f), x = Np(n, f), Bn("invalid", n);
          break;
        default:
          x = f;
      }
      switch (cd(r, x), mF(r, n, d, x, g), r) {
        case "input":
          no(n), Ap(n, f, !1);
          break;
        case "textarea":
          no(n), Kv(n);
          break;
        case "option":
          RS(n, f);
          break;
        case "select":
          MS(n, f);
          break;
        default:
          typeof x.onClick == "function" && v0(n);
          break;
      }
    }
    function xF(n, r, f, d, g) {
      h0(r, d);
      var x = null, C, D;
      switch (r) {
        case "input":
          C = td(n, f), D = td(n, d), x = [];
          break;
        case "select":
          C = Lp(n, f), D = Lp(n, d), x = [];
          break;
        case "textarea":
          C = Np(n, f), D = Np(n, d), x = [];
          break;
        default:
          C = f, D = d, typeof C.onClick != "function" && typeof D.onClick == "function" && v0(n);
          break;
      }
      cd(r, D);
      var k, L, N = null;
      for (k in C)
        if (!(D.hasOwnProperty(k) || !C.hasOwnProperty(k) || C[k] == null))
          if (k === cf) {
            var G = C[k];
            for (L in G)
              G.hasOwnProperty(L) && (N || (N = {}), N[L] = "");
          } else k === Hm || k === uf || k === f0 || k === Eu || k === aD || (Te.hasOwnProperty(k) ? x || (x = []) : (x = x || []).push(k, null));
      for (k in D) {
        var W = D[k], J = C != null ? C[k] : void 0;
        if (!(!D.hasOwnProperty(k) || W === J || W == null && J == null))
          if (k === cf)
            if (W && Object.freeze(W), J) {
              for (L in J)
                J.hasOwnProperty(L) && (!W || !W.hasOwnProperty(L)) && (N || (N = {}), N[L] = "");
              for (L in W)
                W.hasOwnProperty(L) && J[L] !== W[L] && (N || (N = {}), N[L] = W[L]);
            } else
              N || (x || (x = []), x.push(k, N)), N = W;
          else if (k === Hm) {
            var ie = W ? W[d0] : void 0, ue = J ? J[d0] : void 0;
            ie != null && ue !== ie && (x = x || []).push(k, ie);
          } else k === uf ? (typeof W == "string" || typeof W == "number") && (x = x || []).push(k, "" + W) : k === f0 || k === Eu || (Te.hasOwnProperty(k) ? (W != null && (typeof W != "function" && p0(k, W), k === "onScroll" && Bn("scroll", n)), !x && J !== W && (x = [])) : (x = x || []).push(k, W));
      }
      return N && (jS(N, D[cf]), (x = x || []).push(cf, N)), x;
    }
    function SF(n, r, f, d, g) {
      f === "input" && g.type === "radio" && g.name != null && nd(n, g);
      var x = io(f, d), C = io(f, g);
      switch (gF(n, r, x, C), f) {
        case "input":
          eu(n, g);
          break;
        case "textarea":
          Gv(n, g);
          break;
        case "select":
          AS(n, g);
          break;
      }
    }
    function _F(n) {
      {
        var r = n.toLowerCase();
        return Sc.hasOwnProperty(r) && Sc[r] || null;
      }
    }
    function wF(n, r, f, d, g, x, C) {
      var D, k;
      switch (D = io(r, f), h0(r, f), r) {
        case "dialog":
          Bn("cancel", n), Bn("close", n);
          break;
        case "iframe":
        case "object":
        case "embed":
          Bn("load", n);
          break;
        case "video":
        case "audio":
          for (var L = 0; L < Vm.length; L++)
            Bn(Vm[L], n);
          break;
        case "source":
          Bn("error", n);
          break;
        case "img":
        case "image":
        case "link":
          Bn("error", n), Bn("load", n);
          break;
        case "details":
          Bn("toggle", n);
          break;
        case "input":
          ws(n, f), Bn("invalid", n);
          break;
        case "option":
          tu(n, f);
          break;
        case "select":
          od(n, f), Bn("invalid", n);
          break;
        case "textarea":
          zp(n, f), Bn("invalid", n);
          break;
      }
      cd(r, f);
      {
        k = /* @__PURE__ */ new Set();
        for (var N = n.attributes, G = 0; G < N.length; G++) {
          var W = N[G].name.toLowerCase();
          switch (W) {
            // Controlled attributes are not validated
            // TODO: Only ignore them on controlled tags.
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              k.add(N[G].name);
          }
        }
      }
      var J = null;
      for (var ie in f)
        if (f.hasOwnProperty(ie)) {
          var ue = f[ie];
          if (ie === uf)
            typeof ue == "string" ? n.textContent !== ue && (f[Eu] !== !0 && g0(n.textContent, ue, x, C), J = [uf, ue]) : typeof ue == "number" && n.textContent !== "" + ue && (f[Eu] !== !0 && g0(n.textContent, ue, x, C), J = [uf, "" + ue]);
          else if (Te.hasOwnProperty(ie))
            ue != null && (typeof ue != "function" && p0(ie, ue), ie === "onScroll" && Bn("scroll", n));
          else if (C && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof D == "boolean") {
            var Ie = void 0, ft = on(ie);
            if (f[Eu] !== !0) {
              if (!(ie === f0 || ie === Eu || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              ie === "value" || ie === "checked" || ie === "selected")) {
                if (ie === Hm) {
                  var nt = n.innerHTML, It = ue ? ue[d0] : void 0;
                  if (It != null) {
                    var Vt = lD(n, It);
                    Vt !== nt && Um(ie, nt, Vt);
                  }
                } else if (ie === cf) {
                  if (k.delete(ie), oD) {
                    var Q = FS(ue);
                    Ie = n.getAttribute("style"), Q !== Ie && Um(ie, Ie, Q);
                  }
                } else if (D)
                  k.delete(ie.toLowerCase()), Ie = ke(n, ie, ue), ue !== Ie && Um(ie, Ie, ue);
                else if (!dn(ie, ft, D) && !zn(ie, ue, ft, D)) {
                  var ce = !1;
                  if (ft !== null)
                    k.delete(ft.attributeName), Ie = ve(n, ie, ue, ft);
                  else {
                    var q = d;
                    if (q === Cs && (q = jp(r)), q === Cs)
                      k.delete(ie.toLowerCase());
                    else {
                      var Re = _F(ie);
                      Re !== null && Re !== ie && (ce = !0, k.delete(Re)), k.delete(ie);
                    }
                    Ie = ke(n, ie, ue);
                  }
                  var Ke = Ce;
                  !Ke && ue !== Ie && !ce && Um(ie, Ie, ue);
                }
              }
            }
          }
        }
      switch (C && // $FlowFixMe - Should be inferred as not undefined.
      k.size > 0 && f[Eu] !== !0 && sD(k), r) {
        case "input":
          no(n), Ap(n, f, !0);
          break;
        case "textarea":
          no(n), Kv(n);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof f.onClick == "function" && v0(n);
          break;
      }
      return J;
    }
    function CF(n, r, f) {
      var d = n.nodeValue !== r;
      return d;
    }
    function h_(n, r) {
      {
        if (ha)
          return;
        ha = !0, u("Did not expect server HTML to contain a <%s> in <%s>.", r.nodeName.toLowerCase(), n.nodeName.toLowerCase());
      }
    }
    function p_(n, r) {
      {
        if (ha)
          return;
        ha = !0, u('Did not expect server HTML to contain the text node "%s" in <%s>.', r.nodeValue, n.nodeName.toLowerCase());
      }
    }
    function m_(n, r, f) {
      {
        if (ha)
          return;
        ha = !0, u("Expected server HTML to contain a matching <%s> in <%s>.", r, n.nodeName.toLowerCase());
      }
    }
    function g_(n, r) {
      {
        if (r === "" || ha)
          return;
        ha = !0, u('Expected server HTML to contain a matching text node for "%s" in <%s>.', r, n.nodeName.toLowerCase());
      }
    }
    function TF(n, r, f) {
      switch (r) {
        case "input":
          id(n, f);
          return;
        case "textarea":
          PS(n, f);
          return;
        case "select":
          OS(n, f);
          return;
      }
    }
    var Im = function() {
    }, $m = function() {
    };
    {
      var EF = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], cD = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], DF = cD.concat(["button"]), RF = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], fD = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      $m = function(n, r) {
        var f = Lt({}, n || fD), d = {
          tag: r
        };
        return cD.indexOf(r) !== -1 && (f.aTagInScope = null, f.buttonTagInScope = null, f.nobrTagInScope = null), DF.indexOf(r) !== -1 && (f.pTagInButtonScope = null), EF.indexOf(r) !== -1 && r !== "address" && r !== "div" && r !== "p" && (f.listItemTagAutoclosing = null, f.dlItemTagAutoclosing = null), f.current = d, r === "form" && (f.formTag = d), r === "a" && (f.aTagInScope = d), r === "button" && (f.buttonTagInScope = d), r === "nobr" && (f.nobrTagInScope = d), r === "p" && (f.pTagInButtonScope = d), r === "li" && (f.listItemTagAutoclosing = d), (r === "dd" || r === "dt") && (f.dlItemTagAutoclosing = d), f;
      };
      var kF = function(n, r) {
        switch (r) {
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
          case "select":
            return n === "option" || n === "optgroup" || n === "#text";
          case "optgroup":
            return n === "option" || n === "#text";
          // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
          // but
          case "option":
            return n === "#text";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
          // No special behavior since these rules fall back to "in body" mode for
          // all except special table nodes which cause bad parsing behavior anyway.
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
          case "tr":
            return n === "th" || n === "td" || n === "style" || n === "script" || n === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
          case "tbody":
          case "thead":
          case "tfoot":
            return n === "tr" || n === "style" || n === "script" || n === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
          case "colgroup":
            return n === "col" || n === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
          case "table":
            return n === "caption" || n === "colgroup" || n === "tbody" || n === "tfoot" || n === "thead" || n === "style" || n === "script" || n === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
          case "head":
            return n === "base" || n === "basefont" || n === "bgsound" || n === "link" || n === "meta" || n === "title" || n === "noscript" || n === "noframes" || n === "style" || n === "script" || n === "template";
          // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
          case "html":
            return n === "head" || n === "body" || n === "frameset";
          case "frameset":
            return n === "frame";
          case "#document":
            return n === "html";
        }
        switch (n) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r !== "h1" && r !== "h2" && r !== "h3" && r !== "h4" && r !== "h5" && r !== "h6";
          case "rp":
          case "rt":
            return RF.indexOf(r) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return r == null;
        }
        return !0;
      }, MF = function(n, r) {
        switch (n) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r.pTagInButtonScope;
          case "form":
            return r.formTag || r.pTagInButtonScope;
          case "li":
            return r.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return r.dlItemTagAutoclosing;
          case "button":
            return r.buttonTagInScope;
          case "a":
            return r.aTagInScope;
          case "nobr":
            return r.nobrTagInScope;
        }
        return null;
      }, dD = {};
      Im = function(n, r, f) {
        f = f || fD;
        var d = f.current, g = d && d.tag;
        r != null && (n != null && u("validateDOMNesting: when childText is passed, childTag should be null"), n = "#text");
        var x = kF(n, g) ? null : d, C = x ? null : MF(n, f), D = x || C;
        if (D) {
          var k = D.tag, L = !!x + "|" + n + "|" + k;
          if (!dD[L]) {
            dD[L] = !0;
            var N = n, G = "";
            if (n === "#text" ? /\S/.test(r) ? N = "Text nodes" : (N = "Whitespace text nodes", G = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : N = "<" + n + ">", x) {
              var W = "";
              k === "table" && n === "tr" && (W += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), u("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", N, k, G, W);
            } else
              u("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", N, k);
          }
        }
      };
    }
    var y0 = "suppressHydrationWarning", b0 = "$", x0 = "/$", Wm = "$?", Ym = "$!", AF = "style", v_ = null, y_ = null;
    function OF(n) {
      var r, f, d = n.nodeType;
      switch (d) {
        case Es:
        case Hp: {
          r = d === Es ? "#document" : "#fragment";
          var g = n.documentElement;
          f = g ? g.namespaceURI : Bp(null, "");
          break;
        }
        default: {
          var x = d === li ? n.parentNode : n, C = x.namespaceURI || null;
          r = x.tagName, f = Bp(C, r);
          break;
        }
      }
      {
        var D = r.toLowerCase(), k = $m(null, D);
        return {
          namespace: f,
          ancestorInfo: k
        };
      }
    }
    function PF(n, r, f) {
      {
        var d = n, g = Bp(d.namespace, r), x = $m(d.ancestorInfo, r);
        return {
          namespace: g,
          ancestorInfo: x
        };
      }
    }
    function fQ(n) {
      return n;
    }
    function LF(n) {
      v_ = pi(), y_ = Kz();
      var r = null;
      return _i(!1), r;
    }
    function NF(n) {
      Xz(y_), _i(v_), v_ = null, y_ = null;
    }
    function zF(n, r, f, d, g) {
      var x;
      {
        var C = d;
        if (Im(n, null, C.ancestorInfo), typeof r.children == "string" || typeof r.children == "number") {
          var D = "" + r.children, k = $m(C.ancestorInfo, n);
          Im(null, D, k);
        }
        x = C.namespace;
      }
      var L = vF(n, r, f, x);
      return Xm(g, L), E_(L, r), L;
    }
    function FF(n, r) {
      n.appendChild(r);
    }
    function VF(n, r, f, d, g) {
      switch (bF(n, r, f, d), r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!f.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function jF(n, r, f, d, g, x) {
      {
        var C = x;
        if (typeof d.children != typeof f.children && (typeof d.children == "string" || typeof d.children == "number")) {
          var D = "" + d.children, k = $m(C.ancestorInfo, r);
          Im(null, D, k);
        }
      }
      return xF(n, r, f, d);
    }
    function b_(n, r) {
      return n === "textarea" || n === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
    }
    function BF(n, r, f, d) {
      {
        var g = f;
        Im(null, n, g.ancestorInfo);
      }
      var x = yF(n, r);
      return Xm(d, x), x;
    }
    function HF() {
      var n = window.event;
      return n === void 0 ? ua : ih(n.type);
    }
    var x_ = typeof setTimeout == "function" ? setTimeout : void 0, UF = typeof clearTimeout == "function" ? clearTimeout : void 0, S_ = -1, hD = typeof Promise == "function" ? Promise : void 0, IF = typeof queueMicrotask == "function" ? queueMicrotask : typeof hD < "u" ? function(n) {
      return hD.resolve(null).then(n).catch($F);
    } : x_;
    function $F(n) {
      setTimeout(function() {
        throw n;
      });
    }
    function WF(n, r, f, d) {
      switch (r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          f.autoFocus && n.focus();
          return;
        case "img": {
          f.src && (n.src = f.src);
          return;
        }
      }
    }
    function YF(n, r, f, d, g, x) {
      SF(n, r, f, d, g), E_(n, g);
    }
    function pD(n) {
      iu(n, "");
    }
    function GF(n, r, f) {
      n.nodeValue = f;
    }
    function KF(n, r) {
      n.appendChild(r);
    }
    function XF(n, r) {
      var f;
      n.nodeType === li ? (f = n.parentNode, f.insertBefore(r, n)) : (f = n, f.appendChild(r));
      var d = n._reactRootContainer;
      d == null && f.onclick === null && v0(f);
    }
    function QF(n, r, f) {
      n.insertBefore(r, f);
    }
    function qF(n, r, f) {
      n.nodeType === li ? n.parentNode.insertBefore(r, f) : n.insertBefore(r, f);
    }
    function ZF(n, r) {
      n.removeChild(r);
    }
    function JF(n, r) {
      n.nodeType === li ? n.parentNode.removeChild(r) : n.removeChild(r);
    }
    function __(n, r) {
      var f = r, d = 0;
      do {
        var g = f.nextSibling;
        if (n.removeChild(f), g && g.nodeType === li) {
          var x = g.data;
          if (x === x0)
            if (d === 0) {
              n.removeChild(g), xl(r);
              return;
            } else
              d--;
          else (x === b0 || x === Wm || x === Ym) && d++;
        }
        f = g;
      } while (f);
      xl(r);
    }
    function eV(n, r) {
      n.nodeType === li ? __(n.parentNode, r) : n.nodeType === xr && __(n, r), xl(n);
    }
    function tV(n) {
      n = n;
      var r = n.style;
      typeof r.setProperty == "function" ? r.setProperty("display", "none", "important") : r.display = "none";
    }
    function nV(n) {
      n.nodeValue = "";
    }
    function iV(n, r) {
      n = n;
      var f = r[AF], d = f != null && f.hasOwnProperty("display") ? f.display : null;
      n.style.display = ud("display", d);
    }
    function rV(n, r) {
      n.nodeValue = r;
    }
    function aV(n) {
      n.nodeType === xr ? n.textContent = "" : n.nodeType === Es && n.documentElement && n.removeChild(n.documentElement);
    }
    function sV(n, r, f) {
      return n.nodeType !== xr || r.toLowerCase() !== n.nodeName.toLowerCase() ? null : n;
    }
    function oV(n, r) {
      return r === "" || n.nodeType !== Ts ? null : n;
    }
    function lV(n) {
      return n.nodeType !== li ? null : n;
    }
    function mD(n) {
      return n.data === Wm;
    }
    function w_(n) {
      return n.data === Ym;
    }
    function uV(n) {
      var r = n.nextSibling && n.nextSibling.dataset, f, d, g;
      return r && (f = r.dgst, d = r.msg, g = r.stck), {
        message: d,
        digest: f,
        stack: g
      };
    }
    function cV(n, r) {
      n._reactRetry = r;
    }
    function S0(n) {
      for (; n != null; n = n.nextSibling) {
        var r = n.nodeType;
        if (r === xr || r === Ts)
          break;
        if (r === li) {
          var f = n.data;
          if (f === b0 || f === Ym || f === Wm)
            break;
          if (f === x0)
            return null;
        }
      }
      return n;
    }
    function Gm(n) {
      return S0(n.nextSibling);
    }
    function fV(n) {
      return S0(n.firstChild);
    }
    function dV(n) {
      return S0(n.firstChild);
    }
    function hV(n) {
      return S0(n.nextSibling);
    }
    function pV(n, r, f, d, g, x, C) {
      Xm(x, n), E_(n, f);
      var D;
      {
        var k = g;
        D = k.namespace;
      }
      var L = (x.mode & Nt) !== ot;
      return wF(n, r, f, D, d, L, C);
    }
    function mV(n, r, f, d) {
      return Xm(f, n), f.mode & Nt, CF(n, r);
    }
    function gV(n, r) {
      Xm(r, n);
    }
    function vV(n) {
      for (var r = n.nextSibling, f = 0; r; ) {
        if (r.nodeType === li) {
          var d = r.data;
          if (d === x0) {
            if (f === 0)
              return Gm(r);
            f--;
          } else (d === b0 || d === Ym || d === Wm) && f++;
        }
        r = r.nextSibling;
      }
      return null;
    }
    function gD(n) {
      for (var r = n.previousSibling, f = 0; r; ) {
        if (r.nodeType === li) {
          var d = r.data;
          if (d === b0 || d === Ym || d === Wm) {
            if (f === 0)
              return r;
            f--;
          } else d === x0 && f++;
        }
        r = r.previousSibling;
      }
      return null;
    }
    function yV(n) {
      xl(n);
    }
    function bV(n) {
      xl(n);
    }
    function xV(n) {
      return n !== "head" && n !== "body";
    }
    function SV(n, r, f, d) {
      var g = !0;
      g0(r.nodeValue, f, d, g);
    }
    function _V(n, r, f, d, g, x) {
      if (r[y0] !== !0) {
        var C = !0;
        g0(d.nodeValue, g, x, C);
      }
    }
    function wV(n, r) {
      r.nodeType === xr ? h_(n, r) : r.nodeType === li || p_(n, r);
    }
    function CV(n, r) {
      {
        var f = n.parentNode;
        f !== null && (r.nodeType === xr ? h_(f, r) : r.nodeType === li || p_(f, r));
      }
    }
    function TV(n, r, f, d, g) {
      (g || r[y0] !== !0) && (d.nodeType === xr ? h_(f, d) : d.nodeType === li || p_(f, d));
    }
    function EV(n, r, f) {
      m_(n, r);
    }
    function DV(n, r) {
      g_(n, r);
    }
    function RV(n, r, f) {
      {
        var d = n.parentNode;
        d !== null && m_(d, r);
      }
    }
    function kV(n, r) {
      {
        var f = n.parentNode;
        f !== null && g_(f, r);
      }
    }
    function MV(n, r, f, d, g, x) {
      (x || r[y0] !== !0) && m_(f, d);
    }
    function AV(n, r, f, d, g) {
      (g || r[y0] !== !0) && g_(f, d);
    }
    function OV(n) {
      u("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", n.nodeName.toLowerCase());
    }
    function PV(n) {
      jm(n);
    }
    var vh = Math.random().toString(36).slice(2), yh = "__reactFiber$" + vh, C_ = "__reactProps$" + vh, Km = "__reactContainer$" + vh, T_ = "__reactEvents$" + vh, LV = "__reactListeners$" + vh, NV = "__reactHandles$" + vh;
    function zV(n) {
      delete n[yh], delete n[C_], delete n[T_], delete n[LV], delete n[NV];
    }
    function Xm(n, r) {
      r[yh] = n;
    }
    function _0(n, r) {
      r[Km] = n;
    }
    function vD(n) {
      n[Km] = null;
    }
    function Qm(n) {
      return !!n[Km];
    }
    function ff(n) {
      var r = n[yh];
      if (r)
        return r;
      for (var f = n.parentNode; f; ) {
        if (r = f[Km] || f[yh], r) {
          var d = r.alternate;
          if (r.child !== null || d !== null && d.child !== null)
            for (var g = gD(n); g !== null; ) {
              var x = g[yh];
              if (x)
                return x;
              g = gD(g);
            }
          return r;
        }
        n = f, f = n.parentNode;
      }
      return null;
    }
    function Du(n) {
      var r = n[yh] || n[Km];
      return r && (r.tag === E || r.tag === R || r.tag === F || r.tag === S) ? r : null;
    }
    function bh(n) {
      if (n.tag === E || n.tag === R)
        return n.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function w0(n) {
      return n[C_] || null;
    }
    function E_(n, r) {
      n[C_] = r;
    }
    function FV(n) {
      var r = n[T_];
      return r === void 0 && (r = n[T_] = /* @__PURE__ */ new Set()), r;
    }
    var yD = {}, bD = i.ReactDebugCurrentFrame;
    function C0(n) {
      if (n) {
        var r = n._owner, f = Xo(n.type, n._source, r ? r.type : null);
        bD.setExtraStackFrame(f);
      } else
        bD.setExtraStackFrame(null);
    }
    function Fs(n, r, f, d, g) {
      {
        var x = Function.call.bind(St);
        for (var C in n)
          if (x(n, C)) {
            var D = void 0;
            try {
              if (typeof n[C] != "function") {
                var k = Error((d || "React class") + ": " + f + " type `" + C + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof n[C] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw k.name = "Invariant Violation", k;
              }
              D = n[C](r, C, d, f, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (L) {
              D = L;
            }
            D && !(D instanceof Error) && (C0(g), u("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", d || "React class", f, C, typeof D), C0(null)), D instanceof Error && !(D.message in yD) && (yD[D.message] = !0, C0(g), u("Failed %s type: %s", f, D.message), C0(null));
          }
      }
    }
    var D_ = [], T0;
    T0 = [];
    var El = -1;
    function Ru(n) {
      return {
        current: n
      };
    }
    function Ar(n, r) {
      if (El < 0) {
        u("Unexpected pop.");
        return;
      }
      r !== T0[El] && u("Unexpected Fiber popped."), n.current = D_[El], D_[El] = null, T0[El] = null, El--;
    }
    function Or(n, r, f) {
      El++, D_[El] = n.current, T0[El] = f, n.current = r;
    }
    var R_;
    R_ = {};
    var Va = {};
    Object.freeze(Va);
    var Dl = Ru(Va), Co = Ru(!1), k_ = Va;
    function xh(n, r, f) {
      return f && To(r) ? k_ : Dl.current;
    }
    function xD(n, r, f) {
      {
        var d = n.stateNode;
        d.__reactInternalMemoizedUnmaskedChildContext = r, d.__reactInternalMemoizedMaskedChildContext = f;
      }
    }
    function Sh(n, r) {
      {
        var f = n.type, d = f.contextTypes;
        if (!d)
          return Va;
        var g = n.stateNode;
        if (g && g.__reactInternalMemoizedUnmaskedChildContext === r)
          return g.__reactInternalMemoizedMaskedChildContext;
        var x = {};
        for (var C in d)
          x[C] = r[C];
        {
          var D = kt(n) || "Unknown";
          Fs(d, x, "context", D);
        }
        return g && xD(n, r, x), x;
      }
    }
    function E0() {
      return Co.current;
    }
    function To(n) {
      {
        var r = n.childContextTypes;
        return r != null;
      }
    }
    function D0(n) {
      Ar(Co, n), Ar(Dl, n);
    }
    function M_(n) {
      Ar(Co, n), Ar(Dl, n);
    }
    function SD(n, r, f) {
      {
        if (Dl.current !== Va)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Or(Dl, r, n), Or(Co, f, n);
      }
    }
    function _D(n, r, f) {
      {
        var d = n.stateNode, g = r.childContextTypes;
        if (typeof d.getChildContext != "function") {
          {
            var x = kt(n) || "Unknown";
            R_[x] || (R_[x] = !0, u("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", x, x));
          }
          return f;
        }
        var C = d.getChildContext();
        for (var D in C)
          if (!(D in g))
            throw new Error((kt(n) || "Unknown") + '.getChildContext(): key "' + D + '" is not defined in childContextTypes.');
        {
          var k = kt(n) || "Unknown";
          Fs(g, C, "child context", k);
        }
        return Lt({}, f, C);
      }
    }
    function R0(n) {
      {
        var r = n.stateNode, f = r && r.__reactInternalMemoizedMergedChildContext || Va;
        return k_ = Dl.current, Or(Dl, f, n), Or(Co, Co.current, n), !0;
      }
    }
    function wD(n, r, f) {
      {
        var d = n.stateNode;
        if (!d)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (f) {
          var g = _D(n, r, k_);
          d.__reactInternalMemoizedMergedChildContext = g, Ar(Co, n), Ar(Dl, n), Or(Dl, g, n), Or(Co, f, n);
        } else
          Ar(Co, n), Or(Co, f, n);
      }
    }
    function VV(n) {
      {
        if (!sl(n) || n.tag !== v)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var r = n;
        do {
          switch (r.tag) {
            case S:
              return r.stateNode.context;
            case v: {
              var f = r.type;
              if (To(f))
                return r.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          r = r.return;
        } while (r !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var ku = 0, k0 = 1, Rl = null, A_ = !1, O_ = !1;
    function CD(n) {
      Rl === null ? Rl = [n] : Rl.push(n);
    }
    function jV(n) {
      A_ = !0, CD(n);
    }
    function TD() {
      A_ && Mu();
    }
    function Mu() {
      if (!O_ && Rl !== null) {
        O_ = !0;
        var n = 0, r = fa();
        try {
          var f = !0, d = Rl;
          for (hi(ir); n < d.length; n++) {
            var g = d[n];
            do
              g = g(f);
            while (g !== null);
          }
          Rl = null, A_ = !1;
        } catch (x) {
          throw Rl !== null && (Rl = Rl.slice(n + 1)), Jp(kc, Mu), x;
        } finally {
          hi(r), O_ = !1;
        }
      }
      return null;
    }
    var _h = [], wh = 0, M0 = null, A0 = 0, os = [], ls = 0, df = null, kl = 1, Ml = "";
    function BV(n) {
      return pf(), (n.flags & qa) !== st;
    }
    function HV(n) {
      return pf(), A0;
    }
    function UV() {
      var n = Ml, r = kl, f = r & ~IV(r);
      return f.toString(32) + n;
    }
    function hf(n, r) {
      pf(), _h[wh++] = A0, _h[wh++] = M0, M0 = n, A0 = r;
    }
    function ED(n, r, f) {
      pf(), os[ls++] = kl, os[ls++] = Ml, os[ls++] = df, df = n;
      var d = kl, g = Ml, x = O0(d) - 1, C = d & ~(1 << x), D = f + 1, k = O0(r) + x;
      if (k > 30) {
        var L = x - x % 5, N = (1 << L) - 1, G = (C & N).toString(32), W = C >> L, J = x - L, ie = O0(r) + J, ue = D << J, Ie = ue | W, ft = G + g;
        kl = 1 << ie | Ie, Ml = ft;
      } else {
        var nt = D << x, It = nt | C, Vt = g;
        kl = 1 << k | It, Ml = Vt;
      }
    }
    function P_(n) {
      pf();
      var r = n.return;
      if (r !== null) {
        var f = 1, d = 0;
        hf(n, f), ED(n, f, d);
      }
    }
    function O0(n) {
      return 32 - fi(n);
    }
    function IV(n) {
      return 1 << O0(n) - 1;
    }
    function L_(n) {
      for (; n === M0; )
        M0 = _h[--wh], _h[wh] = null, A0 = _h[--wh], _h[wh] = null;
      for (; n === df; )
        df = os[--ls], os[ls] = null, Ml = os[--ls], os[ls] = null, kl = os[--ls], os[ls] = null;
    }
    function $V() {
      return pf(), df !== null ? {
        id: kl,
        overflow: Ml
      } : null;
    }
    function WV(n, r) {
      pf(), os[ls++] = kl, os[ls++] = Ml, os[ls++] = df, kl = r.id, Ml = r.overflow, df = n;
    }
    function pf() {
      lr() || u("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var or = null, us = null, Vs = !1, mf = !1, Au = null;
    function YV() {
      Vs && u("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function DD() {
      mf = !0;
    }
    function GV() {
      return mf;
    }
    function KV(n) {
      var r = n.stateNode.containerInfo;
      return us = dV(r), or = n, Vs = !0, Au = null, mf = !1, !0;
    }
    function XV(n, r, f) {
      return us = hV(r), or = n, Vs = !0, Au = null, mf = !1, f !== null && WV(n, f), !0;
    }
    function RD(n, r) {
      switch (n.tag) {
        case S: {
          wV(n.stateNode.containerInfo, r);
          break;
        }
        case E: {
          var f = (n.mode & Nt) !== ot;
          TV(
            n.type,
            n.memoizedProps,
            n.stateNode,
            r,
            // TODO: Delete this argument when we remove the legacy root API.
            f
          );
          break;
        }
        case F: {
          var d = n.memoizedState;
          d.dehydrated !== null && CV(d.dehydrated, r);
          break;
        }
      }
    }
    function kD(n, r) {
      RD(n, r);
      var f = JH();
      f.stateNode = r, f.return = n;
      var d = n.deletions;
      d === null ? (n.deletions = [f], n.flags |= ra) : d.push(f);
    }
    function N_(n, r) {
      {
        if (mf)
          return;
        switch (n.tag) {
          case S: {
            var f = n.stateNode.containerInfo;
            switch (r.tag) {
              case E:
                var d = r.type;
                r.pendingProps, EV(f, d);
                break;
              case R:
                var g = r.pendingProps;
                DV(f, g);
                break;
            }
            break;
          }
          case E: {
            var x = n.type, C = n.memoizedProps, D = n.stateNode;
            switch (r.tag) {
              case E: {
                var k = r.type, L = r.pendingProps, N = (n.mode & Nt) !== ot;
                MV(
                  x,
                  C,
                  D,
                  k,
                  L,
                  // TODO: Delete this argument when we remove the legacy root API.
                  N
                );
                break;
              }
              case R: {
                var G = r.pendingProps, W = (n.mode & Nt) !== ot;
                AV(
                  x,
                  C,
                  D,
                  G,
                  // TODO: Delete this argument when we remove the legacy root API.
                  W
                );
                break;
              }
            }
            break;
          }
          case F: {
            var J = n.memoizedState, ie = J.dehydrated;
            if (ie !== null) switch (r.tag) {
              case E:
                var ue = r.type;
                r.pendingProps, RV(ie, ue);
                break;
              case R:
                var Ie = r.pendingProps;
                kV(ie, Ie);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function MD(n, r) {
      r.flags = r.flags & -4097 | qn, N_(n, r);
    }
    function AD(n, r) {
      switch (n.tag) {
        case E: {
          var f = n.type;
          n.pendingProps;
          var d = sV(r, f);
          return d !== null ? (n.stateNode = d, or = n, us = fV(d), !0) : !1;
        }
        case R: {
          var g = n.pendingProps, x = oV(r, g);
          return x !== null ? (n.stateNode = x, or = n, us = null, !0) : !1;
        }
        case F: {
          var C = lV(r);
          if (C !== null) {
            var D = {
              dehydrated: C,
              treeContext: $V(),
              retryLane: Yr
            };
            n.memoizedState = D;
            var k = eU(C);
            return k.return = n, n.child = k, or = n, us = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function z_(n) {
      return (n.mode & Nt) !== ot && (n.flags & at) === st;
    }
    function F_(n) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function V_(n) {
      if (Vs) {
        var r = us;
        if (!r) {
          z_(n) && (N_(or, n), F_()), MD(or, n), Vs = !1, or = n;
          return;
        }
        var f = r;
        if (!AD(n, r)) {
          z_(n) && (N_(or, n), F_()), r = Gm(f);
          var d = or;
          if (!r || !AD(n, r)) {
            MD(or, n), Vs = !1, or = n;
            return;
          }
          kD(d, f);
        }
      }
    }
    function QV(n, r, f) {
      var d = n.stateNode, g = !mf, x = pV(d, n.type, n.memoizedProps, r, f, n, g);
      return n.updateQueue = x, x !== null;
    }
    function qV(n) {
      var r = n.stateNode, f = n.memoizedProps, d = mV(r, f, n);
      if (d) {
        var g = or;
        if (g !== null)
          switch (g.tag) {
            case S: {
              var x = g.stateNode.containerInfo, C = (g.mode & Nt) !== ot;
              SV(
                x,
                r,
                f,
                // TODO: Delete this argument when we remove the legacy root API.
                C
              );
              break;
            }
            case E: {
              var D = g.type, k = g.memoizedProps, L = g.stateNode, N = (g.mode & Nt) !== ot;
              _V(
                D,
                k,
                L,
                r,
                f,
                // TODO: Delete this argument when we remove the legacy root API.
                N
              );
              break;
            }
          }
      }
      return d;
    }
    function ZV(n) {
      var r = n.memoizedState, f = r !== null ? r.dehydrated : null;
      if (!f)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      gV(f, n);
    }
    function JV(n) {
      var r = n.memoizedState, f = r !== null ? r.dehydrated : null;
      if (!f)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return vV(f);
    }
    function OD(n) {
      for (var r = n.return; r !== null && r.tag !== E && r.tag !== S && r.tag !== F; )
        r = r.return;
      or = r;
    }
    function P0(n) {
      if (n !== or)
        return !1;
      if (!Vs)
        return OD(n), Vs = !0, !1;
      if (n.tag !== S && (n.tag !== E || xV(n.type) && !b_(n.type, n.memoizedProps))) {
        var r = us;
        if (r)
          if (z_(n))
            PD(n), F_();
          else
            for (; r; )
              kD(n, r), r = Gm(r);
      }
      return OD(n), n.tag === F ? us = JV(n) : us = or ? Gm(n.stateNode) : null, !0;
    }
    function ej() {
      return Vs && us !== null;
    }
    function PD(n) {
      for (var r = us; r; )
        RD(n, r), r = Gm(r);
    }
    function Ch() {
      or = null, us = null, Vs = !1, mf = !1;
    }
    function LD() {
      Au !== null && (Dk(Au), Au = null);
    }
    function lr() {
      return Vs;
    }
    function j_(n) {
      Au === null ? Au = [n] : Au.push(n);
    }
    var tj = i.ReactCurrentBatchConfig, nj = null;
    function ij() {
      return tj.transition;
    }
    var js = {
      recordUnsafeLifecycleWarnings: function(n, r) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(n, r) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var rj = function(n) {
        for (var r = null, f = n; f !== null; )
          f.mode & vn && (r = f), f = f.return;
        return r;
      }, gf = function(n) {
        var r = [];
        return n.forEach(function(f) {
          r.push(f);
        }), r.sort().join(", ");
      }, qm = [], Zm = [], Jm = [], eg = [], tg = [], ng = [], vf = /* @__PURE__ */ new Set();
      js.recordUnsafeLifecycleWarnings = function(n, r) {
        vf.has(n.type) || (typeof r.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        r.componentWillMount.__suppressDeprecationWarning !== !0 && qm.push(n), n.mode & vn && typeof r.UNSAFE_componentWillMount == "function" && Zm.push(n), typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Jm.push(n), n.mode & vn && typeof r.UNSAFE_componentWillReceiveProps == "function" && eg.push(n), typeof r.componentWillUpdate == "function" && r.componentWillUpdate.__suppressDeprecationWarning !== !0 && tg.push(n), n.mode & vn && typeof r.UNSAFE_componentWillUpdate == "function" && ng.push(n));
      }, js.flushPendingUnsafeLifecycleWarnings = function() {
        var n = /* @__PURE__ */ new Set();
        qm.length > 0 && (qm.forEach(function(W) {
          n.add(kt(W) || "Component"), vf.add(W.type);
        }), qm = []);
        var r = /* @__PURE__ */ new Set();
        Zm.length > 0 && (Zm.forEach(function(W) {
          r.add(kt(W) || "Component"), vf.add(W.type);
        }), Zm = []);
        var f = /* @__PURE__ */ new Set();
        Jm.length > 0 && (Jm.forEach(function(W) {
          f.add(kt(W) || "Component"), vf.add(W.type);
        }), Jm = []);
        var d = /* @__PURE__ */ new Set();
        eg.length > 0 && (eg.forEach(function(W) {
          d.add(kt(W) || "Component"), vf.add(W.type);
        }), eg = []);
        var g = /* @__PURE__ */ new Set();
        tg.length > 0 && (tg.forEach(function(W) {
          g.add(kt(W) || "Component"), vf.add(W.type);
        }), tg = []);
        var x = /* @__PURE__ */ new Set();
        if (ng.length > 0 && (ng.forEach(function(W) {
          x.add(kt(W) || "Component"), vf.add(W.type);
        }), ng = []), r.size > 0) {
          var C = gf(r);
          u(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, C);
        }
        if (d.size > 0) {
          var D = gf(d);
          u(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, D);
        }
        if (x.size > 0) {
          var k = gf(x);
          u(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, k);
        }
        if (n.size > 0) {
          var L = gf(n);
          c(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, L);
        }
        if (f.size > 0) {
          var N = gf(f);
          c(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, N);
        }
        if (g.size > 0) {
          var G = gf(g);
          c(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, G);
        }
      };
      var L0 = /* @__PURE__ */ new Map(), ND = /* @__PURE__ */ new Set();
      js.recordLegacyContextWarning = function(n, r) {
        var f = rj(n);
        if (f === null) {
          u("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!ND.has(n.type)) {
          var d = L0.get(f);
          (n.type.contextTypes != null || n.type.childContextTypes != null || r !== null && typeof r.getChildContext == "function") && (d === void 0 && (d = [], L0.set(f, d)), d.push(n));
        }
      }, js.flushLegacyContextWarning = function() {
        L0.forEach(function(n, r) {
          if (n.length !== 0) {
            var f = n[0], d = /* @__PURE__ */ new Set();
            n.forEach(function(x) {
              d.add(kt(x) || "Component"), ND.add(x.type);
            });
            var g = gf(d);
            try {
              Rn(f), u(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, g);
            } finally {
              Wn();
            }
          }
        });
      }, js.discardPendingWarnings = function() {
        qm = [], Zm = [], Jm = [], eg = [], tg = [], ng = [], L0 = /* @__PURE__ */ new Map();
      };
    }
    var B_, H_, U_, I_, $_, zD = function(n, r) {
    };
    B_ = !1, H_ = !1, U_ = {}, I_ = {}, $_ = {}, zD = function(n, r) {
      if (!(n === null || typeof n != "object") && !(!n._store || n._store.validated || n.key != null)) {
        if (typeof n._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        n._store.validated = !0;
        var f = kt(r) || "Component";
        I_[f] || (I_[f] = !0, u('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function aj(n) {
      return n.prototype && n.prototype.isReactComponent;
    }
    function ig(n, r, f) {
      var d = f.ref;
      if (d !== null && typeof d != "function" && typeof d != "object") {
        if ((n.mode & vn || oe) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(f._owner && f._self && f._owner.stateNode !== f._self) && // Will already throw with "Function components cannot have string refs"
        !(f._owner && f._owner.tag !== v) && // Will already warn with "Function components cannot be given refs"
        !(typeof f.type == "function" && !aj(f.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        f._owner) {
          var g = kt(n) || "Component";
          U_[g] || (u('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', g, d), U_[g] = !0);
        }
        if (f._owner) {
          var x = f._owner, C;
          if (x) {
            var D = x;
            if (D.tag !== v)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            C = D.stateNode;
          }
          if (!C)
            throw new Error("Missing owner for string ref " + d + ". This error is likely caused by a bug in React. Please file an issue.");
          var k = C;
          sn(d, "ref");
          var L = "" + d;
          if (r !== null && r.ref !== null && typeof r.ref == "function" && r.ref._stringRef === L)
            return r.ref;
          var N = function(G) {
            var W = k.refs;
            G === null ? delete W[L] : W[L] = G;
          };
          return N._stringRef = L, N;
        } else {
          if (typeof d != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!f._owner)
            throw new Error("Element ref was specified as a string (" + d + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return d;
    }
    function N0(n, r) {
      var f = Object.prototype.toString.call(r);
      throw new Error("Objects are not valid as a React child (found: " + (f === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : f) + "). If you meant to render a collection of children, use an array instead.");
    }
    function z0(n) {
      {
        var r = kt(n) || "Component";
        if ($_[r])
          return;
        $_[r] = !0, u("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function FD(n) {
      var r = n._payload, f = n._init;
      return f(r);
    }
    function VD(n) {
      function r(Q, ce) {
        if (n) {
          var q = Q.deletions;
          q === null ? (Q.deletions = [ce], Q.flags |= ra) : q.push(ce);
        }
      }
      function f(Q, ce) {
        if (!n)
          return null;
        for (var q = ce; q !== null; )
          r(Q, q), q = q.sibling;
        return null;
      }
      function d(Q, ce) {
        for (var q = /* @__PURE__ */ new Map(), Re = ce; Re !== null; )
          Re.key !== null ? q.set(Re.key, Re) : q.set(Re.index, Re), Re = Re.sibling;
        return q;
      }
      function g(Q, ce) {
        var q = Ef(Q, ce);
        return q.index = 0, q.sibling = null, q;
      }
      function x(Q, ce, q) {
        if (Q.index = q, !n)
          return Q.flags |= qa, ce;
        var Re = Q.alternate;
        if (Re !== null) {
          var Ke = Re.index;
          return Ke < ce ? (Q.flags |= qn, ce) : Ke;
        } else
          return Q.flags |= qn, ce;
      }
      function C(Q) {
        return n && Q.alternate === null && (Q.flags |= qn), Q;
      }
      function D(Q, ce, q, Re) {
        if (ce === null || ce.tag !== R) {
          var Ke = jC(q, Q.mode, Re);
          return Ke.return = Q, Ke;
        } else {
          var We = g(ce, q);
          return We.return = Q, We;
        }
      }
      function k(Q, ce, q, Re) {
        var Ke = q.type;
        if (Ke === yr)
          return N(Q, ce, q.props.children, Re, q.key);
        if (ce !== null && (ce.elementType === Ke || // Keep this check inline so it only runs on the false path:
        Ik(ce, q) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Ke == "object" && Ke !== null && Ke.$$typeof === Dt && FD(Ke) === ce.type)) {
          var We = g(ce, q.props);
          return We.ref = ig(Q, ce, q), We.return = Q, We._debugSource = q._source, We._debugOwner = q._owner, We;
        }
        var vt = VC(q, Q.mode, Re);
        return vt.ref = ig(Q, ce, q), vt.return = Q, vt;
      }
      function L(Q, ce, q, Re) {
        if (ce === null || ce.tag !== w || ce.stateNode.containerInfo !== q.containerInfo || ce.stateNode.implementation !== q.implementation) {
          var Ke = BC(q, Q.mode, Re);
          return Ke.return = Q, Ke;
        } else {
          var We = g(ce, q.children || []);
          return We.return = Q, We;
        }
      }
      function N(Q, ce, q, Re, Ke) {
        if (ce === null || ce.tag !== M) {
          var We = Uu(q, Q.mode, Re, Ke);
          return We.return = Q, We;
        } else {
          var vt = g(ce, q);
          return vt.return = Q, vt;
        }
      }
      function G(Q, ce, q) {
        if (typeof ce == "string" && ce !== "" || typeof ce == "number") {
          var Re = jC("" + ce, Q.mode, q);
          return Re.return = Q, Re;
        }
        if (typeof ce == "object" && ce !== null) {
          switch (ce.$$typeof) {
            case hn: {
              var Ke = VC(ce, Q.mode, q);
              return Ke.ref = ig(Q, null, ce), Ke.return = Q, Ke;
            }
            case An: {
              var We = BC(ce, Q.mode, q);
              return We.return = Q, We;
            }
            case Dt: {
              var vt = ce._payload, Rt = ce._init;
              return G(Q, Rt(vt), q);
            }
          }
          if (Ni(ce) || At(ce)) {
            var bn = Uu(ce, Q.mode, q, null);
            return bn.return = Q, bn;
          }
          N0(Q, ce);
        }
        return typeof ce == "function" && z0(Q), null;
      }
      function W(Q, ce, q, Re) {
        var Ke = ce !== null ? ce.key : null;
        if (typeof q == "string" && q !== "" || typeof q == "number")
          return Ke !== null ? null : D(Q, ce, "" + q, Re);
        if (typeof q == "object" && q !== null) {
          switch (q.$$typeof) {
            case hn:
              return q.key === Ke ? k(Q, ce, q, Re) : null;
            case An:
              return q.key === Ke ? L(Q, ce, q, Re) : null;
            case Dt: {
              var We = q._payload, vt = q._init;
              return W(Q, ce, vt(We), Re);
            }
          }
          if (Ni(q) || At(q))
            return Ke !== null ? null : N(Q, ce, q, Re, null);
          N0(Q, q);
        }
        return typeof q == "function" && z0(Q), null;
      }
      function J(Q, ce, q, Re, Ke) {
        if (typeof Re == "string" && Re !== "" || typeof Re == "number") {
          var We = Q.get(q) || null;
          return D(ce, We, "" + Re, Ke);
        }
        if (typeof Re == "object" && Re !== null) {
          switch (Re.$$typeof) {
            case hn: {
              var vt = Q.get(Re.key === null ? q : Re.key) || null;
              return k(ce, vt, Re, Ke);
            }
            case An: {
              var Rt = Q.get(Re.key === null ? q : Re.key) || null;
              return L(ce, Rt, Re, Ke);
            }
            case Dt:
              var bn = Re._payload, nn = Re._init;
              return J(Q, ce, q, nn(bn), Ke);
          }
          if (Ni(Re) || At(Re)) {
            var wi = Q.get(q) || null;
            return N(ce, wi, Re, Ke, null);
          }
          N0(ce, Re);
        }
        return typeof Re == "function" && z0(ce), null;
      }
      function ie(Q, ce, q) {
        {
          if (typeof Q != "object" || Q === null)
            return ce;
          switch (Q.$$typeof) {
            case hn:
            case An:
              zD(Q, q);
              var Re = Q.key;
              if (typeof Re != "string")
                break;
              if (ce === null) {
                ce = /* @__PURE__ */ new Set(), ce.add(Re);
                break;
              }
              if (!ce.has(Re)) {
                ce.add(Re);
                break;
              }
              u("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Re);
              break;
            case Dt:
              var Ke = Q._payload, We = Q._init;
              ie(We(Ke), ce, q);
              break;
          }
        }
        return ce;
      }
      function ue(Q, ce, q, Re) {
        for (var Ke = null, We = 0; We < q.length; We++) {
          var vt = q[We];
          Ke = ie(vt, Ke, Q);
        }
        for (var Rt = null, bn = null, nn = ce, wi = 0, rn = 0, gi = null; nn !== null && rn < q.length; rn++) {
          nn.index > rn ? (gi = nn, nn = null) : gi = nn.sibling;
          var Lr = W(Q, nn, q[rn], Re);
          if (Lr === null) {
            nn === null && (nn = gi);
            break;
          }
          n && nn && Lr.alternate === null && r(Q, nn), wi = x(Lr, wi, rn), bn === null ? Rt = Lr : bn.sibling = Lr, bn = Lr, nn = gi;
        }
        if (rn === q.length) {
          if (f(Q, nn), lr()) {
            var mr = rn;
            hf(Q, mr);
          }
          return Rt;
        }
        if (nn === null) {
          for (; rn < q.length; rn++) {
            var Ba = G(Q, q[rn], Re);
            Ba !== null && (wi = x(Ba, wi, rn), bn === null ? Rt = Ba : bn.sibling = Ba, bn = Ba);
          }
          if (lr()) {
            var Zr = rn;
            hf(Q, Zr);
          }
          return Rt;
        }
        for (var Jr = d(Q, nn); rn < q.length; rn++) {
          var Nr = J(Jr, Q, rn, q[rn], Re);
          Nr !== null && (n && Nr.alternate !== null && Jr.delete(Nr.key === null ? rn : Nr.key), wi = x(Nr, wi, rn), bn === null ? Rt = Nr : bn.sibling = Nr, bn = Nr);
        }
        if (n && Jr.forEach(function(Ih) {
          return r(Q, Ih);
        }), lr()) {
          var Fl = rn;
          hf(Q, Fl);
        }
        return Rt;
      }
      function Ie(Q, ce, q, Re) {
        var Ke = At(q);
        if (typeof Ke != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          q[Symbol.toStringTag] === "Generator" && (H_ || u("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), H_ = !0), q.entries === Ke && (B_ || u("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), B_ = !0);
          var We = Ke.call(q);
          if (We)
            for (var vt = null, Rt = We.next(); !Rt.done; Rt = We.next()) {
              var bn = Rt.value;
              vt = ie(bn, vt, Q);
            }
        }
        var nn = Ke.call(q);
        if (nn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var wi = null, rn = null, gi = ce, Lr = 0, mr = 0, Ba = null, Zr = nn.next(); gi !== null && !Zr.done; mr++, Zr = nn.next()) {
          gi.index > mr ? (Ba = gi, gi = null) : Ba = gi.sibling;
          var Jr = W(Q, gi, Zr.value, Re);
          if (Jr === null) {
            gi === null && (gi = Ba);
            break;
          }
          n && gi && Jr.alternate === null && r(Q, gi), Lr = x(Jr, Lr, mr), rn === null ? wi = Jr : rn.sibling = Jr, rn = Jr, gi = Ba;
        }
        if (Zr.done) {
          if (f(Q, gi), lr()) {
            var Nr = mr;
            hf(Q, Nr);
          }
          return wi;
        }
        if (gi === null) {
          for (; !Zr.done; mr++, Zr = nn.next()) {
            var Fl = G(Q, Zr.value, Re);
            Fl !== null && (Lr = x(Fl, Lr, mr), rn === null ? wi = Fl : rn.sibling = Fl, rn = Fl);
          }
          if (lr()) {
            var Ih = mr;
            hf(Q, Ih);
          }
          return wi;
        }
        for (var Ng = d(Q, gi); !Zr.done; mr++, Zr = nn.next()) {
          var Po = J(Ng, Q, mr, Zr.value, Re);
          Po !== null && (n && Po.alternate !== null && Ng.delete(Po.key === null ? mr : Po.key), Lr = x(Po, Lr, mr), rn === null ? wi = Po : rn.sibling = Po, rn = Po);
        }
        if (n && Ng.forEach(function(AU) {
          return r(Q, AU);
        }), lr()) {
          var MU = mr;
          hf(Q, MU);
        }
        return wi;
      }
      function ft(Q, ce, q, Re) {
        if (ce !== null && ce.tag === R) {
          f(Q, ce.sibling);
          var Ke = g(ce, q);
          return Ke.return = Q, Ke;
        }
        f(Q, ce);
        var We = jC(q, Q.mode, Re);
        return We.return = Q, We;
      }
      function nt(Q, ce, q, Re) {
        for (var Ke = q.key, We = ce; We !== null; ) {
          if (We.key === Ke) {
            var vt = q.type;
            if (vt === yr) {
              if (We.tag === M) {
                f(Q, We.sibling);
                var Rt = g(We, q.props.children);
                return Rt.return = Q, Rt._debugSource = q._source, Rt._debugOwner = q._owner, Rt;
              }
            } else if (We.elementType === vt || // Keep this check inline so it only runs on the false path:
            Ik(We, q) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof vt == "object" && vt !== null && vt.$$typeof === Dt && FD(vt) === We.type) {
              f(Q, We.sibling);
              var bn = g(We, q.props);
              return bn.ref = ig(Q, We, q), bn.return = Q, bn._debugSource = q._source, bn._debugOwner = q._owner, bn;
            }
            f(Q, We);
            break;
          } else
            r(Q, We);
          We = We.sibling;
        }
        if (q.type === yr) {
          var nn = Uu(q.props.children, Q.mode, Re, q.key);
          return nn.return = Q, nn;
        } else {
          var wi = VC(q, Q.mode, Re);
          return wi.ref = ig(Q, ce, q), wi.return = Q, wi;
        }
      }
      function It(Q, ce, q, Re) {
        for (var Ke = q.key, We = ce; We !== null; ) {
          if (We.key === Ke)
            if (We.tag === w && We.stateNode.containerInfo === q.containerInfo && We.stateNode.implementation === q.implementation) {
              f(Q, We.sibling);
              var vt = g(We, q.children || []);
              return vt.return = Q, vt;
            } else {
              f(Q, We);
              break;
            }
          else
            r(Q, We);
          We = We.sibling;
        }
        var Rt = BC(q, Q.mode, Re);
        return Rt.return = Q, Rt;
      }
      function Vt(Q, ce, q, Re) {
        var Ke = typeof q == "object" && q !== null && q.type === yr && q.key === null;
        if (Ke && (q = q.props.children), typeof q == "object" && q !== null) {
          switch (q.$$typeof) {
            case hn:
              return C(nt(Q, ce, q, Re));
            case An:
              return C(It(Q, ce, q, Re));
            case Dt:
              var We = q._payload, vt = q._init;
              return Vt(Q, ce, vt(We), Re);
          }
          if (Ni(q))
            return ue(Q, ce, q, Re);
          if (At(q))
            return Ie(Q, ce, q, Re);
          N0(Q, q);
        }
        return typeof q == "string" && q !== "" || typeof q == "number" ? C(ft(Q, ce, "" + q, Re)) : (typeof q == "function" && z0(Q), f(Q, ce));
      }
      return Vt;
    }
    var Th = VD(!0), jD = VD(!1);
    function sj(n, r) {
      if (n !== null && r.child !== n.child)
        throw new Error("Resuming work not yet implemented.");
      if (r.child !== null) {
        var f = r.child, d = Ef(f, f.pendingProps);
        for (r.child = d, d.return = r; f.sibling !== null; )
          f = f.sibling, d = d.sibling = Ef(f, f.pendingProps), d.return = r;
        d.sibling = null;
      }
    }
    function oj(n, r) {
      for (var f = n.child; f !== null; )
        KH(f, r), f = f.sibling;
    }
    var W_ = Ru(null), Y_;
    Y_ = {};
    var F0 = null, Eh = null, G_ = null, V0 = !1;
    function j0() {
      F0 = null, Eh = null, G_ = null, V0 = !1;
    }
    function BD() {
      V0 = !0;
    }
    function HD() {
      V0 = !1;
    }
    function UD(n, r, f) {
      Or(W_, r._currentValue, n), r._currentValue = f, r._currentRenderer !== void 0 && r._currentRenderer !== null && r._currentRenderer !== Y_ && u("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), r._currentRenderer = Y_;
    }
    function K_(n, r) {
      var f = W_.current;
      Ar(W_, r), n._currentValue = f;
    }
    function X_(n, r, f) {
      for (var d = n; d !== null; ) {
        var g = d.alternate;
        if (bl(d.childLanes, r) ? g !== null && !bl(g.childLanes, r) && (g.childLanes = Mt(g.childLanes, r)) : (d.childLanes = Mt(d.childLanes, r), g !== null && (g.childLanes = Mt(g.childLanes, r))), d === f)
          break;
        d = d.return;
      }
      d !== f && u("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function lj(n, r, f) {
      uj(n, r, f);
    }
    function uj(n, r, f) {
      var d = n.child;
      for (d !== null && (d.return = n); d !== null; ) {
        var g = void 0, x = d.dependencies;
        if (x !== null) {
          g = d.child;
          for (var C = x.firstContext; C !== null; ) {
            if (C.context === r) {
              if (d.tag === v) {
                var D = Ic(f), k = Al(Sn, D);
                k.tag = H0;
                var L = d.updateQueue;
                if (L !== null) {
                  var N = L.shared, G = N.pending;
                  G === null ? k.next = k : (k.next = G.next, G.next = k), N.pending = k;
                }
              }
              d.lanes = Mt(d.lanes, f);
              var W = d.alternate;
              W !== null && (W.lanes = Mt(W.lanes, f)), X_(d.return, f, n), x.lanes = Mt(x.lanes, f);
              break;
            }
            C = C.next;
          }
        } else if (d.tag === z)
          g = d.type === n.type ? null : d.child;
        else if (d.tag === ne) {
          var J = d.return;
          if (J === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          J.lanes = Mt(J.lanes, f);
          var ie = J.alternate;
          ie !== null && (ie.lanes = Mt(ie.lanes, f)), X_(J, f, n), g = d.sibling;
        } else
          g = d.child;
        if (g !== null)
          g.return = d;
        else
          for (g = d; g !== null; ) {
            if (g === n) {
              g = null;
              break;
            }
            var ue = g.sibling;
            if (ue !== null) {
              ue.return = g.return, g = ue;
              break;
            }
            g = g.return;
          }
        d = g;
      }
    }
    function Dh(n, r) {
      F0 = n, Eh = null, G_ = null;
      var f = n.dependencies;
      if (f !== null) {
        var d = f.firstContext;
        d !== null && (Dr(f.lanes, r) && yg(), f.firstContext = null);
      }
    }
    function Ai(n) {
      V0 && u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var r = n._currentValue;
      if (G_ !== n) {
        var f = {
          context: n,
          memoizedValue: r,
          next: null
        };
        if (Eh === null) {
          if (F0 === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Eh = f, F0.dependencies = {
            lanes: ye,
            firstContext: f
          };
        } else
          Eh = Eh.next = f;
      }
      return r;
    }
    var yf = null;
    function Q_(n) {
      yf === null ? yf = [n] : yf.push(n);
    }
    function cj() {
      if (yf !== null) {
        for (var n = 0; n < yf.length; n++) {
          var r = yf[n], f = r.interleaved;
          if (f !== null) {
            r.interleaved = null;
            var d = f.next, g = r.pending;
            if (g !== null) {
              var x = g.next;
              g.next = d, f.next = x;
            }
            r.pending = f;
          }
        }
        yf = null;
      }
    }
    function ID(n, r, f, d) {
      var g = r.interleaved;
      return g === null ? (f.next = f, Q_(r)) : (f.next = g.next, g.next = f), r.interleaved = f, B0(n, d);
    }
    function fj(n, r, f, d) {
      var g = r.interleaved;
      g === null ? (f.next = f, Q_(r)) : (f.next = g.next, g.next = f), r.interleaved = f;
    }
    function dj(n, r, f, d) {
      var g = r.interleaved;
      return g === null ? (f.next = f, Q_(r)) : (f.next = g.next, g.next = f), r.interleaved = f, B0(n, d);
    }
    function pa(n, r) {
      return B0(n, r);
    }
    var hj = B0;
    function B0(n, r) {
      n.lanes = Mt(n.lanes, r);
      var f = n.alternate;
      f !== null && (f.lanes = Mt(f.lanes, r)), f === null && (n.flags & (qn | aa)) !== st && jk(n);
      for (var d = n, g = n.return; g !== null; )
        g.childLanes = Mt(g.childLanes, r), f = g.alternate, f !== null ? f.childLanes = Mt(f.childLanes, r) : (g.flags & (qn | aa)) !== st && jk(n), d = g, g = g.return;
      if (d.tag === S) {
        var x = d.stateNode;
        return x;
      } else
        return null;
    }
    var $D = 0, WD = 1, H0 = 2, q_ = 3, U0 = !1, Z_, I0;
    Z_ = !1, I0 = null;
    function J_(n) {
      var r = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: ye
        },
        effects: null
      };
      n.updateQueue = r;
    }
    function YD(n, r) {
      var f = r.updateQueue, d = n.updateQueue;
      if (f === d) {
        var g = {
          baseState: d.baseState,
          firstBaseUpdate: d.firstBaseUpdate,
          lastBaseUpdate: d.lastBaseUpdate,
          shared: d.shared,
          effects: d.effects
        };
        r.updateQueue = g;
      }
    }
    function Al(n, r) {
      var f = {
        eventTime: n,
        lane: r,
        tag: $D,
        payload: null,
        callback: null,
        next: null
      };
      return f;
    }
    function Ou(n, r, f) {
      var d = n.updateQueue;
      if (d === null)
        return null;
      var g = d.shared;
      if (I0 === g && !Z_ && (u("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), Z_ = !0), fH()) {
        var x = g.pending;
        return x === null ? r.next = r : (r.next = x.next, x.next = r), g.pending = r, hj(n, f);
      } else
        return dj(n, g, r, f);
    }
    function $0(n, r, f) {
      var d = r.updateQueue;
      if (d !== null) {
        var g = d.shared;
        if (gm(f)) {
          var x = g.lanes;
          x = ym(x, n.pendingLanes);
          var C = Mt(x, f);
          g.lanes = C, Jd(n, C);
        }
      }
    }
    function ew(n, r) {
      var f = n.updateQueue, d = n.alternate;
      if (d !== null) {
        var g = d.updateQueue;
        if (f === g) {
          var x = null, C = null, D = f.firstBaseUpdate;
          if (D !== null) {
            var k = D;
            do {
              var L = {
                eventTime: k.eventTime,
                lane: k.lane,
                tag: k.tag,
                payload: k.payload,
                callback: k.callback,
                next: null
              };
              C === null ? x = C = L : (C.next = L, C = L), k = k.next;
            } while (k !== null);
            C === null ? x = C = r : (C.next = r, C = r);
          } else
            x = C = r;
          f = {
            baseState: g.baseState,
            firstBaseUpdate: x,
            lastBaseUpdate: C,
            shared: g.shared,
            effects: g.effects
          }, n.updateQueue = f;
          return;
        }
      }
      var N = f.lastBaseUpdate;
      N === null ? f.firstBaseUpdate = r : N.next = r, f.lastBaseUpdate = r;
    }
    function pj(n, r, f, d, g, x) {
      switch (f.tag) {
        case WD: {
          var C = f.payload;
          if (typeof C == "function") {
            BD();
            var D = C.call(x, d, g);
            {
              if (n.mode & vn) {
                Vn(!0);
                try {
                  C.call(x, d, g);
                } finally {
                  Vn(!1);
                }
              }
              HD();
            }
            return D;
          }
          return C;
        }
        case q_:
          n.flags = n.flags & -65537 | at;
        // Intentional fallthrough
        case $D: {
          var k = f.payload, L;
          if (typeof k == "function") {
            BD(), L = k.call(x, d, g);
            {
              if (n.mode & vn) {
                Vn(!0);
                try {
                  k.call(x, d, g);
                } finally {
                  Vn(!1);
                }
              }
              HD();
            }
          } else
            L = k;
          return L == null ? d : Lt({}, d, L);
        }
        case H0:
          return U0 = !0, d;
      }
      return d;
    }
    function W0(n, r, f, d) {
      var g = n.updateQueue;
      U0 = !1, I0 = g.shared;
      var x = g.firstBaseUpdate, C = g.lastBaseUpdate, D = g.shared.pending;
      if (D !== null) {
        g.shared.pending = null;
        var k = D, L = k.next;
        k.next = null, C === null ? x = L : C.next = L, C = k;
        var N = n.alternate;
        if (N !== null) {
          var G = N.updateQueue, W = G.lastBaseUpdate;
          W !== C && (W === null ? G.firstBaseUpdate = L : W.next = L, G.lastBaseUpdate = k);
        }
      }
      if (x !== null) {
        var J = g.baseState, ie = ye, ue = null, Ie = null, ft = null, nt = x;
        do {
          var It = nt.lane, Vt = nt.eventTime;
          if (bl(d, It)) {
            if (ft !== null) {
              var ce = {
                eventTime: Vt,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Zt,
                tag: nt.tag,
                payload: nt.payload,
                callback: nt.callback,
                next: null
              };
              ft = ft.next = ce;
            }
            J = pj(n, g, nt, J, r, f);
            var q = nt.callback;
            if (q !== null && // If the update was already committed, we should not queue its
            // callback again.
            nt.lane !== Zt) {
              n.flags |= Cn;
              var Re = g.effects;
              Re === null ? g.effects = [nt] : Re.push(nt);
            }
          } else {
            var Q = {
              eventTime: Vt,
              lane: It,
              tag: nt.tag,
              payload: nt.payload,
              callback: nt.callback,
              next: null
            };
            ft === null ? (Ie = ft = Q, ue = J) : ft = ft.next = Q, ie = Mt(ie, It);
          }
          if (nt = nt.next, nt === null) {
            if (D = g.shared.pending, D === null)
              break;
            var Ke = D, We = Ke.next;
            Ke.next = null, nt = We, g.lastBaseUpdate = Ke, g.shared.pending = null;
          }
        } while (!0);
        ft === null && (ue = J), g.baseState = ue, g.firstBaseUpdate = Ie, g.lastBaseUpdate = ft;
        var vt = g.shared.interleaved;
        if (vt !== null) {
          var Rt = vt;
          do
            ie = Mt(ie, Rt.lane), Rt = Rt.next;
          while (Rt !== vt);
        } else x === null && (g.shared.lanes = ye);
        Mg(ie), n.lanes = ie, n.memoizedState = J;
      }
      I0 = null;
    }
    function mj(n, r) {
      if (typeof n != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + n));
      n.call(r);
    }
    function GD() {
      U0 = !1;
    }
    function Y0() {
      return U0;
    }
    function KD(n, r, f) {
      var d = r.effects;
      if (r.effects = null, d !== null)
        for (var g = 0; g < d.length; g++) {
          var x = d[g], C = x.callback;
          C !== null && (x.callback = null, mj(C, f));
        }
    }
    var rg = {}, Pu = Ru(rg), ag = Ru(rg), G0 = Ru(rg);
    function K0(n) {
      if (n === rg)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return n;
    }
    function XD() {
      var n = K0(G0.current);
      return n;
    }
    function tw(n, r) {
      Or(G0, r, n), Or(ag, n, n), Or(Pu, rg, n);
      var f = OF(r);
      Ar(Pu, n), Or(Pu, f, n);
    }
    function Rh(n) {
      Ar(Pu, n), Ar(ag, n), Ar(G0, n);
    }
    function nw() {
      var n = K0(Pu.current);
      return n;
    }
    function QD(n) {
      K0(G0.current);
      var r = K0(Pu.current), f = PF(r, n.type);
      r !== f && (Or(ag, n, n), Or(Pu, f, n));
    }
    function iw(n) {
      ag.current === n && (Ar(Pu, n), Ar(ag, n));
    }
    var gj = 0, qD = 1, ZD = 1, sg = 2, Bs = Ru(gj);
    function rw(n, r) {
      return (n & r) !== 0;
    }
    function kh(n) {
      return n & qD;
    }
    function aw(n, r) {
      return n & qD | r;
    }
    function vj(n, r) {
      return n | r;
    }
    function Lu(n, r) {
      Or(Bs, r, n);
    }
    function Mh(n) {
      Ar(Bs, n);
    }
    function yj(n, r) {
      var f = n.memoizedState;
      return f !== null ? f.dehydrated !== null : (n.memoizedProps, !0);
    }
    function X0(n) {
      for (var r = n; r !== null; ) {
        if (r.tag === F) {
          var f = r.memoizedState;
          if (f !== null) {
            var d = f.dehydrated;
            if (d === null || mD(d) || w_(d))
              return r;
          }
        } else if (r.tag === le && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        r.memoizedProps.revealOrder !== void 0) {
          var g = (r.flags & at) !== st;
          if (g)
            return r;
        } else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === n)
          return null;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === n)
            return null;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return null;
    }
    var ma = (
      /*   */
      0
    ), Bi = (
      /* */
      1
    ), Eo = (
      /*  */
      2
    ), Hi = (
      /*    */
      4
    ), ur = (
      /*   */
      8
    ), sw = [];
    function ow() {
      for (var n = 0; n < sw.length; n++) {
        var r = sw[n];
        r._workInProgressVersionPrimary = null;
      }
      sw.length = 0;
    }
    function bj(n, r) {
      var f = r._getVersion, d = f(r._source);
      n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [r, d] : n.mutableSourceEagerHydrationData.push(r, d);
    }
    var Ge = i.ReactCurrentDispatcher, og = i.ReactCurrentBatchConfig, lw, Ah;
    lw = /* @__PURE__ */ new Set();
    var bf = ye, yn = null, Ui = null, Ii = null, Q0 = !1, lg = !1, ug = 0, xj = 0, Sj = 25, he = null, cs = null, Nu = -1, uw = !1;
    function cn() {
      {
        var n = he;
        cs === null ? cs = [n] : cs.push(n);
      }
    }
    function je() {
      {
        var n = he;
        cs !== null && (Nu++, cs[Nu] !== n && _j(n));
      }
    }
    function Oh(n) {
      n != null && !Ni(n) && u("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", he, typeof n);
    }
    function _j(n) {
      {
        var r = kt(yn);
        if (!lw.has(r) && (lw.add(r), cs !== null)) {
          for (var f = "", d = 30, g = 0; g <= Nu; g++) {
            for (var x = cs[g], C = g === Nu ? n : x, D = g + 1 + ". " + x; D.length < d; )
              D += " ";
            D += C + `
`, f += D;
          }
          u(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, r, f);
        }
      }
    }
    function Pr() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function cw(n, r) {
      if (uw)
        return !1;
      if (r === null)
        return u("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", he), !1;
      n.length !== r.length && u(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, he, "[" + r.join(", ") + "]", "[" + n.join(", ") + "]");
      for (var f = 0; f < r.length && f < n.length; f++)
        if (!_e(n[f], r[f]))
          return !1;
      return !0;
    }
    function Ph(n, r, f, d, g, x) {
      bf = x, yn = r, cs = n !== null ? n._debugHookTypes : null, Nu = -1, uw = n !== null && n.type !== r.type, r.memoizedState = null, r.updateQueue = null, r.lanes = ye, n !== null && n.memoizedState !== null ? Ge.current = xR : cs !== null ? Ge.current = bR : Ge.current = yR;
      var C = f(d, g);
      if (lg) {
        var D = 0;
        do {
          if (lg = !1, ug = 0, D >= Sj)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          D += 1, uw = !1, Ui = null, Ii = null, r.updateQueue = null, Nu = -1, Ge.current = SR, C = f(d, g);
        } while (lg);
      }
      Ge.current = ub, r._debugHookTypes = cs;
      var k = Ui !== null && Ui.next !== null;
      if (bf = ye, yn = null, Ui = null, Ii = null, he = null, cs = null, Nu = -1, n !== null && (n.flags & ci) !== (r.flags & ci) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (n.mode & Nt) !== ot && u("Internal React error: Expected static flag was missing. Please notify the React team."), Q0 = !1, k)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return C;
    }
    function Lh() {
      var n = ug !== 0;
      return ug = 0, n;
    }
    function JD(n, r, f) {
      r.updateQueue = n.updateQueue, (r.mode & en) !== ot ? r.flags &= -50333701 : r.flags &= -2053, n.lanes = $c(n.lanes, f);
    }
    function eR() {
      if (Ge.current = ub, Q0) {
        for (var n = yn.memoizedState; n !== null; ) {
          var r = n.queue;
          r !== null && (r.pending = null), n = n.next;
        }
        Q0 = !1;
      }
      bf = ye, yn = null, Ui = null, Ii = null, cs = null, Nu = -1, he = null, hR = !1, lg = !1, ug = 0;
    }
    function Do() {
      var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ii === null ? yn.memoizedState = Ii = n : Ii = Ii.next = n, Ii;
    }
    function fs() {
      var n;
      if (Ui === null) {
        var r = yn.alternate;
        r !== null ? n = r.memoizedState : n = null;
      } else
        n = Ui.next;
      var f;
      if (Ii === null ? f = yn.memoizedState : f = Ii.next, f !== null)
        Ii = f, f = Ii.next, Ui = n;
      else {
        if (n === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ui = n;
        var d = {
          memoizedState: Ui.memoizedState,
          baseState: Ui.baseState,
          baseQueue: Ui.baseQueue,
          queue: Ui.queue,
          next: null
        };
        Ii === null ? yn.memoizedState = Ii = d : Ii = Ii.next = d;
      }
      return Ii;
    }
    function tR() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function fw(n, r) {
      return typeof r == "function" ? r(n) : r;
    }
    function dw(n, r, f) {
      var d = Do(), g;
      f !== void 0 ? g = f(r) : g = r, d.memoizedState = d.baseState = g;
      var x = {
        pending: null,
        interleaved: null,
        lanes: ye,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: g
      };
      d.queue = x;
      var C = x.dispatch = Ej.bind(null, yn, x);
      return [d.memoizedState, C];
    }
    function hw(n, r, f) {
      var d = fs(), g = d.queue;
      if (g === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      g.lastRenderedReducer = n;
      var x = Ui, C = x.baseQueue, D = g.pending;
      if (D !== null) {
        if (C !== null) {
          var k = C.next, L = D.next;
          C.next = L, D.next = k;
        }
        x.baseQueue !== C && u("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), x.baseQueue = C = D, g.pending = null;
      }
      if (C !== null) {
        var N = C.next, G = x.baseState, W = null, J = null, ie = null, ue = N;
        do {
          var Ie = ue.lane;
          if (bl(bf, Ie)) {
            if (ie !== null) {
              var nt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Zt,
                action: ue.action,
                hasEagerState: ue.hasEagerState,
                eagerState: ue.eagerState,
                next: null
              };
              ie = ie.next = nt;
            }
            if (ue.hasEagerState)
              G = ue.eagerState;
            else {
              var It = ue.action;
              G = n(G, It);
            }
          } else {
            var ft = {
              lane: Ie,
              action: ue.action,
              hasEagerState: ue.hasEagerState,
              eagerState: ue.eagerState,
              next: null
            };
            ie === null ? (J = ie = ft, W = G) : ie = ie.next = ft, yn.lanes = Mt(yn.lanes, Ie), Mg(Ie);
          }
          ue = ue.next;
        } while (ue !== null && ue !== N);
        ie === null ? W = G : ie.next = J, _e(G, d.memoizedState) || yg(), d.memoizedState = G, d.baseState = W, d.baseQueue = ie, g.lastRenderedState = G;
      }
      var Vt = g.interleaved;
      if (Vt !== null) {
        var Q = Vt;
        do {
          var ce = Q.lane;
          yn.lanes = Mt(yn.lanes, ce), Mg(ce), Q = Q.next;
        } while (Q !== Vt);
      } else C === null && (g.lanes = ye);
      var q = g.dispatch;
      return [d.memoizedState, q];
    }
    function pw(n, r, f) {
      var d = fs(), g = d.queue;
      if (g === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      g.lastRenderedReducer = n;
      var x = g.dispatch, C = g.pending, D = d.memoizedState;
      if (C !== null) {
        g.pending = null;
        var k = C.next, L = k;
        do {
          var N = L.action;
          D = n(D, N), L = L.next;
        } while (L !== k);
        _e(D, d.memoizedState) || yg(), d.memoizedState = D, d.baseQueue === null && (d.baseState = D), g.lastRenderedState = D;
      }
      return [D, x];
    }
    function dQ(n, r, f) {
    }
    function hQ(n, r, f) {
    }
    function mw(n, r, f) {
      var d = yn, g = Do(), x, C = lr();
      if (C) {
        if (f === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        x = f(), Ah || x !== f() && (u("The result of getServerSnapshot should be cached to avoid an infinite loop"), Ah = !0);
      } else {
        if (x = r(), !Ah) {
          var D = r();
          _e(x, D) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), Ah = !0);
        }
        var k = Rb();
        if (k === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        qd(k, bf) || nR(d, r, x);
      }
      g.memoizedState = x;
      var L = {
        value: x,
        getSnapshot: r
      };
      return g.queue = L, tb(rR.bind(null, d, L, n), [n]), d.flags |= _r, cg(Bi | ur, iR.bind(null, d, L, x, r), void 0, null), x;
    }
    function q0(n, r, f) {
      var d = yn, g = fs(), x = r();
      if (!Ah) {
        var C = r();
        _e(x, C) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), Ah = !0);
      }
      var D = g.memoizedState, k = !_e(D, x);
      k && (g.memoizedState = x, yg());
      var L = g.queue;
      if (dg(rR.bind(null, d, L, n), [n]), L.getSnapshot !== r || k || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Ii !== null && Ii.memoizedState.tag & Bi) {
        d.flags |= _r, cg(Bi | ur, iR.bind(null, d, L, x, r), void 0, null);
        var N = Rb();
        if (N === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        qd(N, bf) || nR(d, r, x);
      }
      return x;
    }
    function nR(n, r, f) {
      n.flags |= du;
      var d = {
        getSnapshot: r,
        value: f
      }, g = yn.updateQueue;
      if (g === null)
        g = tR(), yn.updateQueue = g, g.stores = [d];
      else {
        var x = g.stores;
        x === null ? g.stores = [d] : x.push(d);
      }
    }
    function iR(n, r, f, d) {
      r.value = f, r.getSnapshot = d, aR(r) && sR(n);
    }
    function rR(n, r, f) {
      var d = function() {
        aR(r) && sR(n);
      };
      return f(d);
    }
    function aR(n) {
      var r = n.getSnapshot, f = n.value;
      try {
        var d = r();
        return !_e(f, d);
      } catch {
        return !0;
      }
    }
    function sR(n) {
      var r = pa(n, gt);
      r !== null && Gi(r, n, gt, Sn);
    }
    function Z0(n) {
      var r = Do();
      typeof n == "function" && (n = n()), r.memoizedState = r.baseState = n;
      var f = {
        pending: null,
        interleaved: null,
        lanes: ye,
        dispatch: null,
        lastRenderedReducer: fw,
        lastRenderedState: n
      };
      r.queue = f;
      var d = f.dispatch = Dj.bind(null, yn, f);
      return [r.memoizedState, d];
    }
    function gw(n) {
      return hw(fw);
    }
    function vw(n) {
      return pw(fw);
    }
    function cg(n, r, f, d) {
      var g = {
        tag: n,
        create: r,
        destroy: f,
        deps: d,
        // Circular
        next: null
      }, x = yn.updateQueue;
      if (x === null)
        x = tR(), yn.updateQueue = x, x.lastEffect = g.next = g;
      else {
        var C = x.lastEffect;
        if (C === null)
          x.lastEffect = g.next = g;
        else {
          var D = C.next;
          C.next = g, g.next = D, x.lastEffect = g;
        }
      }
      return g;
    }
    function yw(n) {
      var r = Do();
      {
        var f = {
          current: n
        };
        return r.memoizedState = f, f;
      }
    }
    function J0(n) {
      var r = fs();
      return r.memoizedState;
    }
    function fg(n, r, f, d) {
      var g = Do(), x = d === void 0 ? null : d;
      yn.flags |= n, g.memoizedState = cg(Bi | r, f, void 0, x);
    }
    function eb(n, r, f, d) {
      var g = fs(), x = d === void 0 ? null : d, C = void 0;
      if (Ui !== null) {
        var D = Ui.memoizedState;
        if (C = D.destroy, x !== null) {
          var k = D.deps;
          if (cw(x, k)) {
            g.memoizedState = cg(r, f, C, x);
            return;
          }
        }
      }
      yn.flags |= n, g.memoizedState = cg(Bi | r, f, C, x);
    }
    function tb(n, r) {
      return (yn.mode & en) !== ot ? fg(Za | _r | Cd, ur, n, r) : fg(_r | Cd, ur, n, r);
    }
    function dg(n, r) {
      return eb(_r, ur, n, r);
    }
    function bw(n, r) {
      return fg(Bt, Eo, n, r);
    }
    function nb(n, r) {
      return eb(Bt, Eo, n, r);
    }
    function xw(n, r) {
      var f = Bt;
      return f |= Rs, (yn.mode & en) !== ot && (f |= oo), fg(f, Hi, n, r);
    }
    function ib(n, r) {
      return eb(Bt, Hi, n, r);
    }
    function oR(n, r) {
      if (typeof r == "function") {
        var f = r, d = n();
        return f(d), function() {
          f(null);
        };
      } else if (r != null) {
        var g = r;
        g.hasOwnProperty("current") || u("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(g).join(", ") + "}");
        var x = n();
        return g.current = x, function() {
          g.current = null;
        };
      }
    }
    function Sw(n, r, f) {
      typeof r != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var d = f != null ? f.concat([n]) : null, g = Bt;
      return g |= Rs, (yn.mode & en) !== ot && (g |= oo), fg(g, Hi, oR.bind(null, r, n), d);
    }
    function rb(n, r, f) {
      typeof r != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var d = f != null ? f.concat([n]) : null;
      return eb(Bt, Hi, oR.bind(null, r, n), d);
    }
    function wj(n, r) {
    }
    var ab = wj;
    function _w(n, r) {
      var f = Do(), d = r === void 0 ? null : r;
      return f.memoizedState = [n, d], n;
    }
    function sb(n, r) {
      var f = fs(), d = r === void 0 ? null : r, g = f.memoizedState;
      if (g !== null && d !== null) {
        var x = g[1];
        if (cw(d, x))
          return g[0];
      }
      return f.memoizedState = [n, d], n;
    }
    function ww(n, r) {
      var f = Do(), d = r === void 0 ? null : r, g = n();
      return f.memoizedState = [g, d], g;
    }
    function ob(n, r) {
      var f = fs(), d = r === void 0 ? null : r, g = f.memoizedState;
      if (g !== null && d !== null) {
        var x = g[1];
        if (cw(d, x))
          return g[0];
      }
      var C = n();
      return f.memoizedState = [C, d], C;
    }
    function Cw(n) {
      var r = Do();
      return r.memoizedState = n, n;
    }
    function lR(n) {
      var r = fs(), f = Ui, d = f.memoizedState;
      return cR(r, d, n);
    }
    function uR(n) {
      var r = fs();
      if (Ui === null)
        return r.memoizedState = n, n;
      var f = Ui.memoizedState;
      return cR(r, f, n);
    }
    function cR(n, r, f) {
      var d = !pm(bf);
      if (d) {
        if (!_e(f, r)) {
          var g = vm();
          yn.lanes = Mt(yn.lanes, g), Mg(g), n.baseState = !0;
        }
        return r;
      } else
        return n.baseState && (n.baseState = !1, yg()), n.memoizedState = f, f;
    }
    function Cj(n, r, f) {
      var d = fa();
      hi(Vy(d, ns)), n(!0);
      var g = og.transition;
      og.transition = {};
      var x = og.transition;
      og.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        n(!1), r();
      } finally {
        if (hi(d), og.transition = g, g === null && x._updatedFibers) {
          var C = x._updatedFibers.size;
          C > 10 && c("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), x._updatedFibers.clear();
        }
      }
    }
    function Tw() {
      var n = Z0(!1), r = n[0], f = n[1], d = Cj.bind(null, f), g = Do();
      return g.memoizedState = d, [r, d];
    }
    function fR() {
      var n = gw(), r = n[0], f = fs(), d = f.memoizedState;
      return [r, d];
    }
    function dR() {
      var n = vw(), r = n[0], f = fs(), d = f.memoizedState;
      return [r, d];
    }
    var hR = !1;
    function Tj() {
      return hR;
    }
    function Ew() {
      var n = Do(), r = Rb(), f = r.identifierPrefix, d;
      if (lr()) {
        var g = UV();
        d = ":" + f + "R" + g;
        var x = ug++;
        x > 0 && (d += "H" + x.toString(32)), d += ":";
      } else {
        var C = xj++;
        d = ":" + f + "r" + C.toString(32) + ":";
      }
      return n.memoizedState = d, d;
    }
    function lb() {
      var n = fs(), r = n.memoizedState;
      return r;
    }
    function Ej(n, r, f) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var d = Bu(n), g = {
        lane: d,
        action: f,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (pR(n))
        mR(r, g);
      else {
        var x = ID(n, r, g, d);
        if (x !== null) {
          var C = qr();
          Gi(x, n, d, C), gR(x, r, d);
        }
      }
      vR(n, d);
    }
    function Dj(n, r, f) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var d = Bu(n), g = {
        lane: d,
        action: f,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (pR(n))
        mR(r, g);
      else {
        var x = n.alternate;
        if (n.lanes === ye && (x === null || x.lanes === ye)) {
          var C = r.lastRenderedReducer;
          if (C !== null) {
            var D;
            D = Ge.current, Ge.current = Hs;
            try {
              var k = r.lastRenderedState, L = C(k, f);
              if (g.hasEagerState = !0, g.eagerState = L, _e(L, k)) {
                fj(n, r, g, d);
                return;
              }
            } catch {
            } finally {
              Ge.current = D;
            }
          }
        }
        var N = ID(n, r, g, d);
        if (N !== null) {
          var G = qr();
          Gi(N, n, d, G), gR(N, r, d);
        }
      }
      vR(n, d);
    }
    function pR(n) {
      var r = n.alternate;
      return n === yn || r !== null && r === yn;
    }
    function mR(n, r) {
      lg = Q0 = !0;
      var f = n.pending;
      f === null ? r.next = r : (r.next = f.next, f.next = r), n.pending = r;
    }
    function gR(n, r, f) {
      if (gm(f)) {
        var d = r.lanes;
        d = ym(d, n.pendingLanes);
        var g = Mt(d, f);
        r.lanes = g, Jd(n, g);
      }
    }
    function vR(n, r, f) {
      Lc(n, r);
    }
    var ub = {
      readContext: Ai,
      useCallback: Pr,
      useContext: Pr,
      useEffect: Pr,
      useImperativeHandle: Pr,
      useInsertionEffect: Pr,
      useLayoutEffect: Pr,
      useMemo: Pr,
      useReducer: Pr,
      useRef: Pr,
      useState: Pr,
      useDebugValue: Pr,
      useDeferredValue: Pr,
      useTransition: Pr,
      useMutableSource: Pr,
      useSyncExternalStore: Pr,
      useId: Pr,
      unstable_isNewReconciler: ae
    }, yR = null, bR = null, xR = null, SR = null, Ro = null, Hs = null, cb = null;
    {
      var Dw = function() {
        u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Ct = function() {
        u("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      yR = {
        readContext: function(n) {
          return Ai(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", cn(), Oh(r), _w(n, r);
        },
        useContext: function(n) {
          return he = "useContext", cn(), Ai(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", cn(), Oh(r), tb(n, r);
        },
        useImperativeHandle: function(n, r, f) {
          return he = "useImperativeHandle", cn(), Oh(f), Sw(n, r, f);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", cn(), Oh(r), bw(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", cn(), Oh(r), xw(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", cn(), Oh(r);
          var f = Ge.current;
          Ge.current = Ro;
          try {
            return ww(n, r);
          } finally {
            Ge.current = f;
          }
        },
        useReducer: function(n, r, f) {
          he = "useReducer", cn();
          var d = Ge.current;
          Ge.current = Ro;
          try {
            return dw(n, r, f);
          } finally {
            Ge.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", cn(), yw(n);
        },
        useState: function(n) {
          he = "useState", cn();
          var r = Ge.current;
          Ge.current = Ro;
          try {
            return Z0(n);
          } finally {
            Ge.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", cn(), void 0;
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", cn(), Cw(n);
        },
        useTransition: function() {
          return he = "useTransition", cn(), Tw();
        },
        useMutableSource: function(n, r, f) {
          return he = "useMutableSource", cn(), void 0;
        },
        useSyncExternalStore: function(n, r, f) {
          return he = "useSyncExternalStore", cn(), mw(n, r, f);
        },
        useId: function() {
          return he = "useId", cn(), Ew();
        },
        unstable_isNewReconciler: ae
      }, bR = {
        readContext: function(n) {
          return Ai(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", je(), _w(n, r);
        },
        useContext: function(n) {
          return he = "useContext", je(), Ai(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", je(), tb(n, r);
        },
        useImperativeHandle: function(n, r, f) {
          return he = "useImperativeHandle", je(), Sw(n, r, f);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", je(), bw(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", je(), xw(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", je();
          var f = Ge.current;
          Ge.current = Ro;
          try {
            return ww(n, r);
          } finally {
            Ge.current = f;
          }
        },
        useReducer: function(n, r, f) {
          he = "useReducer", je();
          var d = Ge.current;
          Ge.current = Ro;
          try {
            return dw(n, r, f);
          } finally {
            Ge.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", je(), yw(n);
        },
        useState: function(n) {
          he = "useState", je();
          var r = Ge.current;
          Ge.current = Ro;
          try {
            return Z0(n);
          } finally {
            Ge.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", je(), void 0;
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", je(), Cw(n);
        },
        useTransition: function() {
          return he = "useTransition", je(), Tw();
        },
        useMutableSource: function(n, r, f) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(n, r, f) {
          return he = "useSyncExternalStore", je(), mw(n, r, f);
        },
        useId: function() {
          return he = "useId", je(), Ew();
        },
        unstable_isNewReconciler: ae
      }, xR = {
        readContext: function(n) {
          return Ai(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", je(), sb(n, r);
        },
        useContext: function(n) {
          return he = "useContext", je(), Ai(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", je(), dg(n, r);
        },
        useImperativeHandle: function(n, r, f) {
          return he = "useImperativeHandle", je(), rb(n, r, f);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", je(), nb(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", je(), ib(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", je();
          var f = Ge.current;
          Ge.current = Hs;
          try {
            return ob(n, r);
          } finally {
            Ge.current = f;
          }
        },
        useReducer: function(n, r, f) {
          he = "useReducer", je();
          var d = Ge.current;
          Ge.current = Hs;
          try {
            return hw(n, r, f);
          } finally {
            Ge.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", je(), J0();
        },
        useState: function(n) {
          he = "useState", je();
          var r = Ge.current;
          Ge.current = Hs;
          try {
            return gw(n);
          } finally {
            Ge.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", je(), ab();
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", je(), lR(n);
        },
        useTransition: function() {
          return he = "useTransition", je(), fR();
        },
        useMutableSource: function(n, r, f) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(n, r, f) {
          return he = "useSyncExternalStore", je(), q0(n, r);
        },
        useId: function() {
          return he = "useId", je(), lb();
        },
        unstable_isNewReconciler: ae
      }, SR = {
        readContext: function(n) {
          return Ai(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", je(), sb(n, r);
        },
        useContext: function(n) {
          return he = "useContext", je(), Ai(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", je(), dg(n, r);
        },
        useImperativeHandle: function(n, r, f) {
          return he = "useImperativeHandle", je(), rb(n, r, f);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", je(), nb(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", je(), ib(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", je();
          var f = Ge.current;
          Ge.current = cb;
          try {
            return ob(n, r);
          } finally {
            Ge.current = f;
          }
        },
        useReducer: function(n, r, f) {
          he = "useReducer", je();
          var d = Ge.current;
          Ge.current = cb;
          try {
            return pw(n, r, f);
          } finally {
            Ge.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", je(), J0();
        },
        useState: function(n) {
          he = "useState", je();
          var r = Ge.current;
          Ge.current = cb;
          try {
            return vw(n);
          } finally {
            Ge.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", je(), ab();
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", je(), uR(n);
        },
        useTransition: function() {
          return he = "useTransition", je(), dR();
        },
        useMutableSource: function(n, r, f) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(n, r, f) {
          return he = "useSyncExternalStore", je(), q0(n, r);
        },
        useId: function() {
          return he = "useId", je(), lb();
        },
        unstable_isNewReconciler: ae
      }, Ro = {
        readContext: function(n) {
          return Dw(), Ai(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", Ct(), cn(), _w(n, r);
        },
        useContext: function(n) {
          return he = "useContext", Ct(), cn(), Ai(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", Ct(), cn(), tb(n, r);
        },
        useImperativeHandle: function(n, r, f) {
          return he = "useImperativeHandle", Ct(), cn(), Sw(n, r, f);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", Ct(), cn(), bw(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", Ct(), cn(), xw(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", Ct(), cn();
          var f = Ge.current;
          Ge.current = Ro;
          try {
            return ww(n, r);
          } finally {
            Ge.current = f;
          }
        },
        useReducer: function(n, r, f) {
          he = "useReducer", Ct(), cn();
          var d = Ge.current;
          Ge.current = Ro;
          try {
            return dw(n, r, f);
          } finally {
            Ge.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", Ct(), cn(), yw(n);
        },
        useState: function(n) {
          he = "useState", Ct(), cn();
          var r = Ge.current;
          Ge.current = Ro;
          try {
            return Z0(n);
          } finally {
            Ge.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", Ct(), cn(), void 0;
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", Ct(), cn(), Cw(n);
        },
        useTransition: function() {
          return he = "useTransition", Ct(), cn(), Tw();
        },
        useMutableSource: function(n, r, f) {
          return he = "useMutableSource", Ct(), cn(), void 0;
        },
        useSyncExternalStore: function(n, r, f) {
          return he = "useSyncExternalStore", Ct(), cn(), mw(n, r, f);
        },
        useId: function() {
          return he = "useId", Ct(), cn(), Ew();
        },
        unstable_isNewReconciler: ae
      }, Hs = {
        readContext: function(n) {
          return Dw(), Ai(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", Ct(), je(), sb(n, r);
        },
        useContext: function(n) {
          return he = "useContext", Ct(), je(), Ai(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", Ct(), je(), dg(n, r);
        },
        useImperativeHandle: function(n, r, f) {
          return he = "useImperativeHandle", Ct(), je(), rb(n, r, f);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", Ct(), je(), nb(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", Ct(), je(), ib(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", Ct(), je();
          var f = Ge.current;
          Ge.current = Hs;
          try {
            return ob(n, r);
          } finally {
            Ge.current = f;
          }
        },
        useReducer: function(n, r, f) {
          he = "useReducer", Ct(), je();
          var d = Ge.current;
          Ge.current = Hs;
          try {
            return hw(n, r, f);
          } finally {
            Ge.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", Ct(), je(), J0();
        },
        useState: function(n) {
          he = "useState", Ct(), je();
          var r = Ge.current;
          Ge.current = Hs;
          try {
            return gw(n);
          } finally {
            Ge.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", Ct(), je(), ab();
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", Ct(), je(), lR(n);
        },
        useTransition: function() {
          return he = "useTransition", Ct(), je(), fR();
        },
        useMutableSource: function(n, r, f) {
          return he = "useMutableSource", Ct(), je(), void 0;
        },
        useSyncExternalStore: function(n, r, f) {
          return he = "useSyncExternalStore", Ct(), je(), q0(n, r);
        },
        useId: function() {
          return he = "useId", Ct(), je(), lb();
        },
        unstable_isNewReconciler: ae
      }, cb = {
        readContext: function(n) {
          return Dw(), Ai(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", Ct(), je(), sb(n, r);
        },
        useContext: function(n) {
          return he = "useContext", Ct(), je(), Ai(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", Ct(), je(), dg(n, r);
        },
        useImperativeHandle: function(n, r, f) {
          return he = "useImperativeHandle", Ct(), je(), rb(n, r, f);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", Ct(), je(), nb(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", Ct(), je(), ib(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", Ct(), je();
          var f = Ge.current;
          Ge.current = Hs;
          try {
            return ob(n, r);
          } finally {
            Ge.current = f;
          }
        },
        useReducer: function(n, r, f) {
          he = "useReducer", Ct(), je();
          var d = Ge.current;
          Ge.current = Hs;
          try {
            return pw(n, r, f);
          } finally {
            Ge.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", Ct(), je(), J0();
        },
        useState: function(n) {
          he = "useState", Ct(), je();
          var r = Ge.current;
          Ge.current = Hs;
          try {
            return vw(n);
          } finally {
            Ge.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", Ct(), je(), ab();
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", Ct(), je(), uR(n);
        },
        useTransition: function() {
          return he = "useTransition", Ct(), je(), dR();
        },
        useMutableSource: function(n, r, f) {
          return he = "useMutableSource", Ct(), je(), void 0;
        },
        useSyncExternalStore: function(n, r, f) {
          return he = "useSyncExternalStore", Ct(), je(), q0(n, r);
        },
        useId: function() {
          return he = "useId", Ct(), je(), lb();
        },
        unstable_isNewReconciler: ae
      };
    }
    var zu = e.unstable_now, _R = 0, fb = -1, hg = -1, db = -1, Rw = !1, hb = !1;
    function wR() {
      return Rw;
    }
    function Rj() {
      hb = !0;
    }
    function kj() {
      Rw = !1, hb = !1;
    }
    function Mj() {
      Rw = hb, hb = !1;
    }
    function CR() {
      return _R;
    }
    function TR() {
      _R = zu();
    }
    function kw(n) {
      hg = zu(), n.actualStartTime < 0 && (n.actualStartTime = zu());
    }
    function ER(n) {
      hg = -1;
    }
    function pb(n, r) {
      if (hg >= 0) {
        var f = zu() - hg;
        n.actualDuration += f, r && (n.selfBaseDuration = f), hg = -1;
      }
    }
    function ko(n) {
      if (fb >= 0) {
        var r = zu() - fb;
        fb = -1;
        for (var f = n.return; f !== null; ) {
          switch (f.tag) {
            case S:
              var d = f.stateNode;
              d.effectDuration += r;
              return;
            case j:
              var g = f.stateNode;
              g.effectDuration += r;
              return;
          }
          f = f.return;
        }
      }
    }
    function Mw(n) {
      if (db >= 0) {
        var r = zu() - db;
        db = -1;
        for (var f = n.return; f !== null; ) {
          switch (f.tag) {
            case S:
              var d = f.stateNode;
              d !== null && (d.passiveEffectDuration += r);
              return;
            case j:
              var g = f.stateNode;
              g !== null && (g.passiveEffectDuration += r);
              return;
          }
          f = f.return;
        }
      }
    }
    function Mo() {
      fb = zu();
    }
    function Aw() {
      db = zu();
    }
    function Ow(n) {
      for (var r = n.child; r; )
        n.actualDuration += r.actualDuration, r = r.sibling;
    }
    function Us(n, r) {
      if (n && n.defaultProps) {
        var f = Lt({}, r), d = n.defaultProps;
        for (var g in d)
          f[g] === void 0 && (f[g] = d[g]);
        return f;
      }
      return r;
    }
    var Pw = {}, Lw, Nw, zw, Fw, Vw, DR, mb, jw, Bw, Hw, pg;
    {
      Lw = /* @__PURE__ */ new Set(), Nw = /* @__PURE__ */ new Set(), zw = /* @__PURE__ */ new Set(), Fw = /* @__PURE__ */ new Set(), jw = /* @__PURE__ */ new Set(), Vw = /* @__PURE__ */ new Set(), Bw = /* @__PURE__ */ new Set(), Hw = /* @__PURE__ */ new Set(), pg = /* @__PURE__ */ new Set();
      var RR = /* @__PURE__ */ new Set();
      mb = function(n, r) {
        if (!(n === null || typeof n == "function")) {
          var f = r + "_" + n;
          RR.has(f) || (RR.add(f), u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, n));
        }
      }, DR = function(n, r) {
        if (r === void 0) {
          var f = mn(n) || "Component";
          Vw.has(f) || (Vw.add(f), u("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", f));
        }
      }, Object.defineProperty(Pw, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Pw);
    }
    function Uw(n, r, f, d) {
      var g = n.memoizedState, x = f(d, g);
      {
        if (n.mode & vn) {
          Vn(!0);
          try {
            x = f(d, g);
          } finally {
            Vn(!1);
          }
        }
        DR(r, x);
      }
      var C = x == null ? g : Lt({}, g, x);
      if (n.memoizedState = C, n.lanes === ye) {
        var D = n.updateQueue;
        D.baseState = C;
      }
    }
    var Iw = {
      isMounted: _y,
      enqueueSetState: function(n, r, f) {
        var d = fu(n), g = qr(), x = Bu(d), C = Al(g, x);
        C.payload = r, f != null && (mb(f, "setState"), C.callback = f);
        var D = Ou(d, C, x);
        D !== null && (Gi(D, d, x, g), $0(D, d, x)), Lc(d, x);
      },
      enqueueReplaceState: function(n, r, f) {
        var d = fu(n), g = qr(), x = Bu(d), C = Al(g, x);
        C.tag = WD, C.payload = r, f != null && (mb(f, "replaceState"), C.callback = f);
        var D = Ou(d, C, x);
        D !== null && (Gi(D, d, x, g), $0(D, d, x)), Lc(d, x);
      },
      enqueueForceUpdate: function(n, r) {
        var f = fu(n), d = qr(), g = Bu(f), x = Al(d, g);
        x.tag = H0, r != null && (mb(r, "forceUpdate"), x.callback = r);
        var C = Ou(f, x, g);
        C !== null && (Gi(C, f, g, d), $0(C, f, g)), Ad(f, g);
      }
    };
    function kR(n, r, f, d, g, x, C) {
      var D = n.stateNode;
      if (typeof D.shouldComponentUpdate == "function") {
        var k = D.shouldComponentUpdate(d, x, C);
        {
          if (n.mode & vn) {
            Vn(!0);
            try {
              k = D.shouldComponentUpdate(d, x, C);
            } finally {
              Vn(!1);
            }
          }
          k === void 0 && u("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", mn(r) || "Component");
        }
        return k;
      }
      return r.prototype && r.prototype.isPureReactComponent ? !Ze(f, d) || !Ze(g, x) : !0;
    }
    function Aj(n, r, f) {
      var d = n.stateNode;
      {
        var g = mn(r) || "Component", x = d.render;
        x || (r.prototype && typeof r.prototype.render == "function" ? u("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", g) : u("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", g)), d.getInitialState && !d.getInitialState.isReactClassApproved && !d.state && u("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", g), d.getDefaultProps && !d.getDefaultProps.isReactClassApproved && u("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", g), d.propTypes && u("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", g), d.contextType && u("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", g), r.childContextTypes && !pg.has(r) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (n.mode & vn) === ot && (pg.add(r), u(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, g)), r.contextTypes && !pg.has(r) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (n.mode & vn) === ot && (pg.add(r), u(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, g)), d.contextTypes && u("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", g), r.contextType && r.contextTypes && !Bw.has(r) && (Bw.add(r), u("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", g)), typeof d.componentShouldUpdate == "function" && u("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", g), r.prototype && r.prototype.isPureReactComponent && typeof d.shouldComponentUpdate < "u" && u("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", mn(r) || "A pure component"), typeof d.componentDidUnmount == "function" && u("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", g), typeof d.componentDidReceiveProps == "function" && u("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", g), typeof d.componentWillRecieveProps == "function" && u("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", g), typeof d.UNSAFE_componentWillRecieveProps == "function" && u("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", g);
        var C = d.props !== f;
        d.props !== void 0 && C && u("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", g, g), d.defaultProps && u("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", g, g), typeof d.getSnapshotBeforeUpdate == "function" && typeof d.componentDidUpdate != "function" && !zw.has(r) && (zw.add(r), u("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", mn(r))), typeof d.getDerivedStateFromProps == "function" && u("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", g), typeof d.getDerivedStateFromError == "function" && u("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", g), typeof r.getSnapshotBeforeUpdate == "function" && u("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", g);
        var D = d.state;
        D && (typeof D != "object" || Ni(D)) && u("%s.state: must be set to an object or null", g), typeof d.getChildContext == "function" && typeof r.childContextTypes != "object" && u("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", g);
      }
    }
    function MR(n, r) {
      r.updater = Iw, n.stateNode = r, al(r, n), r._reactInternalInstance = Pw;
    }
    function AR(n, r, f) {
      var d = !1, g = Va, x = Va, C = r.contextType;
      if ("contextType" in r) {
        var D = (
          // Allow null for conditional declaration
          C === null || C !== void 0 && C.$$typeof === H && C._context === void 0
        );
        if (!D && !Hw.has(r)) {
          Hw.add(r);
          var k = "";
          C === void 0 ? k = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof C != "object" ? k = " However, it is set to a " + typeof C + "." : C.$$typeof === Ra ? k = " Did you accidentally pass the Context.Provider instead?" : C._context !== void 0 ? k = " Did you accidentally pass the Context.Consumer instead?" : k = " However, it is set to an object with keys {" + Object.keys(C).join(", ") + "}.", u("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", mn(r) || "Component", k);
        }
      }
      if (typeof C == "object" && C !== null)
        x = Ai(C);
      else {
        g = xh(n, r, !0);
        var L = r.contextTypes;
        d = L != null, x = d ? Sh(n, g) : Va;
      }
      var N = new r(f, x);
      if (n.mode & vn) {
        Vn(!0);
        try {
          N = new r(f, x);
        } finally {
          Vn(!1);
        }
      }
      var G = n.memoizedState = N.state !== null && N.state !== void 0 ? N.state : null;
      MR(n, N);
      {
        if (typeof r.getDerivedStateFromProps == "function" && G === null) {
          var W = mn(r) || "Component";
          Nw.has(W) || (Nw.add(W), u("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", W, N.state === null ? "null" : "undefined", W));
        }
        if (typeof r.getDerivedStateFromProps == "function" || typeof N.getSnapshotBeforeUpdate == "function") {
          var J = null, ie = null, ue = null;
          if (typeof N.componentWillMount == "function" && N.componentWillMount.__suppressDeprecationWarning !== !0 ? J = "componentWillMount" : typeof N.UNSAFE_componentWillMount == "function" && (J = "UNSAFE_componentWillMount"), typeof N.componentWillReceiveProps == "function" && N.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ie = "componentWillReceiveProps" : typeof N.UNSAFE_componentWillReceiveProps == "function" && (ie = "UNSAFE_componentWillReceiveProps"), typeof N.componentWillUpdate == "function" && N.componentWillUpdate.__suppressDeprecationWarning !== !0 ? ue = "componentWillUpdate" : typeof N.UNSAFE_componentWillUpdate == "function" && (ue = "UNSAFE_componentWillUpdate"), J !== null || ie !== null || ue !== null) {
            var Ie = mn(r) || "Component", ft = typeof r.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Fw.has(Ie) || (Fw.add(Ie), u(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ie, ft, J !== null ? `
  ` + J : "", ie !== null ? `
  ` + ie : "", ue !== null ? `
  ` + ue : ""));
          }
        }
      }
      return d && xD(n, g, x), N;
    }
    function Oj(n, r) {
      var f = r.state;
      typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), f !== r.state && (u("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", kt(n) || "Component"), Iw.enqueueReplaceState(r, r.state, null));
    }
    function OR(n, r, f, d) {
      var g = r.state;
      if (typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(f, d), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(f, d), r.state !== g) {
        {
          var x = kt(n) || "Component";
          Lw.has(x) || (Lw.add(x), u("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", x));
        }
        Iw.enqueueReplaceState(r, r.state, null);
      }
    }
    function $w(n, r, f, d) {
      Aj(n, r, f);
      var g = n.stateNode;
      g.props = f, g.state = n.memoizedState, g.refs = {}, J_(n);
      var x = r.contextType;
      if (typeof x == "object" && x !== null)
        g.context = Ai(x);
      else {
        var C = xh(n, r, !0);
        g.context = Sh(n, C);
      }
      {
        if (g.state === f) {
          var D = mn(r) || "Component";
          jw.has(D) || (jw.add(D), u("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", D));
        }
        n.mode & vn && js.recordLegacyContextWarning(n, g), js.recordUnsafeLifecycleWarnings(n, g);
      }
      g.state = n.memoizedState;
      var k = r.getDerivedStateFromProps;
      if (typeof k == "function" && (Uw(n, r, k, f), g.state = n.memoizedState), typeof r.getDerivedStateFromProps != "function" && typeof g.getSnapshotBeforeUpdate != "function" && (typeof g.UNSAFE_componentWillMount == "function" || typeof g.componentWillMount == "function") && (Oj(n, g), W0(n, f, g, d), g.state = n.memoizedState), typeof g.componentDidMount == "function") {
        var L = Bt;
        L |= Rs, (n.mode & en) !== ot && (L |= oo), n.flags |= L;
      }
    }
    function Pj(n, r, f, d) {
      var g = n.stateNode, x = n.memoizedProps;
      g.props = x;
      var C = g.context, D = r.contextType, k = Va;
      if (typeof D == "object" && D !== null)
        k = Ai(D);
      else {
        var L = xh(n, r, !0);
        k = Sh(n, L);
      }
      var N = r.getDerivedStateFromProps, G = typeof N == "function" || typeof g.getSnapshotBeforeUpdate == "function";
      !G && (typeof g.UNSAFE_componentWillReceiveProps == "function" || typeof g.componentWillReceiveProps == "function") && (x !== f || C !== k) && OR(n, g, f, k), GD();
      var W = n.memoizedState, J = g.state = W;
      if (W0(n, f, g, d), J = n.memoizedState, x === f && W === J && !E0() && !Y0()) {
        if (typeof g.componentDidMount == "function") {
          var ie = Bt;
          ie |= Rs, (n.mode & en) !== ot && (ie |= oo), n.flags |= ie;
        }
        return !1;
      }
      typeof N == "function" && (Uw(n, r, N, f), J = n.memoizedState);
      var ue = Y0() || kR(n, r, x, f, W, J, k);
      if (ue) {
        if (!G && (typeof g.UNSAFE_componentWillMount == "function" || typeof g.componentWillMount == "function") && (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function") {
          var Ie = Bt;
          Ie |= Rs, (n.mode & en) !== ot && (Ie |= oo), n.flags |= Ie;
        }
      } else {
        if (typeof g.componentDidMount == "function") {
          var ft = Bt;
          ft |= Rs, (n.mode & en) !== ot && (ft |= oo), n.flags |= ft;
        }
        n.memoizedProps = f, n.memoizedState = J;
      }
      return g.props = f, g.state = J, g.context = k, ue;
    }
    function Lj(n, r, f, d, g) {
      var x = r.stateNode;
      YD(n, r);
      var C = r.memoizedProps, D = r.type === r.elementType ? C : Us(r.type, C);
      x.props = D;
      var k = r.pendingProps, L = x.context, N = f.contextType, G = Va;
      if (typeof N == "object" && N !== null)
        G = Ai(N);
      else {
        var W = xh(r, f, !0);
        G = Sh(r, W);
      }
      var J = f.getDerivedStateFromProps, ie = typeof J == "function" || typeof x.getSnapshotBeforeUpdate == "function";
      !ie && (typeof x.UNSAFE_componentWillReceiveProps == "function" || typeof x.componentWillReceiveProps == "function") && (C !== k || L !== G) && OR(r, x, d, G), GD();
      var ue = r.memoizedState, Ie = x.state = ue;
      if (W0(r, d, x, g), Ie = r.memoizedState, C === k && ue === Ie && !E0() && !Y0())
        return typeof x.componentDidUpdate == "function" && (C !== n.memoizedProps || ue !== n.memoizedState) && (r.flags |= Bt), typeof x.getSnapshotBeforeUpdate == "function" && (C !== n.memoizedProps || ue !== n.memoizedState) && (r.flags |= xi), !1;
      typeof J == "function" && (Uw(r, f, J, d), Ie = r.memoizedState);
      var ft = Y0() || kR(r, f, D, d, ue, Ie, G) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      me;
      return ft ? (!ie && (typeof x.UNSAFE_componentWillUpdate == "function" || typeof x.componentWillUpdate == "function") && (typeof x.componentWillUpdate == "function" && x.componentWillUpdate(d, Ie, G), typeof x.UNSAFE_componentWillUpdate == "function" && x.UNSAFE_componentWillUpdate(d, Ie, G)), typeof x.componentDidUpdate == "function" && (r.flags |= Bt), typeof x.getSnapshotBeforeUpdate == "function" && (r.flags |= xi)) : (typeof x.componentDidUpdate == "function" && (C !== n.memoizedProps || ue !== n.memoizedState) && (r.flags |= Bt), typeof x.getSnapshotBeforeUpdate == "function" && (C !== n.memoizedProps || ue !== n.memoizedState) && (r.flags |= xi), r.memoizedProps = d, r.memoizedState = Ie), x.props = d, x.state = Ie, x.context = G, ft;
    }
    function xf(n, r) {
      return {
        value: n,
        source: r,
        stack: Zf(r),
        digest: null
      };
    }
    function Ww(n, r, f) {
      return {
        value: n,
        source: null,
        stack: f ?? null,
        digest: r ?? null
      };
    }
    function Nj(n, r) {
      return !0;
    }
    function Yw(n, r) {
      try {
        var f = Nj(n, r);
        if (f === !1)
          return;
        var d = r.value, g = r.source, x = r.stack, C = x !== null ? x : "";
        if (d != null && d._suppressLogging) {
          if (n.tag === v)
            return;
          console.error(d);
        }
        var D = g ? kt(g) : null, k = D ? "The above error occurred in the <" + D + "> component:" : "The above error occurred in one of your React components:", L;
        if (n.tag === S)
          L = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var N = kt(n) || "Anonymous";
          L = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + N + ".");
        }
        var G = k + `
` + C + `

` + ("" + L);
        console.error(G);
      } catch (W) {
        setTimeout(function() {
          throw W;
        });
      }
    }
    var zj = typeof WeakMap == "function" ? WeakMap : Map;
    function PR(n, r, f) {
      var d = Al(Sn, f);
      d.tag = q_, d.payload = {
        element: null
      };
      var g = r.value;
      return d.callback = function() {
        RH(g), Yw(n, r);
      }, d;
    }
    function Gw(n, r, f) {
      var d = Al(Sn, f);
      d.tag = q_;
      var g = n.type.getDerivedStateFromError;
      if (typeof g == "function") {
        var x = r.value;
        d.payload = function() {
          return g(x);
        }, d.callback = function() {
          $k(n), Yw(n, r);
        };
      }
      var C = n.stateNode;
      return C !== null && typeof C.componentDidCatch == "function" && (d.callback = function() {
        $k(n), Yw(n, r), typeof g != "function" && EH(this);
        var k = r.value, L = r.stack;
        this.componentDidCatch(k, {
          componentStack: L !== null ? L : ""
        }), typeof g != "function" && (Dr(n.lanes, gt) || u("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", kt(n) || "Unknown"));
      }), d;
    }
    function LR(n, r, f) {
      var d = n.pingCache, g;
      if (d === null ? (d = n.pingCache = new zj(), g = /* @__PURE__ */ new Set(), d.set(r, g)) : (g = d.get(r), g === void 0 && (g = /* @__PURE__ */ new Set(), d.set(r, g))), !g.has(f)) {
        g.add(f);
        var x = kH.bind(null, n, r, f);
        Er && Ag(n, f), r.then(x, x);
      }
    }
    function Fj(n, r, f, d) {
      var g = n.updateQueue;
      if (g === null) {
        var x = /* @__PURE__ */ new Set();
        x.add(f), n.updateQueue = x;
      } else
        g.add(f);
    }
    function Vj(n, r) {
      var f = n.tag;
      if ((n.mode & Nt) === ot && (f === m || f === B || f === I)) {
        var d = n.alternate;
        d ? (n.updateQueue = d.updateQueue, n.memoizedState = d.memoizedState, n.lanes = d.lanes) : (n.updateQueue = null, n.memoizedState = null);
      }
    }
    function NR(n) {
      var r = n;
      do {
        if (r.tag === F && yj(r))
          return r;
        r = r.return;
      } while (r !== null);
      return null;
    }
    function zR(n, r, f, d, g) {
      if ((n.mode & Nt) === ot) {
        if (n === r)
          n.flags |= wr;
        else {
          if (n.flags |= at, f.flags |= wd, f.flags &= -52805, f.tag === v) {
            var x = f.alternate;
            if (x === null)
              f.tag = ee;
            else {
              var C = Al(Sn, gt);
              C.tag = H0, Ou(f, C, gt);
            }
          }
          f.lanes = Mt(f.lanes, gt);
        }
        return n;
      }
      return n.flags |= wr, n.lanes = g, n;
    }
    function jj(n, r, f, d, g) {
      if (f.flags |= Rc, Er && Ag(n, g), d !== null && typeof d == "object" && typeof d.then == "function") {
        var x = d;
        Vj(f), lr() && f.mode & Nt && DD();
        var C = NR(r);
        if (C !== null) {
          C.flags &= -257, zR(C, r, f, n, g), C.mode & Nt && LR(n, x, g), Fj(C, n, x);
          return;
        } else {
          if (!My(g)) {
            LR(n, x, g), EC();
            return;
          }
          var D = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          d = D;
        }
      } else if (lr() && f.mode & Nt) {
        DD();
        var k = NR(r);
        if (k !== null) {
          (k.flags & wr) === st && (k.flags |= Sr), zR(k, r, f, n, g), j_(xf(d, f));
          return;
        }
      }
      d = xf(d, f), yH(d);
      var L = r;
      do {
        switch (L.tag) {
          case S: {
            var N = d;
            L.flags |= wr;
            var G = Ic(g);
            L.lanes = Mt(L.lanes, G);
            var W = PR(L, N, G);
            ew(L, W);
            return;
          }
          case v:
            var J = d, ie = L.type, ue = L.stateNode;
            if ((L.flags & at) === st && (typeof ie.getDerivedStateFromError == "function" || ue !== null && typeof ue.componentDidCatch == "function" && !Nk(ue))) {
              L.flags |= wr;
              var Ie = Ic(g);
              L.lanes = Mt(L.lanes, Ie);
              var ft = Gw(L, J, Ie);
              ew(L, ft);
              return;
            }
            break;
        }
        L = L.return;
      } while (L !== null);
    }
    function Bj() {
      return null;
    }
    var mg = i.ReactCurrentOwner, Is = !1, Kw, gg, Xw, Qw, qw, Sf, Zw, gb, vg;
    Kw = {}, gg = {}, Xw = {}, Qw = {}, qw = {}, Sf = !1, Zw = {}, gb = {}, vg = {};
    function Xr(n, r, f, d) {
      n === null ? r.child = jD(r, null, f, d) : r.child = Th(r, n.child, f, d);
    }
    function Hj(n, r, f, d) {
      r.child = Th(r, n.child, null, d), r.child = Th(r, null, f, d);
    }
    function FR(n, r, f, d, g) {
      if (r.type !== r.elementType) {
        var x = f.propTypes;
        x && Fs(
          x,
          d,
          // Resolved props
          "prop",
          mn(f)
        );
      }
      var C = f.render, D = r.ref, k, L;
      Dh(r, g), $r(r);
      {
        if (mg.current = r, Li(!0), k = Ph(n, r, C, d, D, g), L = Lh(), r.mode & vn) {
          Vn(!0);
          try {
            k = Ph(n, r, C, d, D, g), L = Lh();
          } finally {
            Vn(!1);
          }
        }
        Li(!1);
      }
      return Wr(), n !== null && !Is ? (JD(n, r, g), Ol(n, r, g)) : (lr() && L && P_(r), r.flags |= Oa, Xr(n, r, k, g), r.child);
    }
    function VR(n, r, f, d, g) {
      if (n === null) {
        var x = f.type;
        if (YH(x) && f.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        f.defaultProps === void 0) {
          var C = x;
          return C = Uh(x), r.tag = I, r.type = C, tC(r, x), jR(n, r, C, d, g);
        }
        {
          var D = x.propTypes;
          if (D && Fs(
            D,
            d,
            // Resolved props
            "prop",
            mn(x)
          ), f.defaultProps !== void 0) {
            var k = mn(x) || "Unknown";
            vg[k] || (u("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", k), vg[k] = !0);
          }
        }
        var L = FC(f.type, null, d, r, r.mode, g);
        return L.ref = r.ref, L.return = r, r.child = L, L;
      }
      {
        var N = f.type, G = N.propTypes;
        G && Fs(
          G,
          d,
          // Resolved props
          "prop",
          mn(N)
        );
      }
      var W = n.child, J = oC(n, g);
      if (!J) {
        var ie = W.memoizedProps, ue = f.compare;
        if (ue = ue !== null ? ue : Ze, ue(ie, d) && n.ref === r.ref)
          return Ol(n, r, g);
      }
      r.flags |= Oa;
      var Ie = Ef(W, d);
      return Ie.ref = r.ref, Ie.return = r, r.child = Ie, Ie;
    }
    function jR(n, r, f, d, g) {
      if (r.type !== r.elementType) {
        var x = r.elementType;
        if (x.$$typeof === Dt) {
          var C = x, D = C._payload, k = C._init;
          try {
            x = k(D);
          } catch {
            x = null;
          }
          var L = x && x.propTypes;
          L && Fs(
            L,
            d,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            mn(x)
          );
        }
      }
      if (n !== null) {
        var N = n.memoizedProps;
        if (Ze(N, d) && n.ref === r.ref && // Prevent bailout if the implementation changed due to hot reload.
        r.type === n.type)
          if (Is = !1, r.pendingProps = d = N, oC(n, g))
            (n.flags & wd) !== st && (Is = !0);
          else return r.lanes = n.lanes, Ol(n, r, g);
      }
      return Jw(n, r, f, d, g);
    }
    function BR(n, r, f) {
      var d = r.pendingProps, g = d.children, x = n !== null ? n.memoizedState : null;
      if (d.mode === "hidden" || pe)
        if ((r.mode & Nt) === ot) {
          var C = {
            baseLanes: ye,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = C, kb(r, f);
        } else if (Dr(f, Yr)) {
          var G = {
            baseLanes: ye,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = G;
          var W = x !== null ? x.baseLanes : f;
          kb(r, W);
        } else {
          var D = null, k;
          if (x !== null) {
            var L = x.baseLanes;
            k = Mt(L, f);
          } else
            k = f;
          r.lanes = r.childLanes = Yr;
          var N = {
            baseLanes: k,
            cachePool: D,
            transitions: null
          };
          return r.memoizedState = N, r.updateQueue = null, kb(r, k), null;
        }
      else {
        var J;
        x !== null ? (J = Mt(x.baseLanes, f), r.memoizedState = null) : J = f, kb(r, J);
      }
      return Xr(n, r, g, f), r.child;
    }
    function Uj(n, r, f) {
      var d = r.pendingProps;
      return Xr(n, r, d, f), r.child;
    }
    function Ij(n, r, f) {
      var d = r.pendingProps.children;
      return Xr(n, r, d, f), r.child;
    }
    function $j(n, r, f) {
      {
        r.flags |= Bt;
        {
          var d = r.stateNode;
          d.effectDuration = 0, d.passiveEffectDuration = 0;
        }
      }
      var g = r.pendingProps, x = g.children;
      return Xr(n, r, x, f), r.child;
    }
    function HR(n, r) {
      var f = r.ref;
      (n === null && f !== null || n !== null && n.ref !== f) && (r.flags |= Yn, r.flags |= hu);
    }
    function Jw(n, r, f, d, g) {
      if (r.type !== r.elementType) {
        var x = f.propTypes;
        x && Fs(
          x,
          d,
          // Resolved props
          "prop",
          mn(f)
        );
      }
      var C;
      {
        var D = xh(r, f, !0);
        C = Sh(r, D);
      }
      var k, L;
      Dh(r, g), $r(r);
      {
        if (mg.current = r, Li(!0), k = Ph(n, r, f, d, C, g), L = Lh(), r.mode & vn) {
          Vn(!0);
          try {
            k = Ph(n, r, f, d, C, g), L = Lh();
          } finally {
            Vn(!1);
          }
        }
        Li(!1);
      }
      return Wr(), n !== null && !Is ? (JD(n, r, g), Ol(n, r, g)) : (lr() && L && P_(r), r.flags |= Oa, Xr(n, r, k, g), r.child);
    }
    function UR(n, r, f, d, g) {
      {
        switch (oU(r)) {
          case !1: {
            var x = r.stateNode, C = r.type, D = new C(r.memoizedProps, x.context), k = D.state;
            x.updater.enqueueSetState(x, k, null);
            break;
          }
          case !0: {
            r.flags |= at, r.flags |= wr;
            var L = new Error("Simulated error coming from DevTools"), N = Ic(g);
            r.lanes = Mt(r.lanes, N);
            var G = Gw(r, xf(L, r), N);
            ew(r, G);
            break;
          }
        }
        if (r.type !== r.elementType) {
          var W = f.propTypes;
          W && Fs(
            W,
            d,
            // Resolved props
            "prop",
            mn(f)
          );
        }
      }
      var J;
      To(f) ? (J = !0, R0(r)) : J = !1, Dh(r, g);
      var ie = r.stateNode, ue;
      ie === null ? (yb(n, r), AR(r, f, d), $w(r, f, d, g), ue = !0) : n === null ? ue = Pj(r, f, d, g) : ue = Lj(n, r, f, d, g);
      var Ie = eC(n, r, f, ue, J, g);
      {
        var ft = r.stateNode;
        ue && ft.props !== d && (Sf || u("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", kt(r) || "a component"), Sf = !0);
      }
      return Ie;
    }
    function eC(n, r, f, d, g, x) {
      HR(n, r);
      var C = (r.flags & at) !== st;
      if (!d && !C)
        return g && wD(r, f, !1), Ol(n, r, x);
      var D = r.stateNode;
      mg.current = r;
      var k;
      if (C && typeof f.getDerivedStateFromError != "function")
        k = null, ER();
      else {
        $r(r);
        {
          if (Li(!0), k = D.render(), r.mode & vn) {
            Vn(!0);
            try {
              D.render();
            } finally {
              Vn(!1);
            }
          }
          Li(!1);
        }
        Wr();
      }
      return r.flags |= Oa, n !== null && C ? Hj(n, r, k, x) : Xr(n, r, k, x), r.memoizedState = D.state, g && wD(r, f, !0), r.child;
    }
    function IR(n) {
      var r = n.stateNode;
      r.pendingContext ? SD(n, r.pendingContext, r.pendingContext !== r.context) : r.context && SD(n, r.context, !1), tw(n, r.containerInfo);
    }
    function Wj(n, r, f) {
      if (IR(r), n === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var d = r.pendingProps, g = r.memoizedState, x = g.element;
      YD(n, r), W0(r, d, null, f);
      var C = r.memoizedState;
      r.stateNode;
      var D = C.element;
      if (g.isDehydrated) {
        var k = {
          element: D,
          isDehydrated: !1,
          cache: C.cache,
          pendingSuspenseBoundaries: C.pendingSuspenseBoundaries,
          transitions: C.transitions
        }, L = r.updateQueue;
        if (L.baseState = k, r.memoizedState = k, r.flags & Sr) {
          var N = xf(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), r);
          return $R(n, r, D, f, N);
        } else if (D !== x) {
          var G = xf(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), r);
          return $R(n, r, D, f, G);
        } else {
          KV(r);
          var W = jD(r, null, D, f);
          r.child = W;
          for (var J = W; J; )
            J.flags = J.flags & -3 | aa, J = J.sibling;
        }
      } else {
        if (Ch(), D === x)
          return Ol(n, r, f);
        Xr(n, r, D, f);
      }
      return r.child;
    }
    function $R(n, r, f, d, g) {
      return Ch(), j_(g), r.flags |= Sr, Xr(n, r, f, d), r.child;
    }
    function Yj(n, r, f) {
      QD(r), n === null && V_(r);
      var d = r.type, g = r.pendingProps, x = n !== null ? n.memoizedProps : null, C = g.children, D = b_(d, g);
      return D ? C = null : x !== null && b_(d, x) && (r.flags |= Pa), HR(n, r), Xr(n, r, C, f), r.child;
    }
    function Gj(n, r) {
      return n === null && V_(r), null;
    }
    function Kj(n, r, f, d) {
      yb(n, r);
      var g = r.pendingProps, x = f, C = x._payload, D = x._init, k = D(C);
      r.type = k;
      var L = r.tag = GH(k), N = Us(k, g), G;
      switch (L) {
        case m:
          return tC(r, k), r.type = k = Uh(k), G = Jw(null, r, k, N, d), G;
        case v:
          return r.type = k = AC(k), G = UR(null, r, k, N, d), G;
        case B:
          return r.type = k = OC(k), G = FR(null, r, k, N, d), G;
        case $: {
          if (r.type !== r.elementType) {
            var W = k.propTypes;
            W && Fs(
              W,
              N,
              // Resolved for outer only
              "prop",
              mn(k)
            );
          }
          return G = VR(
            null,
            r,
            k,
            Us(k.type, N),
            // The inner type can have defaults too
            d
          ), G;
        }
      }
      var J = "";
      throw k !== null && typeof k == "object" && k.$$typeof === Dt && (J = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + k + ". " + ("Lazy element type must resolve to a class or function." + J));
    }
    function Xj(n, r, f, d, g) {
      yb(n, r), r.tag = v;
      var x;
      return To(f) ? (x = !0, R0(r)) : x = !1, Dh(r, g), AR(r, f, d), $w(r, f, d, g), eC(null, r, f, !0, x, g);
    }
    function Qj(n, r, f, d) {
      yb(n, r);
      var g = r.pendingProps, x;
      {
        var C = xh(r, f, !1);
        x = Sh(r, C);
      }
      Dh(r, d);
      var D, k;
      $r(r);
      {
        if (f.prototype && typeof f.prototype.render == "function") {
          var L = mn(f) || "Unknown";
          Kw[L] || (u("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", L, L), Kw[L] = !0);
        }
        r.mode & vn && js.recordLegacyContextWarning(r, null), Li(!0), mg.current = r, D = Ph(null, r, f, g, x, d), k = Lh(), Li(!1);
      }
      if (Wr(), r.flags |= Oa, typeof D == "object" && D !== null && typeof D.render == "function" && D.$$typeof === void 0) {
        var N = mn(f) || "Unknown";
        gg[N] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", N, N, N), gg[N] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof D == "object" && D !== null && typeof D.render == "function" && D.$$typeof === void 0
      ) {
        {
          var G = mn(f) || "Unknown";
          gg[G] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", G, G, G), gg[G] = !0);
        }
        r.tag = v, r.memoizedState = null, r.updateQueue = null;
        var W = !1;
        return To(f) ? (W = !0, R0(r)) : W = !1, r.memoizedState = D.state !== null && D.state !== void 0 ? D.state : null, J_(r), MR(r, D), $w(r, f, g, d), eC(null, r, f, !0, W, d);
      } else {
        if (r.tag = m, r.mode & vn) {
          Vn(!0);
          try {
            D = Ph(null, r, f, g, x, d), k = Lh();
          } finally {
            Vn(!1);
          }
        }
        return lr() && k && P_(r), Xr(null, r, D, d), tC(r, f), r.child;
      }
    }
    function tC(n, r) {
      {
        if (r && r.childContextTypes && u("%s(...): childContextTypes cannot be defined on a function component.", r.displayName || r.name || "Component"), n.ref !== null) {
          var f = "", d = ta();
          d && (f += `

Check the render method of \`` + d + "`.");
          var g = d || "", x = n._debugSource;
          x && (g = x.fileName + ":" + x.lineNumber), qw[g] || (qw[g] = !0, u("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", f));
        }
        if (r.defaultProps !== void 0) {
          var C = mn(r) || "Unknown";
          vg[C] || (u("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", C), vg[C] = !0);
        }
        if (typeof r.getDerivedStateFromProps == "function") {
          var D = mn(r) || "Unknown";
          Qw[D] || (u("%s: Function components do not support getDerivedStateFromProps.", D), Qw[D] = !0);
        }
        if (typeof r.contextType == "object" && r.contextType !== null) {
          var k = mn(r) || "Unknown";
          Xw[k] || (u("%s: Function components do not support contextType.", k), Xw[k] = !0);
        }
      }
    }
    var nC = {
      dehydrated: null,
      treeContext: null,
      retryLane: Zt
    };
    function iC(n) {
      return {
        baseLanes: n,
        cachePool: Bj(),
        transitions: null
      };
    }
    function qj(n, r) {
      var f = null;
      return {
        baseLanes: Mt(n.baseLanes, r),
        cachePool: f,
        transitions: n.transitions
      };
    }
    function Zj(n, r, f, d) {
      if (r !== null) {
        var g = r.memoizedState;
        if (g === null)
          return !1;
      }
      return rw(n, sg);
    }
    function Jj(n, r) {
      return $c(n.childLanes, r);
    }
    function WR(n, r, f) {
      var d = r.pendingProps;
      lU(r) && (r.flags |= at);
      var g = Bs.current, x = !1, C = (r.flags & at) !== st;
      if (C || Zj(g, n) ? (x = !0, r.flags &= -129) : (n === null || n.memoizedState !== null) && (g = vj(g, ZD)), g = kh(g), Lu(r, g), n === null) {
        V_(r);
        var D = r.memoizedState;
        if (D !== null) {
          var k = D.dehydrated;
          if (k !== null)
            return rB(r, k);
        }
        var L = d.children, N = d.fallback;
        if (x) {
          var G = eB(r, L, N, f), W = r.child;
          return W.memoizedState = iC(f), r.memoizedState = nC, G;
        } else
          return rC(r, L);
      } else {
        var J = n.memoizedState;
        if (J !== null) {
          var ie = J.dehydrated;
          if (ie !== null)
            return aB(n, r, C, d, ie, J, f);
        }
        if (x) {
          var ue = d.fallback, Ie = d.children, ft = nB(n, r, Ie, ue, f), nt = r.child, It = n.child.memoizedState;
          return nt.memoizedState = It === null ? iC(f) : qj(It, f), nt.childLanes = Jj(n, f), r.memoizedState = nC, ft;
        } else {
          var Vt = d.children, Q = tB(n, r, Vt, f);
          return r.memoizedState = null, Q;
        }
      }
    }
    function rC(n, r, f) {
      var d = n.mode, g = {
        mode: "visible",
        children: r
      }, x = aC(g, d);
      return x.return = n, n.child = x, x;
    }
    function eB(n, r, f, d) {
      var g = n.mode, x = n.child, C = {
        mode: "hidden",
        children: r
      }, D, k;
      return (g & Nt) === ot && x !== null ? (D = x, D.childLanes = ye, D.pendingProps = C, n.mode & Jt && (D.actualDuration = 0, D.actualStartTime = -1, D.selfBaseDuration = 0, D.treeBaseDuration = 0), k = Uu(f, g, d, null)) : (D = aC(C, g), k = Uu(f, g, d, null)), D.return = n, k.return = n, D.sibling = k, n.child = D, k;
    }
    function aC(n, r, f) {
      return Yk(n, r, ye, null);
    }
    function YR(n, r) {
      return Ef(n, r);
    }
    function tB(n, r, f, d) {
      var g = n.child, x = g.sibling, C = YR(g, {
        mode: "visible",
        children: f
      });
      if ((r.mode & Nt) === ot && (C.lanes = d), C.return = r, C.sibling = null, x !== null) {
        var D = r.deletions;
        D === null ? (r.deletions = [x], r.flags |= ra) : D.push(x);
      }
      return r.child = C, C;
    }
    function nB(n, r, f, d, g) {
      var x = r.mode, C = n.child, D = C.sibling, k = {
        mode: "hidden",
        children: f
      }, L;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (x & Nt) === ot && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        r.child !== C
      ) {
        var N = r.child;
        L = N, L.childLanes = ye, L.pendingProps = k, r.mode & Jt && (L.actualDuration = 0, L.actualStartTime = -1, L.selfBaseDuration = C.selfBaseDuration, L.treeBaseDuration = C.treeBaseDuration), r.deletions = null;
      } else
        L = YR(C, k), L.subtreeFlags = C.subtreeFlags & ci;
      var G;
      return D !== null ? G = Ef(D, d) : (G = Uu(d, x, g, null), G.flags |= qn), G.return = r, L.return = r, L.sibling = G, r.child = L, G;
    }
    function vb(n, r, f, d) {
      d !== null && j_(d), Th(r, n.child, null, f);
      var g = r.pendingProps, x = g.children, C = rC(r, x);
      return C.flags |= qn, r.memoizedState = null, C;
    }
    function iB(n, r, f, d, g) {
      var x = r.mode, C = {
        mode: "visible",
        children: f
      }, D = aC(C, x), k = Uu(d, x, g, null);
      return k.flags |= qn, D.return = r, k.return = r, D.sibling = k, r.child = D, (r.mode & Nt) !== ot && Th(r, n.child, null, g), k;
    }
    function rB(n, r, f) {
      return (n.mode & Nt) === ot ? (u("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), n.lanes = gt) : w_(r) ? n.lanes = Qi : n.lanes = Yr, null;
    }
    function aB(n, r, f, d, g, x, C) {
      if (f)
        if (r.flags & Sr) {
          r.flags &= -257;
          var Q = Ww(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return vb(n, r, C, Q);
        } else {
          if (r.memoizedState !== null)
            return r.child = n.child, r.flags |= at, null;
          var ce = d.children, q = d.fallback, Re = iB(n, r, ce, q, C), Ke = r.child;
          return Ke.memoizedState = iC(C), r.memoizedState = nC, Re;
        }
      else {
        if (YV(), (r.mode & Nt) === ot)
          return vb(
            n,
            r,
            C,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (w_(g)) {
          var D, k, L;
          {
            var N = uV(g);
            D = N.digest, k = N.message, L = N.stack;
          }
          var G;
          k ? G = new Error(k) : G = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var W = Ww(G, D, L);
          return vb(n, r, C, W);
        }
        var J = Dr(C, n.childLanes);
        if (Is || J) {
          var ie = Rb();
          if (ie !== null) {
            var ue = xm(ie, C);
            if (ue !== Zt && ue !== x.retryLane) {
              x.retryLane = ue;
              var Ie = Sn;
              pa(n, ue), Gi(ie, n, ue, Ie);
            }
          }
          EC();
          var ft = Ww(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return vb(n, r, C, ft);
        } else if (mD(g)) {
          r.flags |= at, r.child = n.child;
          var nt = MH.bind(null, n);
          return cV(g, nt), null;
        } else {
          XV(r, g, x.treeContext);
          var It = d.children, Vt = rC(r, It);
          return Vt.flags |= aa, Vt;
        }
      }
    }
    function GR(n, r, f) {
      n.lanes = Mt(n.lanes, r);
      var d = n.alternate;
      d !== null && (d.lanes = Mt(d.lanes, r)), X_(n.return, r, f);
    }
    function sB(n, r, f) {
      for (var d = r; d !== null; ) {
        if (d.tag === F) {
          var g = d.memoizedState;
          g !== null && GR(d, f, n);
        } else if (d.tag === le)
          GR(d, f, n);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === n)
          return;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === n)
            return;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
    }
    function oB(n) {
      for (var r = n, f = null; r !== null; ) {
        var d = r.alternate;
        d !== null && X0(d) === null && (f = r), r = r.sibling;
      }
      return f;
    }
    function lB(n) {
      if (n !== void 0 && n !== "forwards" && n !== "backwards" && n !== "together" && !Zw[n])
        if (Zw[n] = !0, typeof n == "string")
          switch (n.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', n, n.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', n, n.toLowerCase());
              break;
            }
            default:
              u('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', n);
              break;
          }
        else
          u('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', n);
    }
    function uB(n, r) {
      n !== void 0 && !gb[n] && (n !== "collapsed" && n !== "hidden" ? (gb[n] = !0, u('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', n)) : r !== "forwards" && r !== "backwards" && (gb[n] = !0, u('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', n)));
    }
    function KR(n, r) {
      {
        var f = Ni(n), d = !f && typeof At(n) == "function";
        if (f || d) {
          var g = f ? "array" : "iterable";
          return u("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", g, r, g), !1;
        }
      }
      return !0;
    }
    function cB(n, r) {
      if ((r === "forwards" || r === "backwards") && n !== void 0 && n !== null && n !== !1)
        if (Ni(n)) {
          for (var f = 0; f < n.length; f++)
            if (!KR(n[f], f))
              return;
        } else {
          var d = At(n);
          if (typeof d == "function") {
            var g = d.call(n);
            if (g)
              for (var x = g.next(), C = 0; !x.done; x = g.next()) {
                if (!KR(x.value, C))
                  return;
                C++;
              }
          } else
            u('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', r);
        }
    }
    function sC(n, r, f, d, g) {
      var x = n.memoizedState;
      x === null ? n.memoizedState = {
        isBackwards: r,
        rendering: null,
        renderingStartTime: 0,
        last: d,
        tail: f,
        tailMode: g
      } : (x.isBackwards = r, x.rendering = null, x.renderingStartTime = 0, x.last = d, x.tail = f, x.tailMode = g);
    }
    function XR(n, r, f) {
      var d = r.pendingProps, g = d.revealOrder, x = d.tail, C = d.children;
      lB(g), uB(x, g), cB(C, g), Xr(n, r, C, f);
      var D = Bs.current, k = rw(D, sg);
      if (k)
        D = aw(D, sg), r.flags |= at;
      else {
        var L = n !== null && (n.flags & at) !== st;
        L && sB(r, r.child, f), D = kh(D);
      }
      if (Lu(r, D), (r.mode & Nt) === ot)
        r.memoizedState = null;
      else
        switch (g) {
          case "forwards": {
            var N = oB(r.child), G;
            N === null ? (G = r.child, r.child = null) : (G = N.sibling, N.sibling = null), sC(
              r,
              !1,
              // isBackwards
              G,
              N,
              x
            );
            break;
          }
          case "backwards": {
            var W = null, J = r.child;
            for (r.child = null; J !== null; ) {
              var ie = J.alternate;
              if (ie !== null && X0(ie) === null) {
                r.child = J;
                break;
              }
              var ue = J.sibling;
              J.sibling = W, W = J, J = ue;
            }
            sC(
              r,
              !0,
              // isBackwards
              W,
              null,
              // last
              x
            );
            break;
          }
          case "together": {
            sC(
              r,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            r.memoizedState = null;
        }
      return r.child;
    }
    function fB(n, r, f) {
      tw(r, r.stateNode.containerInfo);
      var d = r.pendingProps;
      return n === null ? r.child = Th(r, null, d, f) : Xr(n, r, d, f), r.child;
    }
    var QR = !1;
    function dB(n, r, f) {
      var d = r.type, g = d._context, x = r.pendingProps, C = r.memoizedProps, D = x.value;
      {
        "value" in x || QR || (QR = !0, u("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var k = r.type.propTypes;
        k && Fs(k, x, "prop", "Context.Provider");
      }
      if (UD(r, g, D), C !== null) {
        var L = C.value;
        if (_e(L, D)) {
          if (C.children === x.children && !E0())
            return Ol(n, r, f);
        } else
          lj(r, g, f);
      }
      var N = x.children;
      return Xr(n, r, N, f), r.child;
    }
    var qR = !1;
    function hB(n, r, f) {
      var d = r.type;
      d._context === void 0 ? d !== d.Consumer && (qR || (qR = !0, u("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : d = d._context;
      var g = r.pendingProps, x = g.children;
      typeof x != "function" && u("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Dh(r, f);
      var C = Ai(d);
      $r(r);
      var D;
      return mg.current = r, Li(!0), D = x(C), Li(!1), Wr(), r.flags |= Oa, Xr(n, r, D, f), r.child;
    }
    function yg() {
      Is = !0;
    }
    function yb(n, r) {
      (r.mode & Nt) === ot && n !== null && (n.alternate = null, r.alternate = null, r.flags |= qn);
    }
    function Ol(n, r, f) {
      return n !== null && (r.dependencies = n.dependencies), ER(), Mg(r.lanes), Dr(f, r.childLanes) ? (sj(n, r), r.child) : null;
    }
    function pB(n, r, f) {
      {
        var d = r.return;
        if (d === null)
          throw new Error("Cannot swap the root fiber.");
        if (n.alternate = null, r.alternate = null, f.index = r.index, f.sibling = r.sibling, f.return = r.return, f.ref = r.ref, r === d.child)
          d.child = f;
        else {
          var g = d.child;
          if (g === null)
            throw new Error("Expected parent to have a child.");
          for (; g.sibling !== r; )
            if (g = g.sibling, g === null)
              throw new Error("Expected to find the previous sibling.");
          g.sibling = f;
        }
        var x = d.deletions;
        return x === null ? (d.deletions = [n], d.flags |= ra) : x.push(n), f.flags |= qn, f;
      }
    }
    function oC(n, r) {
      var f = n.lanes;
      return !!Dr(f, r);
    }
    function mB(n, r, f) {
      switch (r.tag) {
        case S:
          IR(r), r.stateNode, Ch();
          break;
        case E:
          QD(r);
          break;
        case v: {
          var d = r.type;
          To(d) && R0(r);
          break;
        }
        case w:
          tw(r, r.stateNode.containerInfo);
          break;
        case z: {
          var g = r.memoizedProps.value, x = r.type._context;
          UD(r, x, g);
          break;
        }
        case j:
          {
            var C = Dr(f, r.childLanes);
            C && (r.flags |= Bt);
            {
              var D = r.stateNode;
              D.effectDuration = 0, D.passiveEffectDuration = 0;
            }
          }
          break;
        case F: {
          var k = r.memoizedState;
          if (k !== null) {
            if (k.dehydrated !== null)
              return Lu(r, kh(Bs.current)), r.flags |= at, null;
            var L = r.child, N = L.childLanes;
            if (Dr(f, N))
              return WR(n, r, f);
            Lu(r, kh(Bs.current));
            var G = Ol(n, r, f);
            return G !== null ? G.sibling : null;
          } else
            Lu(r, kh(Bs.current));
          break;
        }
        case le: {
          var W = (n.flags & at) !== st, J = Dr(f, r.childLanes);
          if (W) {
            if (J)
              return XR(n, r, f);
            r.flags |= at;
          }
          var ie = r.memoizedState;
          if (ie !== null && (ie.rendering = null, ie.tail = null, ie.lastEffect = null), Lu(r, Bs.current), J)
            break;
          return null;
        }
        case se:
        case Ne:
          return r.lanes = ye, BR(n, r, f);
      }
      return Ol(n, r, f);
    }
    function ZR(n, r, f) {
      if (r._debugNeedsRemount && n !== null)
        return pB(n, r, FC(r.type, r.key, r.pendingProps, r._debugOwner || null, r.mode, r.lanes));
      if (n !== null) {
        var d = n.memoizedProps, g = r.pendingProps;
        if (d !== g || E0() || // Force a re-render if the implementation changed due to hot reload:
        r.type !== n.type)
          Is = !0;
        else {
          var x = oC(n, f);
          if (!x && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (r.flags & at) === st)
            return Is = !1, mB(n, r, f);
          (n.flags & wd) !== st ? Is = !0 : Is = !1;
        }
      } else if (Is = !1, lr() && BV(r)) {
        var C = r.index, D = HV();
        ED(r, D, C);
      }
      switch (r.lanes = ye, r.tag) {
        case b:
          return Qj(n, r, r.type, f);
        case K: {
          var k = r.elementType;
          return Kj(n, r, k, f);
        }
        case m: {
          var L = r.type, N = r.pendingProps, G = r.elementType === L ? N : Us(L, N);
          return Jw(n, r, L, G, f);
        }
        case v: {
          var W = r.type, J = r.pendingProps, ie = r.elementType === W ? J : Us(W, J);
          return UR(n, r, W, ie, f);
        }
        case S:
          return Wj(n, r, f);
        case E:
          return Yj(n, r, f);
        case R:
          return Gj(n, r);
        case F:
          return WR(n, r, f);
        case w:
          return fB(n, r, f);
        case B: {
          var ue = r.type, Ie = r.pendingProps, ft = r.elementType === ue ? Ie : Us(ue, Ie);
          return FR(n, r, ue, ft, f);
        }
        case M:
          return Uj(n, r, f);
        case A:
          return Ij(n, r, f);
        case j:
          return $j(n, r, f);
        case z:
          return dB(n, r, f);
        case P:
          return hB(n, r, f);
        case $: {
          var nt = r.type, It = r.pendingProps, Vt = Us(nt, It);
          if (r.type !== r.elementType) {
            var Q = nt.propTypes;
            Q && Fs(
              Q,
              Vt,
              // Resolved for outer only
              "prop",
              mn(nt)
            );
          }
          return Vt = Us(nt.type, Vt), VR(n, r, nt, Vt, f);
        }
        case I:
          return jR(n, r, r.type, r.pendingProps, f);
        case ee: {
          var ce = r.type, q = r.pendingProps, Re = r.elementType === ce ? q : Us(ce, q);
          return Xj(n, r, ce, Re, f);
        }
        case le:
          return XR(n, r, f);
        case re:
          break;
        case se:
          return BR(n, r, f);
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Nh(n) {
      n.flags |= Bt;
    }
    function JR(n) {
      n.flags |= Yn, n.flags |= hu;
    }
    var ek, lC, tk, nk;
    ek = function(n, r, f, d) {
      for (var g = r.child; g !== null; ) {
        if (g.tag === E || g.tag === R)
          FF(n, g.stateNode);
        else if (g.tag !== w) {
          if (g.child !== null) {
            g.child.return = g, g = g.child;
            continue;
          }
        }
        if (g === r)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === r)
            return;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
    }, lC = function(n, r) {
    }, tk = function(n, r, f, d, g) {
      var x = n.memoizedProps;
      if (x !== d) {
        var C = r.stateNode, D = nw(), k = jF(C, f, x, d, g, D);
        r.updateQueue = k, k && Nh(r);
      }
    }, nk = function(n, r, f, d) {
      f !== d && Nh(r);
    };
    function bg(n, r) {
      if (!lr())
        switch (n.tailMode) {
          case "hidden": {
            for (var f = n.tail, d = null; f !== null; )
              f.alternate !== null && (d = f), f = f.sibling;
            d === null ? n.tail = null : d.sibling = null;
            break;
          }
          case "collapsed": {
            for (var g = n.tail, x = null; g !== null; )
              g.alternate !== null && (x = g), g = g.sibling;
            x === null ? !r && n.tail !== null ? n.tail.sibling = null : n.tail = null : x.sibling = null;
            break;
          }
        }
    }
    function cr(n) {
      var r = n.alternate !== null && n.alternate.child === n.child, f = ye, d = st;
      if (r) {
        if ((n.mode & Jt) !== ot) {
          for (var k = n.selfBaseDuration, L = n.child; L !== null; )
            f = Mt(f, Mt(L.lanes, L.childLanes)), d |= L.subtreeFlags & ci, d |= L.flags & ci, k += L.treeBaseDuration, L = L.sibling;
          n.treeBaseDuration = k;
        } else
          for (var N = n.child; N !== null; )
            f = Mt(f, Mt(N.lanes, N.childLanes)), d |= N.subtreeFlags & ci, d |= N.flags & ci, N.return = n, N = N.sibling;
        n.subtreeFlags |= d;
      } else {
        if ((n.mode & Jt) !== ot) {
          for (var g = n.actualDuration, x = n.selfBaseDuration, C = n.child; C !== null; )
            f = Mt(f, Mt(C.lanes, C.childLanes)), d |= C.subtreeFlags, d |= C.flags, g += C.actualDuration, x += C.treeBaseDuration, C = C.sibling;
          n.actualDuration = g, n.treeBaseDuration = x;
        } else
          for (var D = n.child; D !== null; )
            f = Mt(f, Mt(D.lanes, D.childLanes)), d |= D.subtreeFlags, d |= D.flags, D.return = n, D = D.sibling;
        n.subtreeFlags |= d;
      }
      return n.childLanes = f, r;
    }
    function gB(n, r, f) {
      if (ej() && (r.mode & Nt) !== ot && (r.flags & at) === st)
        return PD(r), Ch(), r.flags |= Sr | Rc | wr, !1;
      var d = P0(r);
      if (f !== null && f.dehydrated !== null)
        if (n === null) {
          if (!d)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (ZV(r), cr(r), (r.mode & Jt) !== ot) {
            var g = f !== null;
            if (g) {
              var x = r.child;
              x !== null && (r.treeBaseDuration -= x.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Ch(), (r.flags & at) === st && (r.memoizedState = null), r.flags |= Bt, cr(r), (r.mode & Jt) !== ot) {
            var C = f !== null;
            if (C) {
              var D = r.child;
              D !== null && (r.treeBaseDuration -= D.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return LD(), !0;
    }
    function ik(n, r, f) {
      var d = r.pendingProps;
      switch (L_(r), r.tag) {
        case b:
        case K:
        case I:
        case m:
        case B:
        case M:
        case A:
        case j:
        case P:
        case $:
          return cr(r), null;
        case v: {
          var g = r.type;
          return To(g) && D0(r), cr(r), null;
        }
        case S: {
          var x = r.stateNode;
          if (Rh(r), M_(r), ow(), x.pendingContext && (x.context = x.pendingContext, x.pendingContext = null), n === null || n.child === null) {
            var C = P0(r);
            if (C)
              Nh(r);
            else if (n !== null) {
              var D = n.memoizedState;
              // Check if this is a client root
              (!D.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (r.flags & Sr) !== st) && (r.flags |= xi, LD());
            }
          }
          return lC(n, r), cr(r), null;
        }
        case E: {
          iw(r);
          var k = XD(), L = r.type;
          if (n !== null && r.stateNode != null)
            tk(n, r, L, d, k), n.ref !== r.ref && JR(r);
          else {
            if (!d) {
              if (r.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return cr(r), null;
            }
            var N = nw(), G = P0(r);
            if (G)
              QV(r, k, N) && Nh(r);
            else {
              var W = zF(L, d, k, N, r);
              ek(W, r, !1, !1), r.stateNode = W, VF(W, L, d, k) && Nh(r);
            }
            r.ref !== null && JR(r);
          }
          return cr(r), null;
        }
        case R: {
          var J = d;
          if (n && r.stateNode != null) {
            var ie = n.memoizedProps;
            nk(n, r, ie, J);
          } else {
            if (typeof J != "string" && r.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var ue = XD(), Ie = nw(), ft = P0(r);
            ft ? qV(r) && Nh(r) : r.stateNode = BF(J, ue, Ie, r);
          }
          return cr(r), null;
        }
        case F: {
          Mh(r);
          var nt = r.memoizedState;
          if (n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            var It = gB(n, r, nt);
            if (!It)
              return r.flags & wr ? r : null;
          }
          if ((r.flags & at) !== st)
            return r.lanes = f, (r.mode & Jt) !== ot && Ow(r), r;
          var Vt = nt !== null, Q = n !== null && n.memoizedState !== null;
          if (Vt !== Q && Vt) {
            var ce = r.child;
            if (ce.flags |= ui, (r.mode & Nt) !== ot) {
              var q = n === null && (r.memoizedProps.unstable_avoidThisFallback !== !0 || !0);
              q || rw(Bs.current, ZD) ? vH() : EC();
            }
          }
          var Re = r.updateQueue;
          if (Re !== null && (r.flags |= Bt), cr(r), (r.mode & Jt) !== ot && Vt) {
            var Ke = r.child;
            Ke !== null && (r.treeBaseDuration -= Ke.treeBaseDuration);
          }
          return null;
        }
        case w:
          return Rh(r), lC(n, r), n === null && PV(r.stateNode.containerInfo), cr(r), null;
        case z:
          var We = r.type._context;
          return K_(We, r), cr(r), null;
        case ee: {
          var vt = r.type;
          return To(vt) && D0(r), cr(r), null;
        }
        case le: {
          Mh(r);
          var Rt = r.memoizedState;
          if (Rt === null)
            return cr(r), null;
          var bn = (r.flags & at) !== st, nn = Rt.rendering;
          if (nn === null)
            if (bn)
              bg(Rt, !1);
            else {
              var wi = bH() && (n === null || (n.flags & at) === st);
              if (!wi)
                for (var rn = r.child; rn !== null; ) {
                  var gi = X0(rn);
                  if (gi !== null) {
                    bn = !0, r.flags |= at, bg(Rt, !1);
                    var Lr = gi.updateQueue;
                    return Lr !== null && (r.updateQueue = Lr, r.flags |= Bt), r.subtreeFlags = st, oj(r, f), Lu(r, aw(Bs.current, sg)), r.child;
                  }
                  rn = rn.sibling;
                }
              Rt.tail !== null && Si() > Ck() && (r.flags |= at, bn = !0, bg(Rt, !1), r.lanes = fm);
            }
          else {
            if (!bn) {
              var mr = X0(nn);
              if (mr !== null) {
                r.flags |= at, bn = !0;
                var Ba = mr.updateQueue;
                if (Ba !== null && (r.updateQueue = Ba, r.flags |= Bt), bg(Rt, !0), Rt.tail === null && Rt.tailMode === "hidden" && !nn.alternate && !lr())
                  return cr(r), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              Si() * 2 - Rt.renderingStartTime > Ck() && f !== Yr && (r.flags |= at, bn = !0, bg(Rt, !1), r.lanes = fm);
            }
            if (Rt.isBackwards)
              nn.sibling = r.child, r.child = nn;
            else {
              var Zr = Rt.last;
              Zr !== null ? Zr.sibling = nn : r.child = nn, Rt.last = nn;
            }
          }
          if (Rt.tail !== null) {
            var Jr = Rt.tail;
            Rt.rendering = Jr, Rt.tail = Jr.sibling, Rt.renderingStartTime = Si(), Jr.sibling = null;
            var Nr = Bs.current;
            return bn ? Nr = aw(Nr, sg) : Nr = kh(Nr), Lu(r, Nr), Jr;
          }
          return cr(r), null;
        }
        case re:
          break;
        case se:
        case Ne: {
          TC(r);
          var Fl = r.memoizedState, Ih = Fl !== null;
          if (n !== null) {
            var Ng = n.memoizedState, Po = Ng !== null;
            Po !== Ih && (r.flags |= ui);
          }
          return !Ih || (r.mode & Nt) === ot ? cr(r) : Dr(Oo, Yr) && (cr(r), r.subtreeFlags & (qn | Bt) && (r.flags |= ui)), null;
        }
        case Ee:
          return null;
        case we:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function vB(n, r, f) {
      switch (L_(r), r.tag) {
        case v: {
          var d = r.type;
          To(d) && D0(r);
          var g = r.flags;
          return g & wr ? (r.flags = g & -65537 | at, (r.mode & Jt) !== ot && Ow(r), r) : null;
        }
        case S: {
          r.stateNode, Rh(r), M_(r), ow();
          var x = r.flags;
          return (x & wr) !== st && (x & at) === st ? (r.flags = x & -65537 | at, r) : null;
        }
        case E:
          return iw(r), null;
        case F: {
          Mh(r);
          var C = r.memoizedState;
          if (C !== null && C.dehydrated !== null) {
            if (r.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Ch();
          }
          var D = r.flags;
          return D & wr ? (r.flags = D & -65537 | at, (r.mode & Jt) !== ot && Ow(r), r) : null;
        }
        case le:
          return Mh(r), null;
        case w:
          return Rh(r), null;
        case z:
          var k = r.type._context;
          return K_(k, r), null;
        case se:
        case Ne:
          return TC(r), null;
        case Ee:
          return null;
        default:
          return null;
      }
    }
    function rk(n, r, f) {
      switch (L_(r), r.tag) {
        case v: {
          var d = r.type.childContextTypes;
          d != null && D0(r);
          break;
        }
        case S: {
          r.stateNode, Rh(r), M_(r), ow();
          break;
        }
        case E: {
          iw(r);
          break;
        }
        case w:
          Rh(r);
          break;
        case F:
          Mh(r);
          break;
        case le:
          Mh(r);
          break;
        case z:
          var g = r.type._context;
          K_(g, r);
          break;
        case se:
        case Ne:
          TC(r);
          break;
      }
    }
    var ak = null;
    ak = /* @__PURE__ */ new Set();
    var bb = !1, fr = !1, yB = typeof WeakSet == "function" ? WeakSet : Set, Je = null, zh = null, Fh = null;
    function bB(n) {
      so(null, function() {
        throw n;
      }), Dc();
    }
    var xB = function(n, r) {
      if (r.props = n.memoizedProps, r.state = n.memoizedState, n.mode & Jt)
        try {
          Mo(), r.componentWillUnmount();
        } finally {
          ko(n);
        }
      else
        r.componentWillUnmount();
    };
    function sk(n, r) {
      try {
        Fu(Hi, n);
      } catch (f) {
        kn(n, r, f);
      }
    }
    function uC(n, r, f) {
      try {
        xB(n, f);
      } catch (d) {
        kn(n, r, d);
      }
    }
    function SB(n, r, f) {
      try {
        f.componentDidMount();
      } catch (d) {
        kn(n, r, d);
      }
    }
    function ok(n, r) {
      try {
        uk(n);
      } catch (f) {
        kn(n, r, f);
      }
    }
    function Vh(n, r) {
      var f = n.ref;
      if (f !== null)
        if (typeof f == "function") {
          var d;
          try {
            if (Pe && fe && n.mode & Jt)
              try {
                Mo(), d = f(null);
              } finally {
                ko(n);
              }
            else
              d = f(null);
          } catch (g) {
            kn(n, r, g);
          }
          typeof d == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", kt(n));
        } else
          f.current = null;
    }
    function xb(n, r, f) {
      try {
        f();
      } catch (d) {
        kn(n, r, d);
      }
    }
    var lk = !1;
    function _B(n, r) {
      LF(n.containerInfo), Je = r, wB();
      var f = lk;
      return lk = !1, f;
    }
    function wB() {
      for (; Je !== null; ) {
        var n = Je, r = n.child;
        (n.subtreeFlags & lo) !== st && r !== null ? (r.return = n, Je = r) : CB();
      }
    }
    function CB() {
      for (; Je !== null; ) {
        var n = Je;
        Rn(n);
        try {
          TB(n);
        } catch (f) {
          kn(n, n.return, f);
        }
        Wn();
        var r = n.sibling;
        if (r !== null) {
          r.return = n.return, Je = r;
          return;
        }
        Je = n.return;
      }
    }
    function TB(n) {
      var r = n.alternate, f = n.flags;
      if ((f & xi) !== st) {
        switch (Rn(n), n.tag) {
          case m:
          case B:
          case I:
            break;
          case v: {
            if (r !== null) {
              var d = r.memoizedProps, g = r.memoizedState, x = n.stateNode;
              n.type === n.elementType && !Sf && (x.props !== n.memoizedProps && u("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(n) || "instance"), x.state !== n.memoizedState && u("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(n) || "instance"));
              var C = x.getSnapshotBeforeUpdate(n.elementType === n.type ? d : Us(n.type, d), g);
              {
                var D = ak;
                C === void 0 && !D.has(n.type) && (D.add(n.type), u("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", kt(n)));
              }
              x.__reactInternalSnapshotBeforeUpdate = C;
            }
            break;
          }
          case S: {
            {
              var k = n.stateNode;
              aV(k.containerInfo);
            }
            break;
          }
          case E:
          case R:
          case w:
          case ee:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Wn();
      }
    }
    function $s(n, r, f) {
      var d = r.updateQueue, g = d !== null ? d.lastEffect : null;
      if (g !== null) {
        var x = g.next, C = x;
        do {
          if ((C.tag & n) === n) {
            var D = C.destroy;
            C.destroy = void 0, D !== void 0 && ((n & ur) !== ma ? As(r) : (n & Hi) !== ma && Mc(r), (n & Eo) !== ma && Og(!0), xb(r, f, D), (n & Eo) !== ma && Og(!1), (n & ur) !== ma ? ho() : (n & Hi) !== ma && um());
          }
          C = C.next;
        } while (C !== x);
      }
    }
    function Fu(n, r) {
      var f = r.updateQueue, d = f !== null ? f.lastEffect : null;
      if (d !== null) {
        var g = d.next, x = g;
        do {
          if ((x.tag & n) === n) {
            (n & ur) !== ma ? lm(r) : (n & Hi) !== ma && kd(r);
            var C = x.create;
            (n & Eo) !== ma && Og(!0), x.destroy = C(), (n & Eo) !== ma && Og(!1), (n & ur) !== ma ? Ty() : (n & Hi) !== ma && Ey();
            {
              var D = x.destroy;
              if (D !== void 0 && typeof D != "function") {
                var k = void 0;
                (x.tag & Hi) !== st ? k = "useLayoutEffect" : (x.tag & Eo) !== st ? k = "useInsertionEffect" : k = "useEffect";
                var L = void 0;
                D === null ? L = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof D.then == "function" ? L = `

It looks like you wrote ` + k + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + k + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : L = " You returned: " + D, u("%s must not return anything besides a function, which is used for clean-up.%s", k, L);
              }
            }
          }
          x = x.next;
        } while (x !== g);
      }
    }
    function EB(n, r) {
      if ((r.flags & Bt) !== st)
        switch (r.tag) {
          case j: {
            var f = r.stateNode.passiveEffectDuration, d = r.memoizedProps, g = d.id, x = d.onPostCommit, C = CR(), D = r.alternate === null ? "mount" : "update";
            wR() && (D = "nested-update"), typeof x == "function" && x(g, D, f, C);
            var k = r.return;
            e: for (; k !== null; ) {
              switch (k.tag) {
                case S:
                  var L = k.stateNode;
                  L.passiveEffectDuration += f;
                  break e;
                case j:
                  var N = k.stateNode;
                  N.passiveEffectDuration += f;
                  break e;
              }
              k = k.return;
            }
            break;
          }
        }
    }
    function DB(n, r, f, d) {
      if ((f.flags & co) !== st)
        switch (f.tag) {
          case m:
          case B:
          case I: {
            if (!fr)
              if (f.mode & Jt)
                try {
                  Mo(), Fu(Hi | Bi, f);
                } finally {
                  ko(f);
                }
              else
                Fu(Hi | Bi, f);
            break;
          }
          case v: {
            var g = f.stateNode;
            if (f.flags & Bt && !fr)
              if (r === null)
                if (f.type === f.elementType && !Sf && (g.props !== f.memoizedProps && u("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(f) || "instance"), g.state !== f.memoizedState && u("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(f) || "instance")), f.mode & Jt)
                  try {
                    Mo(), g.componentDidMount();
                  } finally {
                    ko(f);
                  }
                else
                  g.componentDidMount();
              else {
                var x = f.elementType === f.type ? r.memoizedProps : Us(f.type, r.memoizedProps), C = r.memoizedState;
                if (f.type === f.elementType && !Sf && (g.props !== f.memoizedProps && u("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(f) || "instance"), g.state !== f.memoizedState && u("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(f) || "instance")), f.mode & Jt)
                  try {
                    Mo(), g.componentDidUpdate(x, C, g.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    ko(f);
                  }
                else
                  g.componentDidUpdate(x, C, g.__reactInternalSnapshotBeforeUpdate);
              }
            var D = f.updateQueue;
            D !== null && (f.type === f.elementType && !Sf && (g.props !== f.memoizedProps && u("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(f) || "instance"), g.state !== f.memoizedState && u("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(f) || "instance")), KD(f, D, g));
            break;
          }
          case S: {
            var k = f.updateQueue;
            if (k !== null) {
              var L = null;
              if (f.child !== null)
                switch (f.child.tag) {
                  case E:
                    L = f.child.stateNode;
                    break;
                  case v:
                    L = f.child.stateNode;
                    break;
                }
              KD(f, k, L);
            }
            break;
          }
          case E: {
            var N = f.stateNode;
            if (r === null && f.flags & Bt) {
              var G = f.type, W = f.memoizedProps;
              WF(N, G, W);
            }
            break;
          }
          case R:
            break;
          case w:
            break;
          case j: {
            {
              var J = f.memoizedProps, ie = J.onCommit, ue = J.onRender, Ie = f.stateNode.effectDuration, ft = CR(), nt = r === null ? "mount" : "update";
              wR() && (nt = "nested-update"), typeof ue == "function" && ue(f.memoizedProps.id, nt, f.actualDuration, f.treeBaseDuration, f.actualStartTime, ft);
              {
                typeof ie == "function" && ie(f.memoizedProps.id, nt, Ie, ft), CH(f);
                var It = f.return;
                e: for (; It !== null; ) {
                  switch (It.tag) {
                    case S:
                      var Vt = It.stateNode;
                      Vt.effectDuration += Ie;
                      break e;
                    case j:
                      var Q = It.stateNode;
                      Q.effectDuration += Ie;
                      break e;
                  }
                  It = It.return;
                }
              }
            }
            break;
          }
          case F: {
            NB(n, f);
            break;
          }
          case le:
          case ee:
          case re:
          case se:
          case Ne:
          case we:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      fr || f.flags & Yn && uk(f);
    }
    function RB(n) {
      switch (n.tag) {
        case m:
        case B:
        case I: {
          if (n.mode & Jt)
            try {
              Mo(), sk(n, n.return);
            } finally {
              ko(n);
            }
          else
            sk(n, n.return);
          break;
        }
        case v: {
          var r = n.stateNode;
          typeof r.componentDidMount == "function" && SB(n, n.return, r), ok(n, n.return);
          break;
        }
        case E: {
          ok(n, n.return);
          break;
        }
      }
    }
    function kB(n, r) {
      for (var f = null, d = n; ; ) {
        if (d.tag === E) {
          if (f === null) {
            f = d;
            try {
              var g = d.stateNode;
              r ? tV(g) : iV(d.stateNode, d.memoizedProps);
            } catch (C) {
              kn(n, n.return, C);
            }
          }
        } else if (d.tag === R) {
          if (f === null)
            try {
              var x = d.stateNode;
              r ? nV(x) : rV(x, d.memoizedProps);
            } catch (C) {
              kn(n, n.return, C);
            }
        } else if (!((d.tag === se || d.tag === Ne) && d.memoizedState !== null && d !== n)) {
          if (d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
        }
        if (d === n)
          return;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === n)
            return;
          f === d && (f = null), d = d.return;
        }
        f === d && (f = null), d.sibling.return = d.return, d = d.sibling;
      }
    }
    function uk(n) {
      var r = n.ref;
      if (r !== null) {
        var f = n.stateNode, d;
        switch (n.tag) {
          case E:
            d = f;
            break;
          default:
            d = f;
        }
        if (typeof r == "function") {
          var g;
          if (n.mode & Jt)
            try {
              Mo(), g = r(d);
            } finally {
              ko(n);
            }
          else
            g = r(d);
          typeof g == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", kt(n));
        } else
          r.hasOwnProperty("current") || u("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", kt(n)), r.current = d;
      }
    }
    function MB(n) {
      var r = n.alternate;
      r !== null && (r.return = null), n.return = null;
    }
    function ck(n) {
      var r = n.alternate;
      r !== null && (n.alternate = null, ck(r));
      {
        if (n.child = null, n.deletions = null, n.sibling = null, n.tag === E) {
          var f = n.stateNode;
          f !== null && zV(f);
        }
        n.stateNode = null, n._debugOwner = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
      }
    }
    function AB(n) {
      for (var r = n.return; r !== null; ) {
        if (fk(r))
          return r;
        r = r.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function fk(n) {
      return n.tag === E || n.tag === S || n.tag === w;
    }
    function dk(n) {
      var r = n;
      e: for (; ; ) {
        for (; r.sibling === null; ) {
          if (r.return === null || fk(r.return))
            return null;
          r = r.return;
        }
        for (r.sibling.return = r.return, r = r.sibling; r.tag !== E && r.tag !== R && r.tag !== ne; ) {
          if (r.flags & qn || r.child === null || r.tag === w)
            continue e;
          r.child.return = r, r = r.child;
        }
        if (!(r.flags & qn))
          return r.stateNode;
      }
    }
    function OB(n) {
      var r = AB(n);
      switch (r.tag) {
        case E: {
          var f = r.stateNode;
          r.flags & Pa && (pD(f), r.flags &= -33);
          var d = dk(n);
          fC(n, d, f);
          break;
        }
        case S:
        case w: {
          var g = r.stateNode.containerInfo, x = dk(n);
          cC(n, x, g);
          break;
        }
        // eslint-disable-next-line-no-fallthrough
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function cC(n, r, f) {
      var d = n.tag, g = d === E || d === R;
      if (g) {
        var x = n.stateNode;
        r ? qF(f, x, r) : XF(f, x);
      } else if (d !== w) {
        var C = n.child;
        if (C !== null) {
          cC(C, r, f);
          for (var D = C.sibling; D !== null; )
            cC(D, r, f), D = D.sibling;
        }
      }
    }
    function fC(n, r, f) {
      var d = n.tag, g = d === E || d === R;
      if (g) {
        var x = n.stateNode;
        r ? QF(f, x, r) : KF(f, x);
      } else if (d !== w) {
        var C = n.child;
        if (C !== null) {
          fC(C, r, f);
          for (var D = C.sibling; D !== null; )
            fC(D, r, f), D = D.sibling;
        }
      }
    }
    var dr = null, Ws = !1;
    function PB(n, r, f) {
      {
        var d = r;
        e: for (; d !== null; ) {
          switch (d.tag) {
            case E: {
              dr = d.stateNode, Ws = !1;
              break e;
            }
            case S: {
              dr = d.stateNode.containerInfo, Ws = !0;
              break e;
            }
            case w: {
              dr = d.stateNode.containerInfo, Ws = !0;
              break e;
            }
          }
          d = d.return;
        }
        if (dr === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        hk(n, r, f), dr = null, Ws = !1;
      }
      MB(f);
    }
    function Vu(n, r, f) {
      for (var d = f.child; d !== null; )
        hk(n, r, d), d = d.sibling;
    }
    function hk(n, r, f) {
      switch (am(f), f.tag) {
        case E:
          fr || Vh(f, r);
        // eslint-disable-next-line-no-fallthrough
        case R: {
          {
            var d = dr, g = Ws;
            dr = null, Vu(n, r, f), dr = d, Ws = g, dr !== null && (Ws ? JF(dr, f.stateNode) : ZF(dr, f.stateNode));
          }
          return;
        }
        case ne: {
          dr !== null && (Ws ? eV(dr, f.stateNode) : __(dr, f.stateNode));
          return;
        }
        case w: {
          {
            var x = dr, C = Ws;
            dr = f.stateNode.containerInfo, Ws = !0, Vu(n, r, f), dr = x, Ws = C;
          }
          return;
        }
        case m:
        case B:
        case $:
        case I: {
          if (!fr) {
            var D = f.updateQueue;
            if (D !== null) {
              var k = D.lastEffect;
              if (k !== null) {
                var L = k.next, N = L;
                do {
                  var G = N, W = G.destroy, J = G.tag;
                  W !== void 0 && ((J & Eo) !== ma ? xb(f, r, W) : (J & Hi) !== ma && (Mc(f), f.mode & Jt ? (Mo(), xb(f, r, W), ko(f)) : xb(f, r, W), um())), N = N.next;
                } while (N !== L);
              }
            }
          }
          Vu(n, r, f);
          return;
        }
        case v: {
          if (!fr) {
            Vh(f, r);
            var ie = f.stateNode;
            typeof ie.componentWillUnmount == "function" && uC(f, r, ie);
          }
          Vu(n, r, f);
          return;
        }
        case re: {
          Vu(n, r, f);
          return;
        }
        case se: {
          if (
            // TODO: Remove this dead flag
            f.mode & Nt
          ) {
            var ue = fr;
            fr = ue || f.memoizedState !== null, Vu(n, r, f), fr = ue;
          } else
            Vu(n, r, f);
          break;
        }
        default: {
          Vu(n, r, f);
          return;
        }
      }
    }
    function LB(n) {
      n.memoizedState;
    }
    function NB(n, r) {
      var f = r.memoizedState;
      if (f === null) {
        var d = r.alternate;
        if (d !== null) {
          var g = d.memoizedState;
          if (g !== null) {
            var x = g.dehydrated;
            x !== null && bV(x);
          }
        }
      }
    }
    function pk(n) {
      var r = n.updateQueue;
      if (r !== null) {
        n.updateQueue = null;
        var f = n.stateNode;
        f === null && (f = n.stateNode = new yB()), r.forEach(function(d) {
          var g = AH.bind(null, n, d);
          if (!f.has(d)) {
            if (f.add(d), Er)
              if (zh !== null && Fh !== null)
                Ag(Fh, zh);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            d.then(g, g);
          }
        });
      }
    }
    function zB(n, r, f) {
      zh = f, Fh = n, Rn(r), mk(r, n), Rn(r), zh = null, Fh = null;
    }
    function Ys(n, r, f) {
      var d = r.deletions;
      if (d !== null)
        for (var g = 0; g < d.length; g++) {
          var x = d[g];
          try {
            PB(n, r, x);
          } catch (k) {
            kn(x, r, k);
          }
        }
      var C = fc();
      if (r.subtreeFlags & uo)
        for (var D = r.child; D !== null; )
          Rn(D), mk(D, n), D = D.sibling;
      Rn(C);
    }
    function mk(n, r, f) {
      var d = n.alternate, g = n.flags;
      switch (n.tag) {
        case m:
        case B:
        case $:
        case I: {
          if (Ys(r, n), Ao(n), g & Bt) {
            try {
              $s(Eo | Bi, n, n.return), Fu(Eo | Bi, n);
            } catch (vt) {
              kn(n, n.return, vt);
            }
            if (n.mode & Jt) {
              try {
                Mo(), $s(Hi | Bi, n, n.return);
              } catch (vt) {
                kn(n, n.return, vt);
              }
              ko(n);
            } else
              try {
                $s(Hi | Bi, n, n.return);
              } catch (vt) {
                kn(n, n.return, vt);
              }
          }
          return;
        }
        case v: {
          Ys(r, n), Ao(n), g & Yn && d !== null && Vh(d, d.return);
          return;
        }
        case E: {
          Ys(r, n), Ao(n), g & Yn && d !== null && Vh(d, d.return);
          {
            if (n.flags & Pa) {
              var x = n.stateNode;
              try {
                pD(x);
              } catch (vt) {
                kn(n, n.return, vt);
              }
            }
            if (g & Bt) {
              var C = n.stateNode;
              if (C != null) {
                var D = n.memoizedProps, k = d !== null ? d.memoizedProps : D, L = n.type, N = n.updateQueue;
                if (n.updateQueue = null, N !== null)
                  try {
                    YF(C, N, L, k, D, n);
                  } catch (vt) {
                    kn(n, n.return, vt);
                  }
              }
            }
          }
          return;
        }
        case R: {
          if (Ys(r, n), Ao(n), g & Bt) {
            if (n.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var G = n.stateNode, W = n.memoizedProps, J = d !== null ? d.memoizedProps : W;
            try {
              GF(G, J, W);
            } catch (vt) {
              kn(n, n.return, vt);
            }
          }
          return;
        }
        case S: {
          if (Ys(r, n), Ao(n), g & Bt && d !== null) {
            var ie = d.memoizedState;
            if (ie.isDehydrated)
              try {
                yV(r.containerInfo);
              } catch (vt) {
                kn(n, n.return, vt);
              }
          }
          return;
        }
        case w: {
          Ys(r, n), Ao(n);
          return;
        }
        case F: {
          Ys(r, n), Ao(n);
          var ue = n.child;
          if (ue.flags & ui) {
            var Ie = ue.stateNode, ft = ue.memoizedState, nt = ft !== null;
            if (Ie.isHidden = nt, nt) {
              var It = ue.alternate !== null && ue.alternate.memoizedState !== null;
              It || gH();
            }
          }
          if (g & Bt) {
            try {
              LB(n);
            } catch (vt) {
              kn(n, n.return, vt);
            }
            pk(n);
          }
          return;
        }
        case se: {
          var Vt = d !== null && d.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            n.mode & Nt
          ) {
            var Q = fr;
            fr = Q || Vt, Ys(r, n), fr = Q;
          } else
            Ys(r, n);
          if (Ao(n), g & ui) {
            var ce = n.stateNode, q = n.memoizedState, Re = q !== null, Ke = n;
            if (ce.isHidden = Re, Re && !Vt && (Ke.mode & Nt) !== ot) {
              Je = Ke;
              for (var We = Ke.child; We !== null; )
                Je = We, VB(We), We = We.sibling;
            }
            kB(Ke, Re);
          }
          return;
        }
        case le: {
          Ys(r, n), Ao(n), g & Bt && pk(n);
          return;
        }
        case re:
          return;
        default: {
          Ys(r, n), Ao(n);
          return;
        }
      }
    }
    function Ao(n) {
      var r = n.flags;
      if (r & qn) {
        try {
          OB(n);
        } catch (f) {
          kn(n, n.return, f);
        }
        n.flags &= -3;
      }
      r & aa && (n.flags &= -4097);
    }
    function FB(n, r, f) {
      zh = f, Fh = r, Je = n, gk(n, r, f), zh = null, Fh = null;
    }
    function gk(n, r, f) {
      for (var d = (n.mode & Nt) !== ot; Je !== null; ) {
        var g = Je, x = g.child;
        if (g.tag === se && d) {
          var C = g.memoizedState !== null, D = C || bb;
          if (D) {
            dC(n, r, f);
            continue;
          } else {
            var k = g.alternate, L = k !== null && k.memoizedState !== null, N = L || fr, G = bb, W = fr;
            bb = D, fr = N, fr && !W && (Je = g, jB(g));
            for (var J = x; J !== null; )
              Je = J, gk(
                J,
                // New root; bubble back up to here and stop.
                r,
                f
              ), J = J.sibling;
            Je = g, bb = G, fr = W, dC(n, r, f);
            continue;
          }
        }
        (g.subtreeFlags & co) !== st && x !== null ? (x.return = g, Je = x) : dC(n, r, f);
      }
    }
    function dC(n, r, f) {
      for (; Je !== null; ) {
        var d = Je;
        if ((d.flags & co) !== st) {
          var g = d.alternate;
          Rn(d);
          try {
            DB(r, g, d, f);
          } catch (C) {
            kn(d, d.return, C);
          }
          Wn();
        }
        if (d === n) {
          Je = null;
          return;
        }
        var x = d.sibling;
        if (x !== null) {
          x.return = d.return, Je = x;
          return;
        }
        Je = d.return;
      }
    }
    function VB(n) {
      for (; Je !== null; ) {
        var r = Je, f = r.child;
        switch (r.tag) {
          case m:
          case B:
          case $:
          case I: {
            if (r.mode & Jt)
              try {
                Mo(), $s(Hi, r, r.return);
              } finally {
                ko(r);
              }
            else
              $s(Hi, r, r.return);
            break;
          }
          case v: {
            Vh(r, r.return);
            var d = r.stateNode;
            typeof d.componentWillUnmount == "function" && uC(r, r.return, d);
            break;
          }
          case E: {
            Vh(r, r.return);
            break;
          }
          case se: {
            var g = r.memoizedState !== null;
            if (g) {
              vk(n);
              continue;
            }
            break;
          }
        }
        f !== null ? (f.return = r, Je = f) : vk(n);
      }
    }
    function vk(n) {
      for (; Je !== null; ) {
        var r = Je;
        if (r === n) {
          Je = null;
          return;
        }
        var f = r.sibling;
        if (f !== null) {
          f.return = r.return, Je = f;
          return;
        }
        Je = r.return;
      }
    }
    function jB(n) {
      for (; Je !== null; ) {
        var r = Je, f = r.child;
        if (r.tag === se) {
          var d = r.memoizedState !== null;
          if (d) {
            yk(n);
            continue;
          }
        }
        f !== null ? (f.return = r, Je = f) : yk(n);
      }
    }
    function yk(n) {
      for (; Je !== null; ) {
        var r = Je;
        Rn(r);
        try {
          RB(r);
        } catch (d) {
          kn(r, r.return, d);
        }
        if (Wn(), r === n) {
          Je = null;
          return;
        }
        var f = r.sibling;
        if (f !== null) {
          f.return = r.return, Je = f;
          return;
        }
        Je = r.return;
      }
    }
    function BB(n, r, f, d) {
      Je = r, HB(r, n, f, d);
    }
    function HB(n, r, f, d) {
      for (; Je !== null; ) {
        var g = Je, x = g.child;
        (g.subtreeFlags & ks) !== st && x !== null ? (x.return = g, Je = x) : UB(n, r, f, d);
      }
    }
    function UB(n, r, f, d) {
      for (; Je !== null; ) {
        var g = Je;
        if ((g.flags & _r) !== st) {
          Rn(g);
          try {
            IB(r, g, f, d);
          } catch (C) {
            kn(g, g.return, C);
          }
          Wn();
        }
        if (g === n) {
          Je = null;
          return;
        }
        var x = g.sibling;
        if (x !== null) {
          x.return = g.return, Je = x;
          return;
        }
        Je = g.return;
      }
    }
    function IB(n, r, f, d) {
      switch (r.tag) {
        case m:
        case B:
        case I: {
          if (r.mode & Jt) {
            Aw();
            try {
              Fu(ur | Bi, r);
            } finally {
              Mw(r);
            }
          } else
            Fu(ur | Bi, r);
          break;
        }
      }
    }
    function $B(n) {
      Je = n, WB();
    }
    function WB() {
      for (; Je !== null; ) {
        var n = Je, r = n.child;
        if ((Je.flags & ra) !== st) {
          var f = n.deletions;
          if (f !== null) {
            for (var d = 0; d < f.length; d++) {
              var g = f[d];
              Je = g, KB(g, n);
            }
            {
              var x = n.alternate;
              if (x !== null) {
                var C = x.child;
                if (C !== null) {
                  x.child = null;
                  do {
                    var D = C.sibling;
                    C.sibling = null, C = D;
                  } while (C !== null);
                }
              }
            }
            Je = n;
          }
        }
        (n.subtreeFlags & ks) !== st && r !== null ? (r.return = n, Je = r) : YB();
      }
    }
    function YB() {
      for (; Je !== null; ) {
        var n = Je;
        (n.flags & _r) !== st && (Rn(n), GB(n), Wn());
        var r = n.sibling;
        if (r !== null) {
          r.return = n.return, Je = r;
          return;
        }
        Je = n.return;
      }
    }
    function GB(n) {
      switch (n.tag) {
        case m:
        case B:
        case I: {
          n.mode & Jt ? (Aw(), $s(ur | Bi, n, n.return), Mw(n)) : $s(ur | Bi, n, n.return);
          break;
        }
      }
    }
    function KB(n, r) {
      for (; Je !== null; ) {
        var f = Je;
        Rn(f), QB(f, r), Wn();
        var d = f.child;
        d !== null ? (d.return = f, Je = d) : XB(n);
      }
    }
    function XB(n) {
      for (; Je !== null; ) {
        var r = Je, f = r.sibling, d = r.return;
        if (ck(r), r === n) {
          Je = null;
          return;
        }
        if (f !== null) {
          f.return = d, Je = f;
          return;
        }
        Je = d;
      }
    }
    function QB(n, r) {
      switch (n.tag) {
        case m:
        case B:
        case I: {
          n.mode & Jt ? (Aw(), $s(ur, n, r), Mw(n)) : $s(ur, n, r);
          break;
        }
      }
    }
    function qB(n) {
      switch (n.tag) {
        case m:
        case B:
        case I: {
          try {
            Fu(Hi | Bi, n);
          } catch (f) {
            kn(n, n.return, f);
          }
          break;
        }
        case v: {
          var r = n.stateNode;
          try {
            r.componentDidMount();
          } catch (f) {
            kn(n, n.return, f);
          }
          break;
        }
      }
    }
    function ZB(n) {
      switch (n.tag) {
        case m:
        case B:
        case I: {
          try {
            Fu(ur | Bi, n);
          } catch (r) {
            kn(n, n.return, r);
          }
          break;
        }
      }
    }
    function JB(n) {
      switch (n.tag) {
        case m:
        case B:
        case I: {
          try {
            $s(Hi | Bi, n, n.return);
          } catch (f) {
            kn(n, n.return, f);
          }
          break;
        }
        case v: {
          var r = n.stateNode;
          typeof r.componentWillUnmount == "function" && uC(n, n.return, r);
          break;
        }
      }
    }
    function eH(n) {
      switch (n.tag) {
        case m:
        case B:
        case I:
          try {
            $s(ur | Bi, n, n.return);
          } catch (r) {
            kn(n, n.return, r);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var xg = Symbol.for;
      xg("selector.component"), xg("selector.has_pseudo_class"), xg("selector.role"), xg("selector.test_id"), xg("selector.text");
    }
    var tH = [];
    function nH() {
      tH.forEach(function(n) {
        return n();
      });
    }
    var iH = i.ReactCurrentActQueue;
    function rH(n) {
      {
        var r = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), f = typeof jest < "u";
        return f && r !== !1;
      }
    }
    function bk() {
      {
        var n = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !n && iH.current !== null && u("The current testing environment is not configured to support act(...)"), n;
      }
    }
    var aH = Math.ceil, hC = i.ReactCurrentDispatcher, pC = i.ReactCurrentOwner, hr = i.ReactCurrentBatchConfig, Gs = i.ReactCurrentActQueue, $i = (
      /*             */
      0
    ), xk = (
      /*               */
      1
    ), pr = (
      /*                */
      2
    ), ds = (
      /*                */
      4
    ), Pl = 0, Sg = 1, _f = 2, Sb = 3, _g = 4, Sk = 5, mC = 6, Ut = $i, Qr = null, ii = null, Wi = ye, Oo = ye, gC = Ru(ye), Yi = Pl, wg = null, _b = ye, Cg = ye, wb = ye, Tg = null, ga = null, vC = 0, _k = 500, wk = 1 / 0, sH = 500, Ll = null;
    function Eg() {
      wk = Si() + sH;
    }
    function Ck() {
      return wk;
    }
    var Cb = !1, yC = null, jh = null, wf = !1, ju = null, Dg = ye, bC = [], xC = null, oH = 50, Rg = 0, SC = null, _C = !1, Tb = !1, lH = 50, Bh = 0, Eb = null, kg = Sn, Db = ye, Tk = !1;
    function Rb() {
      return Qr;
    }
    function qr() {
      return (Ut & (pr | ds)) !== $i ? Si() : (kg !== Sn || (kg = Si()), kg);
    }
    function Bu(n) {
      var r = n.mode;
      if ((r & Nt) === ot)
        return gt;
      if ((Ut & pr) !== $i && Wi !== ye)
        return Ic(Wi);
      var f = ij() !== nj;
      if (f) {
        if (hr.transition !== null) {
          var d = hr.transition;
          d._updatedFibers || (d._updatedFibers = /* @__PURE__ */ new Set()), d._updatedFibers.add(n);
        }
        return Db === Zt && (Db = vm()), Db;
      }
      var g = fa();
      if (g !== Zt)
        return g;
      var x = HF();
      return x;
    }
    function uH(n) {
      var r = n.mode;
      return (r & Nt) === ot ? gt : Oy();
    }
    function Gi(n, r, f, d) {
      PH(), Tk && u("useInsertionEffect must not schedule updates."), _C && (Tb = !0), vu(n, f, d), (Ut & pr) !== ye && n === Qr ? zH(r) : (Er && Yc(n, r, f), FH(r), n === Qr && ((Ut & pr) === $i && (Cg = Mt(Cg, f)), Yi === _g && Hu(n, Wi)), va(n, d), f === gt && Ut === $i && (r.mode & Nt) === ot && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Gs.isBatchingLegacy && (Eg(), TD()));
    }
    function cH(n, r, f) {
      var d = n.current;
      d.lanes = r, vu(n, r, f), va(n, f);
    }
    function fH(n) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Ut & pr) !== $i
      );
    }
    function va(n, r) {
      var f = n.callbackNode;
      Xd(n, r);
      var d = Kd(n, n === Qr ? Wi : ye);
      if (d === ye) {
        f !== null && Hk(f), n.callbackNode = null, n.callbackPriority = Zt;
        return;
      }
      var g = go(d), x = n.callbackPriority;
      if (x === g && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Gs.current !== null && f !== kC)) {
        f == null && x !== gt && u("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      f != null && Hk(f);
      var C;
      if (g === gt)
        n.tag === ku ? (Gs.isBatchingLegacy !== null && (Gs.didScheduleLegacyUpdate = !0), jV(Rk.bind(null, n))) : CD(Rk.bind(null, n)), Gs.current !== null ? Gs.current.push(Mu) : IF(function() {
          (Ut & (pr | ds)) === $i && Mu();
        }), C = null;
      else {
        var D;
        switch (jy(d)) {
          case ir:
            D = kc;
            break;
          case ns:
            D = fo;
            break;
          case ua:
            D = Ms;
            break;
          case ca:
            D = ol;
            break;
          default:
            D = Ms;
            break;
        }
        C = MC(D, Ek.bind(null, n));
      }
      n.callbackPriority = g, n.callbackNode = C;
    }
    function Ek(n, r) {
      if (kj(), kg = Sn, Db = ye, (Ut & (pr | ds)) !== $i)
        throw new Error("Should not already be working.");
      var f = n.callbackNode, d = zl();
      if (d && n.callbackNode !== f)
        return null;
      var g = Kd(n, n === Qr ? Wi : ye);
      if (g === ye)
        return null;
      var x = !qd(n, g) && !Ay(n, g) && !r, C = x ? SH(n, g) : Mb(n, g);
      if (C !== Pl) {
        if (C === _f) {
          var D = Qd(n);
          D !== ye && (g = D, C = wC(n, D));
        }
        if (C === Sg) {
          var k = wg;
          throw Cf(n, ye), Hu(n, g), va(n, Si()), k;
        }
        if (C === mC)
          Hu(n, g);
        else {
          var L = !qd(n, g), N = n.current.alternate;
          if (L && !hH(N)) {
            if (C = Mb(n, g), C === _f) {
              var G = Qd(n);
              G !== ye && (g = G, C = wC(n, G));
            }
            if (C === Sg) {
              var W = wg;
              throw Cf(n, ye), Hu(n, g), va(n, Si()), W;
            }
          }
          n.finishedWork = N, n.finishedLanes = g, dH(n, C, g);
        }
      }
      return va(n, Si()), n.callbackNode === f ? Ek.bind(null, n) : null;
    }
    function wC(n, r) {
      var f = Tg;
      if (eh(n)) {
        var d = Cf(n, r);
        d.flags |= Sr, OV(n.containerInfo);
      }
      var g = Mb(n, r);
      if (g !== _f) {
        var x = ga;
        ga = f, x !== null && Dk(x);
      }
      return g;
    }
    function Dk(n) {
      ga === null ? ga = n : ga.push.apply(ga, n);
    }
    function dH(n, r, f) {
      switch (r) {
        case Pl:
        case Sg:
          throw new Error("Root did not complete. This is a bug in React.");
        // Flow knows about invariant, so it complains if I add a break
        // statement, but eslint doesn't know about invariant, so it complains
        // if I do. eslint-disable-next-line no-fallthrough
        case _f: {
          Tf(n, ga, Ll);
          break;
        }
        case Sb: {
          if (Hu(n, f), yl(f) && // do not delay if we're inside an act() scope
          !Uk()) {
            var d = vC + _k - Si();
            if (d > 10) {
              var g = Kd(n, ye);
              if (g !== ye)
                break;
              var x = n.suspendedLanes;
              if (!bl(x, f)) {
                qr(), Zd(n, x);
                break;
              }
              n.timeoutHandle = x_(Tf.bind(null, n, ga, Ll), d);
              break;
            }
          }
          Tf(n, ga, Ll);
          break;
        }
        case _g: {
          if (Hu(n, f), mm(f))
            break;
          if (!Uk()) {
            var C = Na(n, f), D = C, k = Si() - D, L = OH(k) - k;
            if (L > 10) {
              n.timeoutHandle = x_(Tf.bind(null, n, ga, Ll), L);
              break;
            }
          }
          Tf(n, ga, Ll);
          break;
        }
        case Sk: {
          Tf(n, ga, Ll);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function hH(n) {
      for (var r = n; ; ) {
        if (r.flags & du) {
          var f = r.updateQueue;
          if (f !== null) {
            var d = f.stores;
            if (d !== null)
              for (var g = 0; g < d.length; g++) {
                var x = d[g], C = x.getSnapshot, D = x.value;
                try {
                  if (!_e(C(), D))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var k = r.child;
        if (r.subtreeFlags & du && k !== null) {
          k.return = r, r = k;
          continue;
        }
        if (r === n)
          return !0;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === n)
            return !0;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return !0;
    }
    function Hu(n, r) {
      r = $c(r, wb), r = $c(r, Cg), Ny(n, r);
    }
    function Rk(n) {
      if (Mj(), (Ut & (pr | ds)) !== $i)
        throw new Error("Should not already be working.");
      zl();
      var r = Kd(n, ye);
      if (!Dr(r, gt))
        return va(n, Si()), null;
      var f = Mb(n, r);
      if (n.tag !== ku && f === _f) {
        var d = Qd(n);
        d !== ye && (r = d, f = wC(n, d));
      }
      if (f === Sg) {
        var g = wg;
        throw Cf(n, ye), Hu(n, r), va(n, Si()), g;
      }
      if (f === mC)
        throw new Error("Root did not complete. This is a bug in React.");
      var x = n.current.alternate;
      return n.finishedWork = x, n.finishedLanes = r, Tf(n, ga, Ll), va(n, Si()), null;
    }
    function pH(n, r) {
      r !== ye && (Jd(n, Mt(r, gt)), va(n, Si()), (Ut & (pr | ds)) === $i && (Eg(), Mu()));
    }
    function CC(n, r) {
      var f = Ut;
      Ut |= xk;
      try {
        return n(r);
      } finally {
        Ut = f, Ut === $i && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Gs.isBatchingLegacy && (Eg(), TD());
      }
    }
    function mH(n, r, f, d, g) {
      var x = fa(), C = hr.transition;
      try {
        return hr.transition = null, hi(ir), n(r, f, d, g);
      } finally {
        hi(x), hr.transition = C, Ut === $i && Eg();
      }
    }
    function Nl(n) {
      ju !== null && ju.tag === ku && (Ut & (pr | ds)) === $i && zl();
      var r = Ut;
      Ut |= xk;
      var f = hr.transition, d = fa();
      try {
        return hr.transition = null, hi(ir), n ? n() : void 0;
      } finally {
        hi(d), hr.transition = f, Ut = r, (Ut & (pr | ds)) === $i && Mu();
      }
    }
    function kk() {
      return (Ut & (pr | ds)) !== $i;
    }
    function kb(n, r) {
      Or(gC, Oo, n), Oo = Mt(Oo, r);
    }
    function TC(n) {
      Oo = gC.current, Ar(gC, n);
    }
    function Cf(n, r) {
      n.finishedWork = null, n.finishedLanes = ye;
      var f = n.timeoutHandle;
      if (f !== S_ && (n.timeoutHandle = S_, UF(f)), ii !== null)
        for (var d = ii.return; d !== null; ) {
          var g = d.alternate;
          rk(g, d), d = d.return;
        }
      Qr = n;
      var x = Ef(n.current, null);
      return ii = x, Wi = Oo = r, Yi = Pl, wg = null, _b = ye, Cg = ye, wb = ye, Tg = null, ga = null, cj(), js.discardPendingWarnings(), x;
    }
    function Mk(n, r) {
      do {
        var f = ii;
        try {
          if (j0(), eR(), Wn(), pC.current = null, f === null || f.return === null) {
            Yi = Sg, wg = r, ii = null;
            return;
          }
          if (Pe && f.mode & Jt && pb(f, !0), Me)
            if (Wr(), r !== null && typeof r == "object" && typeof r.then == "function") {
              var d = r;
              ts(f, d, Wi);
            } else
              Ac(f, r, Wi);
          jj(n, f.return, f, r, Wi), Lk(f);
        } catch (g) {
          r = g, ii === f && f !== null ? (f = f.return, ii = f) : f = ii;
          continue;
        }
        return;
      } while (!0);
    }
    function Ak() {
      var n = hC.current;
      return hC.current = ub, n === null ? ub : n;
    }
    function Ok(n) {
      hC.current = n;
    }
    function gH() {
      vC = Si();
    }
    function Mg(n) {
      _b = Mt(n, _b);
    }
    function vH() {
      Yi === Pl && (Yi = Sb);
    }
    function EC() {
      (Yi === Pl || Yi === Sb || Yi === _f) && (Yi = _g), Qr !== null && (Uc(_b) || Uc(Cg)) && Hu(Qr, Wi);
    }
    function yH(n) {
      Yi !== _g && (Yi = _f), Tg === null ? Tg = [n] : Tg.push(n);
    }
    function bH() {
      return Yi === Pl;
    }
    function Mb(n, r) {
      var f = Ut;
      Ut |= pr;
      var d = Ak();
      if (Qr !== n || Wi !== r) {
        if (Er) {
          var g = n.memoizedUpdaters;
          g.size > 0 && (Ag(n, Wi), g.clear()), zy(n, r);
        }
        Ll = Sm(), Cf(n, r);
      }
      fl(r);
      do
        try {
          xH();
          break;
        } catch (x) {
          Mk(n, x);
        }
      while (!0);
      if (j0(), Ut = f, Ok(d), ii !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Md(), Qr = null, Wi = ye, Yi;
    }
    function xH() {
      for (; ii !== null; )
        Pk(ii);
    }
    function SH(n, r) {
      var f = Ut;
      Ut |= pr;
      var d = Ak();
      if (Qr !== n || Wi !== r) {
        if (Er) {
          var g = n.memoizedUpdaters;
          g.size > 0 && (Ag(n, Wi), g.clear()), zy(n, r);
        }
        Ll = Sm(), Eg(), Cf(n, r);
      }
      fl(r);
      do
        try {
          _H();
          break;
        } catch (x) {
          Mk(n, x);
        }
      while (!0);
      return j0(), Ok(d), Ut = f, ii !== null ? (Dy(), Pl) : (Md(), Qr = null, Wi = ye, Yi);
    }
    function _H() {
      for (; ii !== null && !em(); )
        Pk(ii);
    }
    function Pk(n) {
      var r = n.alternate;
      Rn(n);
      var f;
      (n.mode & Jt) !== ot ? (kw(n), f = DC(r, n, Oo), pb(n, !0)) : f = DC(r, n, Oo), Wn(), n.memoizedProps = n.pendingProps, f === null ? Lk(n) : ii = f, pC.current = null;
    }
    function Lk(n) {
      var r = n;
      do {
        var f = r.alternate, d = r.return;
        if ((r.flags & Rc) === st) {
          Rn(r);
          var g = void 0;
          if ((r.mode & Jt) === ot ? g = ik(f, r, Oo) : (kw(r), g = ik(f, r, Oo), pb(r, !1)), Wn(), g !== null) {
            ii = g;
            return;
          }
        } else {
          var x = vB(f, r);
          if (x !== null) {
            x.flags &= Sy, ii = x;
            return;
          }
          if ((r.mode & Jt) !== ot) {
            pb(r, !1);
            for (var C = r.actualDuration, D = r.child; D !== null; )
              C += D.actualDuration, D = D.sibling;
            r.actualDuration = C;
          }
          if (d !== null)
            d.flags |= Rc, d.subtreeFlags = st, d.deletions = null;
          else {
            Yi = mC, ii = null;
            return;
          }
        }
        var k = r.sibling;
        if (k !== null) {
          ii = k;
          return;
        }
        r = d, ii = r;
      } while (r !== null);
      Yi === Pl && (Yi = Sk);
    }
    function Tf(n, r, f) {
      var d = fa(), g = hr.transition;
      try {
        hr.transition = null, hi(ir), wH(n, r, f, d);
      } finally {
        hr.transition = g, hi(d);
      }
      return null;
    }
    function wH(n, r, f, d) {
      do
        zl();
      while (ju !== null);
      if (LH(), (Ut & (pr | ds)) !== $i)
        throw new Error("Should not already be working.");
      var g = n.finishedWork, x = n.finishedLanes;
      if (sm(x), g === null)
        return om(), null;
      if (x === ye && u("root.finishedLanes should not be empty during a commit. This is a bug in React."), n.finishedWork = null, n.finishedLanes = ye, g === n.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      n.callbackNode = null, n.callbackPriority = Zt;
      var C = Mt(g.lanes, g.childLanes);
      bm(n, C), n === Qr && (Qr = null, ii = null, Wi = ye), ((g.subtreeFlags & ks) !== st || (g.flags & ks) !== st) && (wf || (wf = !0, xC = f, MC(Ms, function() {
        return zl(), null;
      })));
      var D = (g.subtreeFlags & (lo | uo | co | ks)) !== st, k = (g.flags & (lo | uo | co | ks)) !== st;
      if (D || k) {
        var L = hr.transition;
        hr.transition = null;
        var N = fa();
        hi(ir);
        var G = Ut;
        Ut |= ds, pC.current = null, _B(n, g), TR(), zB(n, g, x), NF(n.containerInfo), n.current = g, Oc(x), FB(g, n, x), Pc(), tm(), Ut = G, hi(N), hr.transition = L;
      } else
        n.current = g, TR();
      var W = wf;
      if (wf ? (wf = !1, ju = n, Dg = x) : (Bh = 0, Eb = null), C = n.pendingLanes, C === ye && (jh = null), W || Vk(n.current, !1), im(g.stateNode, d), Er && n.memoizedUpdaters.clear(), nH(), va(n, Si()), r !== null)
        for (var J = n.onRecoverableError, ie = 0; ie < r.length; ie++) {
          var ue = r[ie], Ie = ue.stack, ft = ue.digest;
          J(ue.value, {
            componentStack: Ie,
            digest: ft
          });
        }
      if (Cb) {
        Cb = !1;
        var nt = yC;
        throw yC = null, nt;
      }
      return Dr(Dg, gt) && n.tag !== ku && zl(), C = n.pendingLanes, Dr(C, gt) ? (Rj(), n === SC ? Rg++ : (Rg = 0, SC = n)) : Rg = 0, Mu(), om(), null;
    }
    function zl() {
      if (ju !== null) {
        var n = jy(Dg), r = Kc(ua, n), f = hr.transition, d = fa();
        try {
          return hr.transition = null, hi(r), TH();
        } finally {
          hi(d), hr.transition = f;
        }
      }
      return !1;
    }
    function CH(n) {
      bC.push(n), wf || (wf = !0, MC(Ms, function() {
        return zl(), null;
      }));
    }
    function TH() {
      if (ju === null)
        return !1;
      var n = xC;
      xC = null;
      var r = ju, f = Dg;
      if (ju = null, Dg = ye, (Ut & (pr | ds)) !== $i)
        throw new Error("Cannot flush passive effects while already rendering.");
      _C = !0, Tb = !1, cl(f);
      var d = Ut;
      Ut |= ds, $B(r.current), BB(r, r.current, f, n);
      {
        var g = bC;
        bC = [];
        for (var x = 0; x < g.length; x++) {
          var C = g[x];
          EB(r, C);
        }
      }
      cm(), Vk(r.current, !0), Ut = d, Mu(), Tb ? r === Eb ? Bh++ : (Bh = 0, Eb = r) : Bh = 0, _C = !1, Tb = !1, rm(r);
      {
        var D = r.current.stateNode;
        D.effectDuration = 0, D.passiveEffectDuration = 0;
      }
      return !0;
    }
    function Nk(n) {
      return jh !== null && jh.has(n);
    }
    function EH(n) {
      jh === null ? jh = /* @__PURE__ */ new Set([n]) : jh.add(n);
    }
    function DH(n) {
      Cb || (Cb = !0, yC = n);
    }
    var RH = DH;
    function zk(n, r, f) {
      var d = xf(f, r), g = PR(n, d, gt), x = Ou(n, g, gt), C = qr();
      x !== null && (vu(x, gt, C), va(x, C));
    }
    function kn(n, r, f) {
      if (bB(f), Og(!1), n.tag === S) {
        zk(n, n, f);
        return;
      }
      var d = null;
      for (d = r; d !== null; ) {
        if (d.tag === S) {
          zk(d, n, f);
          return;
        } else if (d.tag === v) {
          var g = d.type, x = d.stateNode;
          if (typeof g.getDerivedStateFromError == "function" || typeof x.componentDidCatch == "function" && !Nk(x)) {
            var C = xf(f, n), D = Gw(d, C, gt), k = Ou(d, D, gt), L = qr();
            k !== null && (vu(k, gt, L), va(k, L));
            return;
          }
        }
        d = d.return;
      }
      u(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, f);
    }
    function kH(n, r, f) {
      var d = n.pingCache;
      d !== null && d.delete(r);
      var g = qr();
      Zd(n, f), VH(n), Qr === n && bl(Wi, f) && (Yi === _g || Yi === Sb && yl(Wi) && Si() - vC < _k ? Cf(n, ye) : wb = Mt(wb, f)), va(n, g);
    }
    function Fk(n, r) {
      r === Zt && (r = uH(n));
      var f = qr(), d = pa(n, r);
      d !== null && (vu(d, r, f), va(d, f));
    }
    function MH(n) {
      var r = n.memoizedState, f = Zt;
      r !== null && (f = r.retryLane), Fk(n, f);
    }
    function AH(n, r) {
      var f = Zt, d;
      switch (n.tag) {
        case F:
          d = n.stateNode;
          var g = n.memoizedState;
          g !== null && (f = g.retryLane);
          break;
        case le:
          d = n.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      d !== null && d.delete(r), Fk(n, f);
    }
    function OH(n) {
      return n < 120 ? 120 : n < 480 ? 480 : n < 1080 ? 1080 : n < 1920 ? 1920 : n < 3e3 ? 3e3 : n < 4320 ? 4320 : aH(n / 1960) * 1960;
    }
    function PH() {
      if (Rg > oH)
        throw Rg = 0, SC = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Bh > lH && (Bh = 0, Eb = null, u("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function LH() {
      js.flushLegacyContextWarning(), js.flushPendingUnsafeLifecycleWarnings();
    }
    function Vk(n, r) {
      Rn(n), Ab(n, oo, JB), r && Ab(n, Za, eH), Ab(n, oo, qB), r && Ab(n, Za, ZB), Wn();
    }
    function Ab(n, r, f) {
      for (var d = n, g = null; d !== null; ) {
        var x = d.subtreeFlags & r;
        d !== g && d.child !== null && x !== st ? d = d.child : ((d.flags & r) !== st && f(d), d.sibling !== null ? d = d.sibling : d = g = d.return);
      }
    }
    var Ob = null;
    function jk(n) {
      {
        if ((Ut & pr) !== $i || !(n.mode & Nt))
          return;
        var r = n.tag;
        if (r !== b && r !== S && r !== v && r !== m && r !== B && r !== $ && r !== I)
          return;
        var f = kt(n) || "ReactComponent";
        if (Ob !== null) {
          if (Ob.has(f))
            return;
          Ob.add(f);
        } else
          Ob = /* @__PURE__ */ new Set([f]);
        var d = nr;
        try {
          Rn(n), u("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          d ? Rn(n) : Wn();
        }
      }
    }
    var DC;
    {
      var NH = null;
      DC = function(n, r, f) {
        var d = Gk(NH, r);
        try {
          return ZR(n, r, f);
        } catch (x) {
          if (GV() || x !== null && typeof x == "object" && typeof x.then == "function")
            throw x;
          if (j0(), eR(), rk(n, r), Gk(r, d), r.mode & Jt && kw(r), so(null, ZR, null, n, r, f), Ds()) {
            var g = Dc();
            typeof g == "object" && g !== null && g._suppressLogging && typeof x == "object" && x !== null && !x._suppressLogging && (x._suppressLogging = !0);
          }
          throw x;
        }
      };
    }
    var Bk = !1, RC;
    RC = /* @__PURE__ */ new Set();
    function zH(n) {
      if (eo && !Tj())
        switch (n.tag) {
          case m:
          case B:
          case I: {
            var r = ii && kt(ii) || "Unknown", f = r;
            if (!RC.has(f)) {
              RC.add(f);
              var d = kt(n) || "Unknown";
              u("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", d, r, r);
            }
            break;
          }
          case v: {
            Bk || (u("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), Bk = !0);
            break;
          }
        }
    }
    function Ag(n, r) {
      if (Er) {
        var f = n.memoizedUpdaters;
        f.forEach(function(d) {
          Yc(n, d, r);
        });
      }
    }
    var kC = {};
    function MC(n, r) {
      {
        var f = Gs.current;
        return f !== null ? (f.push(r), kC) : Jp(n, r);
      }
    }
    function Hk(n) {
      if (n !== kC)
        return wy(n);
    }
    function Uk() {
      return Gs.current !== null;
    }
    function FH(n) {
      {
        if (n.mode & Nt) {
          if (!bk())
            return;
        } else if (!rH() || Ut !== $i || n.tag !== m && n.tag !== B && n.tag !== I)
          return;
        if (Gs.current === null) {
          var r = nr;
          try {
            Rn(n), u(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, kt(n));
          } finally {
            r ? Rn(n) : Wn();
          }
        }
      }
    }
    function VH(n) {
      n.tag !== ku && bk() && Gs.current === null && u(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Og(n) {
      Tk = n;
    }
    var hs = null, Hh = null, jH = function(n) {
      hs = n;
    };
    function Uh(n) {
      {
        if (hs === null)
          return n;
        var r = hs(n);
        return r === void 0 ? n : r.current;
      }
    }
    function AC(n) {
      return Uh(n);
    }
    function OC(n) {
      {
        if (hs === null)
          return n;
        var r = hs(n);
        if (r === void 0) {
          if (n != null && typeof n.render == "function") {
            var f = Uh(n.render);
            if (n.render !== f) {
              var d = {
                $$typeof: ge,
                render: f
              };
              return n.displayName !== void 0 && (d.displayName = n.displayName), d;
            }
          }
          return n;
        }
        return r.current;
      }
    }
    function Ik(n, r) {
      {
        if (hs === null)
          return !1;
        var f = n.elementType, d = r.type, g = !1, x = typeof d == "object" && d !== null ? d.$$typeof : null;
        switch (n.tag) {
          case v: {
            typeof d == "function" && (g = !0);
            break;
          }
          case m: {
            (typeof d == "function" || x === Dt) && (g = !0);
            break;
          }
          case B: {
            (x === ge || x === Dt) && (g = !0);
            break;
          }
          case $:
          case I: {
            (x === ct || x === Dt) && (g = !0);
            break;
          }
          default:
            return !1;
        }
        if (g) {
          var C = hs(f);
          if (C !== void 0 && C === hs(d))
            return !0;
        }
        return !1;
      }
    }
    function $k(n) {
      {
        if (hs === null || typeof WeakSet != "function")
          return;
        Hh === null && (Hh = /* @__PURE__ */ new WeakSet()), Hh.add(n);
      }
    }
    var BH = function(n, r) {
      {
        if (hs === null)
          return;
        var f = r.staleFamilies, d = r.updatedFamilies;
        zl(), Nl(function() {
          PC(n.current, d, f);
        });
      }
    }, HH = function(n, r) {
      {
        if (n.context !== Va)
          return;
        zl(), Nl(function() {
          Pg(r, n, null, null);
        });
      }
    };
    function PC(n, r, f) {
      {
        var d = n.alternate, g = n.child, x = n.sibling, C = n.tag, D = n.type, k = null;
        switch (C) {
          case m:
          case I:
          case v:
            k = D;
            break;
          case B:
            k = D.render;
            break;
        }
        if (hs === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var L = !1, N = !1;
        if (k !== null) {
          var G = hs(k);
          G !== void 0 && (f.has(G) ? N = !0 : r.has(G) && (C === v ? N = !0 : L = !0));
        }
        if (Hh !== null && (Hh.has(n) || d !== null && Hh.has(d)) && (N = !0), N && (n._debugNeedsRemount = !0), N || L) {
          var W = pa(n, gt);
          W !== null && Gi(W, n, gt, Sn);
        }
        g !== null && !N && PC(g, r, f), x !== null && PC(x, r, f);
      }
    }
    var UH = function(n, r) {
      {
        var f = /* @__PURE__ */ new Set(), d = new Set(r.map(function(g) {
          return g.current;
        }));
        return LC(n.current, d, f), f;
      }
    };
    function LC(n, r, f) {
      {
        var d = n.child, g = n.sibling, x = n.tag, C = n.type, D = null;
        switch (x) {
          case m:
          case I:
          case v:
            D = C;
            break;
          case B:
            D = C.render;
            break;
        }
        var k = !1;
        D !== null && r.has(D) && (k = !0), k ? IH(n, f) : d !== null && LC(d, r, f), g !== null && LC(g, r, f);
      }
    }
    function IH(n, r) {
      {
        var f = $H(n, r);
        if (f)
          return;
        for (var d = n; ; ) {
          switch (d.tag) {
            case E:
              r.add(d.stateNode);
              return;
            case w:
              r.add(d.stateNode.containerInfo);
              return;
            case S:
              r.add(d.stateNode.containerInfo);
              return;
          }
          if (d.return === null)
            throw new Error("Expected to reach root first.");
          d = d.return;
        }
      }
    }
    function $H(n, r) {
      for (var f = n, d = !1; ; ) {
        if (f.tag === E)
          d = !0, r.add(f.stateNode);
        else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === n)
          return d;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === n)
            return d;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return !1;
    }
    var NC;
    {
      NC = !1;
      try {
        var Wk = Object.preventExtensions({});
      } catch {
        NC = !0;
      }
    }
    function WH(n, r, f, d) {
      this.tag = n, this.key = f, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = r, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = d, this.flags = st, this.subtreeFlags = st, this.deletions = null, this.lanes = ye, this.childLanes = ye, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !NC && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var ja = function(n, r, f, d) {
      return new WH(n, r, f, d);
    };
    function zC(n) {
      var r = n.prototype;
      return !!(r && r.isReactComponent);
    }
    function YH(n) {
      return typeof n == "function" && !zC(n) && n.defaultProps === void 0;
    }
    function GH(n) {
      if (typeof n == "function")
        return zC(n) ? v : m;
      if (n != null) {
        var r = n.$$typeof;
        if (r === ge)
          return B;
        if (r === ct)
          return $;
      }
      return b;
    }
    function Ef(n, r) {
      var f = n.alternate;
      f === null ? (f = ja(n.tag, r, n.key, n.mode), f.elementType = n.elementType, f.type = n.type, f.stateNode = n.stateNode, f._debugSource = n._debugSource, f._debugOwner = n._debugOwner, f._debugHookTypes = n._debugHookTypes, f.alternate = n, n.alternate = f) : (f.pendingProps = r, f.type = n.type, f.flags = st, f.subtreeFlags = st, f.deletions = null, f.actualDuration = 0, f.actualStartTime = -1), f.flags = n.flags & ci, f.childLanes = n.childLanes, f.lanes = n.lanes, f.child = n.child, f.memoizedProps = n.memoizedProps, f.memoizedState = n.memoizedState, f.updateQueue = n.updateQueue;
      var d = n.dependencies;
      switch (f.dependencies = d === null ? null : {
        lanes: d.lanes,
        firstContext: d.firstContext
      }, f.sibling = n.sibling, f.index = n.index, f.ref = n.ref, f.selfBaseDuration = n.selfBaseDuration, f.treeBaseDuration = n.treeBaseDuration, f._debugNeedsRemount = n._debugNeedsRemount, f.tag) {
        case b:
        case m:
        case I:
          f.type = Uh(n.type);
          break;
        case v:
          f.type = AC(n.type);
          break;
        case B:
          f.type = OC(n.type);
          break;
      }
      return f;
    }
    function KH(n, r) {
      n.flags &= ci | qn;
      var f = n.alternate;
      if (f === null)
        n.childLanes = ye, n.lanes = r, n.child = null, n.subtreeFlags = st, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null, n.selfBaseDuration = 0, n.treeBaseDuration = 0;
      else {
        n.childLanes = f.childLanes, n.lanes = f.lanes, n.child = f.child, n.subtreeFlags = st, n.deletions = null, n.memoizedProps = f.memoizedProps, n.memoizedState = f.memoizedState, n.updateQueue = f.updateQueue, n.type = f.type;
        var d = f.dependencies;
        n.dependencies = d === null ? null : {
          lanes: d.lanes,
          firstContext: d.firstContext
        }, n.selfBaseDuration = f.selfBaseDuration, n.treeBaseDuration = f.treeBaseDuration;
      }
      return n;
    }
    function XH(n, r, f) {
      var d;
      return n === k0 ? (d = Nt, r === !0 && (d |= vn, d |= en)) : d = ot, Er && (d |= Jt), ja(S, null, null, d);
    }
    function FC(n, r, f, d, g, x) {
      var C = b, D = n;
      if (typeof n == "function")
        zC(n) ? (C = v, D = AC(D)) : D = Uh(D);
      else if (typeof n == "string")
        C = E;
      else
        e: switch (n) {
          case yr:
            return Uu(f.children, g, x, r);
          case Hr:
            C = A, g |= vn, (g & Nt) !== ot && (g |= en);
            break;
          case Da:
            return QH(f, g, x, r);
          case Be:
            return qH(f, g, x, r);
          case ut:
            return ZH(f, g, x, r);
          case bi:
            return Yk(f, g, x, r);
          case On:
          // eslint-disable-next-line no-fallthrough
          case Pt:
          // eslint-disable-next-line no-fallthrough
          case Fn:
          // eslint-disable-next-line no-fallthrough
          case tr:
          // eslint-disable-next-line no-fallthrough
          case Ft:
          // eslint-disable-next-line no-fallthrough
          default: {
            if (typeof n == "object" && n !== null)
              switch (n.$$typeof) {
                case Ra:
                  C = z;
                  break e;
                case H:
                  C = P;
                  break e;
                case ge:
                  C = B, D = OC(D);
                  break e;
                case ct:
                  C = $;
                  break e;
                case Dt:
                  C = K, D = null;
                  break e;
              }
            var k = "";
            {
              (n === void 0 || typeof n == "object" && n !== null && Object.keys(n).length === 0) && (k += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var L = d ? kt(d) : null;
              L && (k += `

Check the render method of \`` + L + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (n == null ? n : typeof n) + "." + k));
          }
        }
      var N = ja(C, f, r, g);
      return N.elementType = n, N.type = D, N.lanes = x, N._debugOwner = d, N;
    }
    function VC(n, r, f) {
      var d = null;
      d = n._owner;
      var g = n.type, x = n.key, C = n.props, D = FC(g, x, C, d, r, f);
      return D._debugSource = n._source, D._debugOwner = n._owner, D;
    }
    function Uu(n, r, f, d) {
      var g = ja(M, n, d, r);
      return g.lanes = f, g;
    }
    function QH(n, r, f, d) {
      typeof n.id != "string" && u('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof n.id);
      var g = ja(j, n, d, r | Jt);
      return g.elementType = Da, g.lanes = f, g.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, g;
    }
    function qH(n, r, f, d) {
      var g = ja(F, n, d, r);
      return g.elementType = Be, g.lanes = f, g;
    }
    function ZH(n, r, f, d) {
      var g = ja(le, n, d, r);
      return g.elementType = ut, g.lanes = f, g;
    }
    function Yk(n, r, f, d) {
      var g = ja(se, n, d, r);
      g.elementType = bi, g.lanes = f;
      var x = {
        isHidden: !1
      };
      return g.stateNode = x, g;
    }
    function jC(n, r, f) {
      var d = ja(R, n, null, r);
      return d.lanes = f, d;
    }
    function JH() {
      var n = ja(E, null, null, ot);
      return n.elementType = "DELETED", n;
    }
    function eU(n) {
      var r = ja(ne, null, null, ot);
      return r.stateNode = n, r;
    }
    function BC(n, r, f) {
      var d = n.children !== null ? n.children : [], g = ja(w, d, n.key, r);
      return g.lanes = f, g.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: n.implementation
      }, g;
    }
    function Gk(n, r) {
      return n === null && (n = ja(b, null, null, ot)), n.tag = r.tag, n.key = r.key, n.elementType = r.elementType, n.type = r.type, n.stateNode = r.stateNode, n.return = r.return, n.child = r.child, n.sibling = r.sibling, n.index = r.index, n.ref = r.ref, n.pendingProps = r.pendingProps, n.memoizedProps = r.memoizedProps, n.updateQueue = r.updateQueue, n.memoizedState = r.memoizedState, n.dependencies = r.dependencies, n.mode = r.mode, n.flags = r.flags, n.subtreeFlags = r.subtreeFlags, n.deletions = r.deletions, n.lanes = r.lanes, n.childLanes = r.childLanes, n.alternate = r.alternate, n.actualDuration = r.actualDuration, n.actualStartTime = r.actualStartTime, n.selfBaseDuration = r.selfBaseDuration, n.treeBaseDuration = r.treeBaseDuration, n._debugSource = r._debugSource, n._debugOwner = r._debugOwner, n._debugNeedsRemount = r._debugNeedsRemount, n._debugHookTypes = r._debugHookTypes, n;
    }
    function tU(n, r, f, d, g) {
      this.tag = r, this.containerInfo = n, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = S_, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Zt, this.eventTimes = Wc(ye), this.expirationTimes = Wc(Sn), this.pendingLanes = ye, this.suspendedLanes = ye, this.pingedLanes = ye, this.expiredLanes = ye, this.mutableReadLanes = ye, this.finishedLanes = ye, this.entangledLanes = ye, this.entanglements = Wc(ye), this.identifierPrefix = d, this.onRecoverableError = g, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var x = this.pendingUpdatersLaneMap = [], C = 0; C < dl; C++)
          x.push(/* @__PURE__ */ new Set());
      }
      switch (r) {
        case k0:
          this._debugRootType = f ? "hydrateRoot()" : "createRoot()";
          break;
        case ku:
          this._debugRootType = f ? "hydrate()" : "render()";
          break;
      }
    }
    function Kk(n, r, f, d, g, x, C, D, k, L) {
      var N = new tU(n, r, f, D, k), G = XH(r, x);
      N.current = G, G.stateNode = N;
      {
        var W = {
          element: d,
          isDehydrated: f,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        G.memoizedState = W;
      }
      return J_(G), N;
    }
    var HC = "18.3.1";
    function nU(n, r, f) {
      var d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return an(d), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: An,
        key: d == null ? null : "" + d,
        children: n,
        containerInfo: r,
        implementation: f
      };
    }
    var UC, IC;
    UC = !1, IC = {};
    function Xk(n) {
      if (!n)
        return Va;
      var r = fu(n), f = VV(r);
      if (r.tag === v) {
        var d = r.type;
        if (To(d))
          return _D(r, d, f);
      }
      return f;
    }
    function iU(n, r) {
      {
        var f = fu(n);
        if (f === void 0) {
          if (typeof n.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var d = Object.keys(n).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + d);
        }
        var g = Cr(f);
        if (g === null)
          return null;
        if (g.mode & vn) {
          var x = kt(f) || "Component";
          if (!IC[x]) {
            IC[x] = !0;
            var C = nr;
            try {
              Rn(g), f.mode & vn ? u("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, x) : u("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, x);
            } finally {
              C ? Rn(C) : Wn();
            }
          }
        }
        return g.stateNode;
      }
    }
    function Qk(n, r, f, d, g, x, C, D) {
      var k = !1, L = null;
      return Kk(n, r, k, L, f, d, g, x, C);
    }
    function qk(n, r, f, d, g, x, C, D, k, L) {
      var N = !0, G = Kk(f, d, N, n, g, x, C, D, k);
      G.context = Xk(null);
      var W = G.current, J = qr(), ie = Bu(W), ue = Al(J, ie);
      return ue.callback = r ?? null, Ou(W, ue, ie), cH(G, ie, J), G;
    }
    function Pg(n, r, f, d) {
      nm(r, n);
      var g = r.current, x = qr(), C = Bu(g);
      jn(C);
      var D = Xk(f);
      r.context === null ? r.context = D : r.pendingContext = D, eo && nr !== null && !UC && (UC = !0, u(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, kt(nr) || "Unknown"));
      var k = Al(x, C);
      k.payload = {
        element: n
      }, d = d === void 0 ? null : d, d !== null && (typeof d != "function" && u("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d), k.callback = d);
      var L = Ou(g, k, C);
      return L !== null && (Gi(L, g, C, x), $0(L, g, C)), C;
    }
    function Pb(n) {
      var r = n.current;
      if (!r.child)
        return null;
      switch (r.child.tag) {
        case E:
          return r.child.stateNode;
        default:
          return r.child.stateNode;
      }
    }
    function rU(n) {
      switch (n.tag) {
        case S: {
          var r = n.stateNode;
          if (eh(r)) {
            var f = ky(r);
            pH(r, f);
          }
          break;
        }
        case F: {
          Nl(function() {
            var g = pa(n, gt);
            if (g !== null) {
              var x = qr();
              Gi(g, n, gt, x);
            }
          });
          var d = gt;
          $C(n, d);
          break;
        }
      }
    }
    function Zk(n, r) {
      var f = n.memoizedState;
      f !== null && f.dehydrated !== null && (f.retryLane = Ly(f.retryLane, r));
    }
    function $C(n, r) {
      Zk(n, r);
      var f = n.alternate;
      f && Zk(f, r);
    }
    function aU(n) {
      if (n.tag === F) {
        var r = jc, f = pa(n, r);
        if (f !== null) {
          var d = qr();
          Gi(f, n, r, d);
        }
        $C(n, r);
      }
    }
    function sU(n) {
      if (n.tag === F) {
        var r = Bu(n), f = pa(n, r);
        if (f !== null) {
          var d = qr();
          Gi(f, n, r, d);
        }
        $C(n, r);
      }
    }
    function Jk(n) {
      var r = Pn(n);
      return r === null ? null : r.stateNode;
    }
    var eM = function(n) {
      return null;
    };
    function oU(n) {
      return eM(n);
    }
    var tM = function(n) {
      return !1;
    };
    function lU(n) {
      return tM(n);
    }
    var nM = null, iM = null, rM = null, aM = null, sM = null, oM = null, lM = null, uM = null, cM = null;
    {
      var fM = function(n, r, f) {
        var d = r[f], g = Ni(n) ? n.slice() : Lt({}, n);
        return f + 1 === r.length ? (Ni(g) ? g.splice(d, 1) : delete g[d], g) : (g[d] = fM(n[d], r, f + 1), g);
      }, dM = function(n, r) {
        return fM(n, r, 0);
      }, hM = function(n, r, f, d) {
        var g = r[d], x = Ni(n) ? n.slice() : Lt({}, n);
        if (d + 1 === r.length) {
          var C = f[d];
          x[C] = x[g], Ni(x) ? x.splice(g, 1) : delete x[g];
        } else
          x[g] = hM(
            // $FlowFixMe number or string is fine here
            n[g],
            r,
            f,
            d + 1
          );
        return x;
      }, pM = function(n, r, f) {
        if (r.length !== f.length) {
          c("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var d = 0; d < f.length - 1; d++)
            if (r[d] !== f[d]) {
              c("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return hM(n, r, f, 0);
      }, mM = function(n, r, f, d) {
        if (f >= r.length)
          return d;
        var g = r[f], x = Ni(n) ? n.slice() : Lt({}, n);
        return x[g] = mM(n[g], r, f + 1, d), x;
      }, gM = function(n, r, f) {
        return mM(n, r, 0, f);
      }, WC = function(n, r) {
        for (var f = n.memoizedState; f !== null && r > 0; )
          f = f.next, r--;
        return f;
      };
      nM = function(n, r, f, d) {
        var g = WC(n, r);
        if (g !== null) {
          var x = gM(g.memoizedState, f, d);
          g.memoizedState = x, g.baseState = x, n.memoizedProps = Lt({}, n.memoizedProps);
          var C = pa(n, gt);
          C !== null && Gi(C, n, gt, Sn);
        }
      }, iM = function(n, r, f) {
        var d = WC(n, r);
        if (d !== null) {
          var g = dM(d.memoizedState, f);
          d.memoizedState = g, d.baseState = g, n.memoizedProps = Lt({}, n.memoizedProps);
          var x = pa(n, gt);
          x !== null && Gi(x, n, gt, Sn);
        }
      }, rM = function(n, r, f, d) {
        var g = WC(n, r);
        if (g !== null) {
          var x = pM(g.memoizedState, f, d);
          g.memoizedState = x, g.baseState = x, n.memoizedProps = Lt({}, n.memoizedProps);
          var C = pa(n, gt);
          C !== null && Gi(C, n, gt, Sn);
        }
      }, aM = function(n, r, f) {
        n.pendingProps = gM(n.memoizedProps, r, f), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var d = pa(n, gt);
        d !== null && Gi(d, n, gt, Sn);
      }, sM = function(n, r) {
        n.pendingProps = dM(n.memoizedProps, r), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var f = pa(n, gt);
        f !== null && Gi(f, n, gt, Sn);
      }, oM = function(n, r, f) {
        n.pendingProps = pM(n.memoizedProps, r, f), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var d = pa(n, gt);
        d !== null && Gi(d, n, gt, Sn);
      }, lM = function(n) {
        var r = pa(n, gt);
        r !== null && Gi(r, n, gt, Sn);
      }, uM = function(n) {
        eM = n;
      }, cM = function(n) {
        tM = n;
      };
    }
    function uU(n) {
      var r = Cr(n);
      return r === null ? null : r.stateNode;
    }
    function cU(n) {
      return null;
    }
    function fU() {
      return nr;
    }
    function dU(n) {
      var r = n.findFiberByHostInstance, f = i.ReactCurrentDispatcher;
      return pu({
        bundleType: n.bundleType,
        version: n.version,
        rendererPackageName: n.rendererPackageName,
        rendererConfig: n.rendererConfig,
        overrideHookState: nM,
        overrideHookStateDeletePath: iM,
        overrideHookStateRenamePath: rM,
        overrideProps: aM,
        overridePropsDeletePath: sM,
        overridePropsRenamePath: oM,
        setErrorHandler: uM,
        setSuspenseHandler: cM,
        scheduleUpdate: lM,
        currentDispatcherRef: f,
        findHostInstanceByFiber: uU,
        findFiberByHostInstance: r || cU,
        // React Refresh
        findHostInstancesForRefresh: UH,
        scheduleRefresh: BH,
        scheduleRoot: HH,
        setRefreshHandler: jH,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: fU,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: HC
      });
    }
    var vM = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(n) {
      console.error(n);
    };
    function YC(n) {
      this._internalRoot = n;
    }
    Lb.prototype.render = YC.prototype.render = function(n) {
      var r = this._internalRoot;
      if (r === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? u("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Nb(arguments[1]) ? u("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && u("You passed a second argument to root.render(...) but it only accepts one argument.");
        var f = r.containerInfo;
        if (f.nodeType !== li) {
          var d = Jk(r.current);
          d && d.parentNode !== f && u("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Pg(n, r, null, null);
    }, Lb.prototype.unmount = YC.prototype.unmount = function() {
      typeof arguments[0] == "function" && u("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var n = this._internalRoot;
      if (n !== null) {
        this._internalRoot = null;
        var r = n.containerInfo;
        kk() && u("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Nl(function() {
          Pg(null, n, null, null);
        }), vD(r);
      }
    };
    function hU(n, r) {
      if (!Nb(n))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      yM(n);
      var f = !1, d = !1, g = "", x = vM;
      r != null && (r.hydrate ? c("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof r == "object" && r !== null && r.$$typeof === hn && u(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), r.unstable_strictMode === !0 && (f = !0), r.identifierPrefix !== void 0 && (g = r.identifierPrefix), r.onRecoverableError !== void 0 && (x = r.onRecoverableError), r.transitionCallbacks !== void 0 && r.transitionCallbacks);
      var C = Qk(n, k0, null, f, d, g, x);
      _0(C.current, n);
      var D = n.nodeType === li ? n.parentNode : n;
      return jm(D), new YC(C);
    }
    function Lb(n) {
      this._internalRoot = n;
    }
    function pU(n) {
      n && $y(n);
    }
    Lb.prototype.unstable_scheduleHydration = pU;
    function mU(n, r, f) {
      if (!Nb(n))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      yM(n), r === void 0 && u("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var d = f ?? null, g = f != null && f.hydratedSources || null, x = !1, C = !1, D = "", k = vM;
      f != null && (f.unstable_strictMode === !0 && (x = !0), f.identifierPrefix !== void 0 && (D = f.identifierPrefix), f.onRecoverableError !== void 0 && (k = f.onRecoverableError));
      var L = qk(r, null, n, k0, d, x, C, D, k);
      if (_0(L.current, n), jm(n), g)
        for (var N = 0; N < g.length; N++) {
          var G = g[N];
          bj(L, G);
        }
      return new Lb(L);
    }
    function Nb(n) {
      return !!(n && (n.nodeType === xr || n.nodeType === Es || n.nodeType === Hp));
    }
    function Lg(n) {
      return !!(n && (n.nodeType === xr || n.nodeType === Es || n.nodeType === Hp || n.nodeType === li && n.nodeValue === " react-mount-point-unstable "));
    }
    function yM(n) {
      n.nodeType === xr && n.tagName && n.tagName.toUpperCase() === "BODY" && u("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Qm(n) && (n._reactRootContainer ? u("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : u("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var gU = i.ReactCurrentOwner, bM;
    bM = function(n) {
      if (n._reactRootContainer && n.nodeType !== li) {
        var r = Jk(n._reactRootContainer.current);
        r && r.parentNode !== n && u("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var f = !!n._reactRootContainer, d = GC(n), g = !!(d && Du(d));
      g && !f && u("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), n.nodeType === xr && n.tagName && n.tagName.toUpperCase() === "BODY" && u("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function GC(n) {
      return n ? n.nodeType === Es ? n.documentElement : n.firstChild : null;
    }
    function xM() {
    }
    function vU(n, r, f, d, g) {
      if (g) {
        if (typeof d == "function") {
          var x = d;
          d = function() {
            var W = Pb(C);
            x.call(W);
          };
        }
        var C = qk(
          r,
          d,
          n,
          ku,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          xM
        );
        n._reactRootContainer = C, _0(C.current, n);
        var D = n.nodeType === li ? n.parentNode : n;
        return jm(D), Nl(), C;
      } else {
        for (var k; k = n.lastChild; )
          n.removeChild(k);
        if (typeof d == "function") {
          var L = d;
          d = function() {
            var W = Pb(N);
            L.call(W);
          };
        }
        var N = Qk(
          n,
          ku,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          xM
        );
        n._reactRootContainer = N, _0(N.current, n);
        var G = n.nodeType === li ? n.parentNode : n;
        return jm(G), Nl(function() {
          Pg(r, N, f, d);
        }), N;
      }
    }
    function yU(n, r) {
      n !== null && typeof n != "function" && u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, n);
    }
    function zb(n, r, f, d, g) {
      bM(f), yU(g === void 0 ? null : g, "render");
      var x = f._reactRootContainer, C;
      if (!x)
        C = vU(f, r, n, g, d);
      else {
        if (C = x, typeof g == "function") {
          var D = g;
          g = function() {
            var k = Pb(C);
            D.call(k);
          };
        }
        Pg(r, C, n, g);
      }
      return Pb(C);
    }
    var SM = !1;
    function bU(n) {
      {
        SM || (SM = !0, u("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var r = gU.current;
        if (r !== null && r.stateNode !== null) {
          var f = r.stateNode._warnedAboutRefsInRender;
          f || u("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", mn(r.type) || "A component"), r.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return n == null ? null : n.nodeType === xr ? n : iU(n, "findDOMNode");
    }
    function xU(n, r, f) {
      if (u("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Lg(r))
        throw new Error("Target container is not a DOM element.");
      {
        var d = Qm(r) && r._reactRootContainer === void 0;
        d && u("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return zb(null, n, r, !0, f);
    }
    function SU(n, r, f) {
      if (u("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Lg(r))
        throw new Error("Target container is not a DOM element.");
      {
        var d = Qm(r) && r._reactRootContainer === void 0;
        d && u("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return zb(null, n, r, !1, f);
    }
    function _U(n, r, f, d) {
      if (u("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Lg(f))
        throw new Error("Target container is not a DOM element.");
      if (n == null || !$S(n))
        throw new Error("parentComponent must be a valid React Component");
      return zb(n, r, f, !1, d);
    }
    var _M = !1;
    function wU(n) {
      if (_M || (_M = !0, u("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !Lg(n))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var r = Qm(n) && n._reactRootContainer === void 0;
        r && u("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (n._reactRootContainer) {
        {
          var f = GC(n), d = f && !Du(f);
          d && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Nl(function() {
          zb(null, null, n, !1, function() {
            n._reactRootContainer = null, vD(n);
          });
        }), !0;
      } else {
        {
          var g = GC(n), x = !!(g && Du(g)), C = n.nodeType === xr && Lg(n.parentNode) && !!n.parentNode._reactRootContainer;
          x && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", C ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    qi(rU), yu(aU), By(sU), Qc(fa), _m(Fy), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && u("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), vd(TF), IS(CC, mH, Nl);
    function CU(n, r) {
      var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Nb(r))
        throw new Error("Target container is not a DOM element.");
      return nU(n, r, null, f);
    }
    function TU(n, r, f, d) {
      return _U(n, r, f, d);
    }
    var KC = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Du, bh, w0, ou, yd, CC]
    };
    function EU(n, r) {
      return KC.usingClientEntryPoint || u('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), hU(n, r);
    }
    function DU(n, r, f) {
      return KC.usingClientEntryPoint || u('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), mU(n, r, f);
    }
    function RU(n) {
      return kk() && u("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Nl(n);
    }
    var kU = dU({
      findFiberByHostInstance: ff,
      bundleType: 1,
      version: HC,
      rendererPackageName: "react-dom"
    });
    if (!kU && lt && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var wM = window.location.protocol;
      /^(https?|file):$/.test(wM) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (wM === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    xa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = KC, xa.createPortal = CU, xa.createRoot = EU, xa.findDOMNode = bU, xa.flushSync = RU, xa.hydrate = xU, xa.hydrateRoot = DU, xa.render = SU, xa.unmountComponentAtNode = wU, xa.unstable_batchedUpdates = CC, xa.unstable_renderSubtreeIntoContainer = TU, xa.version = HC, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), xa;
}
var eO;
function eW() {
  if (eO) return Zb.exports;
  eO = 1;
  function t() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
      } catch (e) {
        console.error(e);
      }
    }
  }
  return process.env.NODE_ENV === "production" ? (t(), Zb.exports = Z4()) : Zb.exports = J4(), Zb.exports;
}
var Sa = eW();
const oN = Wo(void 0), _a = (t) => t.replace(/\./g, "-"), tW = ({
  children: t,
  selectedValue: e = Yh(),
  dayFormat: i = ["일", "월", "화", "수", "목", "금", "토"],
  monthLength: a = 4,
  yearLength: o = 3,
  yearBeforeAfterLength: c = 4,
  type: u = iN.DEFAULT,
  isDisabled: h = !1,
  disabledDates: m = [],
  disabledDatesRange: v = [],
  rangeType: b = "",
  scrollEventRefs: S = void 0,
  onBlur: w = () => {
  },
  updateSelectedValue: E = () => {
  },
  className: R = "",
  style: M = {},
  ...A
}) => {
  const { selectedRange: P, setStartDateRange: z, setEndDateRange: B } = aN(), j = (He) => {
    if (P.length === 0)
      return !1;
    const Fe = _a(He);
    return new Date(_a(P[0])) <= new Date(Fe) && new Date(Fe) <= new Date(_a(P[1]));
  }, F = (He) => {
    if (P.length === 0)
      return !1;
    const [Fe, Qe] = P[0].split("."), [mt, de] = P[1].split("."), ve = `${Fe}-${Qe}`, ke = `${mt}-${de}`;
    return new Date(ve) <= new Date(_a(He)) && new Date(_a(He)) <= new Date(ke);
  }, $ = (He) => {
    if (P.length === 0)
      return !1;
    const [Fe] = P[0].split("."), [Qe] = P[1].split("."), mt = `${Fe}`, de = `${Qe}`;
    return new Date(mt) <= new Date(_a(He)) && new Date(_a(He)) <= new Date(de);
  }, I = (He) => {
    const Fe = _a(He), Qe = m.includes(He), mt = v.some((de) => {
      const [ve, ke] = de.split("~");
      if (ve.length === 0 && ke.length > 0)
        return new Date(Fe) < new Date(_a(ke));
      if (ve.length > 0 && ke.length === 0)
        return new Date(_a(ve)) < new Date(Fe);
      if (ve.length > 0 && ke.length > 0)
        return new Date(_a(ve)) < new Date(Fe) && new Date(Fe) < new Date(_a(ke));
    });
    return Qe || mt;
  }, K = (He) => {
    const Fe = _a(He);
    return v.some((Qe) => {
      const [mt, de] = Qe.split("~");
      if (mt.length === 0 && de.length > 0)
        return new Date(Fe) < /* @__PURE__ */ new Date(
          `${de.split(".")[0]}-${de.split(".")[1]}`
        );
      if (mt.length > 0 && de.length === 0)
        return /* @__PURE__ */ new Date(`${mt.split(".")[0]}-${mt.split(".")[1]}`) < new Date(Fe);
      if (mt.length > 0 && de.length > 0)
        return /* @__PURE__ */ new Date(`${mt.split(".")[0]}-${mt.split(".")[1]}`) < new Date(Fe) && new Date(Fe) < /* @__PURE__ */ new Date(`${de.split(".")[0]}-${de.split(".")[1]}`);
    });
  }, ee = (He) => {
    const Fe = _a(He);
    return v.some((Qe) => {
      const [mt, de] = Qe.split("~");
      if (mt.length === 0 && de.length > 0)
        return new Date(Fe).getFullYear() < (/* @__PURE__ */ new Date(`${de.split(".")[0]}`)).getFullYear();
      if (mt.length > 0 && de.length === 0)
        return (/* @__PURE__ */ new Date(`${mt.split(".")[0]}`)).getFullYear() < new Date(Fe).getFullYear();
      if (mt.length > 0 && de.length > 0)
        return (/* @__PURE__ */ new Date(`${mt.split(".")[0]}`)).getFullYear() < new Date(Fe).getFullYear() && new Date(Fe).getFullYear() < (/* @__PURE__ */ new Date(`${de.split(".")[0]}`)).getFullYear();
    });
  }, [ne, le] = En({
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    minusWidth: 0,
    clientWidth: 0,
    clientHeight: 0
  }), [re, se] = En(!1), Ne = () => {
    if (se(!0), ae(!1), we(!1), !pe.current)
      return;
    const { bottom: He, left: Fe, right: Qe, top: mt, width: de } = pe.current.getBoundingClientRect();
    le({
      bottom: He,
      left: Fe,
      right: Qe,
      top: mt,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight,
      minusWidth: de
    });
  }, [Ee, we] = En(!1);
  Xn(() => {
    Ee ? (window.addEventListener("click", Pe), window.addEventListener("scroll", oe), window.addEventListener("resize", Me), Array.isArray(S) && S.forEach((He) => {
      const Fe = document.querySelector(He);
      Fe instanceof HTMLElement && Fe.addEventListener("scroll", oe);
    })) : (window.removeEventListener("click", Pe), window.removeEventListener("scroll", oe), window.removeEventListener("resize", Me), Array.isArray(S) && S.forEach((He) => {
      const Fe = document.querySelector(He);
      Fe instanceof HTMLElement && Fe.removeEventListener(
        "scroll",
        oe
      );
    }));
  }, [Ee]);
  const [Oe, ae] = En(!1), me = () => {
    if (ae(!0), se(!1), we(!1), !pe.current)
      return;
    const { bottom: He, left: Fe, right: Qe, top: mt, width: de } = pe.current.getBoundingClientRect();
    le({
      bottom: He,
      left: Fe,
      right: Qe,
      top: mt,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight,
      minusWidth: de
    });
  }, pe = xn(null), Ce = xn(null), oe = () => {
    if (!pe.current)
      return;
    const { top: He, bottom: Fe, left: Qe, right: mt, width: de } = pe.current.getBoundingClientRect();
    le((ve) => ({
      ...ve,
      top: He,
      bottom: Fe,
      left: Qe,
      right: mt,
      minusWidth: de
    }));
  }, Me = () => {
    le((He) => ({
      ...He,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight
    }));
  }, Pe = (He) => {
    const Fe = He.target;
    if (!(Fe instanceof HTMLElement))
      return;
    const Qe = Fe.closest(".inp_datepicker");
    if (Qe) {
      Qe !== Ce.current && (se(!1), we(!1), ae(!1), w());
      return;
    }
    Fe.closest(".h_calendar_area") || Fe.closest(".h_calendar_month_area") || Fe.closest(".h_calendar_year_area") || (se(!1), we(!1), ae(!1), w());
  }, fe = (He) => {
    switch (b) {
      case bv.START_DATE:
        z(He);
        break;
      case bv.END_DATE:
        B(He);
        break;
    }
  }, Le = (He) => {
    if (He instanceof KeyboardEvent && He.key !== "Enter")
      return;
    const Fe = He.target;
    if (!(Fe instanceof HTMLInputElement))
      return;
    const Qe = Fe.value, mt = (/* @__PURE__ */ new Date()).getFullYear() % 100;
    switch (Qe.length) {
      // 4- 2311(2023.01.01) // 2325(2023.02.05)
      case 4:
        (() => {
          const de = Qe.toString();
          let ve = parseInt(de.slice(0, 2), 10);
          ve > mt ? ve += 1900 : ve += 2e3;
          const ke = de.slice(2, 3).padStart(2, "0"), $e = de.slice(3).padStart(2, "0");
          if (!ms(`${ve}.${ke}.${$e}`) || I(`${ve}.${ke}.${$e}`)) {
            const hn = Te;
            Tn(() => {
              Sa.flushSync(() => {
                xe("");
              }), Tn(() => {
                xe(hn), fe(hn);
              });
            });
            return;
          }
          lt(ve), _t(Number(ke)), Tn(() => {
            Sa.flushSync(() => {
              xe("");
            }), Tn(() => {
              xe(`${ve}.${ke}.${$e}`), fe(`${ve}.${ke}.${$e}`);
            });
          });
        })();
        break;
      // 5 - 23.21(2023.02.01) // 232.1(2023.02.01) // 23210(2023.02.10) // 23101(2023.01.01) // 23131(2023.01.31)
      case 5:
        (() => {
          const de = Qe.replace(/\./g, ""), ve = mt >= parseInt(de.slice(0, 2)) ? 2e3 + parseInt(de.slice(0, 2)) : 1900 + parseInt(de.slice(0, 2));
          let ke = "", $e = "";
          if (de.length === 5 ? (ke = de.slice(2, 3).toString().padStart(2, "0"), $e = de.slice(3)) : de.length === 4 && (ke = "0" + de.charAt(2), $e = "0" + de.charAt(3)), !ms(`${ve}.${ke}.${$e}`) || I(`${ve}.${ke}.${$e}`)) {
            const hn = Te;
            Tn(() => {
              Sa.flushSync(() => {
                xe("");
              }), Tn(() => {
                xe(hn), fe(hn);
              });
            });
            return;
          }
          lt(ve), _t(Number(ke)), Tn(() => {
            Sa.flushSync(() => {
              xe("");
            }), Tn(() => {
              xe(`${ve}.${ke}.${$e}`), fe(`${ve}.${ke}.${$e}`);
            });
          });
        })();
        break;
      // 6 - 202321(2023.02.01) // 23.2.1(2023.02.01) // 23.210(2023.02.10) // 232.10(2023.02.10)
      case 6:
        (() => {
          let de = "", ve = "", ke = "";
          if (Qe.includes(".")) {
            const $e = Qe.replace(/\./g, "");
            de = mt >= parseInt($e.slice(0, 2)) ? (2e3 + parseInt($e.slice(0, 2))).toString() : (1900 + parseInt($e.slice(0, 2))).toString(), ve = $e.slice(2, 3).toString().padStart(2, "0"), ke = $e.slice(3).toString().padStart(2, "0");
          } else
            de = Qe.slice(0, 2), ve = Qe.slice(2, 4).toString().padStart(2, "0"), ke = Qe.slice(4, 6).toString().padStart(2, "0"), ms(`${de}.${ve}.${ke}`) || (de = `${de}${ve}`, ve = ke.toString().split("")[0].padStart(2, "0"), ke = ke.toString().split("")[1].padStart(2, "0"));
          if (!ms(`${de}.${ve}.${ke}`) || I(`${de}.${ve}.${ke}`)) {
            const $e = Te;
            Tn(() => {
              Sa.flushSync(() => {
                xe("");
              }), Tn(() => {
                xe($e), fe($e);
              });
            });
            return;
          }
          lt(Number(de)), _t(Number(ve)), Tn(() => {
            Sa.flushSync(() => {
              xe("");
            }), Tn(() => {
              xe(`${de}.${ve}.${ke}`), fe(`${de}.${ve}.${ke}`);
            });
          });
        })();
        break;
      // 7 - 20232.1(2023.02.01) // 2023.21(2023.02.01) // 20.0511(2020.05.11) // 2023201(2023.02.01) // 2023101(2023.01.01) // 2023130(2023.01.30)
      case 7:
        (() => {
          let de = "", ve = "", ke = "";
          if (Qe.includes(".")) {
            const $e = Qe.replace(/\./g, "");
            de = mt >= parseInt($e.slice(0, 2)) ? (2e3 + parseInt($e.slice(0, 2))).toString() : (1900 + parseInt($e.slice(0, 2))).toString(), ve = $e.slice(2, 4).padStart(2, "0"), ke = $e.slice(4, 6).padStart(2, "0"), ms(`${de}.${ve}.${ke}`) || (de = `${de.slice(2)}${ve}`, ve = `${ke.split("")[0].padStart(2, "0")}`, ke = `${ke.split("")[1].padStart(2, "0")}`);
          } else
            de = Qe.slice(0, 4), ve = Qe.slice(4, 5).toString().padStart(2, "0"), ke = Qe.slice(5).toString().padStart(2, "0");
          if (!ms(`${de}.${ve}.${ke}`) || I(`${de}.${ve}.${ke}`)) {
            const $e = Te;
            Tn(() => {
              Sa.flushSync(() => {
                xe("");
              }), Tn(() => {
                xe($e), fe($e);
              });
            });
            return;
          }
          lt(Number(de)), _t(Number(ve)), Tn(() => {
            Sa.flushSync(() => {
              xe("");
            }), Tn(() => {
              xe(`${de}.${ve}.${ke}`), fe(`${de}.${ve}.${ke}`);
            });
          });
        })();
        break;
      // 8 - 20230212(2023.02.12) // 2023.2.1(2023.02.01) // 20.02.05(2020.02.05) // 2023.021(2023.02.01) // 20232.11(2023.02.11)
      case 8:
        (() => {
          let de = "", ve = "", ke = "";
          if (Qe.includes(".")) {
            const $e = Qe.replace(/\./g, "");
            $e.length === 6 ? (de = mt >= parseInt($e.slice(0, 2)) ? (2e3 + parseInt(
              $e.slice(0, 2)
            )).toString() : (1900 + parseInt(
              $e.slice(0, 2)
            )).toString(), ve = $e.slice(2, 4).padStart(2, "0"), ke = $e.slice(4, 6).padStart(2, "0"), ms(`${de}.${ve}.${ke}`) || (de = `${de.slice(2)}${ve}`, ve = `${ke.split("")[0].padStart(2, "0")}`, ke = `${ke.split("")[1].padStart(2, "0")}`)) : (de = $e.slice(0, 4), ve = $e.slice(4, 5).padStart(2, "0"), ke = $e.slice(5).padStart(2, "0"), ms(`${de}.${ve}.${ke}`) || (ve = ke.split("")[0].padStart(2, "0"), ke = ke.split("")[1].padStart(2, "0")));
          } else
            de = Qe.slice(0, 4), ve = Qe.slice(4, 6), ke = Qe.slice(6, 8);
          if (!ms(`${de}.${ve}.${ke}`) || I(`${de}.${ve}.${ke}`)) {
            const $e = Te;
            Tn(() => {
              Sa.flushSync(() => {
                xe("");
              }), Tn(() => {
                xe($e), fe($e);
              });
            });
            return;
          }
          lt(Number(de)), _t(Number(ve)), Tn(() => {
            Sa.flushSync(() => {
              xe("");
            }), Tn(() => {
              xe(`${de}.${ve}.${ke}`), fe(`${de}.${ve}.${ke}`);
            });
          });
        })();
        break;
      // 9 - 2023.02.1(2023.02.01) // 2023.0212(2023.02.12) // 202302.12(2023.02.12) // 2023.2.11(2023.02.11) // 2023.02.1(2023.02.01) // 2023.19.1(2023.09.01)
      case 9:
        (() => {
          let de = "", ve = "", ke = "";
          if (Qe.includes(".")) {
            const $e = Qe.replace(/\./g, "");
            if (de = $e.slice(0, 4), ve = $e.slice(4, 5).padStart(2, "0"), ke = $e.slice(5).padStart(2, "0"), !ms(`${de}.${ve}.${ke}`)) {
              const [hn, ...An] = ke.split("");
              ve = hn.padStart(2, "0"), ke = An.join("").padStart(2, "0");
            }
          }
          if (!ms(`${de}.${ve}.${ke}`) || I(`${de}.${ve}.${ke}`)) {
            const $e = Te;
            Tn(() => {
              Sa.flushSync(() => {
                xe("");
              }), Tn(() => {
                xe($e), fe($e);
              });
            });
            return;
          }
          lt(Number(de)), _t(Number(ve)), Tn(() => {
            Sa.flushSync(() => {
              xe("");
            }), Tn(() => {
              xe(`${de}.${ve}.${ke}`), fe(`${de}.${ve}.${ke}`);
            });
          });
        })();
        break;
      // 10 - 2023.02.12
      case 10:
      default:
        (() => {
          if (!ms(Qe) || I(Qe)) {
            const $e = Te;
            Tn(() => {
              Sa.flushSync(() => {
                xe("");
              }), Tn(() => {
                xe($e), fe($e);
              });
            });
            return;
          }
          const [de, ve, ke] = Qe.split(".");
          lt(Number(de)), _t(Number(ve)), Tn(() => {
            Sa.flushSync(() => {
              xe("");
            }), Tn(() => {
              xe(`${de}.${ve}.${ke}`), fe(`${de}.${ve}.${ke}`);
            });
          });
        })();
        break;
    }
  }, [Te, xe] = En(e);
  Xn(() => {
    xe(e);
  }, [e]);
  const it = (He) => {
    xe(He), we(!1), ae(!1), se(!1), E(He);
  }, [dt, lt] = En(
    Number(Te == null ? void 0 : Te.split(".")[0]) || (/* @__PURE__ */ new Date()).getFullYear()
  ), [St, _t] = En(
    Number(Te == null ? void 0 : Te.split(".")[1]) || (/* @__PURE__ */ new Date()).getMonth() + 1
  ), rt = (He) => {
    const Fe = St + He;
    Fe > 12 ? (_t(1), lt((Qe) => Qe + 1)) : Fe < 1 ? (_t(12), lt((Qe) => Qe - 1)) : _t(Fe);
  }, [xt, Wt] = En(dt), an = (He) => {
    Wt((Fe) => Fe + He);
  }, [sn, Yt] = En(dt), [Gt, Ot] = En(sn - c), [wt, Kt] = En(sn + c), wn = (He) => {
    Ot((Fe) => Fe + He), Kt((Fe) => Fe + He);
  };
  Xn(() => {
    Wt(dt), Yt(dt);
  }, [dt]);
  const Mn = () => {
    Ce.current && (Ce.current.addEventListener(
      "keyup",
      Le
    ), Ce.current.addEventListener(
      "blur",
      Le
    ));
  }, oi = () => {
    Ce.current && (Ce.current.removeEventListener(
      "keyup",
      Le
    ), Ce.current.removeEventListener(
      "blur",
      Le
    ));
  }, Pi = () => {
    if (Ee || Oe || re)
      switch (!0) {
        case Ee:
          we(!0), ae(!1), se(!1);
          break;
        case Oe:
          we(!1), ae(!0), se(!1);
          break;
        case re:
          we(!1), ae(!1), se(!0);
          break;
      }
    else
      we(!0), ae(!1), se(!1);
    if (!pe.current)
      return;
    const { bottom: He, left: Fe, right: Qe, top: mt, width: de } = pe.current.getBoundingClientRect();
    le({
      bottom: He,
      left: Fe,
      right: Qe,
      top: mt,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight,
      minusWidth: de
    });
  }, Ei = (() => {
    const [He, Fe] = Yh().split("."), mt = Array.from({ length: 12 }, (ve, ke) => ke + 1).map((ve) => {
      var ke, $e, hn, An;
      return {
        year: String(xt),
        month: String(ve),
        isActive: Number(Te.split(".")[0]) === xt && St === ve,
        inRange: F(
          `${String(xt)}.${String(
            ve
          ).padStart(2, "0")}`
        ),
        isDisabled: K(
          `${String(xt)}.${String(
            ve
          ).padStart(2, "0")}`
        ),
        isCurrentMonth: xt === Number(He) && ve === Number(Fe),
        isStartMonth: Number((ke = P[0]) == null ? void 0 : ke.split(".")[0]) === xt && Number(($e = P[0]) == null ? void 0 : $e.split(".")[1]) === ve,
        isEndMonth: Number((hn = P[1]) == null ? void 0 : hn.split(".")[0]) === xt && Number((An = P[1]) == null ? void 0 : An.split(".")[1]) === ve
      };
    }), de = [];
    for (let ve = 0; ve < mt.length; ve += a)
      de.push(mt.slice(ve, ve + a));
    return de;
  })(), ze = Zs(() => c * 2 + 1, [c]), Et = (() => {
    const [He] = Yh().split("."), Fe = [];
    for (let de = Gt; de <= wt; de++)
      Fe.push(de);
    const Qe = Fe.map((de) => {
      var ve, ke;
      return {
        year: String(de),
        isActive: Number(Te.split(".")[0]) === de,
        inRange: $(String(de)),
        // Todo
        isDisabled: ee(String(de)),
        isCurrentYear: de === Number(He),
        isStartYear: Number((ve = P[0]) == null ? void 0 : ve.split(".")[0]) === de,
        isEndYear: Number((ke = P[1]) == null ? void 0 : ke.split(".")[0]) === de
      };
    }), mt = [];
    for (let de = 0; de < Qe.length; de += o)
      mt.push(Qe.slice(de, de + o));
    return mt;
  })(), ln = ((He, Fe) => {
    var Da, Ra, H, ge, Be, ut;
    const [Qe, mt, de] = Yh().split("."), [ve, ke, $e] = (Te == null ? void 0 : Te.split(".")) || [null, null, null], hn = Number(ve) === He && Number(ke) === Fe, An = new Date(He, Fe, 0).getDate(), yr = [];
    let Hr = Array(7).fill(null);
    for (let ct = 1; ct <= An; ct++) {
      const Pt = new Date(He, Fe - 1, ct).getDay();
      Hr[Pt] = {
        year: String(He),
        month: String(Fe).padStart(2, "0"),
        date: String(ct),
        isActive: hn && Number($e) === ct,
        inRange: j(
          `${String(He)}.${String(Fe).padStart(
            2,
            "0"
          )}.${String(ct).padStart(2, "0")}`
        ),
        isDisabled: I(
          `${String(He)}.${String(Fe).padStart(
            2,
            "0"
          )}.${String(ct).padStart(2, "0")}`
        ),
        isCurrentDate: Number(Qe) === He && Number(mt) === Fe && Number(de) === ct,
        isStartDate: Number((Da = P[0]) == null ? void 0 : Da.split(".")[0]) === He && Number((Ra = P[0]) == null ? void 0 : Ra.split(".")[1]) === Fe && Number((H = P[0]) == null ? void 0 : H.split(".")[2]) === ct,
        isEndDate: Number((ge = P[1]) == null ? void 0 : ge.split(".")[0]) === He && Number((Be = P[1]) == null ? void 0 : Be.split(".")[1]) === Fe && Number((ut = P[1]) == null ? void 0 : ut.split(".")[2]) === ct
      }, (Pt === 6 || ct === An) && (yr.push(Hr), Hr = Array(7).fill(null));
    }
    return yr;
  })(dt, St), dn = (He) => {
    const [Fe, Qe] = He.split(".");
    lt(Number(Fe)), _t(Number(Qe)), ae(!1), se(!1), we(!0);
  }, gn = (He) => {
    lt(Number(He)), se(!1), ae(!0), we(!1);
  }, zn = xn(null), on = xn(null), jt = xn(null), Qt = Zs(() => h, [h]), Di = {
    selectedDatePickerValue: Te,
    clickedDatePickerInput: Pi,
    updateSelectedDatePickerValue: it,
    // setSelectedDatePickerValue
    updateNowMonth: rt,
    // setNowMonth
    updateYearForYearCalendar: wn,
    // setYearForYearCalendar
    updateYearForMonthCalendar: an,
    // setYearForMonthCalendar
    yearsArrLength: ze,
    updateIsActiveYearCalendar: Ne,
    // setIsActiveYearCalendar
    updateIsActiveMonthCalendar: me,
    // setIsActiveMonthCalendar
    setNowMonthByMonthCalendar: dn,
    setNowYearByYearCalendar: gn,
    calendarInputButtonRef: Ce,
    // calendarInput
    calendarInputAreaRef: pe,
    // calendarInputArea
    calendarPosition: ne,
    calendarAreaRef: zn,
    // calendarArea
    calendarMonthAreaRef: on,
    // calendarMonthArea
    calendarYearAreaRef: jt,
    // calendarYearArea
    type: u,
    // calendarType
    focusInDatePickerInput: Mn,
    focusOutDatePickerInput: oi,
    rangeType: b,
    isDisabledValue: Qt
    // isDisabled
  }, yi = () => {
    se(!1), ae(!1), we(!1);
  };
  return /* @__PURE__ */ Ae.jsx(oN.Provider, { value: Di, children: /* @__PURE__ */ Ae.jsx("div", { className: `h_single_datepicker_area ${u} ${R}`, style: M, ...A, children: t({
    isActiveCalendar: Ee,
    isActiveMonthCalendar: Oe,
    isActiveYearCalendar: re,
    dayFormat: i,
    monthDates: ln,
    nowYear: dt,
    nowMonth: St,
    months: Ei,
    years: Et,
    startYear: Gt,
    endYear: wt,
    yearForYearCalendar: sn,
    yearForMonthCalendar: xt,
    closeAllCalendar: yi
  }) }) });
};
tW.displayName = "HSingleDatePickerArea";
const Xi = () => {
  const t = Oi(oN);
  if (!t)
    throw new Error("useHSingleDatePickerAreaContext must be used within a HSingleDatePickerAreaProvider");
  return t;
}, nW = ({
  children: t,
  childrenTableHead: e,
  className: i = "",
  tableClassName: a = "",
  tableHeadClassName: o = "",
  tableBodyClassName: c = "",
  style: u = {},
  ...h
}) => {
  const { type: m } = Xi();
  return /* @__PURE__ */ Ae.jsx("div", { className: `h_calendar ${m} ${i}`, style: u, ...h, children: /* @__PURE__ */ Ae.jsxs("table", { className: `h_calendar_table ${a}`, children: [
    /* @__PURE__ */ Ae.jsx("caption", { children: /* @__PURE__ */ Ae.jsx("span", { className: "blind", children: "Dates" }) }),
    /* @__PURE__ */ Ae.jsx("thead", { className: `calendar_head ${o}`, children: e }),
    /* @__PURE__ */ Ae.jsx("tbody", { className: `calendar_body ${c}`, children: t })
  ] }) });
};
nW.displayName = "HSingleDatePickerCalendar";
const iW = ({
  value: t,
  children: e,
  className: i = "",
  style: a = {},
  disabled: o = !1
}) => {
  const { type: c, updateSelectedDatePickerValue: u, rangeType: h } = Xi(), { setStartDateRange: m, setEndDateRange: v } = aN(), b = () => {
    switch (u(t), h) {
      case bv.START_DATE:
        m(t);
        break;
      case bv.END_DATE:
        v(t);
        break;
    }
  };
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_common ${c} ${i}`,
      style: a,
      onClick: b,
      disabled: o,
      children: e
    }
  );
};
iW.displayName = "HSingleDatePickerCalendarDateButton";
const rW = ({
  children: t,
  className: e = "",
  style: i = {},
  ...a
}) => {
  const { type: o, calendarPosition: c, calendarAreaRef: u } = Xi(), [h, m] = En({});
  return Xn(() => {
    if (!c)
      return;
    const {
      bottom: v,
      left: b,
      right: S,
      top: w,
      clientWidth: E,
      clientHeight: R,
      minusWidth: M
    } = c;
    if (!u.current)
      return;
    const { height: A, width: P } = u.current.getBoundingClientRect();
    m({
      position: "fixed",
      zIndex: "220",
      ...KE(w, v, A, R),
      ...XE(b, S, P, E, M)
    });
  }, [c, u]), /* @__PURE__ */ Ae.jsx(
    "div",
    {
      ref: u,
      className: `h_calendar_area ${o} ${e}`,
      style: {
        position: "fixed",
        ...i,
        ...h
      },
      ...a,
      children: t
    }
  );
};
rW.displayName = "HSingleDatePickerCalendarArea";
const aW = ({
  children: t,
  className: e = "",
  style: i = {},
  ...a
}) => {
  const { type: o, calendarPosition: c, calendarMonthAreaRef: u } = Xi(), [h, m] = En({});
  return Xn(() => {
    if (!c)
      return;
    const {
      bottom: v,
      left: b,
      right: S,
      top: w,
      clientWidth: E,
      clientHeight: R,
      minusWidth: M
    } = c;
    if (!u.current)
      return;
    const { height: A, width: P } = u.current.getBoundingClientRect();
    m({
      position: "fixed",
      zIndex: "220",
      ...KE(w, v, A, R),
      ...XE(b, S, P, E, M)
    });
  }, [c, u]), /* @__PURE__ */ Ae.jsx(
    "div",
    {
      ref: u,
      className: `h_calendar_month_area ${o} ${e}`,
      style: {
        position: "fixed",
        ...i,
        ...h
      },
      ...a,
      children: t
    }
  );
};
aW.displayName = "HSingleDatePickerCalendarMonthArea";
const sW = ({
  children: t,
  className: e = "",
  tableClassName: i = "",
  style: a = {},
  childrenTableHead: o
}) => {
  const { type: c } = Xi();
  return /* @__PURE__ */ Ae.jsx("div", { className: `h_calendar_month ${c} ${e}`, style: a, children: /* @__PURE__ */ Ae.jsxs("table", { className: `h_calendar_month_table ${i}`, children: [
    /* @__PURE__ */ Ae.jsx("caption", { children: /* @__PURE__ */ Ae.jsx("span", { className: "blind", children: "Months" }) }),
    /* @__PURE__ */ Ae.jsx("thead", { children: o }),
    /* @__PURE__ */ Ae.jsx("tbody", { children: t })
  ] }) });
};
sW.displayName = "HSingleDatePickerCalendarMonth";
const oW = ({
  children: t,
  className: e = "",
  style: i = {},
  disabled: a = !1
}) => {
  const { type: o, updateIsActiveMonthCalendar: c } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_month ${o} ${e}`,
      onClick: c,
      style: i,
      disabled: a,
      children: t
    }
  );
};
oW.displayName = "HSingleDatePickerMonthButton";
const lW = ({
  value: t,
  children: e,
  className: i = "",
  style: a = {},
  disabled: o = !1
}) => {
  const { type: c, setNowMonthByMonthCalendar: u } = Xi(), h = () => {
    u(t);
  };
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_common ${c} ${i}`,
      onClick: h,
      disabled: o,
      style: a,
      children: e
    }
  );
};
lW.displayName = "HSingleDatePickerCalendarMonthButton";
const uW = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAZCAYAAAABmx/yAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADBSURBVHgBvdSxCQMhFABQFQS73Ai3QWa4USytQkbIBukUG0dJRsgIN4KlWEjUIuRyen4t8kH8IE8E//8I/SOMMZPW+pJy3IO898+YnuO6guAPWkMISxOWkBBixSMoneERVIUtVIQQtINQtIE96AN7UYYjKAVxzk1xP+VbMLaMMYsAkZ8qpZwJIY+YzhG/KKUL59w24QjefEcP3hUAFBdLDoKrRd7Ch211hJuNXMOg0VHC4GH1jWNZ3lBPJKyUuqf8DUy8w9O6XZwQAAAAAElFTkSuQmCC", iS = () => /* @__PURE__ */ Ae.jsx("span", { children: /* @__PURE__ */ Ae.jsx("img", { src: uW, alt: "왼쪽 화살표" }) });
iS.displayName = "IconArrowLeft";
const cW = ({
  children: t,
  className: e = "",
  style: i = {}
}) => {
  const { type: a, updateYearForMonthCalendar: o } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_month_prev ${a} ${e}`,
      onClick: () => o(-1),
      style: i,
      children: t || a === "type1" && /* @__PURE__ */ Ae.jsx(iS, {})
    }
  );
};
cW.displayName = "HSingleDatePickerMonthPrevButton";
const fW = ({
  children: t,
  childrenTableHead: e,
  childrenTableBody: i,
  className: a = "",
  tableClassName: o = "",
  style: c = {}
}) => {
  const { type: u } = Xi();
  return /* @__PURE__ */ Ae.jsxs("div", { className: `h_calendar_year ${u} ${a}`, style: c, children: [
    t,
    /* @__PURE__ */ Ae.jsxs("table", { className: `h_calendar_year_table ${o}`, children: [
      /* @__PURE__ */ Ae.jsx("caption", { children: /* @__PURE__ */ Ae.jsx("span", { className: "blind", children: "Years" }) }),
      /* @__PURE__ */ Ae.jsx("thead", { children: e }),
      /* @__PURE__ */ Ae.jsx("tbody", { children: i })
    ] })
  ] });
};
fW.displayName = "HSingleDatePickerCalendarYear";
const dW = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAZCAYAAAABmx/yAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAC+SURBVHgBpdS9FcIgEADgHEVqR8gIruAGjiAllRnFCh40uIEjZIWMkBHseQ88LfKi8nOnFBx3730cDdd1/yzn3NkYM3CMsNaOKaWLEGLiYNH3/RUAZjwPHAzPzXu/CyFM2HmP6RJjPCillib8BcM24WD4LFAx5G6j4Cyk4CJs4Sqs4SYsYUGBUso7hnlbI3XET+Cx24n11BxqdiyhKqyhImyhLKSgL0hFb5CDVshFL4jD6ojxxkHr0lqP3PH4AAMhEevOZzQ6AAAAAElFTkSuQmCC", rS = () => /* @__PURE__ */ Ae.jsx("span", { children: /* @__PURE__ */ Ae.jsx("img", { src: dW, alt: "오른쪽 화살표" }) });
rS.displayName = "IconArrowRight";
const hW = ({
  children: t,
  className: e = "",
  style: i = {},
  disabled: a = !1
}) => {
  const { type: o, updateNowMonth: c } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_next ${o} ${e}`,
      disabled: a,
      onClick: () => c(1),
      style: i,
      children: t || o === "type1" && /* @__PURE__ */ Ae.jsx(rS, {})
    }
  );
};
hW.displayName = "HSingleDatePickerNextButton";
const pW = ({
  children: t,
  className: e = "",
  style: i = {},
  disabled: a = !1
}) => {
  const { type: o, updateNowMonth: c } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_prev ${o} ${e}`,
      disabled: a,
      onClick: () => c(-1),
      style: i,
      children: t || o === "type1" && /* @__PURE__ */ Ae.jsx(iS, {})
    }
  );
};
pW.displayName = "HSingleDatePickerPrevButton";
const mW = ({
  children: t,
  className: e = "",
  style: i = {},
  ...a
}) => {
  const { calendarYearAreaRef: o, type: c, calendarPosition: u } = Xi(), [h, m] = En({});
  return Xn(() => {
    if (!u)
      return;
    const {
      bottom: v,
      left: b,
      right: S,
      top: w,
      clientWidth: E,
      clientHeight: R,
      minusWidth: M
    } = u;
    if (!o.current)
      return;
    const { height: A, width: P } = o.current.getBoundingClientRect();
    m({
      position: "fixed",
      zIndex: "220",
      ...KE(w, v, A, R),
      ...XE(b, S, P, E, M)
    });
  }, [u, o]), /* @__PURE__ */ Ae.jsx(
    "div",
    {
      ref: o,
      className: `h_calendar_year_area ${c} ${e}`,
      style: {
        position: "fixed",
        ...i,
        ...h
      },
      ...a,
      children: t
    }
  );
};
mW.displayName = "HSingleDatePickerCalendarYearArea";
const gW = ({
  children: t,
  className: e = "",
  style: i = {},
  disabled: a = !1
}) => {
  const { type: o, updateIsActiveYearCalendar: c } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_year ${o} ${e}`,
      onClick: c,
      style: i,
      disabled: a,
      children: t
    }
  );
};
gW.displayName = "HSingleDatePickerYearButton";
const vW = ({
  children: t,
  className: e = "",
  style: i = {}
}) => {
  const { type: a, updateYearForYearCalendar: o, yearsArrLength: c } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_year_next ${a} ${e}`,
      onClick: () => o(c),
      style: i,
      children: t || a === "type1" && /* @__PURE__ */ Ae.jsx(rS, {})
    }
  );
};
vW.displayName = "HSingleDatePickerYearNextButton";
const yW = ({
  children: t,
  className: e = "",
  value: i,
  disabled: a = !1,
  style: o = {}
}) => {
  const { type: c, setNowYearByYearCalendar: u } = Xi(), h = () => {
    u(i);
  };
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_common ${c} ${e}`,
      onClick: h,
      disabled: a,
      style: o,
      children: t
    }
  );
};
yW.displayName = "HSingleDatePickerCalendarYearButton";
const lN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFgSURBVHgB7ZnRbYNADIZ9iAceM8J1g3aDdJL2CcRTlQ3aEfqE4KXqBO0G7QbpBmUEFgDii4gURbkAZ0cOkj/pMNKPJf9wdzIAoCiKokhRluW/GxAINd8RAw0LNCwQiWDhGJ9QVdULhue+71fgxw6xhjDsWL4xpsEa3rIs+z6ne6cQJr1iuFT8uUJCseCvw4UPHPMMwFA83oGHtm2bU7HrulUcx9vh/A5mMiX/6BrvjRxdxGma/vk03EH2Mc/zGgKYkn+4xsfiFzF1G62BRg1ESAZwjj4mSdJAINR8B8lA6Nznyncsfg2oAWnUgDRqQBoWA9h633NrUyEbwGbrC1veLRbzw6XNgeMJrN0Bi1kzapMhG8B+ZoPvDL94uuHSWMBH3LsBwozVobuQNGpAGjUgjRqQRg1IM/pZhfoD4tp4DWCz9RlF0RMw/ISggh3ru08zlxKLorBwA3B8AFMU5UbZAevho9IdayVBAAAAAElFTkSuQmCC";
var gr = [];
for (var cT = 0; cT < 256; ++cT)
  gr.push((cT + 256).toString(16).slice(1));
function bW(t, e = 0) {
  return (gr[t[e + 0]] + gr[t[e + 1]] + gr[t[e + 2]] + gr[t[e + 3]] + "-" + gr[t[e + 4]] + gr[t[e + 5]] + "-" + gr[t[e + 6]] + gr[t[e + 7]] + "-" + gr[t[e + 8]] + gr[t[e + 9]] + "-" + gr[t[e + 10]] + gr[t[e + 11]] + gr[t[e + 12]] + gr[t[e + 13]] + gr[t[e + 14]] + gr[t[e + 15]]).toLowerCase();
}
var ex, xW = new Uint8Array(16);
function SW() {
  if (!ex && (ex = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !ex))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return ex(xW);
}
var _W = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const tO = {
  randomUUID: _W
};
function wW(t, e, i) {
  if (tO.randomUUID && !t)
    return tO.randomUUID();
  t = t || {};
  var a = t.random || (t.rng || SW)();
  return a[6] = a[6] & 15 | 64, a[8] = a[8] & 63 | 128, bW(a);
}
function nO() {
  return wW();
}
const uN = ({ className: t }) => /* @__PURE__ */ Ae.jsx("img", { src: lN, alt: "달력 이미지", className: t });
uN.displayName = "IconCalendar";
const CW = ({
  reactiveImage: t = !1,
  placeholder: e = "",
  className: i = "",
  inputClassName: a = "",
  iconClassName: o = "",
  style: c = {},
  inputName: u = "",
  ...h
}) => {
  const {
    calendarInputAreaRef: m,
    calendarInputButtonRef: v,
    type: b,
    selectedDatePickerValue: S,
    clickedDatePickerInput: w,
    focusInDatePickerInput: E,
    focusOutDatePickerInput: R,
    isDisabledValue: M,
    updateSelectedDatePickerValue: A
  } = Xi(), [P, z] = En(nO());
  return Xn(() => {
    z(nO()), A(S);
  }, [S]), /* @__PURE__ */ Ae.jsxs(
    "div",
    {
      ref: m,
      className: `h_inp_datepicker_area ${b} ${i}`,
      style: c,
      ...h,
      children: [
        t ? /* @__PURE__ */ Ae.jsx("img", { className: `icon_calendar ${o}`, src: lN, alt: "달력 이미지" }) : b === "type1" && /* @__PURE__ */ Ae.jsx(uN, { className: o }),
        /* @__PURE__ */ Ae.jsx(
          "input",
          {
            id: P,
            ref: v,
            type: "text",
            className: `inp_datepicker ${a}`,
            defaultValue: S,
            disabled: M,
            placeholder: e,
            onClick: w,
            onKeyUp: E,
            onBlur: R,
            onChange: () => {
            },
            name: u
          },
          P
        )
      ]
    }
  );
};
CW.displayName = "HSingleDatePickerInput";
const TW = ({
  children: t,
  className: e = "",
  style: i = {}
}) => {
  const { type: a, updateYearForMonthCalendar: o } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_month_next ${a} ${e}`,
      onClick: () => o(1),
      style: i,
      children: t || a === "type1" && /* @__PURE__ */ Ae.jsx(rS, {})
    }
  );
};
TW.displayName = "HSingleDatePickerMonthNextButton";
const EW = ({ children: t, className: e = "", style: i = {} }) => {
  const { type: a, updateIsActiveYearCalendar: o } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_year_in_month ${a} ${e}`,
      onClick: o,
      style: i,
      children: t
    }
  );
};
EW.displayName = "HSingleDatePickerMonthYearButton";
const DW = ({
  children: t,
  className: e = "",
  style: i = {}
}) => {
  const { type: a, updateYearForYearCalendar: o, yearsArrLength: c } = Xi();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_year_prev ${a} ${e}`,
      onClick: () => o(-1 * c),
      style: i,
      children: t || a === "type1" && /* @__PURE__ */ Ae.jsx(iS, {})
    }
  );
};
DW.displayName = "HSingleDatePickerYearPrevButton";
const cN = Wo(void 0), RW = Av(({
  children: t,
  initialSelectedValue: e = null,
  onBlurDropdown: i = () => {
  },
  onChangeSelectedValue: a = () => {
  },
  scrollEventRefs: o = [],
  disabled: c = !1,
  style: u,
  ...h
}, m) => {
  const v = xn(null), b = xn(null), S = xn(null), [w, E] = En(e), [R, M] = En(!1), [A, P] = En(0), [z, B] = En({
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    clientWidth: 0,
    clientHeight: 0
  });
  Xx(m, () => ({
    selectedValue: w,
    dropdownAreaWidth: A,
    isActiveList: R
  }));
  const j = () => {
    if (M((Oe) => !Oe), !v.current)
      return;
    const { bottom: re, left: se, right: Ne, top: Ee, width: we } = v.current.getBoundingClientRect();
    P(we), B({
      top: Ee,
      bottom: re,
      left: se,
      right: Ne,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight
    });
  }, F = () => {
    if (!v.current)
      return;
    const { top: re, bottom: se, left: Ne, right: Ee } = v.current.getBoundingClientRect();
    B((we) => ({
      ...we,
      top: re,
      bottom: se,
      left: Ne,
      right: Ee
    }));
  }, $ = () => {
    B((re) => ({
      ...re,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight
    }));
  }, I = (re) => {
    const se = re.target;
    if (!(se instanceof HTMLElement))
      return;
    const Ne = se.closest(
      ".h_dropdown_button"
    );
    if (Ne) {
      Ne !== b.current && (M(!1), i());
      return;
    }
    const Ee = se.closest(".h_dropdown_list");
    Ee || (M(!1), i()), Ee !== S.current && (M(!1), i());
  }, K = (re, se) => {
    E(se), M(!1), a(se);
  };
  Xn(() => (R ? (window.addEventListener("scroll", F), Array.isArray(o) && o.forEach((re) => {
    const se = document.querySelector(re);
    se instanceof HTMLElement && se.addEventListener("scroll", F);
  }), window.addEventListener("resize", $), window.addEventListener("click", I)) : (window.removeEventListener("scroll", F), Array.isArray(o) && o.forEach((re) => {
    const se = document.querySelector(re);
    se instanceof HTMLElement && se.removeEventListener(
      "scroll",
      F
    );
  }), window.removeEventListener("resize", $), window.removeEventListener("click", I)), () => {
    window.removeEventListener("scroll", F), window.removeEventListener("resize", $), window.removeEventListener("click", I);
  }), [R]);
  const [ee, ne] = En(c);
  Xn(() => {
    ne(c);
  }, [c]);
  const le = {
    onClickedDropdownButton: j,
    isActiveList: R,
    listPosition: z,
    dropdownListRef: S,
    dropdownButtonRef: b,
    onClickedDropdownItemButton: K,
    isButtonDisabled: ee
  };
  return /* @__PURE__ */ Ae.jsx(cN.Provider, { value: le, children: /* @__PURE__ */ Ae.jsx("div", { ref: v, className: "h_dropdown_area", style: u, ...h, children: t({ isActiveList: R, dropdownAreaWidth: A }) }) });
});
RW.displayName = "HDropdownArea";
const kW = ({ children: t }) => /* @__PURE__ */ Ae.jsx("div", { className: "h_dropdown_item", children: t });
kW.displayName = "HDropdownItem";
const QE = () => {
  const t = Oi(cN);
  if (!t)
    throw new Error("useHDropdownAreaContext must be used within a HDropdownAreaProvider");
  return t;
}, MW = ({ children: t, ...e }) => {
  const { onClickedDropdownButton: i, dropdownButtonRef: a, isButtonDisabled: o } = QE();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      ref: a,
      onClick: i,
      disabled: o,
      className: "h_dropdown_button",
      ...e,
      children: t
    }
  );
};
MW.displayName = "HDropdownButton";
const AW = ({
  children: t,
  disabled: e = !1,
  optionValue: i,
  onClick: a,
  className: o,
  ...c
}) => {
  const { onClickedDropdownItemButton: u } = QE();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      disabled: e,
      onClick: (h) => {
        u(h, i), a == null || a(h, i);
      },
      className: `h_dropdown_item_button ${o}`,
      ...c,
      children: t
    }
  );
};
AW.displayName = "HDropdownItemButton";
/*!
 * OverlayScrollbars
 * Version: 2.11.1
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */
const Ua = (t, e) => {
  const { o: i, i: a, u: o } = t;
  let c = i, u;
  const h = (b, S) => {
    const w = c, E = b, R = S || (a ? !a(w, E) : w !== E);
    return (R || o) && (c = E, u = w), [c, R, u];
  };
  return [e ? (b) => h(e(c, u), b) : h, (b) => [c, !!b, u]];
}, OW = typeof window < "u" && typeof HTMLElement < "u" && !!window.document, Ta = OW ? window : {}, fN = Math.max, PW = Math.min, GT = Math.round, Ox = Math.abs, iO = Math.sign, dN = Ta.cancelAnimationFrame, qE = Ta.requestAnimationFrame, Px = Ta.setTimeout, KT = Ta.clearTimeout, aS = (t) => typeof Ta[t] < "u" ? Ta[t] : void 0, LW = aS("MutationObserver"), rO = aS("IntersectionObserver"), Gh = aS("ResizeObserver"), qg = aS("ScrollTimeline"), ZE = (t) => t === void 0, sS = (t) => t === null, Bo = (t) => typeof t == "number", Lv = (t) => typeof t == "string", oS = (t) => typeof t == "boolean", ys = (t) => typeof t == "function", $o = (t) => Array.isArray(t), Lx = (t) => typeof t == "object" && !$o(t) && !sS(t), JE = (t) => {
  const e = !!t && t.length, i = Bo(e) && e > -1 && e % 1 == 0;
  return $o(t) || !ys(t) && i ? e > 0 && Lx(t) ? e - 1 in t : !0 : !1;
}, Nx = (t) => !!t && t.constructor === Object, zx = (t) => t instanceof HTMLElement, lS = (t) => t instanceof Element;
function Dn(t, e) {
  if (JE(t))
    for (let i = 0; i < t.length && e(t[i], i, t) !== !1; i++)
      ;
  else t && Dn(Object.keys(t), (i) => e(t[i], i, t));
  return t;
}
const hN = (t, e) => t.indexOf(e) >= 0, xv = (t, e) => t.concat(e), ai = (t, e, i) => (!Lv(e) && JE(e) ? Array.prototype.push.apply(t, e) : t.push(e), t), sc = (t) => Array.from(t || []), e1 = (t) => $o(t) ? t : !Lv(t) && JE(t) ? sc(t) : [t], XT = (t) => !!t && !t.length, QT = (t) => sc(new Set(t)), Wa = (t, e, i) => {
  Dn(t, (o) => o ? o.apply(void 0, e || []) : !0), i || (t.length = 0);
}, pN = "paddingTop", mN = "paddingRight", gN = "paddingLeft", vN = "paddingBottom", yN = "marginLeft", bN = "marginRight", xN = "marginBottom", SN = "overflowX", _N = "overflowY", uS = "width", cS = "height", Wu = "visible", Vf = "hidden", lp = "scroll", NW = (t) => {
  const e = String(t || "");
  return e ? e[0].toUpperCase() + e.slice(1) : "";
}, fS = (t, e, i, a) => {
  if (t && e) {
    let o = !0;
    return Dn(i, (c) => {
      const u = t[c], h = e[c];
      u !== h && (o = !1);
    }), o;
  }
  return !1;
}, wN = (t, e) => fS(t, e, ["w", "h"]), yx = (t, e) => fS(t, e, ["x", "y"]), zW = (t, e) => fS(t, e, ["t", "r", "b", "l"]), qu = () => {
}, Tt = (t, ...e) => t.bind(0, ...e), Kh = (t) => {
  let e;
  const i = t ? Px : qE, a = t ? KT : dN;
  return [(o) => {
    a(e), e = i(() => o(), ys(t) ? t() : t);
  }, () => a(e)];
}, Fx = (t, e) => {
  const { _: i, p: a, v: o, S: c } = e || {};
  let u, h, m, v, b = qu;
  const S = function(A) {
    b(), KT(u), v = u = h = void 0, b = qu, t.apply(this, A);
  }, w = (M) => c && h ? c(h, M) : M, E = () => {
    b !== qu && S(w(m) || m);
  }, R = function() {
    const A = sc(arguments), P = ys(i) ? i() : i;
    if (Bo(P) && P >= 0) {
      const B = ys(a) ? a() : a, j = Bo(B) && B >= 0, F = P > 0 ? Px : qE, $ = P > 0 ? KT : dN, K = w(A) || A, ee = S.bind(0, K);
      let ne;
      b(), o && !v ? (ee(), v = !0, ne = F(() => v = void 0, P)) : (ne = F(ee, P), j && !u && (u = Px(E, B))), b = () => $(ne), h = m = K;
    } else
      S(A);
  };
  return R.m = E, R;
}, CN = (t, e) => Object.prototype.hasOwnProperty.call(t, e), Js = (t) => t ? Object.keys(t) : [], fn = (t, e, i, a, o, c, u) => {
  const h = [e, i, a, o, c, u];
  return (typeof t != "object" || sS(t)) && !ys(t) && (t = {}), Dn(h, (m) => {
    Dn(m, (v, b) => {
      const S = m[b];
      if (t === S)
        return !0;
      const w = $o(S);
      if (S && Nx(S)) {
        const E = t[b];
        let R = E;
        w && !$o(E) ? R = [] : !w && !Nx(E) && (R = {}), t[b] = fn(R, S);
      } else
        t[b] = w ? S.slice() : S;
    });
  }), t;
}, TN = (t, e) => Dn(fn({}, t), (i, a, o) => {
  i === void 0 ? delete o[a] : i && Nx(i) && (o[a] = TN(i));
}), t1 = (t) => !Js(t).length, EN = (t, e, i) => fN(t, PW(e, i)), Uf = (t) => QT(($o(t) ? t : (t || "").split(" ")).filter((e) => e)), n1 = (t, e) => t && t.getAttribute(e), aO = (t, e) => t && t.hasAttribute(e), Hl = (t, e, i) => {
  Dn(Uf(e), (a) => {
    t && t.setAttribute(a, String(i || ""));
  });
}, No = (t, e) => {
  Dn(Uf(e), (i) => t && t.removeAttribute(i));
}, dS = (t, e) => {
  const i = Uf(n1(t, e)), a = Tt(Hl, t, e), o = (c, u) => {
    const h = new Set(i);
    return Dn(Uf(c), (m) => {
      h[u](m);
    }), sc(h).join(" ");
  };
  return {
    O: (c) => a(o(c, "delete")),
    $: (c) => a(o(c, "add")),
    C: (c) => {
      const u = Uf(c);
      return u.reduce((h, m) => h && i.includes(m), u.length > 0);
    }
  };
}, DN = (t, e, i) => (dS(t, e).O(i), Tt(i1, t, e, i)), i1 = (t, e, i) => (dS(t, e).$(i), Tt(DN, t, e, i)), Vx = (t, e, i, a) => (a ? i1 : DN)(t, e, i), r1 = (t, e, i) => dS(t, e).C(i), RN = (t) => dS(t, "class"), kN = (t, e) => {
  RN(t).O(e);
}, a1 = (t, e) => (RN(t).$(e), Tt(kN, t, e)), MN = (t, e) => {
  const i = e ? lS(e) && e : document;
  return i ? sc(i.querySelectorAll(t)) : [];
}, FW = (t, e) => {
  const i = e ? lS(e) && e : document;
  return i && i.querySelector(t);
}, qT = (t, e) => lS(t) && t.matches(e), AN = (t) => qT(t, "body"), ZT = (t) => t ? sc(t.childNodes) : [], Sv = (t) => t && t.parentElement, Xh = (t, e) => lS(t) && t.closest(e), JT = (t) => document.activeElement, VW = (t, e, i) => {
  const a = Xh(t, e), o = t && FW(i, a), c = Xh(o, e) === a;
  return a && o ? a === t || o === t || c && Xh(Xh(t, i), e) !== a : !1;
}, up = (t) => {
  Dn(e1(t), (e) => {
    const i = Sv(e);
    e && i && i.removeChild(e);
  });
}, Ca = (t, e) => Tt(up, t && e && Dn(e1(e), (i) => {
  i && t.appendChild(i);
}));
let ON;
const jW = () => ON, BW = (t) => {
  ON = t;
}, np = (t) => {
  const e = document.createElement("div");
  return Hl(e, "class", t), e;
}, PN = (t) => {
  const e = np(), i = jW(), a = t.trim();
  return e.innerHTML = i ? i.createHTML(a) : a, Dn(ZT(e), (o) => up(o));
}, sO = (t, e) => t.getPropertyValue(e) || t[e] || "", LN = (t) => {
  const e = t || 0;
  return isFinite(e) ? e : 0;
}, tx = (t) => LN(parseFloat(t || "")), eE = (t) => Math.round(t * 1e4) / 1e4, NN = (t) => `${eE(LN(t))}px`;
function _v(t, e) {
  t && e && Dn(e, (i, a) => {
    try {
      const o = t.style, c = sS(i) || oS(i) ? "" : Bo(i) ? NN(i) : i;
      a.indexOf("--") === 0 ? o.setProperty(a, c) : o[a] = c;
    } catch {
    }
  });
}
function Kl(t, e, i) {
  const a = Lv(e);
  let o = a ? "" : {};
  if (t) {
    const c = Ta.getComputedStyle(t, i) || t.style;
    o = a ? sO(c, e) : sc(e).reduce((u, h) => (u[h] = sO(c, h), u), o);
  }
  return o;
}
const oO = (t, e, i) => {
  const a = e ? `${e}-` : "", o = i ? `-${i}` : "", c = `${a}top${o}`, u = `${a}right${o}`, h = `${a}bottom${o}`, m = `${a}left${o}`, v = Kl(t, [c, u, h, m]);
  return {
    t: tx(v[c]),
    r: tx(v[u]),
    b: tx(v[h]),
    l: tx(v[m])
  };
}, fT = (t, e) => `translate${Lx(t) ? `(${t.x},${t.y})` : `${e ? "X" : "Y"}(${t})`}`, HW = (t) => !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length), UW = {
  w: 0,
  h: 0
}, hS = (t, e) => e ? {
  w: e[`${t}Width`],
  h: e[`${t}Height`]
} : UW, IW = (t) => hS("inner", t || Ta), ip = Tt(hS, "offset"), zN = Tt(hS, "client"), jx = Tt(hS, "scroll"), s1 = (t) => {
  const e = parseFloat(Kl(t, uS)) || 0, i = parseFloat(Kl(t, cS)) || 0;
  return {
    w: e - GT(e),
    h: i - GT(i)
  };
}, dT = (t) => t.getBoundingClientRect(), $W = (t) => !!t && HW(t), tE = (t) => !!(t && (t[cS] || t[uS])), FN = (t, e) => {
  const i = tE(t);
  return !tE(e) && i;
}, lO = (t, e, i, a) => {
  Dn(Uf(e), (o) => {
    t && t.removeEventListener(o, i, a);
  });
}, Gn = (t, e, i, a) => {
  var o;
  const c = (o = a && a.H) != null ? o : !0, u = a && a.I || !1, h = a && a.A || !1, m = {
    passive: c,
    capture: u
  };
  return Tt(Wa, Uf(e).map((v) => {
    const b = h ? (S) => {
      lO(t, v, b, u), i && i(S);
    } : i;
    return t && t.addEventListener(v, b, m), Tt(lO, t, v, b, u);
  }));
}, VN = (t) => t.stopPropagation(), nE = (t) => t.preventDefault(), jN = (t) => VN(t) || nE(t), Vo = (t, e) => {
  const { x: i, y: a } = Bo(e) ? {
    x: e,
    y: e
  } : e || {};
  Bo(i) && (t.scrollLeft = i), Bo(a) && (t.scrollTop = a);
}, $a = (t) => ({
  x: t.scrollLeft,
  y: t.scrollTop
}), BN = () => ({
  D: {
    x: 0,
    y: 0
  },
  M: {
    x: 0,
    y: 0
  }
}), WW = (t, e) => {
  const { D: i, M: a } = t, { w: o, h: c } = e, u = (S, w, E) => {
    let R = iO(S) * E, M = iO(w) * E;
    if (R === M) {
      const A = Ox(S), P = Ox(w);
      M = A > P ? 0 : M, R = A < P ? 0 : R;
    }
    return R = R === M ? 0 : R, [R + 0, M + 0];
  }, [h, m] = u(i.x, a.x, o), [v, b] = u(i.y, a.y, c);
  return {
    D: {
      x: h,
      y: v
    },
    M: {
      x: m,
      y: b
    }
  };
}, hT = ({ D: t, M: e }) => {
  const i = (a, o) => a === 0 && a <= o;
  return {
    x: i(t.x, e.x),
    y: i(t.y, e.y)
  };
}, uO = ({ D: t, M: e }, i) => {
  const a = (o, c, u) => EN(0, 1, (o - u) / (o - c) || 0);
  return {
    x: a(t.x, e.x, i.x),
    y: a(t.y, e.y, i.y)
  };
}, iE = (t) => {
  t && t.focus && t.focus({
    preventScroll: !0
  });
}, cO = (t, e) => {
  Dn(e1(e), t);
}, rE = (t) => {
  const e = /* @__PURE__ */ new Map(), i = (c, u) => {
    if (c) {
      const h = e.get(c);
      cO((m) => {
        h && h[m ? "delete" : "clear"](m);
      }, u);
    } else
      e.forEach((h) => {
        h.clear();
      }), e.clear();
  }, a = (c, u) => {
    if (Lv(c)) {
      const v = e.get(c) || /* @__PURE__ */ new Set();
      return e.set(c, v), cO((b) => {
        ys(b) && v.add(b);
      }, u), Tt(i, c, u);
    }
    oS(u) && u && i();
    const h = Js(c), m = [];
    return Dn(h, (v) => {
      const b = c[v];
      b && ai(m, a(v, b));
    }), Tt(Wa, m);
  }, o = (c, u) => {
    Dn(sc(e.get(c)), (h) => {
      u && !XT(u) ? h.apply(0, u) : h();
    });
  };
  return a(t || {}), [a, i, o];
}, HN = {}, UN = {}, YW = (t) => {
  Dn(t, (e) => Dn(e, (i, a) => {
    HN[a] = e[a];
  }));
}, IN = (t, e, i) => Js(t).map((a) => {
  const { static: o, instance: c } = t[a], [u, h, m] = i || [], v = i ? c : o;
  if (v) {
    const b = i ? v(u, h, e) : v(e);
    return (m || UN)[a] = b;
  }
}), Nv = (t) => UN[t], GW = "__osOptionsValidationPlugin", mp = "data-overlayscrollbars", bx = "os-environment", nx = `${bx}-scrollbar-hidden`, pT = `${mp}-initialize`, xx = "noClipping", fO = `${mp}-body`, Zu = mp, KW = "host", Ul = `${mp}-viewport`, XW = SN, QW = _N, qW = "arrange", $N = "measuring", ZW = "scrolling", WN = "scrollbarHidden", JW = "noContent", aE = `${mp}-padding`, dO = `${mp}-content`, o1 = "os-size-observer", e8 = `${o1}-appear`, t8 = `${o1}-listener`, n8 = "os-trinsic-observer", i8 = "os-theme-none", Ga = "os-scrollbar", r8 = `${Ga}-rtl`, a8 = `${Ga}-horizontal`, s8 = `${Ga}-vertical`, YN = `${Ga}-track`, l1 = `${Ga}-handle`, o8 = `${Ga}-visible`, l8 = `${Ga}-cornerless`, hO = `${Ga}-interaction`, pO = `${Ga}-unusable`, sE = `${Ga}-auto-hide`, mO = `${sE}-hidden`, gO = `${Ga}-wheel`, u8 = `${YN}-interactive`, c8 = `${l1}-interactive`, f8 = "__osSizeObserverPlugin", d8 = (t, e) => {
  const { T: i } = e, [a, o] = t("showNativeOverlaidScrollbars");
  return [a && i.x && i.y, o];
}, cp = (t) => t.indexOf(Wu) === 0, h8 = (t, e) => {
  const i = (o, c, u, h) => {
    const m = o === Wu ? Vf : o.replace(`${Wu}-`, ""), v = cp(o), b = cp(u);
    return !c && !h ? Vf : v && b ? Wu : v ? c && h ? m : c ? Wu : Vf : c ? m : b && h ? Wu : Vf;
  }, a = {
    x: i(e.x, t.x, e.y, t.y),
    y: i(e.y, t.y, e.x, t.x)
  };
  return {
    k: a,
    R: {
      x: a.x === lp,
      y: a.y === lp
    }
  };
}, GN = "__osScrollbarsHidingPlugin", p8 = "__osClickScrollPlugin", vO = (t) => JSON.stringify(t, (e, i) => {
  if (ys(i))
    throw 0;
  return i;
}), yO = (t, e) => t ? `${e}`.split(".").reduce((i, a) => i && CN(i, a) ? i[a] : void 0, t) : void 0, m8 = {
  paddingAbsolute: !1,
  showNativeOverlaidScrollbars: !1,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    autoHideSuspend: !1,
    dragScroll: !0,
    clickScroll: !1,
    pointers: ["mouse", "touch", "pen"]
  }
}, KN = (t, e) => {
  const i = {}, a = xv(Js(e), Js(t));
  return Dn(a, (o) => {
    const c = t[o], u = e[o];
    if (Lx(c) && Lx(u))
      fn(i[o] = {}, KN(c, u)), t1(i[o]) && delete i[o];
    else if (CN(e, o) && u !== c) {
      let h = !0;
      if ($o(c) || $o(u))
        try {
          vO(c) === vO(u) && (h = !1);
        } catch {
        }
      h && (i[o] = u);
    }
  }), i;
}, bO = (t, e, i) => (a) => [yO(t, a), i || yO(e, a) !== void 0];
let XN;
const g8 = () => XN, v8 = (t) => {
  XN = t;
};
let mT;
const y8 = () => {
  const t = (j, F, $) => {
    Ca(document.body, j), Ca(document.body, j);
    const I = zN(j), K = ip(j), ee = s1(F);
    return $ && up(j), {
      x: K.h - I.h + ee.h,
      y: K.w - I.w + ee.w
    };
  }, e = (j) => {
    let F = !1;
    const $ = a1(j, nx);
    try {
      F = Kl(j, "scrollbar-width") === "none" || Kl(j, "display", "::-webkit-scrollbar") === "none";
    } catch {
    }
    return $(), F;
  }, i = `.${bx}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${bx} div{width:200%;height:200%;margin:10px 0}.${nx}{scrollbar-width:none!important}.${nx}::-webkit-scrollbar,.${nx}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`, o = PN(`<div class="${bx}"><div></div><style>${i}</style></div>`)[0], c = o.firstChild, u = o.lastChild, h = g8();
  h && (u.nonce = h);
  const [m, , v] = rE(), [b, S] = Ua({
    o: t(o, c),
    i: yx
  }, Tt(t, o, c, !0)), [w] = S(), E = e(o), R = {
    x: w.x === 0,
    y: w.y === 0
  }, M = {
    elements: {
      host: null,
      padding: !E,
      viewport: (j) => E && AN(j) && j,
      content: !1
    },
    scrollbars: {
      slot: !0
    },
    cancel: {
      nativeScrollbarsOverlaid: !1,
      body: null
    }
  }, A = fn({}, m8), P = Tt(fn, {}, A), z = Tt(fn, {}, M), B = {
    N: w,
    T: R,
    P: E,
    G: !!qg,
    K: Tt(m, "r"),
    Z: z,
    tt: (j) => fn(M, j) && z(),
    nt: P,
    ot: (j) => fn(A, j) && P(),
    st: fn({}, M),
    et: fn({}, A)
  };
  if (No(o, "style"), up(o), Gn(Ta, "resize", () => {
    v("r", []);
  }), ys(Ta.matchMedia) && !E && (!R.x || !R.y)) {
    const j = (F) => {
      const $ = Ta.matchMedia(`(resolution: ${Ta.devicePixelRatio}dppx)`);
      Gn($, "change", () => {
        F(), j(F);
      }, {
        A: !0
      });
    };
    j(() => {
      const [F, $] = b();
      fn(B.N, F), v("r", [$]);
    });
  }
  return B;
}, Yo = () => (mT || (mT = y8()), mT), b8 = (t, e, i) => {
  let a = !1;
  const o = i ? /* @__PURE__ */ new WeakMap() : !1, c = () => {
    a = !0;
  }, u = (h) => {
    if (o && i) {
      const m = i.map((v) => {
        const [b, S] = v || [];
        return [S && b ? (h || MN)(b, t) : [], S];
      });
      Dn(m, (v) => Dn(v[0], (b) => {
        const S = v[1], w = o.get(b) || [];
        if (t.contains(b) && S) {
          const R = Gn(b, S, (M) => {
            a ? (R(), o.delete(b)) : e(M);
          });
          o.set(b, ai(w, R));
        } else
          Wa(w), o.delete(b);
      }));
    }
  };
  return u(), [c, u];
}, xO = (t, e, i, a) => {
  let o = !1;
  const { ct: c, rt: u, lt: h, it: m, ut: v, ft: b } = a || {}, S = Fx(() => o && i(!0), {
    _: 33,
    p: 99
  }), [w, E] = b8(t, S, h), R = c || [], M = u || [], A = xv(R, M), P = (B, j) => {
    if (!XT(j)) {
      const F = v || qu, $ = b || qu, I = [], K = [];
      let ee = !1, ne = !1;
      if (Dn(j, (le) => {
        const { attributeName: re, target: se, type: Ne, oldValue: Ee, addedNodes: we, removedNodes: Oe } = le, ae = Ne === "attributes", me = Ne === "childList", pe = t === se, Ce = ae && re, oe = Ce && n1(se, re || ""), Me = Lv(oe) ? oe : null, Pe = Ce && Ee !== Me, fe = hN(M, re) && Pe;
        if (e && (me || !pe)) {
          const Le = ae && Pe, Te = Le && m && qT(se, m), it = (Te ? !F(se, re, Ee, Me) : !ae || Le) && !$(le, !!Te, t, a);
          Dn(we, (dt) => ai(I, dt)), Dn(Oe, (dt) => ai(I, dt)), ne = ne || it;
        }
        !e && pe && Pe && !F(se, re, Ee, Me) && (ai(K, re), ee = ee || fe);
      }), E((le) => QT(I).reduce((re, se) => (ai(re, MN(le, se)), qT(se, le) ? ai(re, se) : re), [])), e)
        return !B && ne && i(!1), [!1];
      if (!XT(K) || ee) {
        const le = [QT(K), ee];
        return B || i.apply(0, le), le;
      }
    }
  }, z = new LW(Tt(P, !1));
  return [() => (z.observe(t, {
    attributes: !0,
    attributeOldValue: !0,
    attributeFilter: A,
    subtree: e,
    childList: e,
    characterData: e
  }), o = !0, () => {
    o && (w(), z.disconnect(), o = !1);
  }), () => {
    if (o)
      return S.m(), P(!0, z.takeRecords());
  }];
};
let Af = null;
const QN = (t, e, i) => {
  const { _t: a } = i || {}, o = Nv(f8), [c] = Ua({
    o: !1,
    u: !0
  });
  return () => {
    const u = [], m = PN(`<div class="${o1}"><div class="${t8}"></div></div>`)[0], v = m.firstChild, b = (S) => {
      const w = S instanceof ResizeObserverEntry;
      let E = !1, R = !1;
      if (w) {
        const [M, , A] = c(S.contentRect), P = tE(M);
        R = FN(M, A), E = !R && !P;
      } else
        R = S === !0;
      E || e({
        dt: !0,
        _t: R
      });
    };
    if (Gh) {
      if (!oS(Af)) {
        const R = new Gh(qu);
        R.observe(t, {
          get box() {
            Af = !0;
          }
        }), Af = Af || !1, R.disconnect();
      }
      const S = Fx(b, {
        _: 0,
        p: 0
      }), w = (R) => S(R.pop()), E = new Gh(w);
      if (E.observe(Af ? t : v), ai(u, [() => E.disconnect(), !Af && Ca(t, m)]), Af) {
        const R = new Gh(w);
        R.observe(t, {
          box: "border-box"
        }), ai(u, () => R.disconnect());
      }
    } else if (o) {
      const [S, w] = o(v, b, a);
      ai(u, xv([a1(m, e8), Gn(m, "animationstart", S), Ca(t, m)], w));
    } else
      return qu;
    return Tt(Wa, u);
  };
}, x8 = (t, e) => {
  let i;
  const a = (m) => m.h === 0 || m.isIntersecting || m.intersectionRatio > 0, o = np(n8), [c] = Ua({
    o: !1
  }), u = (m, v) => {
    if (m) {
      const b = c(a(m)), [, S] = b;
      return S && !v && e(b) && [b];
    }
  }, h = (m, v) => u(v.pop(), m);
  return [() => {
    const m = [];
    if (rO)
      i = new rO(Tt(h, !1), {
        root: t
      }), i.observe(o), ai(m, () => {
        i.disconnect();
      });
    else {
      const v = () => {
        const b = ip(o);
        u(b);
      };
      ai(m, QN(o, v)()), v();
    }
    return Tt(Wa, ai(m, Ca(t, o)));
  }, () => i && h(!0, i.takeRecords())];
}, S8 = (t, e, i, a) => {
  let o, c, u, h, m, v;
  const b = `[${Zu}]`, S = `[${Ul}]`, w = ["id", "class", "style", "open", "wrap", "cols", "rows"], { vt: E, ht: R, U: M, gt: A, bt: P, L: z, wt: B, yt: j, St: F, Ot: $ } = t, I = (fe) => Kl(fe, "direction") === "rtl", K = {
    $t: !1,
    F: I(E)
  }, ee = Yo(), ne = Nv(GN), [le] = Ua({
    i: wN,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const fe = ne && ne.V(t, e, K, ee, i).W, Te = !(B && z) && r1(R, Zu, xx), xe = !z && j(qW), it = xe && $a(A), dt = it && $(), lt = F($N, Te), St = xe && fe && fe()[0], _t = jx(M), rt = s1(M);
    return St && St(), Vo(A, it), dt && dt(), Te && lt(), {
      w: _t.w + rt.w,
      h: _t.h + rt.h
    };
  }), re = Fx(a, {
    _: () => o,
    p: () => c,
    S(fe, Le) {
      const [Te] = fe, [xe] = Le;
      return [xv(Js(Te), Js(xe)).reduce((it, dt) => (it[dt] = Te[dt] || xe[dt], it), {})];
    }
  }), se = (fe) => {
    const Le = I(E);
    fn(fe, {
      Ct: v !== Le
    }), fn(K, {
      F: Le
    }), v = Le;
  }, Ne = (fe, Le) => {
    const [Te, xe] = fe, it = {
      xt: xe
    };
    return fn(K, {
      $t: Te
    }), Le || a(it), it;
  }, Ee = ({ dt: fe, _t: Le }) => {
    const xe = !(fe && !Le) && ee.P ? re : a, it = {
      dt: fe || Le,
      _t: Le
    };
    se(it), xe(it);
  }, we = (fe, Le) => {
    const [, Te] = le(), xe = {
      Ht: Te
    };
    return se(xe), Te && !Le && (fe ? a : re)(xe), xe;
  }, Oe = (fe, Le, Te) => {
    const xe = {
      Et: Le
    };
    return se(xe), Le && !Te && re(xe), xe;
  }, [ae, me] = P ? x8(R, Ne) : [], pe = !z && QN(R, Ee, {
    _t: !0
  }), [Ce, oe] = xO(R, !1, Oe, {
    rt: w,
    ct: w
  }), Me = z && Gh && new Gh((fe) => {
    const Le = fe[fe.length - 1].contentRect;
    Ee({
      dt: !0,
      _t: FN(Le, m)
    }), m = Le;
  }), Pe = Fx(() => {
    const [, fe] = le();
    a({
      Ht: fe
    });
  }, {
    _: 222,
    v: !0
  });
  return [() => {
    Me && Me.observe(R);
    const fe = pe && pe(), Le = ae && ae(), Te = Ce(), xe = ee.K((it) => {
      it ? re({
        zt: it
      }) : Pe();
    });
    return () => {
      Me && Me.disconnect(), fe && fe(), Le && Le(), h && h(), Te(), xe();
    };
  }, ({ It: fe, At: Le, Dt: Te }) => {
    const xe = {}, [it] = fe("update.ignoreMutation"), [dt, lt] = fe("update.attributes"), [St, _t] = fe("update.elementEvents"), [rt, xt] = fe("update.debounce"), Wt = _t || lt, an = Le || Te, sn = (Yt) => ys(it) && it(Yt);
    if (Wt) {
      u && u(), h && h();
      const [Yt, Gt] = xO(P || M, !0, we, {
        ct: xv(w, dt || []),
        lt: St,
        it: b,
        ft: (Ot, wt) => {
          const { target: Kt, attributeName: wn } = Ot;
          return (!wt && wn && !z ? VW(Kt, b, S) : !1) || !!Xh(Kt, `.${Ga}`) || !!sn(Ot);
        }
      });
      h = Yt(), u = Gt;
    }
    if (xt)
      if (re.m(), $o(rt)) {
        const Yt = rt[0], Gt = rt[1];
        o = Bo(Yt) && Yt, c = Bo(Gt) && Gt;
      } else Bo(rt) ? (o = rt, c = !1) : (o = !1, c = !1);
    if (an) {
      const Yt = oe(), Gt = me && me(), Ot = u && u();
      Yt && fn(xe, Oe(Yt[0], Yt[1], an)), Gt && fn(xe, Ne(Gt[0], an)), Ot && fn(xe, we(Ot[0], an));
    }
    return se(xe), xe;
  }, K];
}, qN = (t, e) => ys(e) ? e.apply(0, t) : e, _8 = (t, e, i, a) => {
  const o = ZE(a) ? i : a;
  return qN(t, o) || e.apply(0, t);
}, ZN = (t, e, i, a) => {
  const o = ZE(a) ? i : a, c = qN(t, o);
  return !!c && (zx(c) ? c : e.apply(0, t));
}, w8 = (t, e) => {
  const { nativeScrollbarsOverlaid: i, body: a } = e || {}, { T: o, P: c, Z: u } = Yo(), { nativeScrollbarsOverlaid: h, body: m } = u().cancel, v = i ?? h, b = ZE(a) ? m : a, S = (o.x || o.y) && v, w = t && (sS(b) ? !c : b);
  return !!S || !!w;
}, C8 = (t, e, i, a) => {
  const o = "--os-viewport-percent", c = "--os-scroll-percent", u = "--os-scroll-direction", { Z: h } = Yo(), { scrollbars: m } = h(), { slot: v } = m, { vt: b, ht: S, U: w, Mt: E, gt: R, wt: M, L: A } = e, { scrollbars: P } = E ? {} : t, { slot: z } = P || {}, B = [], j = [], F = [], $ = ZN([b, S, w], () => A && M ? b : S, v, z), I = (Ce) => {
    if (qg) {
      let oe = null, Me = [];
      const Pe = new qg({
        source: R,
        axis: Ce
      }), fe = () => {
        oe && oe.cancel(), oe = null;
      };
      return {
        Rt: (Te) => {
          const { Tt: xe } = i, it = hT(xe)[Ce], dt = Ce === "x", lt = [fT(0, dt), fT(`calc(100cq${dt ? "w" : "h"} + -100%)`, dt)], St = it ? lt : lt.reverse();
          return Me[0] === St[0] && Me[1] === St[1] || (fe(), Me = St, oe = Te.kt.animate({
            clear: ["left"],
            transform: St
          }, {
            timeline: Pe
          })), fe;
        }
      };
    }
  }, K = {
    x: I("x"),
    y: I("y")
  }, ee = () => {
    const { Vt: Ce, Lt: oe } = i, Me = (Pe, fe) => EN(0, 1, Pe / (Pe + fe) || 0);
    return {
      x: Me(oe.x, Ce.x),
      y: Me(oe.y, Ce.y)
    };
  }, ne = (Ce, oe, Me) => {
    const Pe = Me ? a1 : kN;
    Dn(Ce, (fe) => {
      Pe(fe.Ut, oe);
    });
  }, le = (Ce, oe) => {
    Dn(Ce, (Me) => {
      const [Pe, fe] = oe(Me);
      _v(Pe, fe);
    });
  }, re = (Ce, oe, Me) => {
    const Pe = oS(Me), fe = Pe ? Me : !0, Le = Pe ? !Me : !0;
    fe && ne(j, Ce, oe), Le && ne(F, Ce, oe);
  }, se = () => {
    const Ce = ee(), oe = (Me) => (Pe) => [Pe.Ut, {
      [o]: eE(Me) + ""
    }];
    le(j, oe(Ce.x)), le(F, oe(Ce.y));
  }, Ne = () => {
    if (!qg) {
      const { Tt: Ce } = i, oe = uO(Ce, $a(R)), Me = (Pe) => (fe) => [fe.Ut, {
        [c]: eE(Pe) + ""
      }];
      le(j, Me(oe.x)), le(F, Me(oe.y));
    }
  }, Ee = () => {
    const { Tt: Ce } = i, oe = hT(Ce), Me = (Pe) => (fe) => [fe.Ut, {
      [u]: Pe ? "0" : "1"
    }];
    le(j, Me(oe.x)), le(F, Me(oe.y)), qg && (j.forEach(K.x.Rt), F.forEach(K.y.Rt));
  }, we = () => {
    if (A && !M) {
      const { Vt: Ce, Tt: oe } = i, Me = hT(oe), Pe = uO(oe, $a(R)), fe = (Le) => {
        const { Ut: Te } = Le, xe = Sv(Te) === w && Te, it = (dt, lt, St) => {
          const _t = lt * dt;
          return NN(St ? _t : -_t);
        };
        return [xe, xe && {
          transform: fT({
            x: it(Pe.x, Ce.x, Me.x),
            y: it(Pe.y, Ce.y, Me.y)
          })
        }];
      };
      le(j, fe), le(F, fe);
    }
  }, Oe = (Ce) => {
    const oe = Ce ? "x" : "y", Pe = np(`${Ga} ${Ce ? a8 : s8}`), fe = np(YN), Le = np(l1), Te = {
      Ut: Pe,
      Pt: fe,
      kt: Le
    }, xe = K[oe];
    return ai(Ce ? j : F, Te), ai(B, [Ca(Pe, fe), Ca(fe, Le), Tt(up, Pe), xe && xe.Rt(Te), a(Te, re, Ce)]), Te;
  }, ae = Tt(Oe, !0), me = Tt(Oe, !1), pe = () => (Ca($, j[0].Ut), Ca($, F[0].Ut), Tt(Wa, B));
  return ae(), me(), [{
    Nt: se,
    qt: Ne,
    Bt: Ee,
    Ft: we,
    jt: re,
    Xt: {
      Yt: j,
      Wt: ae,
      Jt: Tt(le, j)
    },
    Gt: {
      Yt: F,
      Wt: me,
      Jt: Tt(le, F)
    }
  }, pe];
}, T8 = (t, e, i, a) => (o, c, u) => {
  const { ht: h, U: m, L: v, gt: b, Kt: S, Ot: w } = e, { Ut: E, Pt: R, kt: M } = o, [A, P] = Kh(333), [z, B] = Kh(444), j = (I) => {
    ys(b.scrollBy) && b.scrollBy({
      behavior: "smooth",
      left: I.x,
      top: I.y
    });
  }, F = () => {
    const I = "pointerup pointercancel lostpointercapture", K = `client${u ? "X" : "Y"}`, ee = u ? uS : cS, ne = u ? "left" : "top", le = u ? "w" : "h", re = u ? "x" : "y", se = (Ee, we) => (Oe) => {
      const { Vt: ae } = i, me = ip(R)[le] - ip(M)[le], Ce = we * Oe / me * ae[re];
      Vo(b, {
        [re]: Ee + Ce
      });
    }, Ne = [];
    return Gn(R, "pointerdown", (Ee) => {
      const we = Xh(Ee.target, `.${l1}`) === M, Oe = we ? M : R, ae = t.scrollbars, me = ae[we ? "dragScroll" : "clickScroll"], { button: pe, isPrimary: Ce, pointerType: oe } = Ee, { pointers: Me } = ae;
      if (pe === 0 && Ce && me && (Me || []).includes(oe)) {
        Wa(Ne), B();
        const fe = !we && (Ee.shiftKey || me === "instant"), Le = Tt(dT, M), Te = Tt(dT, R), xe = (wt, Kt) => (wt || Le())[ne] - (Kt || Te())[ne], it = GT(dT(b)[ee]) / ip(b)[le] || 1, dt = se($a(b)[re], 1 / it), lt = Ee[K], St = Le(), _t = Te(), rt = St[ee], xt = xe(St, _t) + rt / 2, Wt = lt - _t[ne], an = we ? 0 : Wt - xt, sn = (wt) => {
          Wa(Ot), Oe.releasePointerCapture(wt.pointerId);
        }, Yt = we || fe, Gt = w(), Ot = [Gn(S, I, sn), Gn(S, "selectstart", (wt) => nE(wt), {
          H: !1
        }), Gn(R, I, sn), Yt && Gn(R, "pointermove", (wt) => dt(an + (wt[K] - lt))), Yt && (() => {
          const wt = $a(b);
          Gt();
          const Kt = $a(b), wn = {
            x: Kt.x - wt.x,
            y: Kt.y - wt.y
          };
          (Ox(wn.x) > 3 || Ox(wn.y) > 3) && (w(), Vo(b, wt), j(wn), z(Gt));
        })];
        if (Oe.setPointerCapture(Ee.pointerId), fe)
          dt(an);
        else if (!we) {
          const wt = Nv(p8);
          if (wt) {
            const Kt = wt(dt, an, rt, (wn) => {
              wn ? Gt() : ai(Ot, Gt);
            });
            ai(Ot, Kt), ai(Ne, Tt(Kt, !0));
          }
        }
      }
    });
  };
  let $ = !0;
  return Tt(Wa, [Gn(M, "pointermove pointerleave", a), Gn(E, "pointerenter", () => {
    c(hO, !0);
  }), Gn(E, "pointerleave pointercancel", () => {
    c(hO, !1);
  }), !v && Gn(E, "mousedown", () => {
    const I = JT();
    (aO(I, Ul) || aO(I, Zu) || I === document.body) && Px(Tt(iE, m), 25);
  }), Gn(E, "wheel", (I) => {
    const { deltaX: K, deltaY: ee, deltaMode: ne } = I;
    $ && ne === 0 && Sv(E) === h && j({
      x: K,
      y: ee
    }), $ = !1, c(gO, !0), A(() => {
      $ = !0, c(gO);
    }), nE(I);
  }, {
    H: !1,
    I: !0
  }), Gn(E, "pointerdown", Tt(Gn, S, "click", jN, {
    A: !0,
    I: !0,
    H: !1
  }), {
    I: !0
  }), F(), P, B]);
}, E8 = (t, e, i, a, o, c) => {
  let u, h, m, v, b, S = qu, w = 0;
  const E = ["mouse", "pen"], R = (oe) => E.includes(oe.pointerType), [M, A] = Kh(), [P, z] = Kh(100), [B, j] = Kh(100), [F, $] = Kh(() => w), [I, K] = C8(t, o, a, T8(e, o, a, (oe) => R(oe) && ae())), { ht: ee, Qt: ne, wt: le } = o, { jt: re, Nt: se, qt: Ne, Bt: Ee, Ft: we } = I, Oe = (oe, Me) => {
    if ($(), oe)
      re(mO);
    else {
      const Pe = Tt(re, mO, !0);
      w > 0 && !Me ? F(Pe) : Pe();
    }
  }, ae = () => {
    (m ? !u : !v) && (Oe(!0), P(() => {
      Oe(!1);
    }));
  }, me = (oe) => {
    re(sE, oe, !0), re(sE, oe, !1);
  }, pe = (oe) => {
    R(oe) && (u = m, m && Oe(!0));
  }, Ce = [$, z, j, A, () => S(), Gn(ee, "pointerover", pe, {
    A: !0
  }), Gn(ee, "pointerenter", pe), Gn(ee, "pointerleave", (oe) => {
    R(oe) && (u = !1, m && Oe(!1));
  }), Gn(ee, "pointermove", (oe) => {
    R(oe) && h && ae();
  }), Gn(ne, "scroll", (oe) => {
    M(() => {
      Ne(), ae();
    }), c(oe), we();
  })];
  return [() => Tt(Wa, ai(Ce, K())), ({ It: oe, Dt: Me, Zt: Pe, tn: fe }) => {
    const { nn: Le, sn: Te, en: xe, cn: it } = fe || {}, { Ct: dt, _t: lt } = Pe || {}, { F: St } = i, { T: _t } = Yo(), { k: rt, rn: xt } = a, [Wt, an] = oe("showNativeOverlaidScrollbars"), [sn, Yt] = oe("scrollbars.theme"), [Gt, Ot] = oe("scrollbars.visibility"), [wt, Kt] = oe("scrollbars.autoHide"), [wn, Mn] = oe("scrollbars.autoHideSuspend"), [oi] = oe("scrollbars.autoHideDelay"), [Pi, er] = oe("scrollbars.dragScroll"), [Ei, ze] = oe("scrollbars.clickScroll"), [tt, Et] = oe("overflow"), Xt = lt && !Me, ln = xt.x || xt.y, dn = Le || Te || it || dt || Me, gn = xe || Ot || Et, zn = Wt && _t.x && _t.y, on = (jt, Qt, Di) => {
      const yi = jt.includes(lp) && (Gt === Wu || Gt === "auto" && Qt === lp);
      return re(o8, yi, Di), yi;
    };
    if (w = oi, Xt && (wn && ln ? (me(!1), S(), B(() => {
      S = Gn(ne, "scroll", Tt(me, !0), {
        A: !0
      });
    })) : me(!0)), an && re(i8, zn), Yt && (re(b), re(sn, !0), b = sn), Mn && !wn && me(!0), Kt && (h = wt === "move", m = wt === "leave", v = wt === "never", Oe(v, !0)), er && re(c8, Pi), ze && re(u8, !!Ei), gn) {
      const jt = on(tt.x, rt.x, !0), Qt = on(tt.y, rt.y, !1);
      re(l8, !(jt && Qt));
    }
    dn && (Ne(), se(), we(), it && Ee(), re(pO, !xt.x, !0), re(pO, !xt.y, !1), re(r8, St && !le));
  }, {}, I];
}, D8 = (t) => {
  const e = Yo(), { Z: i, P: a } = e, { elements: o } = i(), { padding: c, viewport: u, content: h } = o, m = zx(t), v = m ? {} : t, { elements: b } = v, { padding: S, viewport: w, content: E } = b || {}, R = m ? t : v.target, M = AN(R), A = R.ownerDocument, P = A.documentElement, z = () => A.defaultView || Ta, B = Tt(_8, [R]), j = Tt(ZN, [R]), F = Tt(np, ""), $ = Tt(B, F, u), I = Tt(j, F, h), K = (rt) => {
    const xt = ip(rt), Wt = jx(rt), an = Kl(rt, SN), sn = Kl(rt, _N);
    return Wt.w - xt.w > 0 && !cp(an) || Wt.h - xt.h > 0 && !cp(sn);
  }, ee = $(w), ne = ee === R, le = ne && M, re = !ne && I(E), se = !ne && ee === re, Ne = le ? P : ee, Ee = le ? Ne : R, we = !ne && j(F, c, S), Oe = !se && re, ae = [Oe, Ne, we, Ee].map((rt) => zx(rt) && !Sv(rt) && rt), me = (rt) => rt && hN(ae, rt), pe = !me(Ne) && K(Ne) ? Ne : R, Ce = le ? P : Ne, Me = {
    vt: R,
    ht: Ee,
    U: Ne,
    ln: we,
    bt: Oe,
    gt: Ce,
    Qt: le ? A : Ne,
    an: M ? P : pe,
    Kt: A,
    wt: M,
    Mt: m,
    L: ne,
    un: z,
    yt: (rt) => r1(Ne, Ul, rt),
    St: (rt, xt) => Vx(Ne, Ul, rt, xt),
    Ot: () => Vx(Ce, Ul, ZW, !0)
  }, { vt: Pe, ht: fe, ln: Le, U: Te, bt: xe } = Me, it = [() => {
    No(fe, [Zu, pT]), No(Pe, pT), M && No(P, [pT, Zu]);
  }];
  let dt = ZT([xe, Te, Le, fe, Pe].find((rt) => rt && !me(rt)));
  const lt = le ? Pe : xe || Te, St = Tt(Wa, it);
  return [Me, () => {
    const rt = z(), xt = JT(), Wt = (Ot) => {
      Ca(Sv(Ot), ZT(Ot)), up(Ot);
    }, an = (Ot) => Gn(Ot, "focusin focusout focus blur", jN, {
      I: !0,
      H: !1
    }), sn = "tabindex", Yt = n1(Te, sn), Gt = an(xt);
    return Hl(fe, Zu, ne ? "" : KW), Hl(Le, aE, ""), Hl(Te, Ul, ""), Hl(xe, dO, ""), ne || (Hl(Te, sn, Yt || "-1"), M && Hl(P, fO, "")), Ca(lt, dt), Ca(fe, Le), Ca(Le || fe, !ne && Te), Ca(Te, xe), ai(it, [Gt, () => {
      const Ot = JT(), wt = me(Te), Kt = wt && Ot === Te ? Pe : Ot, wn = an(Kt);
      No(Le, aE), No(xe, dO), No(Te, Ul), M && No(P, fO), Yt ? Hl(Te, sn, Yt) : No(Te, sn), me(xe) && Wt(xe), wt && Wt(Te), me(Le) && Wt(Le), iE(Kt), wn();
    }]), a && !ne && (i1(Te, Ul, WN), ai(it, Tt(No, Te, Ul))), iE(!ne && M && xt === Pe && rt.top === rt ? Te : xt), Gt(), dt = 0, St;
  }, St];
}, R8 = ({ bt: t }) => ({ Zt: e, fn: i, Dt: a }) => {
  const { xt: o } = e || {}, { $t: c } = i;
  t && (o || a) && _v(t, {
    [cS]: c && "100%"
  });
}, k8 = ({ ht: t, ln: e, U: i, L: a }, o) => {
  const [c, u] = Ua({
    i: zW,
    o: oO()
  }, Tt(oO, t, "padding", ""));
  return ({ It: h, Zt: m, fn: v, Dt: b }) => {
    let [S, w] = u(b);
    const { P: E } = Yo(), { dt: R, Ht: M, Ct: A } = m || {}, { F: P } = v, [z, B] = h("paddingAbsolute");
    (R || w || (b || M)) && ([S, w] = c(b));
    const F = !a && (B || A || w);
    if (F) {
      const $ = !z || !e && !E, I = S.r + S.l, K = S.t + S.b, ee = {
        [bN]: $ && !P ? -I : 0,
        [xN]: $ ? -K : 0,
        [yN]: $ && P ? -I : 0,
        top: $ ? -S.t : 0,
        right: $ ? P ? -S.r : "auto" : 0,
        left: $ ? P ? "auto" : -S.l : 0,
        [uS]: $ && `calc(100% + ${I}px)`
      }, ne = {
        [pN]: $ ? S.t : 0,
        [mN]: $ ? S.r : 0,
        [vN]: $ ? S.b : 0,
        [gN]: $ ? S.l : 0
      };
      _v(e || i, ee), _v(i, ne), fn(o, {
        ln: S,
        _n: !$,
        j: e ? ne : fn({}, ee, ne)
      });
    }
    return {
      dn: F
    };
  };
}, M8 = (t, e) => {
  const i = Yo(), { ht: a, ln: o, U: c, L: u, Qt: h, gt: m, wt: v, St: b, un: S } = t, { P: w } = i, E = v && u, R = Tt(fN, 0), M = {
    display: () => !1,
    direction: (oe) => oe !== "ltr",
    flexDirection: (oe) => oe.endsWith("-reverse"),
    writingMode: (oe) => oe !== "horizontal-tb"
  }, A = Js(M), P = {
    i: wN,
    o: {
      w: 0,
      h: 0
    }
  }, z = {
    i: yx,
    o: {}
  }, B = (oe) => {
    b($N, !E && oe);
  }, j = (oe) => {
    if (!A.some((lt) => {
      const St = oe[lt];
      return St && M[lt](St);
    }))
      return {
        D: {
          x: 0,
          y: 0
        },
        M: {
          x: 1,
          y: 1
        }
      };
    B(!0);
    const Pe = $a(m), fe = b(JW, !0), Le = Gn(h, lp, (lt) => {
      const St = $a(m);
      lt.isTrusted && St.x === Pe.x && St.y === Pe.y && VN(lt);
    }, {
      I: !0,
      A: !0
    });
    Vo(m, {
      x: 0,
      y: 0
    }), fe();
    const Te = $a(m), xe = jx(m);
    Vo(m, {
      x: xe.w,
      y: xe.h
    });
    const it = $a(m);
    Vo(m, {
      x: it.x - Te.x < 1 && -xe.w,
      y: it.y - Te.y < 1 && -xe.h
    });
    const dt = $a(m);
    return Vo(m, Pe), qE(() => Le()), {
      D: Te,
      M: dt
    };
  }, F = (oe, Me) => {
    const Pe = Ta.devicePixelRatio % 1 !== 0 ? 1 : 0, fe = {
      w: R(oe.w - Me.w),
      h: R(oe.h - Me.h)
    };
    return {
      w: fe.w > Pe ? fe.w : 0,
      h: fe.h > Pe ? fe.h : 0
    };
  }, [$, I] = Ua(P, Tt(s1, c)), [K, ee] = Ua(P, Tt(jx, c)), [ne, le] = Ua(P), [re] = Ua(z), [se, Ne] = Ua(P), [Ee] = Ua(z), [we] = Ua({
    i: (oe, Me) => fS(oe, Me, A),
    o: {}
  }, () => $W(c) ? Kl(c, A) : {}), [Oe, ae] = Ua({
    i: (oe, Me) => yx(oe.D, Me.D) && yx(oe.M, Me.M),
    o: BN()
  }), me = Nv(GN), pe = (oe, Me) => `${Me ? XW : QW}${NW(oe)}`, Ce = (oe) => {
    const Me = (fe) => [Wu, Vf, lp].map((Le) => pe(Le, fe)), Pe = Me(!0).concat(Me()).join(" ");
    b(Pe), b(Js(oe).map((fe) => pe(oe[fe], fe === "x")).join(" "), !0);
  };
  return ({ It: oe, Zt: Me, fn: Pe, Dt: fe }, { dn: Le }) => {
    const { dt: Te, Ht: xe, Ct: it, _t: dt, zt: lt } = Me || {}, St = me && me.V(t, e, Pe, i, oe), { Y: _t, W: rt, J: xt } = St || {}, [Wt, an] = d8(oe, i), [sn, Yt] = oe("overflow"), Gt = cp(sn.x), Ot = cp(sn.y), wt = Te || Le || xe || it || lt || an;
    let Kt = I(fe), wn = ee(fe), Mn = le(fe), oi = Ne(fe);
    if (an && w && b(WN, !Wt), wt) {
      r1(a, Zu, xx) && B(!0);
      const [de] = rt ? rt() : [], [ve] = Kt = $(fe), [ke] = wn = K(fe), $e = zN(c), hn = E && IW(S()), An = {
        w: R(ke.w + ve.w),
        h: R(ke.h + ve.h)
      }, yr = {
        w: R((hn ? hn.w : $e.w + R($e.w - ke.w)) + ve.w),
        h: R((hn ? hn.h : $e.h + R($e.h - ke.h)) + ve.h)
      };
      de && de(), oi = se(yr), Mn = ne(F(An, yr), fe);
    }
    const [Pi, er] = oi, [Ei, ze] = Mn, [tt, Et] = wn, [Xt, ln] = Kt, [dn, gn] = re({
      x: Ei.w > 0,
      y: Ei.h > 0
    }), zn = Gt && Ot && (dn.x || dn.y) || Gt && dn.x && !dn.y || Ot && dn.y && !dn.x, on = Le || it || lt || ln || Et || er || ze || Yt || an || wt, jt = h8(dn, sn), [Qt, Di] = Ee(jt.k), [yi, He] = we(fe), Fe = it || dt || He || gn || fe, [Qe, mt] = Fe ? Oe(j(yi), fe) : ae();
    return on && (Di && Ce(jt.k), xt && _t && _v(c, xt(jt, Pe, _t(jt, tt, Xt)))), B(!1), Vx(a, Zu, xx, zn), Vx(o, aE, xx, zn), fn(e, {
      k: Qt,
      Lt: {
        x: Pi.w,
        y: Pi.h
      },
      Vt: {
        x: Ei.w,
        y: Ei.h
      },
      rn: dn,
      Tt: WW(Qe, Ei)
    }), {
      en: Di,
      nn: er,
      sn: ze,
      cn: mt || ze,
      pn: Fe
    };
  };
}, A8 = (t) => {
  const [e, i, a] = D8(t), o = {
    ln: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    },
    _n: !1,
    j: {
      [bN]: 0,
      [xN]: 0,
      [yN]: 0,
      [pN]: 0,
      [mN]: 0,
      [vN]: 0,
      [gN]: 0
    },
    Lt: {
      x: 0,
      y: 0
    },
    Vt: {
      x: 0,
      y: 0
    },
    k: {
      x: Vf,
      y: Vf
    },
    rn: {
      x: !1,
      y: !1
    },
    Tt: BN()
  }, { vt: c, gt: u, L: h, Ot: m } = e, { P: v, T: b } = Yo(), S = !v && (b.x || b.y), w = [R8(e), k8(e, o), M8(e, o)];
  return [i, (E) => {
    const R = {}, A = S && $a(u), P = A && m();
    return Dn(w, (z) => {
      fn(R, z(E, R) || {});
    }), Vo(u, A), P && P(), h || Vo(c, 0), R;
  }, o, e, a];
}, O8 = (t, e, i, a, o) => {
  let c = !1;
  const u = bO(e, {}), [h, m, v, b, S] = A8(t), [w, E, R] = S8(b, v, u, (j) => {
    B({}, j);
  }), [M, A, , P] = E8(t, e, R, v, b, o), z = (j) => Js(j).some((F) => !!j[F]), B = (j, F) => {
    if (i())
      return !1;
    const { vn: $, Dt: I, At: K, hn: ee } = j, ne = $ || {}, le = !!I || !c, re = {
      It: bO(e, ne, le),
      vn: ne,
      Dt: le
    };
    if (ee)
      return A(re), !1;
    const se = F || E(fn({}, re, {
      At: K
    })), Ne = m(fn({}, re, {
      fn: R,
      Zt: se
    }));
    A(fn({}, re, {
      Zt: se,
      tn: Ne
    }));
    const Ee = z(se), we = z(Ne), Oe = Ee || we || !t1(ne) || le;
    return c = !0, Oe && a(j, {
      Zt: se,
      tn: Ne
    }), Oe;
  };
  return [() => {
    const { an: j, gt: F, Ot: $ } = b, I = $a(j), K = [w(), h(), M()], ee = $();
    return Vo(F, I), ee(), Tt(Wa, K);
  }, B, () => ({
    gn: R,
    bn: v
  }), {
    wn: b,
    yn: P
  }, S];
}, u1 = /* @__PURE__ */ new WeakMap(), P8 = (t, e) => {
  u1.set(t, e);
}, L8 = (t) => {
  u1.delete(t);
}, JN = (t) => u1.get(t), Qs = (t, e, i) => {
  const { nt: a } = Yo(), o = zx(t), c = o ? t : t.target, u = JN(c);
  if (e && !u) {
    let h = !1;
    const m = [], v = {}, b = (ne) => {
      const le = TN(ne), re = Nv(GW);
      return re ? re(le, !0) : le;
    }, S = fn({}, a(), b(e)), [w, E, R] = rE(), [M, A, P] = rE(i), z = (ne, le) => {
      P(ne, le), R(ne, le);
    }, [B, j, F, $, I] = O8(t, S, () => h, ({ vn: ne, Dt: le }, { Zt: re, tn: se }) => {
      const { dt: Ne, Ct: Ee, xt: we, Ht: Oe, Et: ae, _t: me } = re, { nn: pe, sn: Ce, en: oe, cn: Me } = se;
      z("updated", [ee, {
        updateHints: {
          sizeChanged: !!Ne,
          directionChanged: !!Ee,
          heightIntrinsicChanged: !!we,
          overflowEdgeChanged: !!pe,
          overflowAmountChanged: !!Ce,
          overflowStyleChanged: !!oe,
          scrollCoordinatesChanged: !!Me,
          contentMutation: !!Oe,
          hostMutation: !!ae,
          appear: !!me
        },
        changedOptions: ne || {},
        force: !!le
      }]);
    }, (ne) => z("scroll", [ee, ne])), K = (ne) => {
      L8(c), Wa(m), h = !0, z("destroyed", [ee, ne]), E(), A();
    }, ee = {
      options(ne, le) {
        if (ne) {
          const re = le ? a() : {}, se = KN(S, fn(re, b(ne)));
          t1(se) || (fn(S, se), j({
            vn: se
          }));
        }
        return fn({}, S);
      },
      on: M,
      off: (ne, le) => {
        ne && le && A(ne, le);
      },
      state() {
        const { gn: ne, bn: le } = F(), { F: re } = ne, { Lt: se, Vt: Ne, k: Ee, rn: we, ln: Oe, _n: ae, Tt: me } = le;
        return fn({}, {
          overflowEdge: se,
          overflowAmount: Ne,
          overflowStyle: Ee,
          hasOverflow: we,
          scrollCoordinates: {
            start: me.D,
            end: me.M
          },
          padding: Oe,
          paddingAbsolute: ae,
          directionRTL: re,
          destroyed: h
        });
      },
      elements() {
        const { vt: ne, ht: le, ln: re, U: se, bt: Ne, gt: Ee, Qt: we } = $.wn, { Xt: Oe, Gt: ae } = $.yn, me = (Ce) => {
          const { kt: oe, Pt: Me, Ut: Pe } = Ce;
          return {
            scrollbar: Pe,
            track: Me,
            handle: oe
          };
        }, pe = (Ce) => {
          const { Yt: oe, Wt: Me } = Ce, Pe = me(oe[0]);
          return fn({}, Pe, {
            clone: () => {
              const fe = me(Me());
              return j({
                hn: !0
              }), fe;
            }
          });
        };
        return fn({}, {
          target: ne,
          host: le,
          padding: re || se,
          viewport: se,
          content: Ne || se,
          scrollOffsetElement: Ee,
          scrollEventElement: we,
          scrollbarHorizontal: pe(Oe),
          scrollbarVertical: pe(ae)
        });
      },
      update: (ne) => j({
        Dt: ne,
        At: !0
      }),
      destroy: Tt(K, !1),
      plugin: (ne) => v[Js(ne)[0]]
    };
    return ai(m, [I]), P8(c, ee), IN(HN, Qs, [ee, w, v]), w8($.wn.wt, !o && t.cancel) ? (K(!0), ee) : (ai(m, B()), z("initialized", [ee]), ee.update(), ee);
  }
  return u;
};
Qs.plugin = (t) => {
  const e = $o(t), i = e ? t : [t], a = i.map((o) => IN(o, Qs)[0]);
  return YW(i), e ? a : a[0];
};
Qs.valid = (t) => {
  const e = t && t.elements, i = ys(e) && e();
  return Nx(i) && !!JN(i.target);
};
Qs.env = () => {
  const { N: t, T: e, P: i, G: a, st: o, et: c, Z: u, tt: h, nt: m, ot: v } = Yo();
  return fn({}, {
    scrollbarsSize: t,
    scrollbarsOverlaid: e,
    scrollbarsHiding: i,
    scrollTimeline: a,
    staticDefaultInitialization: o,
    staticDefaultOptions: c,
    getDefaultInitialization: u,
    setDefaultInitialization: h,
    getDefaultOptions: m,
    setDefaultOptions: v
  });
};
Qs.nonce = v8;
Qs.trustedTypePolicy = BW;
const N8 = () => {
  if (typeof window > "u") {
    const v = () => {
    };
    return [v, v];
  }
  let t, e;
  const i = window, a = typeof i.requestIdleCallback == "function", o = i.requestAnimationFrame, c = i.cancelAnimationFrame, u = a ? i.requestIdleCallback : o, h = a ? i.cancelIdleCallback : c, m = () => {
    h(t), c(e);
  };
  return [
    (v, b) => {
      m(), t = u(
        a ? () => {
          m(), e = o(v);
        } : v,
        typeof b == "object" ? b : { timeout: 2233 }
      );
    },
    m
  ];
}, z8 = (t) => {
  const { options: e, events: i, defer: a } = t || {}, [o, c] = Zs(N8, []), u = xn(null), h = xn(a), m = xn(e), v = xn(i);
  return Xn(() => {
    h.current = a;
  }, [a]), Xn(() => {
    const { current: b } = u;
    m.current = e, Qs.valid(b) && b.options(e || {}, !0);
  }, [e]), Xn(() => {
    const { current: b } = u;
    v.current = i, Qs.valid(b) && b.on(i || {}, !0);
  }, [i]), Xn(
    () => () => {
      var b;
      c(), (b = u.current) == null || b.destroy();
    },
    []
  ), Zs(
    () => [
      (b) => {
        const S = u.current;
        if (Qs.valid(S))
          return;
        const w = h.current, E = m.current || {}, R = v.current || {}, M = () => u.current = Qs(b, E, R);
        w ? o(M, w) : M();
      },
      () => u.current
    ],
    []
  );
}, F8 = (t, e) => {
  const { element: i = "div", options: a, events: o, defer: c, children: u, ...h } = t, m = i, v = xn(null), b = xn(null), [S, w] = z8({ options: a, events: o, defer: c });
  return Xn(() => {
    const { current: E } = v, { current: R } = b;
    if (!E)
      return;
    const M = E;
    return S(
      i === "body" ? {
        target: M,
        cancel: {
          body: null
        }
      } : {
        target: M,
        elements: {
          viewport: R,
          content: R
        }
      }
    ), () => {
      var A;
      return (A = w()) == null ? void 0 : A.destroy();
    };
  }, [S, i]), Xx(
    e,
    () => ({
      osInstance: w,
      getElement: () => v.current
    }),
    []
  ), // @ts-ignore
  /* @__PURE__ */ rp.createElement(m, { "data-overlayscrollbars-initialize": "", ref: v, ...h }, i === "body" ? u : /* @__PURE__ */ rp.createElement("div", { "data-overlayscrollbars-contents": "", ref: b }, u));
}, V8 = Av(F8), e2 = ({
  children: t,
  maxHeight: e,
  options: i,
  onScroll: a = () => {
  },
  onScrollEndX: o = () => {
  },
  onScrollEndY: c = () => {
  }
}) => {
  const u = (b) => {
    console.debug("initialized:", b);
  }, h = (b) => {
    console.debug("destroyed:", b);
  }, m = (b) => {
    console.debug("updated:", b);
  }, v = (b) => {
    a({
      x: b.elements().viewport.scrollLeft,
      y: b.elements().viewport.scrollTop
    }), b.state().hasOverflow.x && b.state().overflowAmount.x === b.elements().viewport.scrollLeft && o(b), b.state().hasOverflow.y && b.state().overflowAmount.y === b.elements().viewport.scrollTop && c(b);
  };
  return /* @__PURE__ */ Ae.jsx(
    V8,
    {
      className: "h-overlay-scroll",
      style: {
        maxHeight: e === 0 ? "none" : `${e}px`
      },
      options: {
        ...i
      },
      events: {
        initialized: u,
        destroyed: h,
        updated: m,
        scroll: v
      },
      defer: !0,
      children: t
    }
  );
};
e2.displayName = "HScrollbars";
const j8 = ({ children: t, listWidth: e }) => {
  const { isActiveList: i, listPosition: a, dropdownListRef: o } = QE(), c = (v, b, S, w) => b + S > w ? {
    top: "auto",
    bottom: `${w - v}px`,
    marginBottom: "-1px"
  } : {
    top: `${b}px`,
    bottom: "auto",
    marginTop: "-1px"
  }, u = (v, b, S, w) => b + S > w ? {
    left: "auto",
    right: `${w - b}px`
  } : {
    left: `${v}px`,
    right: "auto"
  }, [h, m] = En({});
  return Xn(() => {
    (() => {
      if (!a) {
        m({
          position: "fixed"
        });
        return;
      }
      const { bottom: v, left: b, right: S, top: w, clientWidth: E, clientHeight: R } = a;
      if (!o.current) {
        m({});
        return;
      }
      const { height: M, width: A } = o.current.getBoundingClientRect();
      m({
        position: "fixed",
        zIndex: "220",
        ...c(w, v, M, R),
        ...u(b, S, A, E),
        width: `${e}px`
      });
    })();
  }, [a]), /* @__PURE__ */ Ae.jsx(Ae.Fragment, { children: i && /* @__PURE__ */ Ae.jsx(
    "div",
    {
      ref: o,
      style: h,
      className: "h_dropdown_list",
      children: /* @__PURE__ */ Ae.jsx(e2, { maxHeight: 300, children: t })
    }
  ) });
};
j8.displayName = "HDropdownList";
var t2 = typeof global == "object" && global && global.Object === Object && global, B8 = typeof self == "object" && self && self.Object === Object && self, ql = t2 || B8 || Function("return this")(), fp = ql.Symbol, n2 = Object.prototype, H8 = n2.hasOwnProperty, U8 = n2.toString, Ig = fp ? fp.toStringTag : void 0;
function I8(t) {
  var e = H8.call(t, Ig), i = t[Ig];
  try {
    t[Ig] = void 0;
    var a = !0;
  } catch {
  }
  var o = U8.call(t);
  return a && (e ? t[Ig] = i : delete t[Ig]), o;
}
var $8 = Object.prototype, W8 = $8.toString;
function Y8(t) {
  return W8.call(t);
}
var G8 = "[object Null]", K8 = "[object Undefined]", SO = fp ? fp.toStringTag : void 0;
function zv(t) {
  return t == null ? t === void 0 ? K8 : G8 : SO && SO in Object(t) ? I8(t) : Y8(t);
}
function wv(t) {
  return t != null && typeof t == "object";
}
var Bx = Array.isArray;
function i2(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var X8 = "[object AsyncFunction]", Q8 = "[object Function]", q8 = "[object GeneratorFunction]", Z8 = "[object Proxy]";
function r2(t) {
  if (!i2(t))
    return !1;
  var e = zv(t);
  return e == Q8 || e == q8 || e == X8 || e == Z8;
}
var gT = ql["__core-js_shared__"], _O = function() {
  var t = /[^.]+$/.exec(gT && gT.keys && gT.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function J8(t) {
  return !!_O && _O in t;
}
var e6 = Function.prototype, t6 = e6.toString;
function Kf(t) {
  if (t != null) {
    try {
      return t6.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var n6 = /[\\^$.*+?()[\]{}|]/g, i6 = /^\[object .+?Constructor\]$/, r6 = Function.prototype, a6 = Object.prototype, s6 = r6.toString, o6 = a6.hasOwnProperty, l6 = RegExp(
  "^" + s6.call(o6).replace(n6, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function u6(t) {
  if (!i2(t) || J8(t))
    return !1;
  var e = r2(t) ? l6 : i6;
  return e.test(Kf(t));
}
function c6(t, e) {
  return t == null ? void 0 : t[e];
}
function gp(t, e) {
  var i = c6(t, e);
  return u6(i) ? i : void 0;
}
var oE = gp(ql, "WeakMap"), f6 = 9007199254740991, d6 = /^(?:0|[1-9]\d*)$/;
function h6(t, e) {
  var i = typeof t;
  return e = e ?? f6, !!e && (i == "number" || i != "symbol" && d6.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function a2(t, e) {
  return t === e || t !== t && e !== e;
}
var p6 = 9007199254740991;
function s2(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= p6;
}
function m6(t) {
  return t != null && s2(t.length) && !r2(t);
}
var g6 = Object.prototype;
function v6(t) {
  var e = t && t.constructor, i = typeof e == "function" && e.prototype || g6;
  return t === i;
}
function y6(t, e) {
  for (var i = -1, a = Array(t); ++i < t; )
    a[i] = e(i);
  return a;
}
var b6 = "[object Arguments]";
function wO(t) {
  return wv(t) && zv(t) == b6;
}
var o2 = Object.prototype, x6 = o2.hasOwnProperty, S6 = o2.propertyIsEnumerable, _6 = wO(/* @__PURE__ */ function() {
  return arguments;
}()) ? wO : function(t) {
  return wv(t) && x6.call(t, "callee") && !S6.call(t, "callee");
};
function w6() {
  return !1;
}
var l2 = typeof exports == "object" && exports && !exports.nodeType && exports, CO = l2 && typeof module == "object" && module && !module.nodeType && module, C6 = CO && CO.exports === l2, TO = C6 ? ql.Buffer : void 0, T6 = TO ? TO.isBuffer : void 0, lE = T6 || w6, E6 = "[object Arguments]", D6 = "[object Array]", R6 = "[object Boolean]", k6 = "[object Date]", M6 = "[object Error]", A6 = "[object Function]", O6 = "[object Map]", P6 = "[object Number]", L6 = "[object Object]", N6 = "[object RegExp]", z6 = "[object Set]", F6 = "[object String]", V6 = "[object WeakMap]", j6 = "[object ArrayBuffer]", B6 = "[object DataView]", H6 = "[object Float32Array]", U6 = "[object Float64Array]", I6 = "[object Int8Array]", $6 = "[object Int16Array]", W6 = "[object Int32Array]", Y6 = "[object Uint8Array]", G6 = "[object Uint8ClampedArray]", K6 = "[object Uint16Array]", X6 = "[object Uint32Array]", Hn = {};
Hn[H6] = Hn[U6] = Hn[I6] = Hn[$6] = Hn[W6] = Hn[Y6] = Hn[G6] = Hn[K6] = Hn[X6] = !0;
Hn[E6] = Hn[D6] = Hn[j6] = Hn[R6] = Hn[B6] = Hn[k6] = Hn[M6] = Hn[A6] = Hn[O6] = Hn[P6] = Hn[L6] = Hn[N6] = Hn[z6] = Hn[F6] = Hn[V6] = !1;
function Q6(t) {
  return wv(t) && s2(t.length) && !!Hn[zv(t)];
}
function q6(t) {
  return function(e) {
    return t(e);
  };
}
var u2 = typeof exports == "object" && exports && !exports.nodeType && exports, sv = u2 && typeof module == "object" && module && !module.nodeType && module, Z6 = sv && sv.exports === u2, vT = Z6 && t2.process, EO = function() {
  try {
    var t = sv && sv.require && sv.require("util").types;
    return t || vT && vT.binding && vT.binding("util");
  } catch {
  }
}(), DO = EO && EO.isTypedArray, c2 = DO ? q6(DO) : Q6, J6 = Object.prototype, eY = J6.hasOwnProperty;
function tY(t, e) {
  var i = Bx(t), a = !i && _6(t), o = !i && !a && lE(t), c = !i && !a && !o && c2(t), u = i || a || o || c, h = u ? y6(t.length, String) : [], m = h.length;
  for (var v in t)
    eY.call(t, v) && !(u && // Safari 9 has enumerable `arguments.length` in strict mode.
    (v == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    o && (v == "offset" || v == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    c && (v == "buffer" || v == "byteLength" || v == "byteOffset") || // Skip index properties.
    h6(v, m))) && h.push(v);
  return h;
}
function nY(t, e) {
  return function(i) {
    return t(e(i));
  };
}
var iY = nY(Object.keys, Object), rY = Object.prototype, aY = rY.hasOwnProperty;
function sY(t) {
  if (!v6(t))
    return iY(t);
  var e = [];
  for (var i in Object(t))
    aY.call(t, i) && i != "constructor" && e.push(i);
  return e;
}
function oY(t) {
  return m6(t) ? tY(t) : sY(t);
}
var Cv = gp(Object, "create");
function lY() {
  this.__data__ = Cv ? Cv(null) : {}, this.size = 0;
}
function uY(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var cY = "__lodash_hash_undefined__", fY = Object.prototype, dY = fY.hasOwnProperty;
function hY(t) {
  var e = this.__data__;
  if (Cv) {
    var i = e[t];
    return i === cY ? void 0 : i;
  }
  return dY.call(e, t) ? e[t] : void 0;
}
var pY = Object.prototype, mY = pY.hasOwnProperty;
function gY(t) {
  var e = this.__data__;
  return Cv ? e[t] !== void 0 : mY.call(e, t);
}
var vY = "__lodash_hash_undefined__";
function yY(t, e) {
  var i = this.__data__;
  return this.size += this.has(t) ? 0 : 1, i[t] = Cv && e === void 0 ? vY : e, this;
}
function Yf(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var a = t[e];
    this.set(a[0], a[1]);
  }
}
Yf.prototype.clear = lY;
Yf.prototype.delete = uY;
Yf.prototype.get = hY;
Yf.prototype.has = gY;
Yf.prototype.set = yY;
function bY() {
  this.__data__ = [], this.size = 0;
}
function pS(t, e) {
  for (var i = t.length; i--; )
    if (a2(t[i][0], e))
      return i;
  return -1;
}
var xY = Array.prototype, SY = xY.splice;
function _Y(t) {
  var e = this.__data__, i = pS(e, t);
  if (i < 0)
    return !1;
  var a = e.length - 1;
  return i == a ? e.pop() : SY.call(e, i, 1), --this.size, !0;
}
function wY(t) {
  var e = this.__data__, i = pS(e, t);
  return i < 0 ? void 0 : e[i][1];
}
function CY(t) {
  return pS(this.__data__, t) > -1;
}
function TY(t, e) {
  var i = this.__data__, a = pS(i, t);
  return a < 0 ? (++this.size, i.push([t, e])) : i[a][1] = e, this;
}
function Zl(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var a = t[e];
    this.set(a[0], a[1]);
  }
}
Zl.prototype.clear = bY;
Zl.prototype.delete = _Y;
Zl.prototype.get = wY;
Zl.prototype.has = CY;
Zl.prototype.set = TY;
var Tv = gp(ql, "Map");
function EY() {
  this.size = 0, this.__data__ = {
    hash: new Yf(),
    map: new (Tv || Zl)(),
    string: new Yf()
  };
}
function DY(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function mS(t, e) {
  var i = t.__data__;
  return DY(e) ? i[typeof e == "string" ? "string" : "hash"] : i.map;
}
function RY(t) {
  var e = mS(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function kY(t) {
  return mS(this, t).get(t);
}
function MY(t) {
  return mS(this, t).has(t);
}
function AY(t, e) {
  var i = mS(this, t), a = i.size;
  return i.set(t, e), this.size += i.size == a ? 0 : 1, this;
}
function Xf(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var a = t[e];
    this.set(a[0], a[1]);
  }
}
Xf.prototype.clear = EY;
Xf.prototype.delete = RY;
Xf.prototype.get = kY;
Xf.prototype.has = MY;
Xf.prototype.set = AY;
function OY(t, e) {
  for (var i = -1, a = e.length, o = t.length; ++i < a; )
    t[o + i] = e[i];
  return t;
}
function PY() {
  this.__data__ = new Zl(), this.size = 0;
}
function LY(t) {
  var e = this.__data__, i = e.delete(t);
  return this.size = e.size, i;
}
function NY(t) {
  return this.__data__.get(t);
}
function zY(t) {
  return this.__data__.has(t);
}
var FY = 200;
function VY(t, e) {
  var i = this.__data__;
  if (i instanceof Zl) {
    var a = i.__data__;
    if (!Tv || a.length < FY - 1)
      return a.push([t, e]), this.size = ++i.size, this;
    i = this.__data__ = new Xf(a);
  }
  return i.set(t, e), this.size = i.size, this;
}
function Ju(t) {
  var e = this.__data__ = new Zl(t);
  this.size = e.size;
}
Ju.prototype.clear = PY;
Ju.prototype.delete = LY;
Ju.prototype.get = NY;
Ju.prototype.has = zY;
Ju.prototype.set = VY;
function jY(t, e) {
  for (var i = -1, a = t == null ? 0 : t.length, o = 0, c = []; ++i < a; ) {
    var u = t[i];
    e(u, i, t) && (c[o++] = u);
  }
  return c;
}
function BY() {
  return [];
}
var HY = Object.prototype, UY = HY.propertyIsEnumerable, RO = Object.getOwnPropertySymbols, IY = RO ? function(t) {
  return t == null ? [] : (t = Object(t), jY(RO(t), function(e) {
    return UY.call(t, e);
  }));
} : BY;
function $Y(t, e, i) {
  var a = e(t);
  return Bx(t) ? a : OY(a, i(t));
}
function kO(t) {
  return $Y(t, oY, IY);
}
var uE = gp(ql, "DataView"), cE = gp(ql, "Promise"), fE = gp(ql, "Set"), MO = "[object Map]", WY = "[object Object]", AO = "[object Promise]", OO = "[object Set]", PO = "[object WeakMap]", LO = "[object DataView]", YY = Kf(uE), GY = Kf(Tv), KY = Kf(cE), XY = Kf(fE), QY = Kf(oE), $u = zv;
(uE && $u(new uE(new ArrayBuffer(1))) != LO || Tv && $u(new Tv()) != MO || cE && $u(cE.resolve()) != AO || fE && $u(new fE()) != OO || oE && $u(new oE()) != PO) && ($u = function(t) {
  var e = zv(t), i = e == WY ? t.constructor : void 0, a = i ? Kf(i) : "";
  if (a)
    switch (a) {
      case YY:
        return LO;
      case GY:
        return MO;
      case KY:
        return AO;
      case XY:
        return OO;
      case QY:
        return PO;
    }
  return e;
});
var NO = ql.Uint8Array, qY = "__lodash_hash_undefined__";
function ZY(t) {
  return this.__data__.set(t, qY), this;
}
function JY(t) {
  return this.__data__.has(t);
}
function Hx(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.__data__ = new Xf(); ++e < i; )
    this.add(t[e]);
}
Hx.prototype.add = Hx.prototype.push = ZY;
Hx.prototype.has = JY;
function e9(t, e) {
  for (var i = -1, a = t == null ? 0 : t.length; ++i < a; )
    if (e(t[i], i, t))
      return !0;
  return !1;
}
function t9(t, e) {
  return t.has(e);
}
var n9 = 1, i9 = 2;
function f2(t, e, i, a, o, c) {
  var u = i & n9, h = t.length, m = e.length;
  if (h != m && !(u && m > h))
    return !1;
  var v = c.get(t), b = c.get(e);
  if (v && b)
    return v == e && b == t;
  var S = -1, w = !0, E = i & i9 ? new Hx() : void 0;
  for (c.set(t, e), c.set(e, t); ++S < h; ) {
    var R = t[S], M = e[S];
    if (a)
      var A = u ? a(M, R, S, e, t, c) : a(R, M, S, t, e, c);
    if (A !== void 0) {
      if (A)
        continue;
      w = !1;
      break;
    }
    if (E) {
      if (!e9(e, function(P, z) {
        if (!t9(E, z) && (R === P || o(R, P, i, a, c)))
          return E.push(z);
      })) {
        w = !1;
        break;
      }
    } else if (!(R === M || o(R, M, i, a, c))) {
      w = !1;
      break;
    }
  }
  return c.delete(t), c.delete(e), w;
}
function r9(t) {
  var e = -1, i = Array(t.size);
  return t.forEach(function(a, o) {
    i[++e] = [o, a];
  }), i;
}
function a9(t) {
  var e = -1, i = Array(t.size);
  return t.forEach(function(a) {
    i[++e] = a;
  }), i;
}
var s9 = 1, o9 = 2, l9 = "[object Boolean]", u9 = "[object Date]", c9 = "[object Error]", f9 = "[object Map]", d9 = "[object Number]", h9 = "[object RegExp]", p9 = "[object Set]", m9 = "[object String]", g9 = "[object Symbol]", v9 = "[object ArrayBuffer]", y9 = "[object DataView]", zO = fp ? fp.prototype : void 0, yT = zO ? zO.valueOf : void 0;
function b9(t, e, i, a, o, c, u) {
  switch (i) {
    case y9:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case v9:
      return !(t.byteLength != e.byteLength || !c(new NO(t), new NO(e)));
    case l9:
    case u9:
    case d9:
      return a2(+t, +e);
    case c9:
      return t.name == e.name && t.message == e.message;
    case h9:
    case m9:
      return t == e + "";
    case f9:
      var h = r9;
    case p9:
      var m = a & s9;
      if (h || (h = a9), t.size != e.size && !m)
        return !1;
      var v = u.get(t);
      if (v)
        return v == e;
      a |= o9, u.set(t, e);
      var b = f2(h(t), h(e), a, o, c, u);
      return u.delete(t), b;
    case g9:
      if (yT)
        return yT.call(t) == yT.call(e);
  }
  return !1;
}
var x9 = 1, S9 = Object.prototype, _9 = S9.hasOwnProperty;
function w9(t, e, i, a, o, c) {
  var u = i & x9, h = kO(t), m = h.length, v = kO(e), b = v.length;
  if (m != b && !u)
    return !1;
  for (var S = m; S--; ) {
    var w = h[S];
    if (!(u ? w in e : _9.call(e, w)))
      return !1;
  }
  var E = c.get(t), R = c.get(e);
  if (E && R)
    return E == e && R == t;
  var M = !0;
  c.set(t, e), c.set(e, t);
  for (var A = u; ++S < m; ) {
    w = h[S];
    var P = t[w], z = e[w];
    if (a)
      var B = u ? a(z, P, w, e, t, c) : a(P, z, w, t, e, c);
    if (!(B === void 0 ? P === z || o(P, z, i, a, c) : B)) {
      M = !1;
      break;
    }
    A || (A = w == "constructor");
  }
  if (M && !A) {
    var j = t.constructor, F = e.constructor;
    j != F && "constructor" in t && "constructor" in e && !(typeof j == "function" && j instanceof j && typeof F == "function" && F instanceof F) && (M = !1);
  }
  return c.delete(t), c.delete(e), M;
}
var C9 = 1, FO = "[object Arguments]", VO = "[object Array]", ix = "[object Object]", T9 = Object.prototype, jO = T9.hasOwnProperty;
function E9(t, e, i, a, o, c) {
  var u = Bx(t), h = Bx(e), m = u ? VO : $u(t), v = h ? VO : $u(e);
  m = m == FO ? ix : m, v = v == FO ? ix : v;
  var b = m == ix, S = v == ix, w = m == v;
  if (w && lE(t)) {
    if (!lE(e))
      return !1;
    u = !0, b = !1;
  }
  if (w && !b)
    return c || (c = new Ju()), u || c2(t) ? f2(t, e, i, a, o, c) : b9(t, e, m, i, a, o, c);
  if (!(i & C9)) {
    var E = b && jO.call(t, "__wrapped__"), R = S && jO.call(e, "__wrapped__");
    if (E || R) {
      var M = E ? t.value() : t, A = R ? e.value() : e;
      return c || (c = new Ju()), o(M, A, i, a, c);
    }
  }
  return w ? (c || (c = new Ju()), w9(t, e, i, a, o, c)) : !1;
}
function d2(t, e, i, a, o) {
  return t === e ? !0 : t == null || e == null || !wv(t) && !wv(e) ? t !== t && e !== e : E9(t, e, i, a, d2, o);
}
function dE(t, e) {
  return d2(t, e);
}
const yQ = (t, e) => dE(t, e), bQ = ({ data: t, backgroundColor: e, borderColor: i, borderWidth: a, labelFillStyle: o, legendLabelsColor: c }) => {
  const u = xn(null), h = xn(null);
  return Xn(() => {
    var v;
    h.current && h.current.destroy();
    const m = (v = u.current) == null ? void 0 : v.getContext("2d");
    if (m)
      return h.current = new Fo(m, {
        type: "pie",
        data: {
          labels: t.map((b) => b.label),
          datasets: [
            {
              data: t.map((b) => b.value),
              backgroundColor: e || Array.from({ length: t.length }, (b, S) => S % 2 === 0 ? "#4CAF50" : "#2196F3"),
              borderColor: i || Array.from({ length: t.length }, (b, S) => S % 2 === 0 ? "#45a049" : "#1e88e5"),
              borderWidth: a || 1
            }
          ]
        },
        options: {
          responsive: !0,
          maintainAspectRatio: !1,
          plugins: {
            legend: {
              display: !0,
              position: "bottom",
              labels: {
                color: c || "#333"
              }
            },
            tooltip: {
              enabled: !0,
              callbacks: {
                label: (b) => `${b.label}: ${b.parsed}`
              }
            }
          },
          animation: {
            duration: 1e3,
            easing: "easeInOutQuart"
          },
          layout: {
            padding: {
              top: 20,
              right: 10,
              bottom: 10,
              left: 10
            }
          }
        },
        plugins: [
          {
            id: "percentage",
            afterDraw: (b) => {
              const S = b.ctx, w = b.data.datasets[0].data.reduce((E, R) => E + parseFloat(R + ""), 0);
              b.data.datasets.forEach((E, R) => {
                b.getDatasetMeta(R).data.forEach((A) => {
                  const P = A.innerRadius + (A.outerRadius - A.innerRadius) / 2, z = A.startAngle, B = A.endAngle, j = z + (B - z) / 2, F = P * Math.cos(j), $ = P * Math.sin(j);
                  S.save(), S.translate(A.x, A.y), S.fillStyle = o || "#000000", S.font = "12px Arial", S.textAlign = "center", S.textBaseline = "middle";
                  const I = (parseFloat(E.data[A.$context.index] + "") / w * 100).toFixed(1) + "%";
                  S.fillText(I, F, $), S.restore();
                });
              });
            }
          }
        ]
      }), () => {
        h.current && h.current.destroy();
      };
  }, [t]), /* @__PURE__ */ Ae.jsx("canvas", { ref: u });
}, c1 = Wo({});
function f1(t) {
  const e = xn(null);
  return e.current === null && (e.current = t()), e.current;
}
const gS = Wo(null), d1 = Wo({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
});
class D9 extends kE.Component {
  getSnapshotBeforeUpdate(e) {
    const i = this.props.childRef.current;
    if (i && e.isPresent && !this.props.isPresent) {
      const a = this.props.sizeRef.current;
      a.height = i.offsetHeight || 0, a.width = i.offsetWidth || 0, a.top = i.offsetTop, a.left = i.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function R9({ children: t, isPresent: e }) {
  const i = Qx(), a = xn(null), o = xn({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: c } = Oi(d1);
  return rL(() => {
    const { width: u, height: h, top: m, left: v } = o.current;
    if (e || !a.current || !u || !h)
      return;
    a.current.dataset.motionPopId = i;
    const b = document.createElement("style");
    return c && (b.nonce = c), document.head.appendChild(b), b.sheet && b.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${u}px !important;
            height: ${h}px !important;
            top: ${m}px !important;
            left: ${v}px !important;
          }
        `), () => {
      document.head.removeChild(b);
    };
  }, [e]), Ae.jsx(D9, { isPresent: e, childRef: a, sizeRef: o, children: kE.cloneElement(t, { ref: a }) });
}
const k9 = ({ children: t, initial: e, isPresent: i, onExitComplete: a, custom: o, presenceAffectsLayout: c, mode: u }) => {
  const h = f1(M9), m = Qx(), v = ME((S) => {
    h.set(S, !0);
    for (const w of h.values())
      if (!w)
        return;
    a && a();
  }, [h, a]), b = Zs(
    () => ({
      id: m,
      initial: e,
      isPresent: i,
      custom: o,
      onExitComplete: v,
      register: (S) => (h.set(S, !1), () => h.delete(S))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    c ? [Math.random(), v] : [i, v]
  );
  return Zs(() => {
    h.forEach((S, w) => h.set(w, !1));
  }, [i]), kE.useEffect(() => {
    !i && !h.size && a && a();
  }, [i]), u === "popLayout" && (t = Ae.jsx(R9, { isPresent: i, children: t })), Ae.jsx(gS.Provider, { value: b, children: t });
};
function M9() {
  return /* @__PURE__ */ new Map();
}
function h2(t = !0) {
  const e = Oi(gS);
  if (e === null)
    return [!0, null];
  const { isPresent: i, onExitComplete: a, register: o } = e, c = Qx();
  Xn(() => {
    t && o(c);
  }, [t]);
  const u = ME(() => t && a && a(c), [c, a, t]);
  return !i && a ? [!1, u] : [!0];
}
const rx = (t) => t.key || "";
function BO(t) {
  const e = [];
  return LU.forEach(t, (i) => {
    aL(i) && e.push(i);
  }), e;
}
const h1 = typeof window < "u", p2 = h1 ? NU : Xn, m2 = ({ children: t, custom: e, initial: i = !0, onExitComplete: a, presenceAffectsLayout: o = !0, mode: c = "sync", propagate: u = !1 }) => {
  const [h, m] = h2(u), v = Zs(() => BO(t), [t]), b = u && !h ? [] : v.map(rx), S = xn(!0), w = xn(v), E = f1(() => /* @__PURE__ */ new Map()), [R, M] = En(v), [A, P] = En(v);
  p2(() => {
    S.current = !1, w.current = v;
    for (let j = 0; j < A.length; j++) {
      const F = rx(A[j]);
      b.includes(F) ? E.delete(F) : E.get(F) !== !0 && E.set(F, !1);
    }
  }, [A, b.length, b.join("-")]);
  const z = [];
  if (v !== R) {
    let j = [...v];
    for (let F = 0; F < A.length; F++) {
      const $ = A[F], I = rx($);
      b.includes(I) || (j.splice(F, 0, $), z.push($));
    }
    c === "wait" && z.length && (j = z), P(BO(j)), M(v);
    return;
  }
  process.env.NODE_ENV !== "production" && c === "wait" && A.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: B } = Oi(c1);
  return Ae.jsx(Ae.Fragment, { children: A.map((j) => {
    const F = rx(j), $ = u && !h ? !1 : v === A || b.includes(F), I = () => {
      if (E.has(F))
        E.set(F, !0);
      else
        return;
      let K = !0;
      E.forEach((ee) => {
        ee || (K = !1);
      }), K && (B == null || B(), P(w.current), u && (m == null || m()), a && a());
    };
    return Ae.jsx(k9, { isPresent: $, initial: !S.current || i ? void 0 : !1, custom: $ ? void 0 : e, presenceAffectsLayout: o, mode: c, onExitComplete: $ ? void 0 : I, children: j }, F);
  }) });
}, Ea = /* @__NO_SIDE_EFFECTS__ */ (t) => t;
let vp = Ea, nc = Ea;
process.env.NODE_ENV !== "production" && (vp = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, nc = (t, e) => {
  if (!t)
    throw new Error(e);
});
// @__NO_SIDE_EFFECTS__
function p1(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const dp = /* @__NO_SIDE_EFFECTS__ */ (t, e, i) => {
  const a = e - t;
  return a === 0 ? 1 : (i - t) / a;
}, Ho = /* @__NO_SIDE_EFFECTS__ */ (t) => t * 1e3, Gl = /* @__NO_SIDE_EFFECTS__ */ (t) => t / 1e3, A9 = {
  useManualTiming: !1
};
function O9(t) {
  let e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), a = !1, o = !1;
  const c = /* @__PURE__ */ new WeakSet();
  let u = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function h(v) {
    c.has(v) && (m.schedule(v), t()), v(u);
  }
  const m = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (v, b = !1, S = !1) => {
      const E = S && a ? e : i;
      return b && c.add(v), E.has(v) || E.add(v), v;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (v) => {
      i.delete(v), c.delete(v);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (v) => {
      if (u = v, a) {
        o = !0;
        return;
      }
      a = !0, [e, i] = [i, e], e.forEach(h), e.clear(), a = !1, o && (o = !1, m.process(v));
    }
  };
  return m;
}
const ax = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], P9 = 40;
function g2(t, e) {
  let i = !1, a = !0;
  const o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, c = () => i = !0, u = ax.reduce((P, z) => (P[z] = O9(c), P), {}), { read: h, resolveKeyframes: m, update: v, preRender: b, render: S, postRender: w } = u, E = () => {
    const P = performance.now();
    i = !1, o.delta = a ? 1e3 / 60 : Math.max(Math.min(P - o.timestamp, P9), 1), o.timestamp = P, o.isProcessing = !0, h.process(o), m.process(o), v.process(o), b.process(o), S.process(o), w.process(o), o.isProcessing = !1, i && e && (a = !1, t(E));
  }, R = () => {
    i = !0, a = !0, o.isProcessing || t(E);
  };
  return { schedule: ax.reduce((P, z) => {
    const B = u[z];
    return P[z] = (j, F = !1, $ = !1) => (i || R(), B.schedule(j, F, $)), P;
  }, {}), cancel: (P) => {
    for (let z = 0; z < ax.length; z++)
      u[ax[z]].cancel(P);
  }, state: o, steps: u };
}
const { schedule: $n, cancel: ic, state: vr, steps: bT } = g2(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Ea, !0), v2 = Wo({ strict: !1 }), HO = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, hp = {};
for (const t in HO)
  hp[t] = {
    isEnabled: (e) => HO[t].some((i) => !!e[i])
  };
function L9(t) {
  for (const e in t)
    hp[e] = {
      ...hp[e],
      ...t[e]
    };
}
const N9 = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function Ux(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || N9.has(t);
}
let y2 = (t) => !Ux(t);
function z9(t) {
  t && (y2 = (e) => e.startsWith("on") ? !Ux(e) : t(e));
}
try {
  z9(require("@emotion/is-prop-valid").default);
} catch {
}
function F9(t, e, i) {
  const a = {};
  for (const o in t)
    o === "values" && typeof t.values == "object" || (y2(o) || i === !0 && Ux(o) || !e && !Ux(o) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && o.startsWith("onDrag")) && (a[o] = t[o]);
  return a;
}
const UO = /* @__PURE__ */ new Set();
function vS(t, e, i) {
  t || UO.has(e) || (console.warn(e), UO.add(e));
}
function V9(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), i = (...a) => (process.env.NODE_ENV !== "production" && vS(!1, "motion() is deprecated. Use motion.create() instead."), t(...a));
  return new Proxy(i, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (a, o) => o === "create" ? t : (e.has(o) || e.set(o, t(o)), e.get(o))
  });
}
const yS = Wo({});
function Ev(t) {
  return typeof t == "string" || Array.isArray(t);
}
function bS(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const m1 = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], g1 = ["initial", ...m1];
function xS(t) {
  return bS(t.animate) || g1.some((e) => Ev(t[e]));
}
function b2(t) {
  return !!(xS(t) || t.variants);
}
function j9(t, e) {
  if (xS(t)) {
    const { initial: i, animate: a } = t;
    return {
      initial: i === !1 || Ev(i) ? i : void 0,
      animate: Ev(a) ? a : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function B9(t) {
  const { initial: e, animate: i } = j9(t, Oi(yS));
  return Zs(() => ({ initial: e, animate: i }), [IO(e), IO(i)]);
}
function IO(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const H9 = Symbol.for("motionComponentSymbol");
function Qh(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
function U9(t, e, i) {
  return ME(
    (a) => {
      a && t.onMount && t.onMount(a), e && (a ? e.mount(a) : e.unmount()), i && (typeof i == "function" ? i(a) : Qh(i) && (i.current = a));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
const v1 = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), I9 = "framerAppearId", x2 = "data-" + v1(I9), { schedule: y1 } = g2(queueMicrotask, !1), S2 = Wo({});
function $9(t, e, i, a, o) {
  var c, u;
  const { visualElement: h } = Oi(yS), m = Oi(v2), v = Oi(gS), b = Oi(d1).reducedMotion, S = xn(null);
  a = a || m.renderer, !S.current && a && (S.current = a(t, {
    visualState: e,
    parent: h,
    props: i,
    presenceContext: v,
    blockInitialAnimation: v ? v.initial === !1 : !1,
    reducedMotionConfig: b
  }));
  const w = S.current, E = Oi(S2);
  w && !w.projection && o && (w.type === "html" || w.type === "svg") && W9(S.current, i, o, E);
  const R = xn(!1);
  rL(() => {
    w && R.current && w.update(i, v);
  });
  const M = i[x2], A = xn(!!M && !(!((c = window.MotionHandoffIsComplete) === null || c === void 0) && c.call(window, M)) && ((u = window.MotionHasOptimisedAnimation) === null || u === void 0 ? void 0 : u.call(window, M)));
  return p2(() => {
    w && (R.current = !0, window.MotionIsMounted = !0, w.updateFeatures(), y1.render(w.render), A.current && w.animationState && w.animationState.animateChanges());
  }), Xn(() => {
    w && (!A.current && w.animationState && w.animationState.animateChanges(), A.current && (queueMicrotask(() => {
      var P;
      (P = window.MotionHandoffMarkAsComplete) === null || P === void 0 || P.call(window, M);
    }), A.current = !1));
  }), w;
}
function W9(t, e, i, a) {
  const { layoutId: o, layout: c, drag: u, dragConstraints: h, layoutScroll: m, layoutRoot: v } = e;
  t.projection = new i(t.latestValues, e["data-framer-portal-id"] ? void 0 : _2(t.parent)), t.projection.setOptions({
    layoutId: o,
    layout: c,
    alwaysMeasureLayout: !!u || h && Qh(h),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof c == "string" ? c : "both",
    initialPromotionConfig: a,
    layoutScroll: m,
    layoutRoot: v
  });
}
function _2(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : _2(t.parent);
}
function Y9({ preloadedFeatures: t, createVisualElement: e, useRender: i, useVisualState: a, Component: o }) {
  var c, u;
  t && L9(t);
  function h(v, b) {
    let S;
    const w = {
      ...Oi(d1),
      ...v,
      layoutId: G9(v)
    }, { isStatic: E } = w, R = B9(v), M = a(v, E);
    if (!E && h1) {
      K9(w, t);
      const A = X9(w);
      S = A.MeasureLayout, R.visualElement = $9(o, M, w, e, A.ProjectionNode);
    }
    return Ae.jsxs(yS.Provider, { value: R, children: [S && R.visualElement ? Ae.jsx(S, { visualElement: R.visualElement, ...w }) : null, i(o, v, U9(M, R.visualElement, b), M, E, R.visualElement)] });
  }
  h.displayName = `motion.${typeof o == "string" ? o : `create(${(u = (c = o.displayName) !== null && c !== void 0 ? c : o.name) !== null && u !== void 0 ? u : ""})`}`;
  const m = Av(h);
  return m[H9] = o, m;
}
function G9({ layoutId: t }) {
  const e = Oi(c1).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function K9(t, e) {
  const i = Oi(v2).strict;
  if (process.env.NODE_ENV !== "production" && e && i) {
    const a = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? vp(!1, a) : nc(!1, a);
  }
}
function X9(t) {
  const { drag: e, layout: i } = hp;
  if (!e && !i)
    return {};
  const a = { ...e, ...i };
  return {
    MeasureLayout: e != null && e.isEnabled(t) || i != null && i.isEnabled(t) ? a.MeasureLayout : void 0,
    ProjectionNode: a.ProjectionNode
  };
}
const Q9 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function b1(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Q9.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function $O(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((i, a) => {
    e[0][a] = i.get(), e[1][a] = i.getVelocity();
  }), e;
}
function x1(t, e, i, a) {
  if (typeof e == "function") {
    const [o, c] = $O(a);
    e = e(i !== void 0 ? i : t.custom, o, c);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [o, c] = $O(a);
    e = e(i !== void 0 ? i : t.custom, o, c);
  }
  return e;
}
const hE = (t) => Array.isArray(t), q9 = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), Z9 = (t) => hE(t) ? t[t.length - 1] || 0 : t, jr = (t) => !!(t && t.getVelocity);
function Sx(t) {
  const e = jr(t) ? t.get() : t;
  return q9(e) ? e.toValue() : e;
}
function J9({ scrapeMotionValuesFromProps: t, createRenderState: e, onUpdate: i }, a, o, c) {
  const u = {
    latestValues: e7(a, o, c, t),
    renderState: e()
  };
  return i && (u.onMount = (h) => i({ props: a, current: h, ...u }), u.onUpdate = (h) => i(h)), u;
}
const w2 = (t) => (e, i) => {
  const a = Oi(yS), o = Oi(gS), c = () => J9(t, e, a, o);
  return i ? c() : f1(c);
};
function e7(t, e, i, a) {
  const o = {}, c = a(t, {});
  for (const w in c)
    o[w] = Sx(c[w]);
  let { initial: u, animate: h } = t;
  const m = xS(t), v = b2(t);
  e && v && !m && t.inherit !== !1 && (u === void 0 && (u = e.initial), h === void 0 && (h = e.animate));
  let b = i ? i.initial === !1 : !1;
  b = b || u === !1;
  const S = b ? h : u;
  if (S && typeof S != "boolean" && !bS(S)) {
    const w = Array.isArray(S) ? S : [S];
    for (let E = 0; E < w.length; E++) {
      const R = x1(t, w[E]);
      if (R) {
        const { transitionEnd: M, transition: A, ...P } = R;
        for (const z in P) {
          let B = P[z];
          if (Array.isArray(B)) {
            const j = b ? B.length - 1 : 0;
            B = B[j];
          }
          B !== null && (o[z] = B);
        }
        for (const z in M)
          o[z] = M[z];
      }
    }
  }
  return o;
}
const yp = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Qf = new Set(yp), C2 = (t) => (e) => typeof e == "string" && e.startsWith(t), T2 = /* @__PURE__ */ C2("--"), t7 = /* @__PURE__ */ C2("var(--"), S1 = (t) => t7(t) ? n7.test(t.split("/*")[0].trim()) : !1, n7 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, E2 = (t, e) => e && typeof t == "number" ? e.transform(t) : t, Xl = (t, e, i) => i > e ? e : i < t ? t : i, bp = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, Dv = {
  ...bp,
  transform: (t) => Xl(0, 1, t)
}, sx = {
  ...bp,
  default: 1
}, Fv = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), Iu = /* @__PURE__ */ Fv("deg"), Uo = /* @__PURE__ */ Fv("%"), bt = /* @__PURE__ */ Fv("px"), i7 = /* @__PURE__ */ Fv("vh"), r7 = /* @__PURE__ */ Fv("vw"), WO = {
  ...Uo,
  parse: (t) => Uo.parse(t) / 100,
  transform: (t) => Uo.transform(t * 100)
}, a7 = {
  // Border props
  borderWidth: bt,
  borderTopWidth: bt,
  borderRightWidth: bt,
  borderBottomWidth: bt,
  borderLeftWidth: bt,
  borderRadius: bt,
  radius: bt,
  borderTopLeftRadius: bt,
  borderTopRightRadius: bt,
  borderBottomRightRadius: bt,
  borderBottomLeftRadius: bt,
  // Positioning props
  width: bt,
  maxWidth: bt,
  height: bt,
  maxHeight: bt,
  top: bt,
  right: bt,
  bottom: bt,
  left: bt,
  // Spacing props
  padding: bt,
  paddingTop: bt,
  paddingRight: bt,
  paddingBottom: bt,
  paddingLeft: bt,
  margin: bt,
  marginTop: bt,
  marginRight: bt,
  marginBottom: bt,
  marginLeft: bt,
  // Misc
  backgroundPositionX: bt,
  backgroundPositionY: bt
}, s7 = {
  rotate: Iu,
  rotateX: Iu,
  rotateY: Iu,
  rotateZ: Iu,
  scale: sx,
  scaleX: sx,
  scaleY: sx,
  scaleZ: sx,
  skew: Iu,
  skewX: Iu,
  skewY: Iu,
  distance: bt,
  translateX: bt,
  translateY: bt,
  translateZ: bt,
  x: bt,
  y: bt,
  z: bt,
  perspective: bt,
  transformPerspective: bt,
  opacity: Dv,
  originX: WO,
  originY: WO,
  originZ: bt
}, YO = {
  ...bp,
  transform: Math.round
}, _1 = {
  ...a7,
  ...s7,
  zIndex: YO,
  size: bt,
  // SVG
  fillOpacity: Dv,
  strokeOpacity: Dv,
  numOctaves: YO
}, o7 = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, l7 = yp.length;
function u7(t, e, i) {
  let a = "", o = !0;
  for (let c = 0; c < l7; c++) {
    const u = yp[c], h = t[u];
    if (h === void 0)
      continue;
    let m = !0;
    if (typeof h == "number" ? m = h === (u.startsWith("scale") ? 1 : 0) : m = parseFloat(h) === 0, !m || i) {
      const v = E2(h, _1[u]);
      if (!m) {
        o = !1;
        const b = o7[u] || u;
        a += `${b}(${v}) `;
      }
      i && (e[u] = v);
    }
  }
  return a = a.trim(), i ? a = i(e, o ? "" : a) : o && (a = "none"), a;
}
function w1(t, e, i) {
  const { style: a, vars: o, transformOrigin: c } = t;
  let u = !1, h = !1;
  for (const m in e) {
    const v = e[m];
    if (Qf.has(m)) {
      u = !0;
      continue;
    } else if (T2(m)) {
      o[m] = v;
      continue;
    } else {
      const b = E2(v, _1[m]);
      m.startsWith("origin") ? (h = !0, c[m] = b) : a[m] = b;
    }
  }
  if (e.transform || (u || i ? a.transform = u7(e, t.transform, i) : a.transform && (a.transform = "none")), h) {
    const { originX: m = "50%", originY: v = "50%", originZ: b = 0 } = c;
    a.transformOrigin = `${m} ${v} ${b}`;
  }
}
const c7 = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, f7 = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function d7(t, e, i = 1, a = 0, o = !0) {
  t.pathLength = 1;
  const c = o ? c7 : f7;
  t[c.offset] = bt.transform(-a);
  const u = bt.transform(e), h = bt.transform(i);
  t[c.array] = `${u} ${h}`;
}
function GO(t, e, i) {
  return typeof t == "string" ? t : bt.transform(e + i * t);
}
function h7(t, e, i) {
  const a = GO(e, t.x, t.width), o = GO(i, t.y, t.height);
  return `${a} ${o}`;
}
function C1(t, {
  attrX: e,
  attrY: i,
  attrScale: a,
  originX: o,
  originY: c,
  pathLength: u,
  pathSpacing: h = 1,
  pathOffset: m = 0,
  // This is object creation, which we try to avoid per-frame.
  ...v
}, b, S) {
  if (w1(t, v, S), b) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: w, style: E, dimensions: R } = t;
  w.transform && (R && (E.transform = w.transform), delete w.transform), R && (o !== void 0 || c !== void 0 || E.transform) && (E.transformOrigin = h7(R, o !== void 0 ? o : 0.5, c !== void 0 ? c : 0.5)), e !== void 0 && (w.x = e), i !== void 0 && (w.y = i), a !== void 0 && (w.scale = a), u !== void 0 && d7(w, u, h, m, !1);
}
const T1 = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), D2 = () => ({
  ...T1(),
  attrs: {}
}), E1 = (t) => typeof t == "string" && t.toLowerCase() === "svg";
function R2(t, { style: e, vars: i }, a, o) {
  Object.assign(t.style, e, o && o.getProjectionStyles(a));
  for (const c in i)
    t.style.setProperty(c, i[c]);
}
const k2 = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function M2(t, e, i, a) {
  R2(t, e, void 0, a);
  for (const o in e.attrs)
    t.setAttribute(k2.has(o) ? o : v1(o), e.attrs[o]);
}
const Ix = {};
function p7(t) {
  Object.assign(Ix, t);
}
function A2(t, { layout: e, layoutId: i }) {
  return Qf.has(t) || t.startsWith("origin") || (e || i !== void 0) && (!!Ix[t] || t === "opacity");
}
function D1(t, e, i) {
  var a;
  const { style: o } = t, c = {};
  for (const u in o)
    (jr(o[u]) || e.style && jr(e.style[u]) || A2(u, t) || ((a = i == null ? void 0 : i.getValue(u)) === null || a === void 0 ? void 0 : a.liveStyle) !== void 0) && (c[u] = o[u]);
  return c;
}
function O2(t, e, i) {
  const a = D1(t, e, i);
  for (const o in t)
    if (jr(t[o]) || jr(e[o])) {
      const c = yp.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
      a[c] = t[o];
    }
  return a;
}
function m7(t, e) {
  try {
    e.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
  } catch {
    e.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
const KO = ["x", "y", "width", "height", "cx", "cy", "r"], g7 = {
  useVisualState: w2({
    scrapeMotionValuesFromProps: O2,
    createRenderState: D2,
    onUpdate: ({ props: t, prevProps: e, current: i, renderState: a, latestValues: o }) => {
      if (!i)
        return;
      let c = !!t.drag;
      if (!c) {
        for (const h in o)
          if (Qf.has(h)) {
            c = !0;
            break;
          }
      }
      if (!c)
        return;
      let u = !e;
      if (e)
        for (let h = 0; h < KO.length; h++) {
          const m = KO[h];
          t[m] !== e[m] && (u = !0);
        }
      u && $n.read(() => {
        m7(i, a), $n.render(() => {
          C1(a, o, E1(i.tagName), t.transformTemplate), M2(i, a);
        });
      });
    }
  })
}, v7 = {
  useVisualState: w2({
    scrapeMotionValuesFromProps: D1,
    createRenderState: T1
  })
};
function P2(t, e, i) {
  for (const a in e)
    !jr(e[a]) && !A2(a, i) && (t[a] = e[a]);
}
function y7({ transformTemplate: t }, e) {
  return Zs(() => {
    const i = T1();
    return w1(i, e, t), Object.assign({}, i.vars, i.style);
  }, [e]);
}
function b7(t, e) {
  const i = t.style || {}, a = {};
  return P2(a, i, t), Object.assign(a, y7(t, e)), a;
}
function x7(t, e) {
  const i = {}, a = b7(t, e);
  return t.drag && t.dragListener !== !1 && (i.draggable = !1, a.userSelect = a.WebkitUserSelect = a.WebkitTouchCallout = "none", a.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (i.tabIndex = 0), i.style = a, i;
}
function S7(t, e, i, a) {
  const o = Zs(() => {
    const c = D2();
    return C1(c, e, E1(a), t.transformTemplate), {
      ...c.attrs,
      style: { ...c.style }
    };
  }, [e]);
  if (t.style) {
    const c = {};
    P2(c, t.style, t), o.style = { ...c, ...o.style };
  }
  return o;
}
function _7(t = !1) {
  return (i, a, o, { latestValues: c }, u) => {
    const m = (b1(i) ? S7 : x7)(a, c, u, i), v = F9(a, typeof i == "string", t), b = i !== sL ? { ...v, ...m, ref: o } : {}, { children: S } = a, w = Zs(() => jr(S) ? S.get() : S, [S]);
    return zU(i, {
      ...b,
      children: w
    });
  };
}
function w7(t, e) {
  return function(a, { forwardMotionProps: o } = { forwardMotionProps: !1 }) {
    const u = {
      ...b1(a) ? g7 : v7,
      preloadedFeatures: t,
      useRender: _7(o),
      createVisualElement: e,
      Component: a
    };
    return Y9(u);
  };
}
function L2(t, e) {
  if (!Array.isArray(e))
    return !1;
  const i = e.length;
  if (i !== t.length)
    return !1;
  for (let a = 0; a < i; a++)
    if (e[a] !== t[a])
      return !1;
  return !0;
}
function SS(t, e, i) {
  const a = t.getProps();
  return x1(a, e, i !== void 0 ? i : a.custom, t);
}
const C7 = /* @__PURE__ */ p1(() => window.ScrollTimeline !== void 0);
class T7 {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((e) => "finished" in e ? e.finished : e));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, i) {
    for (let a = 0; a < this.animations.length; a++)
      this.animations[a][e] = i;
  }
  attachTimeline(e, i) {
    const a = this.animations.map((o) => {
      if (C7() && o.attachTimeline)
        return o.attachTimeline(e);
      if (typeof i == "function")
        return i(o);
    });
    return () => {
      a.forEach((o, c) => {
        o && o(), this.animations[c].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let i = 0; i < this.animations.length; i++)
      e = Math.max(e, this.animations[i].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((i) => i[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class E7 extends T7 {
  then(e, i) {
    return Promise.all(this.animations).then(e).catch(i);
  }
}
function R1(t, e) {
  return t ? t[e] || t.default || t : void 0;
}
const pE = 2e4;
function N2(t) {
  let e = 0;
  const i = 50;
  let a = t.next(e);
  for (; !a.done && e < pE; )
    e += i, a = t.next(e);
  return e >= pE ? 1 / 0 : e;
}
function k1(t) {
  return typeof t == "function";
}
function XO(t, e) {
  t.timeline = e, t.onfinish = null;
}
const M1 = (t) => Array.isArray(t) && typeof t[0] == "number", D7 = {
  linearEasing: void 0
};
function R7(t, e) {
  const i = /* @__PURE__ */ p1(t);
  return () => {
    var a;
    return (a = D7[e]) !== null && a !== void 0 ? a : i();
  };
}
const $x = /* @__PURE__ */ R7(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), z2 = (t, e, i = 10) => {
  let a = "";
  const o = Math.max(Math.round(e / i), 2);
  for (let c = 0; c < o; c++)
    a += t(/* @__PURE__ */ dp(0, o - 1, c)) + ", ";
  return `linear(${a.substring(0, a.length - 2)})`;
};
function F2(t) {
  return !!(typeof t == "function" && $x() || !t || typeof t == "string" && (t in mE || $x()) || M1(t) || Array.isArray(t) && t.every(F2));
}
const Zg = ([t, e, i, a]) => `cubic-bezier(${t}, ${e}, ${i}, ${a})`, mE = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Zg([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Zg([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Zg([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Zg([0.33, 1.53, 0.69, 0.99])
};
function V2(t, e) {
  if (t)
    return typeof t == "function" && $x() ? z2(t, e) : M1(t) ? Zg(t) : Array.isArray(t) ? t.map((i) => V2(i, e) || mE.easeOut) : mE[t];
}
const Ks = {
  x: !1,
  y: !1
};
function j2() {
  return Ks.x || Ks.y;
}
function k7(t, e, i) {
  var a;
  if (t instanceof Element)
    return [t];
  if (typeof t == "string") {
    let o = document;
    const c = (a = void 0) !== null && a !== void 0 ? a : o.querySelectorAll(t);
    return c ? Array.from(c) : [];
  }
  return Array.from(t);
}
function B2(t, e) {
  const i = k7(t), a = new AbortController(), o = {
    passive: !0,
    ...e,
    signal: a.signal
  };
  return [i, o, () => a.abort()];
}
function QO(t) {
  return (e) => {
    e.pointerType === "touch" || j2() || t(e);
  };
}
function M7(t, e, i = {}) {
  const [a, o, c] = B2(t, i), u = QO((h) => {
    const { target: m } = h, v = e(h);
    if (typeof v != "function" || !m)
      return;
    const b = QO((S) => {
      v(S), m.removeEventListener("pointerleave", b);
    });
    m.addEventListener("pointerleave", b, o);
  });
  return a.forEach((h) => {
    h.addEventListener("pointerenter", u, o);
  }), c;
}
const H2 = (t, e) => e ? t === e ? !0 : H2(t, e.parentElement) : !1, A1 = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1, A7 = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function O7(t) {
  return A7.has(t.tagName) || t.tabIndex !== -1;
}
const Jg = /* @__PURE__ */ new WeakSet();
function qO(t) {
  return (e) => {
    e.key === "Enter" && t(e);
  };
}
function xT(t, e) {
  t.dispatchEvent(new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 }));
}
const P7 = (t, e) => {
  const i = t.currentTarget;
  if (!i)
    return;
  const a = qO(() => {
    if (Jg.has(i))
      return;
    xT(i, "down");
    const o = qO(() => {
      xT(i, "up");
    }), c = () => xT(i, "cancel");
    i.addEventListener("keyup", o, e), i.addEventListener("blur", c, e);
  });
  i.addEventListener("keydown", a, e), i.addEventListener("blur", () => i.removeEventListener("keydown", a), e);
};
function ZO(t) {
  return A1(t) && !j2();
}
function L7(t, e, i = {}) {
  const [a, o, c] = B2(t, i), u = (h) => {
    const m = h.currentTarget;
    if (!ZO(h) || Jg.has(m))
      return;
    Jg.add(m);
    const v = e(h), b = (E, R) => {
      window.removeEventListener("pointerup", S), window.removeEventListener("pointercancel", w), !(!ZO(E) || !Jg.has(m)) && (Jg.delete(m), typeof v == "function" && v(E, { success: R }));
    }, S = (E) => {
      b(E, i.useGlobalTarget || H2(m, E.target));
    }, w = (E) => {
      b(E, !1);
    };
    window.addEventListener("pointerup", S, o), window.addEventListener("pointercancel", w, o);
  };
  return a.forEach((h) => {
    !O7(h) && h.getAttribute("tabindex") === null && (h.tabIndex = 0), (i.useGlobalTarget ? window : h).addEventListener("pointerdown", u, o), h.addEventListener("focus", (v) => P7(v, o), o);
  }), c;
}
function N7(t) {
  return t === "x" || t === "y" ? Ks[t] ? null : (Ks[t] = !0, () => {
    Ks[t] = !1;
  }) : Ks.x || Ks.y ? null : (Ks.x = Ks.y = !0, () => {
    Ks.x = Ks.y = !1;
  });
}
const U2 = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...yp
]);
let _x;
function z7() {
  _x = void 0;
}
const Io = {
  now: () => (_x === void 0 && Io.set(vr.isProcessing || A9.useManualTiming ? vr.timestamp : performance.now()), _x),
  set: (t) => {
    _x = t, queueMicrotask(z7);
  }
};
function O1(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function P1(t, e) {
  const i = t.indexOf(e);
  i > -1 && t.splice(i, 1);
}
class L1 {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return O1(this.subscriptions, e), () => P1(this.subscriptions, e);
  }
  notify(e, i, a) {
    const o = this.subscriptions.length;
    if (o)
      if (o === 1)
        this.subscriptions[0](e, i, a);
      else
        for (let c = 0; c < o; c++) {
          const u = this.subscriptions[c];
          u && u(e, i, a);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function I2(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const JO = 30, F7 = (t) => !isNaN(parseFloat(t));
class V7 {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, i = {}) {
    this.version = "11.18.2", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (a, o = !0) => {
      const c = Io.now();
      this.updatedAt !== c && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(a), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), o && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = i.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = Io.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = F7(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && vS(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, i) {
    this.events[e] || (this.events[e] = new L1());
    const a = this.events[e].add(i);
    return e === "change" ? () => {
      a(), $n.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : a;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, i) {
    this.passiveEffect = e, this.stopPassiveEffect = i;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, i = !0) {
    !i || !this.passiveEffect ? this.updateAndNotify(e, i) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, i, a) {
    this.set(i), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - a;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, i = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, i && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = Io.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > JO)
      return 0;
    const i = Math.min(this.updatedAt - this.prevUpdatedAt, JO);
    return I2(parseFloat(this.current) - parseFloat(this.prevFrameValue), i);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((i) => {
      this.hasAnimated = !0, this.animation = e(i), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Rv(t, e) {
  return new V7(t, e);
}
function j7(t, e, i) {
  t.hasValue(e) ? t.getValue(e).set(i) : t.addValue(e, Rv(i));
}
function B7(t, e) {
  const i = SS(t, e);
  let { transitionEnd: a = {}, transition: o = {}, ...c } = i || {};
  c = { ...c, ...a };
  for (const u in c) {
    const h = Z9(c[u]);
    j7(t, u, h);
  }
}
function H7(t) {
  return !!(jr(t) && t.add);
}
function gE(t, e) {
  const i = t.getValue("willChange");
  if (H7(i))
    return i.add(e);
}
function $2(t) {
  return t.props[x2];
}
const W2 = (t, e, i) => (((1 - 3 * i + 3 * e) * t + (3 * i - 6 * e)) * t + 3 * e) * t, U7 = 1e-7, I7 = 12;
function $7(t, e, i, a, o) {
  let c, u, h = 0;
  do
    u = e + (i - e) / 2, c = W2(u, a, o) - t, c > 0 ? i = u : e = u;
  while (Math.abs(c) > U7 && ++h < I7);
  return u;
}
function Vv(t, e, i, a) {
  if (t === e && i === a)
    return Ea;
  const o = (c) => $7(c, 0, 1, t, i);
  return (c) => c === 0 || c === 1 ? c : W2(o(c), e, a);
}
const Y2 = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, G2 = (t) => (e) => 1 - t(1 - e), K2 = /* @__PURE__ */ Vv(0.33, 1.53, 0.69, 0.99), N1 = /* @__PURE__ */ G2(K2), X2 = /* @__PURE__ */ Y2(N1), Q2 = (t) => (t *= 2) < 1 ? 0.5 * N1(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), z1 = (t) => 1 - Math.sin(Math.acos(t)), q2 = G2(z1), Z2 = Y2(z1), J2 = (t) => /^0[^.\s]+$/u.test(t);
function W7(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || J2(t) : !0;
}
const ov = (t) => Math.round(t * 1e5) / 1e5, F1 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function Y7(t) {
  return t == null;
}
const G7 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, V1 = (t, e) => (i) => !!(typeof i == "string" && G7.test(i) && i.startsWith(t) || e && !Y7(i) && Object.prototype.hasOwnProperty.call(i, e)), ez = (t, e, i) => (a) => {
  if (typeof a != "string")
    return a;
  const [o, c, u, h] = a.match(F1);
  return {
    [t]: parseFloat(o),
    [e]: parseFloat(c),
    [i]: parseFloat(u),
    alpha: h !== void 0 ? parseFloat(h) : 1
  };
}, K7 = (t) => Xl(0, 255, t), ST = {
  ...bp,
  transform: (t) => Math.round(K7(t))
}, jf = {
  test: /* @__PURE__ */ V1("rgb", "red"),
  parse: /* @__PURE__ */ ez("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: i, alpha: a = 1 }) => "rgba(" + ST.transform(t) + ", " + ST.transform(e) + ", " + ST.transform(i) + ", " + ov(Dv.transform(a)) + ")"
};
function X7(t) {
  let e = "", i = "", a = "", o = "";
  return t.length > 5 ? (e = t.substring(1, 3), i = t.substring(3, 5), a = t.substring(5, 7), o = t.substring(7, 9)) : (e = t.substring(1, 2), i = t.substring(2, 3), a = t.substring(3, 4), o = t.substring(4, 5), e += e, i += i, a += a, o += o), {
    red: parseInt(e, 16),
    green: parseInt(i, 16),
    blue: parseInt(a, 16),
    alpha: o ? parseInt(o, 16) / 255 : 1
  };
}
const vE = {
  test: /* @__PURE__ */ V1("#"),
  parse: X7,
  transform: jf.transform
}, qh = {
  test: /* @__PURE__ */ V1("hsl", "hue"),
  parse: /* @__PURE__ */ ez("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: i, alpha: a = 1 }) => "hsla(" + Math.round(t) + ", " + Uo.transform(ov(e)) + ", " + Uo.transform(ov(i)) + ", " + ov(Dv.transform(a)) + ")"
}, Fr = {
  test: (t) => jf.test(t) || vE.test(t) || qh.test(t),
  parse: (t) => jf.test(t) ? jf.parse(t) : qh.test(t) ? qh.parse(t) : vE.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? jf.transform(t) : qh.transform(t)
}, Q7 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function q7(t) {
  var e, i;
  return isNaN(t) && typeof t == "string" && (((e = t.match(F1)) === null || e === void 0 ? void 0 : e.length) || 0) + (((i = t.match(Q7)) === null || i === void 0 ? void 0 : i.length) || 0) > 0;
}
const tz = "number", nz = "color", Z7 = "var", J7 = "var(", eP = "${}", eG = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function kv(t) {
  const e = t.toString(), i = [], a = {
    color: [],
    number: [],
    var: []
  }, o = [];
  let c = 0;
  const h = e.replace(eG, (m) => (Fr.test(m) ? (a.color.push(c), o.push(nz), i.push(Fr.parse(m))) : m.startsWith(J7) ? (a.var.push(c), o.push(Z7), i.push(m)) : (a.number.push(c), o.push(tz), i.push(parseFloat(m))), ++c, eP)).split(eP);
  return { values: i, split: h, indexes: a, types: o };
}
function iz(t) {
  return kv(t).values;
}
function rz(t) {
  const { split: e, types: i } = kv(t), a = e.length;
  return (o) => {
    let c = "";
    for (let u = 0; u < a; u++)
      if (c += e[u], o[u] !== void 0) {
        const h = i[u];
        h === tz ? c += ov(o[u]) : h === nz ? c += Fr.transform(o[u]) : c += o[u];
      }
    return c;
  };
}
const tG = (t) => typeof t == "number" ? 0 : t;
function nG(t) {
  const e = iz(t);
  return rz(t)(e.map(tG));
}
const rc = {
  test: q7,
  parse: iz,
  createTransformer: rz,
  getAnimatableNone: nG
}, iG = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function rG(t) {
  const [e, i] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [a] = i.match(F1) || [];
  if (!a)
    return t;
  const o = i.replace(a, "");
  let c = iG.has(e) ? 1 : 0;
  return a !== i && (c *= 100), e + "(" + c + o + ")";
}
const aG = /\b([a-z-]*)\(.*?\)/gu, yE = {
  ...rc,
  getAnimatableNone: (t) => {
    const e = t.match(aG);
    return e ? e.map(rG).join(" ") : t;
  }
}, sG = {
  ..._1,
  // Color props
  color: Fr,
  backgroundColor: Fr,
  outlineColor: Fr,
  fill: Fr,
  stroke: Fr,
  // Border props
  borderColor: Fr,
  borderTopColor: Fr,
  borderRightColor: Fr,
  borderBottomColor: Fr,
  borderLeftColor: Fr,
  filter: yE,
  WebkitFilter: yE
}, j1 = (t) => sG[t];
function az(t, e) {
  let i = j1(t);
  return i !== yE && (i = rc), i.getAnimatableNone ? i.getAnimatableNone(e) : void 0;
}
const oG = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function lG(t, e, i) {
  let a = 0, o;
  for (; a < t.length && !o; ) {
    const c = t[a];
    typeof c == "string" && !oG.has(c) && kv(c).values.length && (o = t[a]), a++;
  }
  if (o && i)
    for (const c of e)
      t[c] = az(i, o);
}
const tP = (t) => t === bp || t === bt, nP = (t, e) => parseFloat(t.split(", ")[e]), iP = (t, e) => (i, { transform: a }) => {
  if (a === "none" || !a)
    return 0;
  const o = a.match(/^matrix3d\((.+)\)$/u);
  if (o)
    return nP(o[1], e);
  {
    const c = a.match(/^matrix\((.+)\)$/u);
    return c ? nP(c[1], t) : 0;
  }
}, uG = /* @__PURE__ */ new Set(["x", "y", "z"]), cG = yp.filter((t) => !uG.has(t));
function fG(t) {
  const e = [];
  return cG.forEach((i) => {
    const a = t.getValue(i);
    a !== void 0 && (e.push([i, a.get()]), a.set(i.startsWith("scale") ? 1 : 0));
  }), e;
}
const pp = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: i = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(i),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: i = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(i),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: iP(4, 13),
  y: iP(5, 14)
};
pp.translateX = pp.x;
pp.translateY = pp.y;
const If = /* @__PURE__ */ new Set();
let bE = !1, xE = !1;
function sz() {
  if (xE) {
    const t = Array.from(If).filter((a) => a.needsMeasurement), e = new Set(t.map((a) => a.element)), i = /* @__PURE__ */ new Map();
    e.forEach((a) => {
      const o = fG(a);
      o.length && (i.set(a, o), a.render());
    }), t.forEach((a) => a.measureInitialState()), e.forEach((a) => {
      a.render();
      const o = i.get(a);
      o && o.forEach(([c, u]) => {
        var h;
        (h = a.getValue(c)) === null || h === void 0 || h.set(u);
      });
    }), t.forEach((a) => a.measureEndState()), t.forEach((a) => {
      a.suspendedScrollY !== void 0 && window.scrollTo(0, a.suspendedScrollY);
    });
  }
  xE = !1, bE = !1, If.forEach((t) => t.complete()), If.clear();
}
function oz() {
  If.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (xE = !0);
  });
}
function dG() {
  oz(), sz();
}
class B1 {
  constructor(e, i, a, o, c, u = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = i, this.name = a, this.motionValue = o, this.element = c, this.isAsync = u;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (If.add(this), bE || (bE = !0, $n.read(oz), $n.resolveKeyframes(sz))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: i, element: a, motionValue: o } = this;
    for (let c = 0; c < e.length; c++)
      if (e[c] === null)
        if (c === 0) {
          const u = o == null ? void 0 : o.get(), h = e[e.length - 1];
          if (u !== void 0)
            e[0] = u;
          else if (a && i) {
            const m = a.readValue(i, h);
            m != null && (e[0] = m);
          }
          e[0] === void 0 && (e[0] = h), o && u === void 0 && o.set(e[0]);
        } else
          e[c] = e[c - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), If.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, If.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const lz = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), hG = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function pG(t) {
  const e = hG.exec(t);
  if (!e)
    return [,];
  const [, i, a, o] = e;
  return [`--${i ?? a}`, o];
}
const mG = 4;
function uz(t, e, i = 1) {
  nc(i <= mG, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [a, o] = pG(t);
  if (!a)
    return;
  const c = window.getComputedStyle(e).getPropertyValue(a);
  if (c) {
    const u = c.trim();
    return lz(u) ? parseFloat(u) : u;
  }
  return S1(o) ? uz(o, e, i + 1) : o;
}
const cz = (t) => (e) => e.test(t), gG = {
  test: (t) => t === "auto",
  parse: (t) => t
}, fz = [bp, bt, Uo, Iu, r7, i7, gG], rP = (t) => fz.find(cz(t));
class dz extends B1 {
  constructor(e, i, a, o, c) {
    super(e, i, a, o, c, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: i, name: a } = this;
    if (!i || !i.current)
      return;
    super.readKeyframes();
    for (let m = 0; m < e.length; m++) {
      let v = e[m];
      if (typeof v == "string" && (v = v.trim(), S1(v))) {
        const b = uz(v, i.current);
        b !== void 0 && (e[m] = b), m === e.length - 1 && (this.finalKeyframe = v);
      }
    }
    if (this.resolveNoneKeyframes(), !U2.has(a) || e.length !== 2)
      return;
    const [o, c] = e, u = rP(o), h = rP(c);
    if (u !== h)
      if (tP(u) && tP(h))
        for (let m = 0; m < e.length; m++) {
          const v = e[m];
          typeof v == "string" && (e[m] = parseFloat(v));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: i } = this, a = [];
    for (let o = 0; o < e.length; o++)
      W7(e[o]) && a.push(o);
    a.length && lG(e, a, i);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: i, name: a } = this;
    if (!e || !e.current)
      return;
    a === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = pp[a](e.measureViewportBox(), window.getComputedStyle(e.current)), i[0] = this.measuredOrigin;
    const o = i[i.length - 1];
    o !== void 0 && e.getValue(a, o).jump(o, !1);
  }
  measureEndState() {
    var e;
    const { element: i, name: a, unresolvedKeyframes: o } = this;
    if (!i || !i.current)
      return;
    const c = i.getValue(a);
    c && c.jump(this.measuredOrigin, !1);
    const u = o.length - 1, h = o[u];
    o[u] = pp[a](i.measureViewportBox(), window.getComputedStyle(i.current)), h !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = h), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([m, v]) => {
      i.getValue(m).set(v);
    }), this.resolveNoneKeyframes();
  }
}
const aP = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(rc.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function vG(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let i = 0; i < t.length; i++)
    if (t[i] !== e)
      return !0;
}
function yG(t, e, i, a) {
  const o = t[0];
  if (o === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const c = t[t.length - 1], u = aP(o, e), h = aP(c, e);
  return vp(u === h, `You are trying to animate ${e} from "${o}" to "${c}". ${o} is not an animatable value - to enable this animation set ${o} to a value animatable to ${c} via the \`style\` property.`), !u || !h ? !1 : vG(t) || (i === "spring" || k1(i)) && a;
}
const bG = (t) => t !== null;
function _S(t, { repeat: e, repeatType: i = "loop" }, a) {
  const o = t.filter(bG), c = e && i !== "loop" && e % 2 === 1 ? 0 : o.length - 1;
  return !c || a === void 0 ? o[c] : a;
}
const xG = 40;
class hz {
  constructor({ autoplay: e = !0, delay: i = 0, type: a = "keyframes", repeat: o = 0, repeatDelay: c = 0, repeatType: u = "loop", ...h }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Io.now(), this.options = {
      autoplay: e,
      delay: i,
      type: a,
      repeat: o,
      repeatDelay: c,
      repeatType: u,
      ...h
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > xG ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && dG(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, i) {
    this.resolvedAt = Io.now(), this.hasAttemptedResolve = !0;
    const { name: a, type: o, velocity: c, delay: u, onComplete: h, onUpdate: m, isGenerator: v } = this.options;
    if (!v && !yG(e, a, o, c))
      if (u)
        this.options.duration = 0;
      else {
        m && m(_S(e, this.options, i)), h && h(), this.resolveFinishedPromise();
        return;
      }
    const b = this.initPlayback(e, i);
    b !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: i,
      ...b
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, i) {
    return this.currentFinishedPromise.then(e, i);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
const si = (t, e, i) => t + (e - t) * i;
function _T(t, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + (e - t) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t;
}
function SG({ hue: t, saturation: e, lightness: i, alpha: a }) {
  t /= 360, e /= 100, i /= 100;
  let o = 0, c = 0, u = 0;
  if (!e)
    o = c = u = i;
  else {
    const h = i < 0.5 ? i * (1 + e) : i + e - i * e, m = 2 * i - h;
    o = _T(m, h, t + 1 / 3), c = _T(m, h, t), u = _T(m, h, t - 1 / 3);
  }
  return {
    red: Math.round(o * 255),
    green: Math.round(c * 255),
    blue: Math.round(u * 255),
    alpha: a
  };
}
function Wx(t, e) {
  return (i) => i > 0 ? e : t;
}
const wT = (t, e, i) => {
  const a = t * t, o = i * (e * e - a) + a;
  return o < 0 ? 0 : Math.sqrt(o);
}, _G = [vE, jf, qh], wG = (t) => _G.find((e) => e.test(t));
function sP(t) {
  const e = wG(t);
  if (vp(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let i = e.parse(t);
  return e === qh && (i = SG(i)), i;
}
const oP = (t, e) => {
  const i = sP(t), a = sP(e);
  if (!i || !a)
    return Wx(t, e);
  const o = { ...i };
  return (c) => (o.red = wT(i.red, a.red, c), o.green = wT(i.green, a.green, c), o.blue = wT(i.blue, a.blue, c), o.alpha = si(i.alpha, a.alpha, c), jf.transform(o));
}, CG = (t, e) => (i) => e(t(i)), jv = (...t) => t.reduce(CG), SE = /* @__PURE__ */ new Set(["none", "hidden"]);
function TG(t, e) {
  return SE.has(t) ? (i) => i <= 0 ? t : e : (i) => i >= 1 ? e : t;
}
function EG(t, e) {
  return (i) => si(t, e, i);
}
function H1(t) {
  return typeof t == "number" ? EG : typeof t == "string" ? S1(t) ? Wx : Fr.test(t) ? oP : kG : Array.isArray(t) ? pz : typeof t == "object" ? Fr.test(t) ? oP : DG : Wx;
}
function pz(t, e) {
  const i = [...t], a = i.length, o = t.map((c, u) => H1(c)(c, e[u]));
  return (c) => {
    for (let u = 0; u < a; u++)
      i[u] = o[u](c);
    return i;
  };
}
function DG(t, e) {
  const i = { ...t, ...e }, a = {};
  for (const o in i)
    t[o] !== void 0 && e[o] !== void 0 && (a[o] = H1(t[o])(t[o], e[o]));
  return (o) => {
    for (const c in a)
      i[c] = a[c](o);
    return i;
  };
}
function RG(t, e) {
  var i;
  const a = [], o = { color: 0, var: 0, number: 0 };
  for (let c = 0; c < e.values.length; c++) {
    const u = e.types[c], h = t.indexes[u][o[u]], m = (i = t.values[h]) !== null && i !== void 0 ? i : 0;
    a[c] = m, o[u]++;
  }
  return a;
}
const kG = (t, e) => {
  const i = rc.createTransformer(e), a = kv(t), o = kv(e);
  return a.indexes.var.length === o.indexes.var.length && a.indexes.color.length === o.indexes.color.length && a.indexes.number.length >= o.indexes.number.length ? SE.has(t) && !o.values.length || SE.has(e) && !a.values.length ? TG(t, e) : jv(pz(RG(a, o), o.values), i) : (vp(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Wx(t, e));
};
function mz(t, e, i) {
  return typeof t == "number" && typeof e == "number" && typeof i == "number" ? si(t, e, i) : H1(t)(t, e);
}
const MG = 5;
function gz(t, e, i) {
  const a = Math.max(e - MG, 0);
  return I2(i - t(a), e - a);
}
const ri = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, lP = 1e-3;
function AG({ duration: t = ri.duration, bounce: e = ri.bounce, velocity: i = ri.velocity, mass: a = ri.mass }) {
  let o, c;
  vp(t <= /* @__PURE__ */ Ho(ri.maxDuration), "Spring duration must be 10 seconds or less");
  let u = 1 - e;
  u = Xl(ri.minDamping, ri.maxDamping, u), t = Xl(ri.minDuration, ri.maxDuration, /* @__PURE__ */ Gl(t)), u < 1 ? (o = (v) => {
    const b = v * u, S = b * t, w = b - i, E = _E(v, u), R = Math.exp(-S);
    return lP - w / E * R;
  }, c = (v) => {
    const S = v * u * t, w = S * i + i, E = Math.pow(u, 2) * Math.pow(v, 2) * t, R = Math.exp(-S), M = _E(Math.pow(v, 2), u);
    return (-o(v) + lP > 0 ? -1 : 1) * ((w - E) * R) / M;
  }) : (o = (v) => {
    const b = Math.exp(-v * t), S = (v - i) * t + 1;
    return -1e-3 + b * S;
  }, c = (v) => {
    const b = Math.exp(-v * t), S = (i - v) * (t * t);
    return b * S;
  });
  const h = 5 / t, m = PG(o, c, h);
  if (t = /* @__PURE__ */ Ho(t), isNaN(m))
    return {
      stiffness: ri.stiffness,
      damping: ri.damping,
      duration: t
    };
  {
    const v = Math.pow(m, 2) * a;
    return {
      stiffness: v,
      damping: u * 2 * Math.sqrt(a * v),
      duration: t
    };
  }
}
const OG = 12;
function PG(t, e, i) {
  let a = i;
  for (let o = 1; o < OG; o++)
    a = a - t(a) / e(a);
  return a;
}
function _E(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const LG = ["duration", "bounce"], NG = ["stiffness", "damping", "mass"];
function uP(t, e) {
  return e.some((i) => t[i] !== void 0);
}
function zG(t) {
  let e = {
    velocity: ri.velocity,
    stiffness: ri.stiffness,
    damping: ri.damping,
    mass: ri.mass,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!uP(t, NG) && uP(t, LG))
    if (t.visualDuration) {
      const i = t.visualDuration, a = 2 * Math.PI / (i * 1.2), o = a * a, c = 2 * Xl(0.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(o);
      e = {
        ...e,
        mass: ri.mass,
        stiffness: o,
        damping: c
      };
    } else {
      const i = AG(t);
      e = {
        ...e,
        ...i,
        mass: ri.mass
      }, e.isResolvedFromDuration = !0;
    }
  return e;
}
function vz(t = ri.visualDuration, e = ri.bounce) {
  const i = typeof t != "object" ? {
    visualDuration: t,
    keyframes: [0, 1],
    bounce: e
  } : t;
  let { restSpeed: a, restDelta: o } = i;
  const c = i.keyframes[0], u = i.keyframes[i.keyframes.length - 1], h = { done: !1, value: c }, { stiffness: m, damping: v, mass: b, duration: S, velocity: w, isResolvedFromDuration: E } = zG({
    ...i,
    velocity: -/* @__PURE__ */ Gl(i.velocity || 0)
  }), R = w || 0, M = v / (2 * Math.sqrt(m * b)), A = u - c, P = /* @__PURE__ */ Gl(Math.sqrt(m / b)), z = Math.abs(A) < 5;
  a || (a = z ? ri.restSpeed.granular : ri.restSpeed.default), o || (o = z ? ri.restDelta.granular : ri.restDelta.default);
  let B;
  if (M < 1) {
    const F = _E(P, M);
    B = ($) => {
      const I = Math.exp(-M * P * $);
      return u - I * ((R + M * P * A) / F * Math.sin(F * $) + A * Math.cos(F * $));
    };
  } else if (M === 1)
    B = (F) => u - Math.exp(-P * F) * (A + (R + P * A) * F);
  else {
    const F = P * Math.sqrt(M * M - 1);
    B = ($) => {
      const I = Math.exp(-M * P * $), K = Math.min(F * $, 300);
      return u - I * ((R + M * P * A) * Math.sinh(K) + F * A * Math.cosh(K)) / F;
    };
  }
  const j = {
    calculatedDuration: E && S || null,
    next: (F) => {
      const $ = B(F);
      if (E)
        h.done = F >= S;
      else {
        let I = 0;
        M < 1 && (I = F === 0 ? /* @__PURE__ */ Ho(R) : gz(B, F, $));
        const K = Math.abs(I) <= a, ee = Math.abs(u - $) <= o;
        h.done = K && ee;
      }
      return h.value = h.done ? u : $, h;
    },
    toString: () => {
      const F = Math.min(N2(j), pE), $ = z2((I) => j.next(F * I).value, F, 30);
      return F + "ms " + $;
    }
  };
  return j;
}
function cP({ keyframes: t, velocity: e = 0, power: i = 0.8, timeConstant: a = 325, bounceDamping: o = 10, bounceStiffness: c = 500, modifyTarget: u, min: h, max: m, restDelta: v = 0.5, restSpeed: b }) {
  const S = t[0], w = {
    done: !1,
    value: S
  }, E = (K) => h !== void 0 && K < h || m !== void 0 && K > m, R = (K) => h === void 0 ? m : m === void 0 || Math.abs(h - K) < Math.abs(m - K) ? h : m;
  let M = i * e;
  const A = S + M, P = u === void 0 ? A : u(A);
  P !== A && (M = P - S);
  const z = (K) => -M * Math.exp(-K / a), B = (K) => P + z(K), j = (K) => {
    const ee = z(K), ne = B(K);
    w.done = Math.abs(ee) <= v, w.value = w.done ? P : ne;
  };
  let F, $;
  const I = (K) => {
    E(w.value) && (F = K, $ = vz({
      keyframes: [w.value, R(w.value)],
      velocity: gz(B, K, w.value),
      // TODO: This should be passing * 1000
      damping: o,
      stiffness: c,
      restDelta: v,
      restSpeed: b
    }));
  };
  return I(0), {
    calculatedDuration: null,
    next: (K) => {
      let ee = !1;
      return !$ && F === void 0 && (ee = !0, j(K), I(K)), F !== void 0 && K >= F ? $.next(K - F) : (!ee && j(K), w);
    }
  };
}
const FG = /* @__PURE__ */ Vv(0.42, 0, 1, 1), VG = /* @__PURE__ */ Vv(0, 0, 0.58, 1), yz = /* @__PURE__ */ Vv(0.42, 0, 0.58, 1), jG = (t) => Array.isArray(t) && typeof t[0] != "number", fP = {
  linear: Ea,
  easeIn: FG,
  easeInOut: yz,
  easeOut: VG,
  circIn: z1,
  circInOut: Z2,
  circOut: q2,
  backIn: N1,
  backInOut: X2,
  backOut: K2,
  anticipate: Q2
}, dP = (t) => {
  if (M1(t)) {
    nc(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, i, a, o] = t;
    return Vv(e, i, a, o);
  } else if (typeof t == "string")
    return nc(fP[t] !== void 0, `Invalid easing type '${t}'`), fP[t];
  return t;
};
function BG(t, e, i) {
  const a = [], o = i || mz, c = t.length - 1;
  for (let u = 0; u < c; u++) {
    let h = o(t[u], t[u + 1]);
    if (e) {
      const m = Array.isArray(e) ? e[u] || Ea : e;
      h = jv(m, h);
    }
    a.push(h);
  }
  return a;
}
function HG(t, e, { clamp: i = !0, ease: a, mixer: o } = {}) {
  const c = t.length;
  if (nc(c === e.length, "Both input and output ranges must be the same length"), c === 1)
    return () => e[0];
  if (c === 2 && e[0] === e[1])
    return () => e[1];
  const u = t[0] === t[1];
  t[0] > t[c - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const h = BG(e, a, o), m = h.length, v = (b) => {
    if (u && b < t[0])
      return e[0];
    let S = 0;
    if (m > 1)
      for (; S < t.length - 2 && !(b < t[S + 1]); S++)
        ;
    const w = /* @__PURE__ */ dp(t[S], t[S + 1], b);
    return h[S](w);
  };
  return i ? (b) => v(Xl(t[0], t[c - 1], b)) : v;
}
function UG(t, e) {
  const i = t[t.length - 1];
  for (let a = 1; a <= e; a++) {
    const o = /* @__PURE__ */ dp(0, e, a);
    t.push(si(i, 1, o));
  }
}
function IG(t) {
  const e = [0];
  return UG(e, t.length - 1), e;
}
function $G(t, e) {
  return t.map((i) => i * e);
}
function WG(t, e) {
  return t.map(() => e || yz).splice(0, t.length - 1);
}
function Yx({ duration: t = 300, keyframes: e, times: i, ease: a = "easeInOut" }) {
  const o = jG(a) ? a.map(dP) : dP(a), c = {
    done: !1,
    value: e[0]
  }, u = $G(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    i && i.length === e.length ? i : IG(e),
    t
  ), h = HG(u, e, {
    ease: Array.isArray(o) ? o : WG(e, o)
  });
  return {
    calculatedDuration: t,
    next: (m) => (c.value = h(m), c.done = m >= t, c)
  };
}
const YG = (t) => {
  const e = ({ timestamp: i }) => t(i);
  return {
    start: () => $n.update(e, !0),
    stop: () => ic(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => vr.isProcessing ? vr.timestamp : Io.now()
  };
}, GG = {
  decay: cP,
  inertia: cP,
  tween: Yx,
  keyframes: Yx,
  spring: vz
}, KG = (t) => t / 100;
class U1 extends hz {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: m } = this.options;
      m && m();
    };
    const { name: i, motionValue: a, element: o, keyframes: c } = this.options, u = (o == null ? void 0 : o.KeyframeResolver) || B1, h = (m, v) => this.onKeyframesResolved(m, v);
    this.resolver = new u(c, h, i, a, o), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(e) {
    const { type: i = "keyframes", repeat: a = 0, repeatDelay: o = 0, repeatType: c, velocity: u = 0 } = this.options, h = k1(i) ? i : GG[i] || Yx;
    let m, v;
    h !== Yx && typeof e[0] != "number" && (process.env.NODE_ENV !== "production" && nc(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), m = jv(KG, mz(e[0], e[1])), e = [0, 100]);
    const b = h({ ...this.options, keyframes: e });
    c === "mirror" && (v = h({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -u
    })), b.calculatedDuration === null && (b.calculatedDuration = N2(b));
    const { calculatedDuration: S } = b, w = S + o, E = w * (a + 1) - o;
    return {
      generator: b,
      mirroredGenerator: v,
      mapPercentToKeyframes: m,
      calculatedDuration: S,
      resolvedDuration: w,
      totalDuration: E
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, i = !1) {
    const { resolved: a } = this;
    if (!a) {
      const { keyframes: K } = this.options;
      return { done: !0, value: K[K.length - 1] };
    }
    const { finalKeyframe: o, generator: c, mirroredGenerator: u, mapPercentToKeyframes: h, keyframes: m, calculatedDuration: v, totalDuration: b, resolvedDuration: S } = a;
    if (this.startTime === null)
      return c.next(0);
    const { delay: w, repeat: E, repeatType: R, repeatDelay: M, onUpdate: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - b / this.speed, this.startTime)), i ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const P = this.currentTime - w * (this.speed >= 0 ? 1 : -1), z = this.speed >= 0 ? P < 0 : P > b;
    this.currentTime = Math.max(P, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = b);
    let B = this.currentTime, j = c;
    if (E) {
      const K = Math.min(this.currentTime, b) / S;
      let ee = Math.floor(K), ne = K % 1;
      !ne && K >= 1 && (ne = 1), ne === 1 && ee--, ee = Math.min(ee, E + 1), !!(ee % 2) && (R === "reverse" ? (ne = 1 - ne, M && (ne -= M / S)) : R === "mirror" && (j = u)), B = Xl(0, 1, ne) * S;
    }
    const F = z ? { done: !1, value: m[0] } : j.next(B);
    h && (F.value = h(F.value));
    let { done: $ } = F;
    !z && v !== null && ($ = this.speed >= 0 ? this.currentTime >= b : this.currentTime <= 0);
    const I = this.holdTime === null && (this.state === "finished" || this.state === "running" && $);
    return I && o !== void 0 && (F.value = _S(m, this.options, o)), A && A(F.value), I && this.finish(), F;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? /* @__PURE__ */ Gl(e.calculatedDuration) : 0;
  }
  get time() {
    return /* @__PURE__ */ Gl(this.currentTime);
  }
  set time(e) {
    e = /* @__PURE__ */ Ho(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const i = this.playbackSpeed !== e;
    this.playbackSpeed = e, i && (this.time = /* @__PURE__ */ Gl(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = YG, onPlay: i, startTime: a } = this.options;
    this.driver || (this.driver = e((c) => this.tick(c))), i && i();
    const o = this.driver.now();
    this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = o) : this.startTime = a ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const XG = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]);
function QG(t, e, i, { delay: a = 0, duration: o = 300, repeat: c = 0, repeatType: u = "loop", ease: h = "easeInOut", times: m } = {}) {
  const v = { [e]: i };
  m && (v.offset = m);
  const b = V2(h, o);
  return Array.isArray(b) && (v.easing = b), t.animate(v, {
    delay: a,
    duration: o,
    easing: Array.isArray(b) ? "linear" : b,
    fill: "both",
    iterations: c + 1,
    direction: u === "reverse" ? "alternate" : "normal"
  });
}
const qG = /* @__PURE__ */ p1(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Gx = 10, ZG = 2e4;
function JG(t) {
  return k1(t.type) || t.type === "spring" || !F2(t.ease);
}
function eK(t, e) {
  const i = new U1({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let a = { done: !1, value: t[0] };
  const o = [];
  let c = 0;
  for (; !a.done && c < ZG; )
    a = i.sample(c), o.push(a.value), c += Gx;
  return {
    times: void 0,
    keyframes: o,
    duration: c - Gx,
    ease: "linear"
  };
}
const bz = {
  anticipate: Q2,
  backInOut: X2,
  circInOut: Z2
};
function tK(t) {
  return t in bz;
}
class hP extends hz {
  constructor(e) {
    super(e);
    const { name: i, motionValue: a, element: o, keyframes: c } = this.options;
    this.resolver = new dz(c, (u, h) => this.onKeyframesResolved(u, h), i, a, o), this.resolver.scheduleResolve();
  }
  initPlayback(e, i) {
    let { duration: a = 300, times: o, ease: c, type: u, motionValue: h, name: m, startTime: v } = this.options;
    if (!h.owner || !h.owner.current)
      return !1;
    if (typeof c == "string" && $x() && tK(c) && (c = bz[c]), JG(this.options)) {
      const { onComplete: S, onUpdate: w, motionValue: E, element: R, ...M } = this.options, A = eK(e, M);
      e = A.keyframes, e.length === 1 && (e[1] = e[0]), a = A.duration, o = A.times, c = A.ease, u = "keyframes";
    }
    const b = QG(h.owner.current, m, e, { ...this.options, duration: a, times: o, ease: c });
    return b.startTime = v ?? this.calcStartTime(), this.pendingTimeline ? (XO(b, this.pendingTimeline), this.pendingTimeline = void 0) : b.onfinish = () => {
      const { onComplete: S } = this.options;
      h.set(_S(e, this.options, i)), S && S(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: b,
      duration: a,
      times: o,
      type: u,
      ease: c,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: i } = e;
    return /* @__PURE__ */ Gl(i);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: i } = e;
    return /* @__PURE__ */ Gl(i.currentTime || 0);
  }
  set time(e) {
    const { resolved: i } = this;
    if (!i)
      return;
    const { animation: a } = i;
    a.currentTime = /* @__PURE__ */ Ho(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: i } = e;
    return i.playbackRate;
  }
  set speed(e) {
    const { resolved: i } = this;
    if (!i)
      return;
    const { animation: a } = i;
    a.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: i } = e;
    return i.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: i } = e;
    return i.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: i } = this;
      if (!i)
        return Ea;
      const { animation: a } = i;
      XO(a, e);
    }
    return Ea;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: i } = e;
    i.playState === "finished" && this.updateFinishedPromise(), i.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: i } = e;
    i.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: i, keyframes: a, duration: o, type: c, ease: u, times: h } = e;
    if (i.playState === "idle" || i.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: v, onUpdate: b, onComplete: S, element: w, ...E } = this.options, R = new U1({
        ...E,
        keyframes: a,
        duration: o,
        type: c,
        ease: u,
        times: h,
        isGenerator: !0
      }), M = /* @__PURE__ */ Ho(this.time);
      v.setWithVelocity(R.sample(M - Gx).value, R.sample(M).value, Gx);
    }
    const { onStop: m } = this.options;
    m && m(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: i, name: a, repeatDelay: o, repeatType: c, damping: u, type: h } = e;
    if (!i || !i.owner || !(i.owner.current instanceof HTMLElement))
      return !1;
    const { onUpdate: m, transformTemplate: v } = i.owner.getProps();
    return qG() && a && XG.has(a) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !m && !v && !o && c !== "mirror" && u !== 0 && h !== "inertia";
  }
}
const nK = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, iK = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), rK = {
  type: "keyframes",
  duration: 0.8
}, aK = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, sK = (t, { keyframes: e }) => e.length > 2 ? rK : Qf.has(t) ? t.startsWith("scale") ? iK(e[1]) : nK : aK;
function oK({ when: t, delay: e, delayChildren: i, staggerChildren: a, staggerDirection: o, repeat: c, repeatType: u, repeatDelay: h, from: m, elapsed: v, ...b }) {
  return !!Object.keys(b).length;
}
const I1 = (t, e, i, a = {}, o, c) => (u) => {
  const h = R1(a, t) || {}, m = h.delay || a.delay || 0;
  let { elapsed: v = 0 } = a;
  v = v - /* @__PURE__ */ Ho(m);
  let b = {
    keyframes: Array.isArray(i) ? i : [null, i],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...h,
    delay: -v,
    onUpdate: (w) => {
      e.set(w), h.onUpdate && h.onUpdate(w);
    },
    onComplete: () => {
      u(), h.onComplete && h.onComplete();
    },
    name: t,
    motionValue: e,
    element: c ? void 0 : o
  };
  oK(h) || (b = {
    ...b,
    ...sK(t, b)
  }), b.duration && (b.duration = /* @__PURE__ */ Ho(b.duration)), b.repeatDelay && (b.repeatDelay = /* @__PURE__ */ Ho(b.repeatDelay)), b.from !== void 0 && (b.keyframes[0] = b.from);
  let S = !1;
  if ((b.type === !1 || b.duration === 0 && !b.repeatDelay) && (b.duration = 0, b.delay === 0 && (S = !0)), S && !c && e.get() !== void 0) {
    const w = _S(b.keyframes, h);
    if (w !== void 0)
      return $n.update(() => {
        b.onUpdate(w), b.onComplete();
      }), new E7([]);
  }
  return !c && hP.supports(b) ? new hP(b) : new U1(b);
};
function lK({ protectedKeys: t, needsAnimating: e }, i) {
  const a = t.hasOwnProperty(i) && e[i] !== !0;
  return e[i] = !1, a;
}
function xz(t, e, { delay: i = 0, transitionOverride: a, type: o } = {}) {
  var c;
  let { transition: u = t.getDefaultTransition(), transitionEnd: h, ...m } = e;
  a && (u = a);
  const v = [], b = o && t.animationState && t.animationState.getState()[o];
  for (const S in m) {
    const w = t.getValue(S, (c = t.latestValues[S]) !== null && c !== void 0 ? c : null), E = m[S];
    if (E === void 0 || b && lK(b, S))
      continue;
    const R = {
      delay: i,
      ...R1(u || {}, S)
    };
    let M = !1;
    if (window.MotionHandoffAnimation) {
      const P = $2(t);
      if (P) {
        const z = window.MotionHandoffAnimation(P, S, $n);
        z !== null && (R.startTime = z, M = !0);
      }
    }
    gE(t, S), w.start(I1(S, w, E, t.shouldReduceMotion && U2.has(S) ? { type: !1 } : R, t, M));
    const A = w.animation;
    A && v.push(A);
  }
  return h && Promise.all(v).then(() => {
    $n.update(() => {
      h && B7(t, h);
    });
  }), v;
}
function wE(t, e, i = {}) {
  var a;
  const o = SS(t, e, i.type === "exit" ? (a = t.presenceContext) === null || a === void 0 ? void 0 : a.custom : void 0);
  let { transition: c = t.getDefaultTransition() || {} } = o || {};
  i.transitionOverride && (c = i.transitionOverride);
  const u = o ? () => Promise.all(xz(t, o, i)) : () => Promise.resolve(), h = t.variantChildren && t.variantChildren.size ? (v = 0) => {
    const { delayChildren: b = 0, staggerChildren: S, staggerDirection: w } = c;
    return uK(t, e, b + v, S, w, i);
  } : () => Promise.resolve(), { when: m } = c;
  if (m) {
    const [v, b] = m === "beforeChildren" ? [u, h] : [h, u];
    return v().then(() => b());
  } else
    return Promise.all([u(), h(i.delay)]);
}
function uK(t, e, i = 0, a = 0, o = 1, c) {
  const u = [], h = (t.variantChildren.size - 1) * a, m = o === 1 ? (v = 0) => v * a : (v = 0) => h - v * a;
  return Array.from(t.variantChildren).sort(cK).forEach((v, b) => {
    v.notify("AnimationStart", e), u.push(wE(v, e, {
      ...c,
      delay: i + m(b)
    }).then(() => v.notify("AnimationComplete", e)));
  }), Promise.all(u);
}
function cK(t, e) {
  return t.sortNodePosition(e);
}
function fK(t, e, i = {}) {
  t.notify("AnimationStart", e);
  let a;
  if (Array.isArray(e)) {
    const o = e.map((c) => wE(t, c, i));
    a = Promise.all(o);
  } else if (typeof e == "string")
    a = wE(t, e, i);
  else {
    const o = typeof e == "function" ? SS(t, e, i.custom) : e;
    a = Promise.all(xz(t, o, i));
  }
  return a.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const dK = g1.length;
function Sz(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const i = t.parent ? Sz(t.parent) || {} : {};
    return t.props.initial !== void 0 && (i.initial = t.props.initial), i;
  }
  const e = {};
  for (let i = 0; i < dK; i++) {
    const a = g1[i], o = t.props[a];
    (Ev(o) || o === !1) && (e[a] = o);
  }
  return e;
}
const hK = [...m1].reverse(), pK = m1.length;
function mK(t) {
  return (e) => Promise.all(e.map(({ animation: i, options: a }) => fK(t, i, a)));
}
function gK(t) {
  let e = mK(t), i = pP(), a = !0;
  const o = (m) => (v, b) => {
    var S;
    const w = SS(t, b, m === "exit" ? (S = t.presenceContext) === null || S === void 0 ? void 0 : S.custom : void 0);
    if (w) {
      const { transition: E, transitionEnd: R, ...M } = w;
      v = { ...v, ...M, ...R };
    }
    return v;
  };
  function c(m) {
    e = m(t);
  }
  function u(m) {
    const { props: v } = t, b = Sz(t.parent) || {}, S = [], w = /* @__PURE__ */ new Set();
    let E = {}, R = 1 / 0;
    for (let A = 0; A < pK; A++) {
      const P = hK[A], z = i[P], B = v[P] !== void 0 ? v[P] : b[P], j = Ev(B), F = P === m ? z.isActive : null;
      F === !1 && (R = A);
      let $ = B === b[P] && B !== v[P] && j;
      if ($ && a && t.manuallyAnimateOnMount && ($ = !1), z.protectedKeys = { ...E }, // If it isn't active and hasn't *just* been set as inactive
      !z.isActive && F === null || // If we didn't and don't have any defined prop for this animation type
      !B && !z.prevProp || // Or if the prop doesn't define an animation
      bS(B) || typeof B == "boolean")
        continue;
      const I = vK(z.prevProp, B);
      let K = I || // If we're making this variant active, we want to always make it active
      P === m && z.isActive && !$ && j || // If we removed a higher-priority variant (i is in reverse order)
      A > R && j, ee = !1;
      const ne = Array.isArray(B) ? B : [B];
      let le = ne.reduce(o(P), {});
      F === !1 && (le = {});
      const { prevResolvedValues: re = {} } = z, se = {
        ...re,
        ...le
      }, Ne = (Oe) => {
        K = !0, w.has(Oe) && (ee = !0, w.delete(Oe)), z.needsAnimating[Oe] = !0;
        const ae = t.getValue(Oe);
        ae && (ae.liveStyle = !1);
      };
      for (const Oe in se) {
        const ae = le[Oe], me = re[Oe];
        if (E.hasOwnProperty(Oe))
          continue;
        let pe = !1;
        hE(ae) && hE(me) ? pe = !L2(ae, me) : pe = ae !== me, pe ? ae != null ? Ne(Oe) : w.add(Oe) : ae !== void 0 && w.has(Oe) ? Ne(Oe) : z.protectedKeys[Oe] = !0;
      }
      z.prevProp = B, z.prevResolvedValues = le, z.isActive && (E = { ...E, ...le }), a && t.blockInitialAnimation && (K = !1), K && (!($ && I) || ee) && S.push(...ne.map((Oe) => ({
        animation: Oe,
        options: { type: P }
      })));
    }
    if (w.size) {
      const A = {};
      w.forEach((P) => {
        const z = t.getBaseTarget(P), B = t.getValue(P);
        B && (B.liveStyle = !0), A[P] = z ?? null;
      }), S.push({ animation: A });
    }
    let M = !!S.length;
    return a && (v.initial === !1 || v.initial === v.animate) && !t.manuallyAnimateOnMount && (M = !1), a = !1, M ? e(S) : Promise.resolve();
  }
  function h(m, v) {
    var b;
    if (i[m].isActive === v)
      return Promise.resolve();
    (b = t.variantChildren) === null || b === void 0 || b.forEach((w) => {
      var E;
      return (E = w.animationState) === null || E === void 0 ? void 0 : E.setActive(m, v);
    }), i[m].isActive = v;
    const S = u(m);
    for (const w in i)
      i[w].protectedKeys = {};
    return S;
  }
  return {
    animateChanges: u,
    setActive: h,
    setAnimateFunction: c,
    getState: () => i,
    reset: () => {
      i = pP(), a = !0;
    }
  };
}
function vK(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !L2(e, t) : !1;
}
function Of(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function pP() {
  return {
    animate: Of(!0),
    whileInView: Of(),
    whileHover: Of(),
    whileTap: Of(),
    whileDrag: Of(),
    whileFocus: Of(),
    exit: Of()
  };
}
class oc {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class yK extends oc {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = gK(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    bS(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: i } = this.node.prevProps || {};
    e !== i && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let bK = 0;
class xK extends oc {
  constructor() {
    super(...arguments), this.id = bK++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: i } = this.node.presenceContext, { isPresent: a } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === a)
      return;
    const o = this.node.animationState.setActive("exit", !e);
    i && !e && o.then(() => i(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const SK = {
  animation: {
    Feature: yK
  },
  exit: {
    Feature: xK
  }
};
function Mv(t, e, i, a = { passive: !0 }) {
  return t.addEventListener(e, i, a), () => t.removeEventListener(e, i);
}
function Bv(t) {
  return {
    point: {
      x: t.pageX,
      y: t.pageY
    }
  };
}
const _K = (t) => (e) => A1(e) && t(e, Bv(e));
function lv(t, e, i, a) {
  return Mv(t, e, _K(i), a);
}
const mP = (t, e) => Math.abs(t - e);
function wK(t, e) {
  const i = mP(t.x, e.x), a = mP(t.y, e.y);
  return Math.sqrt(i ** 2 + a ** 2);
}
class _z {
  constructor(e, i, { transformPagePoint: a, contextWindow: o, dragSnapToOrigin: c = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const S = TT(this.lastMoveEventInfo, this.history), w = this.startEvent !== null, E = wK(S.offset, { x: 0, y: 0 }) >= 3;
      if (!w && !E)
        return;
      const { point: R } = S, { timestamp: M } = vr;
      this.history.push({ ...R, timestamp: M });
      const { onStart: A, onMove: P } = this.handlers;
      w || (A && A(this.lastMoveEvent, S), this.startEvent = this.lastMoveEvent), P && P(this.lastMoveEvent, S);
    }, this.handlePointerMove = (S, w) => {
      this.lastMoveEvent = S, this.lastMoveEventInfo = CT(w, this.transformPagePoint), $n.update(this.updatePoint, !0);
    }, this.handlePointerUp = (S, w) => {
      this.end();
      const { onEnd: E, onSessionEnd: R, resumeAnimation: M } = this.handlers;
      if (this.dragSnapToOrigin && M && M(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const A = TT(S.type === "pointercancel" ? this.lastMoveEventInfo : CT(w, this.transformPagePoint), this.history);
      this.startEvent && E && E(S, A), R && R(S, A);
    }, !A1(e))
      return;
    this.dragSnapToOrigin = c, this.handlers = i, this.transformPagePoint = a, this.contextWindow = o || window;
    const u = Bv(e), h = CT(u, this.transformPagePoint), { point: m } = h, { timestamp: v } = vr;
    this.history = [{ ...m, timestamp: v }];
    const { onSessionStart: b } = i;
    b && b(e, TT(h, this.history)), this.removeListeners = jv(lv(this.contextWindow, "pointermove", this.handlePointerMove), lv(this.contextWindow, "pointerup", this.handlePointerUp), lv(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), ic(this.updatePoint);
  }
}
function CT(t, e) {
  return e ? { point: e(t.point) } : t;
}
function gP(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function TT({ point: t }, e) {
  return {
    point: t,
    delta: gP(t, wz(e)),
    offset: gP(t, CK(e)),
    velocity: TK(e, 0.1)
  };
}
function CK(t) {
  return t[0];
}
function wz(t) {
  return t[t.length - 1];
}
function TK(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let i = t.length - 1, a = null;
  const o = wz(t);
  for (; i >= 0 && (a = t[i], !(o.timestamp - a.timestamp > /* @__PURE__ */ Ho(e))); )
    i--;
  if (!a)
    return { x: 0, y: 0 };
  const c = /* @__PURE__ */ Gl(o.timestamp - a.timestamp);
  if (c === 0)
    return { x: 0, y: 0 };
  const u = {
    x: (o.x - a.x) / c,
    y: (o.y - a.y) / c
  };
  return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u;
}
const Cz = 1e-4, EK = 1 - Cz, DK = 1 + Cz, Tz = 0.01, RK = 0 - Tz, kK = 0 + Tz;
function Ya(t) {
  return t.max - t.min;
}
function MK(t, e, i) {
  return Math.abs(t - e) <= i;
}
function vP(t, e, i, a = 0.5) {
  t.origin = a, t.originPoint = si(e.min, e.max, t.origin), t.scale = Ya(i) / Ya(e), t.translate = si(i.min, i.max, t.origin) - t.originPoint, (t.scale >= EK && t.scale <= DK || isNaN(t.scale)) && (t.scale = 1), (t.translate >= RK && t.translate <= kK || isNaN(t.translate)) && (t.translate = 0);
}
function uv(t, e, i, a) {
  vP(t.x, e.x, i.x, a ? a.originX : void 0), vP(t.y, e.y, i.y, a ? a.originY : void 0);
}
function yP(t, e, i) {
  t.min = i.min + e.min, t.max = t.min + Ya(e);
}
function AK(t, e, i) {
  yP(t.x, e.x, i.x), yP(t.y, e.y, i.y);
}
function bP(t, e, i) {
  t.min = e.min - i.min, t.max = t.min + Ya(e);
}
function cv(t, e, i) {
  bP(t.x, e.x, i.x), bP(t.y, e.y, i.y);
}
function OK(t, { min: e, max: i }, a) {
  return e !== void 0 && t < e ? t = a ? si(e, t, a.min) : Math.max(t, e) : i !== void 0 && t > i && (t = a ? si(i, t, a.max) : Math.min(t, i)), t;
}
function xP(t, e, i) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: i !== void 0 ? t.max + i - (t.max - t.min) : void 0
  };
}
function PK(t, { top: e, left: i, bottom: a, right: o }) {
  return {
    x: xP(t.x, i, o),
    y: xP(t.y, e, a)
  };
}
function SP(t, e) {
  let i = e.min - t.min, a = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([i, a] = [a, i]), { min: i, max: a };
}
function LK(t, e) {
  return {
    x: SP(t.x, e.x),
    y: SP(t.y, e.y)
  };
}
function NK(t, e) {
  let i = 0.5;
  const a = Ya(t), o = Ya(e);
  return o > a ? i = /* @__PURE__ */ dp(e.min, e.max - a, t.min) : a > o && (i = /* @__PURE__ */ dp(t.min, t.max - o, e.min)), Xl(0, 1, i);
}
function zK(t, e) {
  const i = {};
  return e.min !== void 0 && (i.min = e.min - t.min), e.max !== void 0 && (i.max = e.max - t.min), i;
}
const CE = 0.35;
function FK(t = CE) {
  return t === !1 ? t = 0 : t === !0 && (t = CE), {
    x: _P(t, "left", "right"),
    y: _P(t, "top", "bottom")
  };
}
function _P(t, e, i) {
  return {
    min: wP(t, e),
    max: wP(t, i)
  };
}
function wP(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const CP = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Zh = () => ({
  x: CP(),
  y: CP()
}), TP = () => ({ min: 0, max: 0 }), Ci = () => ({
  x: TP(),
  y: TP()
});
function vs(t) {
  return [t("x"), t("y")];
}
function Ez({ top: t, left: e, right: i, bottom: a }) {
  return {
    x: { min: e, max: i },
    y: { min: t, max: a }
  };
}
function VK({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function jK(t, e) {
  if (!e)
    return t;
  const i = e({ x: t.left, y: t.top }), a = e({ x: t.right, y: t.bottom });
  return {
    top: i.y,
    left: i.x,
    bottom: a.y,
    right: a.x
  };
}
function ET(t) {
  return t === void 0 || t === 1;
}
function TE({ scale: t, scaleX: e, scaleY: i }) {
  return !ET(t) || !ET(e) || !ET(i);
}
function Nf(t) {
  return TE(t) || Dz(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function Dz(t) {
  return EP(t.x) || EP(t.y);
}
function EP(t) {
  return t && t !== "0%";
}
function Kx(t, e, i) {
  const a = t - i, o = e * a;
  return i + o;
}
function DP(t, e, i, a, o) {
  return o !== void 0 && (t = Kx(t, o, a)), Kx(t, i, a) + e;
}
function EE(t, e = 0, i = 1, a, o) {
  t.min = DP(t.min, e, i, a, o), t.max = DP(t.max, e, i, a, o);
}
function Rz(t, { x: e, y: i }) {
  EE(t.x, e.translate, e.scale, e.originPoint), EE(t.y, i.translate, i.scale, i.originPoint);
}
const RP = 0.999999999999, kP = 1.0000000000001;
function BK(t, e, i, a = !1) {
  const o = i.length;
  if (!o)
    return;
  e.x = e.y = 1;
  let c, u;
  for (let h = 0; h < o; h++) {
    c = i[h], u = c.projectionDelta;
    const { visualElement: m } = c.options;
    m && m.props.style && m.props.style.display === "contents" || (a && c.options.layoutScroll && c.scroll && c !== c.root && ep(t, {
      x: -c.scroll.offset.x,
      y: -c.scroll.offset.y
    }), u && (e.x *= u.x.scale, e.y *= u.y.scale, Rz(t, u)), a && Nf(c.latestValues) && ep(t, c.latestValues));
  }
  e.x < kP && e.x > RP && (e.x = 1), e.y < kP && e.y > RP && (e.y = 1);
}
function Jh(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function MP(t, e, i, a, o = 0.5) {
  const c = si(t.min, t.max, o);
  EE(t, e, i, c, a);
}
function ep(t, e) {
  MP(t.x, e.x, e.scaleX, e.scale, e.originX), MP(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function kz(t, e) {
  return Ez(jK(t.getBoundingClientRect(), e));
}
function HK(t, e, i) {
  const a = kz(t, i), { scroll: o } = e;
  return o && (Jh(a.x, o.offset.x), Jh(a.y, o.offset.y)), a;
}
const Mz = ({ current: t }) => t ? t.ownerDocument.defaultView : null, UK = /* @__PURE__ */ new WeakMap();
class IK {
  constructor(e) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ci(), this.visualElement = e;
  }
  start(e, { snapToCursor: i = !1 } = {}) {
    const { presenceContext: a } = this.visualElement;
    if (a && a.isPresent === !1)
      return;
    const o = (b) => {
      const { dragSnapToOrigin: S } = this.getProps();
      S ? this.pauseAnimation() : this.stopAnimation(), i && this.snapToCursor(Bv(b).point);
    }, c = (b, S) => {
      const { drag: w, dragPropagation: E, onDragStart: R } = this.getProps();
      if (w && !E && (this.openDragLock && this.openDragLock(), this.openDragLock = N7(w), !this.openDragLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), vs((A) => {
        let P = this.getAxisMotionValue(A).get() || 0;
        if (Uo.test(P)) {
          const { projection: z } = this.visualElement;
          if (z && z.layout) {
            const B = z.layout.layoutBox[A];
            B && (P = Ya(B) * (parseFloat(P) / 100));
          }
        }
        this.originPoint[A] = P;
      }), R && $n.postRender(() => R(b, S)), gE(this.visualElement, "transform");
      const { animationState: M } = this.visualElement;
      M && M.setActive("whileDrag", !0);
    }, u = (b, S) => {
      const { dragPropagation: w, dragDirectionLock: E, onDirectionLock: R, onDrag: M } = this.getProps();
      if (!w && !this.openDragLock)
        return;
      const { offset: A } = S;
      if (E && this.currentDirection === null) {
        this.currentDirection = $K(A), this.currentDirection !== null && R && R(this.currentDirection);
        return;
      }
      this.updateAxis("x", S.point, A), this.updateAxis("y", S.point, A), this.visualElement.render(), M && M(b, S);
    }, h = (b, S) => this.stop(b, S), m = () => vs((b) => {
      var S;
      return this.getAnimationState(b) === "paused" && ((S = this.getAxisMotionValue(b).animation) === null || S === void 0 ? void 0 : S.play());
    }), { dragSnapToOrigin: v } = this.getProps();
    this.panSession = new _z(e, {
      onSessionStart: o,
      onStart: c,
      onMove: u,
      onSessionEnd: h,
      resumeAnimation: m
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: v,
      contextWindow: Mz(this.visualElement)
    });
  }
  stop(e, i) {
    const a = this.isDragging;
    if (this.cancel(), !a)
      return;
    const { velocity: o } = i;
    this.startAnimation(o);
    const { onDragEnd: c } = this.getProps();
    c && $n.postRender(() => c(e, i));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: i } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: a } = this.getProps();
    !a && this.openDragLock && (this.openDragLock(), this.openDragLock = null), i && i.setActive("whileDrag", !1);
  }
  updateAxis(e, i, a) {
    const { drag: o } = this.getProps();
    if (!a || !ox(e, o, this.currentDirection))
      return;
    const c = this.getAxisMotionValue(e);
    let u = this.originPoint[e] + a[e];
    this.constraints && this.constraints[e] && (u = OK(u, this.constraints[e], this.elastic[e])), c.set(u);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: i, dragElastic: a } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, c = this.constraints;
    i && Qh(i) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : i && o ? this.constraints = PK(o.layoutBox, i) : this.constraints = !1, this.elastic = FK(a), c !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && vs((u) => {
      this.constraints !== !1 && this.getAxisMotionValue(u) && (this.constraints[u] = zK(o.layoutBox[u], this.constraints[u]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: i } = this.getProps();
    if (!e || !Qh(e))
      return !1;
    const a = e.current;
    nc(a !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: o } = this.visualElement;
    if (!o || !o.layout)
      return !1;
    const c = HK(a, o.root, this.visualElement.getTransformPagePoint());
    let u = LK(o.layout.layoutBox, c);
    if (i) {
      const h = i(VK(u));
      this.hasMutatedConstraints = !!h, h && (u = Ez(h));
    }
    return u;
  }
  startAnimation(e) {
    const { drag: i, dragMomentum: a, dragElastic: o, dragTransition: c, dragSnapToOrigin: u, onDragTransitionEnd: h } = this.getProps(), m = this.constraints || {}, v = vs((b) => {
      if (!ox(b, i, this.currentDirection))
        return;
      let S = m && m[b] || {};
      u && (S = { min: 0, max: 0 });
      const w = o ? 200 : 1e6, E = o ? 40 : 1e7, R = {
        type: "inertia",
        velocity: a ? e[b] : 0,
        bounceStiffness: w,
        bounceDamping: E,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...c,
        ...S
      };
      return this.startAxisValueAnimation(b, R);
    });
    return Promise.all(v).then(h);
  }
  startAxisValueAnimation(e, i) {
    const a = this.getAxisMotionValue(e);
    return gE(this.visualElement, e), a.start(I1(e, a, 0, i, this.visualElement, !1));
  }
  stopAnimation() {
    vs((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    vs((e) => {
      var i;
      return (i = this.getAxisMotionValue(e).animation) === null || i === void 0 ? void 0 : i.pause();
    });
  }
  getAnimationState(e) {
    var i;
    return (i = this.getAxisMotionValue(e).animation) === null || i === void 0 ? void 0 : i.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const i = `_drag${e.toUpperCase()}`, a = this.visualElement.getProps(), o = a[i];
    return o || this.visualElement.getValue(e, (a.initial ? a.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    vs((i) => {
      const { drag: a } = this.getProps();
      if (!ox(i, a, this.currentDirection))
        return;
      const { projection: o } = this.visualElement, c = this.getAxisMotionValue(i);
      if (o && o.layout) {
        const { min: u, max: h } = o.layout.layoutBox[i];
        c.set(e[i] - si(u, h, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: i } = this.getProps(), { projection: a } = this.visualElement;
    if (!Qh(i) || !a || !this.constraints)
      return;
    this.stopAnimation();
    const o = { x: 0, y: 0 };
    vs((u) => {
      const h = this.getAxisMotionValue(u);
      if (h && this.constraints !== !1) {
        const m = h.get();
        o[u] = NK({ min: m, max: m }, this.constraints[u]);
      }
    });
    const { transformTemplate: c } = this.visualElement.getProps();
    this.visualElement.current.style.transform = c ? c({}, "") : "none", a.root && a.root.updateScroll(), a.updateLayout(), this.resolveConstraints(), vs((u) => {
      if (!ox(u, e, null))
        return;
      const h = this.getAxisMotionValue(u), { min: m, max: v } = this.constraints[u];
      h.set(si(m, v, o[u]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    UK.set(this.visualElement, this);
    const e = this.visualElement.current, i = lv(e, "pointerdown", (m) => {
      const { drag: v, dragListener: b = !0 } = this.getProps();
      v && b && this.start(m);
    }), a = () => {
      const { dragConstraints: m } = this.getProps();
      Qh(m) && m.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: o } = this.visualElement, c = o.addEventListener("measure", a);
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), $n.read(a);
    const u = Mv(window, "resize", () => this.scalePositionWithinConstraints()), h = o.addEventListener("didUpdate", ({ delta: m, hasLayoutChanged: v }) => {
      this.isDragging && v && (vs((b) => {
        const S = this.getAxisMotionValue(b);
        S && (this.originPoint[b] += m[b].translate, S.set(S.get() + m[b].translate));
      }), this.visualElement.render());
    });
    return () => {
      u(), i(), c(), h && h();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: i = !1, dragDirectionLock: a = !1, dragPropagation: o = !1, dragConstraints: c = !1, dragElastic: u = CE, dragMomentum: h = !0 } = e;
    return {
      ...e,
      drag: i,
      dragDirectionLock: a,
      dragPropagation: o,
      dragConstraints: c,
      dragElastic: u,
      dragMomentum: h
    };
  }
}
function ox(t, e, i) {
  return (e === !0 || e === t) && (i === null || i === t);
}
function $K(t, e = 10) {
  let i = null;
  return Math.abs(t.y) > e ? i = "y" : Math.abs(t.x) > e && (i = "x"), i;
}
class WK extends oc {
  constructor(e) {
    super(e), this.removeGroupControls = Ea, this.removeListeners = Ea, this.controls = new IK(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Ea;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const AP = (t) => (e, i) => {
  t && $n.postRender(() => t(e, i));
};
class YK extends oc {
  constructor() {
    super(...arguments), this.removePointerDownListener = Ea;
  }
  onPointerDown(e) {
    this.session = new _z(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: Mz(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: i, onPan: a, onPanEnd: o } = this.node.getProps();
    return {
      onSessionStart: AP(e),
      onStart: AP(i),
      onMove: a,
      onEnd: (c, u) => {
        delete this.session, o && $n.postRender(() => o(c, u));
      }
    };
  }
  mount() {
    this.removePointerDownListener = lv(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const wx = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function OP(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const $g = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (bt.test(t))
        t = parseFloat(t);
      else
        return t;
    const i = OP(t, e.target.x), a = OP(t, e.target.y);
    return `${i}% ${a}%`;
  }
}, GK = {
  correct: (t, { treeScale: e, projectionDelta: i }) => {
    const a = t, o = rc.parse(t);
    if (o.length > 5)
      return a;
    const c = rc.createTransformer(t), u = typeof o[0] != "number" ? 1 : 0, h = i.x.scale * e.x, m = i.y.scale * e.y;
    o[0 + u] /= h, o[1 + u] /= m;
    const v = si(h, m, 0.5);
    return typeof o[2 + u] == "number" && (o[2 + u] /= v), typeof o[3 + u] == "number" && (o[3 + u] /= v), c(o);
  }
};
class KK extends FU {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: i, switchLayoutGroup: a, layoutId: o } = this.props, { projection: c } = e;
    p7(XK), c && (i.group && i.group.add(c), a && a.register && o && a.register(c), c.root.didUpdate(), c.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), c.setOptions({
      ...c.options,
      onExitComplete: () => this.safeToRemove()
    })), wx.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: i, visualElement: a, drag: o, isPresent: c } = this.props, u = a.projection;
    return u && (u.isPresent = c, o || e.layoutDependency !== i || i === void 0 ? u.willUpdate() : this.safeToRemove(), e.isPresent !== c && (c ? u.promote() : u.relegate() || $n.postRender(() => {
      const h = u.getStack();
      (!h || !h.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), y1.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: i, switchLayoutGroup: a } = this.props, { projection: o } = e;
    o && (o.scheduleCheckAfterUnmount(), i && i.group && i.group.remove(o), a && a.deregister && a.deregister(o));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function Az(t) {
  const [e, i] = h2(), a = Oi(c1);
  return Ae.jsx(KK, { ...t, layoutGroup: a, switchLayoutGroup: Oi(S2), isPresent: e, safeToRemove: i });
}
const XK = {
  borderRadius: {
    ...$g,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: $g,
  borderTopRightRadius: $g,
  borderBottomLeftRadius: $g,
  borderBottomRightRadius: $g,
  boxShadow: GK
};
function QK(t, e, i) {
  const a = jr(t) ? t : Rv(t);
  return a.start(I1("", a, e, i)), a.animation;
}
function qK(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
const ZK = (t, e) => t.depth - e.depth;
class JK {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    O1(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    P1(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(ZK), this.isDirty = !1, this.children.forEach(e);
  }
}
function eX(t, e) {
  const i = Io.now(), a = ({ timestamp: o }) => {
    const c = o - i;
    c >= e && (ic(a), t(c - e));
  };
  return $n.read(a, !0), () => ic(a);
}
const Oz = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], tX = Oz.length, PP = (t) => typeof t == "string" ? parseFloat(t) : t, LP = (t) => typeof t == "number" || bt.test(t);
function nX(t, e, i, a, o, c) {
  o ? (t.opacity = si(
    0,
    // TODO Reinstate this if only child
    i.opacity !== void 0 ? i.opacity : 1,
    iX(a)
  ), t.opacityExit = si(e.opacity !== void 0 ? e.opacity : 1, 0, rX(a))) : c && (t.opacity = si(e.opacity !== void 0 ? e.opacity : 1, i.opacity !== void 0 ? i.opacity : 1, a));
  for (let u = 0; u < tX; u++) {
    const h = `border${Oz[u]}Radius`;
    let m = NP(e, h), v = NP(i, h);
    if (m === void 0 && v === void 0)
      continue;
    m || (m = 0), v || (v = 0), m === 0 || v === 0 || LP(m) === LP(v) ? (t[h] = Math.max(si(PP(m), PP(v), a), 0), (Uo.test(v) || Uo.test(m)) && (t[h] += "%")) : t[h] = v;
  }
  (e.rotate || i.rotate) && (t.rotate = si(e.rotate || 0, i.rotate || 0, a));
}
function NP(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const iX = /* @__PURE__ */ Pz(0, 0.5, q2), rX = /* @__PURE__ */ Pz(0.5, 0.95, Ea);
function Pz(t, e, i) {
  return (a) => a < t ? 0 : a > e ? 1 : i(/* @__PURE__ */ dp(t, e, a));
}
function zP(t, e) {
  t.min = e.min, t.max = e.max;
}
function gs(t, e) {
  zP(t.x, e.x), zP(t.y, e.y);
}
function FP(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function VP(t, e, i, a, o) {
  return t -= e, t = Kx(t, 1 / i, a), o !== void 0 && (t = Kx(t, 1 / o, a)), t;
}
function aX(t, e = 0, i = 1, a = 0.5, o, c = t, u = t) {
  if (Uo.test(e) && (e = parseFloat(e), e = si(u.min, u.max, e / 100) - u.min), typeof e != "number")
    return;
  let h = si(c.min, c.max, a);
  t === c && (h -= e), t.min = VP(t.min, e, i, h, o), t.max = VP(t.max, e, i, h, o);
}
function jP(t, e, [i, a, o], c, u) {
  aX(t, e[i], e[a], e[o], e.scale, c, u);
}
const sX = ["x", "scaleX", "originX"], oX = ["y", "scaleY", "originY"];
function BP(t, e, i, a) {
  jP(t.x, e, sX, i ? i.x : void 0, a ? a.x : void 0), jP(t.y, e, oX, i ? i.y : void 0, a ? a.y : void 0);
}
function HP(t) {
  return t.translate === 0 && t.scale === 1;
}
function Lz(t) {
  return HP(t.x) && HP(t.y);
}
function UP(t, e) {
  return t.min === e.min && t.max === e.max;
}
function lX(t, e) {
  return UP(t.x, e.x) && UP(t.y, e.y);
}
function IP(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function Nz(t, e) {
  return IP(t.x, e.x) && IP(t.y, e.y);
}
function $P(t) {
  return Ya(t.x) / Ya(t.y);
}
function WP(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class uX {
  constructor() {
    this.members = [];
  }
  add(e) {
    O1(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (P1(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const i = this.members[this.members.length - 1];
      i && this.promote(i);
    }
  }
  relegate(e) {
    const i = this.members.findIndex((o) => e === o);
    if (i === 0)
      return !1;
    let a;
    for (let o = i; o >= 0; o--) {
      const c = this.members[o];
      if (c.isPresent !== !1) {
        a = c;
        break;
      }
    }
    return a ? (this.promote(a), !0) : !1;
  }
  promote(e, i) {
    const a = this.lead;
    if (e !== a && (this.prevLead = a, this.lead = e, e.show(), a)) {
      a.instance && a.scheduleRender(), e.scheduleRender(), e.resumeFrom = a, i && (e.resumeFrom.preserveOpacity = !0), a.snapshot && (e.snapshot = a.snapshot, e.snapshot.latestValues = a.animationValues || a.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: o } = e.options;
      o === !1 && a.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: i, resumingFrom: a } = e;
      i.onExitComplete && i.onExitComplete(), a && a.options.onExitComplete && a.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function cX(t, e, i) {
  let a = "";
  const o = t.x.translate / e.x, c = t.y.translate / e.y, u = (i == null ? void 0 : i.z) || 0;
  if ((o || c || u) && (a = `translate3d(${o}px, ${c}px, ${u}px) `), (e.x !== 1 || e.y !== 1) && (a += `scale(${1 / e.x}, ${1 / e.y}) `), i) {
    const { transformPerspective: v, rotate: b, rotateX: S, rotateY: w, skewX: E, skewY: R } = i;
    v && (a = `perspective(${v}px) ${a}`), b && (a += `rotate(${b}deg) `), S && (a += `rotateX(${S}deg) `), w && (a += `rotateY(${w}deg) `), E && (a += `skewX(${E}deg) `), R && (a += `skewY(${R}deg) `);
  }
  const h = t.x.scale * e.x, m = t.y.scale * e.y;
  return (h !== 1 || m !== 1) && (a += `scale(${h}, ${m})`), a || "none";
}
const zf = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, ev = typeof window < "u" && window.MotionDebug !== void 0, DT = ["", "X", "Y", "Z"], fX = { visibility: "hidden" }, YP = 1e3;
let dX = 0;
function RT(t, e, i, a) {
  const { latestValues: o } = e;
  o[t] && (i[t] = o[t], e.setStaticValue(t, 0), a && (a[t] = 0));
}
function zz(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const i = $2(e);
  if (window.MotionHasOptimisedAnimation(i, "transform")) {
    const { layout: o, layoutId: c } = t.options;
    window.MotionCancelOptimisedAnimation(i, "transform", $n, !(o || c));
  }
  const { parent: a } = t;
  a && !a.hasCheckedOptimisedAppear && zz(a);
}
function Fz({ attachResizeListener: t, defaultParent: e, measureScroll: i, checkIsScrollRoot: a, resetTransform: o }) {
  return class {
    constructor(u = {}, h = e == null ? void 0 : e()) {
      this.id = dX++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, ev && (zf.totalNodes = zf.resolvedTargetDeltas = zf.recalculatedProjection = 0), this.nodes.forEach(mX), this.nodes.forEach(xX), this.nodes.forEach(SX), this.nodes.forEach(gX), ev && window.MotionDebug.record(zf);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = u, this.root = h ? h.root || h : this, this.path = h ? [...h.path, h] : [], this.parent = h, this.depth = h ? h.depth + 1 : 0;
      for (let m = 0; m < this.path.length; m++)
        this.path[m].shouldResetTransform = !0;
      this.root === this && (this.nodes = new JK());
    }
    addEventListener(u, h) {
      return this.eventHandlers.has(u) || this.eventHandlers.set(u, new L1()), this.eventHandlers.get(u).add(h);
    }
    notifyListeners(u, ...h) {
      const m = this.eventHandlers.get(u);
      m && m.notify(...h);
    }
    hasListeners(u) {
      return this.eventHandlers.has(u);
    }
    /**
     * Lifecycles
     */
    mount(u, h = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = qK(u), this.instance = u;
      const { layoutId: m, layout: v, visualElement: b } = this.options;
      if (b && !b.current && b.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), h && (v || m) && (this.isLayoutDirty = !0), t) {
        let S;
        const w = () => this.root.updateBlockedByResize = !1;
        t(u, () => {
          this.root.updateBlockedByResize = !0, S && S(), S = eX(w, 250), wx.hasAnimatedSinceResize && (wx.hasAnimatedSinceResize = !1, this.nodes.forEach(KP));
        });
      }
      m && this.root.registerSharedNode(m, this), this.options.animate !== !1 && b && (m || v) && this.addEventListener("didUpdate", ({ delta: S, hasLayoutChanged: w, hasRelativeTargetChanged: E, layout: R }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const M = this.options.transition || b.getDefaultTransition() || EX, { onLayoutAnimationStart: A, onLayoutAnimationComplete: P } = b.getProps(), z = !this.targetLayout || !Nz(this.targetLayout, R) || E, B = !w && E;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || B || w && (z || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(S, B);
          const j = {
            ...R1(M, "layout"),
            onPlay: A,
            onComplete: P
          };
          (b.shouldReduceMotion || this.options.layoutRoot) && (j.delay = 0, j.type = !1), this.startAnimation(j);
        } else
          w || KP(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = R;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const u = this.getStack();
      u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, ic(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(_X), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: u } = this.options;
      return u && u.getProps().transformTemplate;
    }
    willUpdate(u = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && zz(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let b = 0; b < this.path.length; b++) {
        const S = this.path[b];
        S.shouldResetTransform = !0, S.updateScroll("snapshot"), S.options.layoutRoot && S.willUpdate(!1);
      }
      const { layoutId: h, layout: m } = this.options;
      if (h === void 0 && !m)
        return;
      const v = this.getTransformTemplate();
      this.prevTransformTemplateValue = v ? v(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(GP);
        return;
      }
      this.isUpdating || this.nodes.forEach(yX), this.isUpdating = !1, this.nodes.forEach(bX), this.nodes.forEach(hX), this.nodes.forEach(pX), this.clearAllSnapshots();
      const h = Io.now();
      vr.delta = Xl(0, 1e3 / 60, h - vr.timestamp), vr.timestamp = h, vr.isProcessing = !0, bT.update.process(vr), bT.preRender.process(vr), bT.render.process(vr), vr.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, y1.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(vX), this.sharedNodes.forEach(wX);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, $n.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      $n.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let m = 0; m < this.path.length; m++)
          this.path[m].updateScroll();
      const u = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Ci(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: h } = this.options;
      h && h.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0);
    }
    updateScroll(u = "measure") {
      let h = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (h = !1), h) {
        const m = a(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: u,
          isRoot: m,
          offset: i(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : m
        };
      }
    }
    resetTransform() {
      if (!o)
        return;
      const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, h = this.projectionDelta && !Lz(this.projectionDelta), m = this.getTransformTemplate(), v = m ? m(this.latestValues, "") : void 0, b = v !== this.prevTransformTemplateValue;
      u && (h || Nf(this.latestValues) || b) && (o(this.instance, v), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(u = !0) {
      const h = this.measurePageBox();
      let m = this.removeElementScroll(h);
      return u && (m = this.removeTransform(m)), DX(m), {
        animationId: this.root.animationId,
        measuredBox: h,
        layoutBox: m,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var u;
      const { visualElement: h } = this.options;
      if (!h)
        return Ci();
      const m = h.measureViewportBox();
      if (!(((u = this.scroll) === null || u === void 0 ? void 0 : u.wasRoot) || this.path.some(RX))) {
        const { scroll: b } = this.root;
        b && (Jh(m.x, b.offset.x), Jh(m.y, b.offset.y));
      }
      return m;
    }
    removeElementScroll(u) {
      var h;
      const m = Ci();
      if (gs(m, u), !((h = this.scroll) === null || h === void 0) && h.wasRoot)
        return m;
      for (let v = 0; v < this.path.length; v++) {
        const b = this.path[v], { scroll: S, options: w } = b;
        b !== this.root && S && w.layoutScroll && (S.wasRoot && gs(m, u), Jh(m.x, S.offset.x), Jh(m.y, S.offset.y));
      }
      return m;
    }
    applyTransform(u, h = !1) {
      const m = Ci();
      gs(m, u);
      for (let v = 0; v < this.path.length; v++) {
        const b = this.path[v];
        !h && b.options.layoutScroll && b.scroll && b !== b.root && ep(m, {
          x: -b.scroll.offset.x,
          y: -b.scroll.offset.y
        }), Nf(b.latestValues) && ep(m, b.latestValues);
      }
      return Nf(this.latestValues) && ep(m, this.latestValues), m;
    }
    removeTransform(u) {
      const h = Ci();
      gs(h, u);
      for (let m = 0; m < this.path.length; m++) {
        const v = this.path[m];
        if (!v.instance || !Nf(v.latestValues))
          continue;
        TE(v.latestValues) && v.updateSnapshot();
        const b = Ci(), S = v.measurePageBox();
        gs(b, S), BP(h, v.latestValues, v.snapshot ? v.snapshot.layoutBox : void 0, b);
      }
      return Nf(this.latestValues) && BP(h, this.latestValues), h;
    }
    setTargetDelta(u) {
      this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(u) {
      this.options = {
        ...this.options,
        ...u,
        crossfade: u.crossfade !== void 0 ? u.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== vr.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(u = !1) {
      var h;
      const m = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = m.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = m.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = m.isSharedProjectionDirty);
      const v = !!this.resumingFrom || this !== m;
      if (!(u || v && this.isSharedProjectionDirty || this.isProjectionDirty || !((h = this.parent) === null || h === void 0) && h.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: S, layoutId: w } = this.options;
      if (!(!this.layout || !(S || w))) {
        if (this.resolvedRelativeTargetAt = vr.timestamp, !this.targetDelta && !this.relativeTarget) {
          const E = this.getClosestProjectingParent();
          E && E.layout && this.animationProgress !== 1 ? (this.relativeParent = E, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ci(), this.relativeTargetOrigin = Ci(), cv(this.relativeTargetOrigin, this.layout.layoutBox, E.layout.layoutBox), gs(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = Ci(), this.targetWithTransforms = Ci()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), AK(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : gs(this.target, this.layout.layoutBox), Rz(this.target, this.targetDelta)) : gs(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const E = this.getClosestProjectingParent();
            E && !!E.resumingFrom == !!this.resumingFrom && !E.options.layoutScroll && E.target && this.animationProgress !== 1 ? (this.relativeParent = E, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ci(), this.relativeTargetOrigin = Ci(), cv(this.relativeTargetOrigin, this.target, E.target), gs(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          ev && zf.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || TE(this.parent.latestValues) || Dz(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var u;
      const h = this.getLead(), m = !!this.resumingFrom || this !== h;
      let v = !0;
      if ((this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty) && (v = !1), m && (this.isSharedProjectionDirty || this.isTransformDirty) && (v = !1), this.resolvedRelativeTargetAt === vr.timestamp && (v = !1), v)
        return;
      const { layout: b, layoutId: S } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(b || S))
        return;
      gs(this.layoutCorrected, this.layout.layoutBox);
      const w = this.treeScale.x, E = this.treeScale.y;
      BK(this.layoutCorrected, this.treeScale, this.path, m), h.layout && !h.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (h.target = h.layout.layoutBox, h.targetWithTransforms = Ci());
      const { target: R } = h;
      if (!R) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (FP(this.prevProjectionDelta.x, this.projectionDelta.x), FP(this.prevProjectionDelta.y, this.projectionDelta.y)), uv(this.projectionDelta, this.layoutCorrected, R, this.latestValues), (this.treeScale.x !== w || this.treeScale.y !== E || !WP(this.projectionDelta.x, this.prevProjectionDelta.x) || !WP(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", R)), ev && zf.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(u = !0) {
      var h;
      if ((h = this.options.visualElement) === null || h === void 0 || h.scheduleRender(), u) {
        const m = this.getStack();
        m && m.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Zh(), this.projectionDelta = Zh(), this.projectionDeltaWithTransform = Zh();
    }
    setAnimationOrigin(u, h = !1) {
      const m = this.snapshot, v = m ? m.latestValues : {}, b = { ...this.latestValues }, S = Zh();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !h;
      const w = Ci(), E = m ? m.source : void 0, R = this.layout ? this.layout.source : void 0, M = E !== R, A = this.getStack(), P = !A || A.members.length <= 1, z = !!(M && !P && this.options.crossfade === !0 && !this.path.some(TX));
      this.animationProgress = 0;
      let B;
      this.mixTargetDelta = (j) => {
        const F = j / 1e3;
        XP(S.x, u.x, F), XP(S.y, u.y, F), this.setTargetDelta(S), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (cv(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox), CX(this.relativeTarget, this.relativeTargetOrigin, w, F), B && lX(this.relativeTarget, B) && (this.isProjectionDirty = !1), B || (B = Ci()), gs(B, this.relativeTarget)), M && (this.animationValues = b, nX(b, v, this.latestValues, F, z, P)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = F;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(u) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (ic(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = $n.update(() => {
        wx.hasAnimatedSinceResize = !0, this.currentAnimation = QK(0, YP, {
          ...u,
          onUpdate: (h) => {
            this.mixTargetDelta(h), u.onUpdate && u.onUpdate(h);
          },
          onComplete: () => {
            u.onComplete && u.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const u = this.getStack();
      u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(YP), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const u = this.getLead();
      let { targetWithTransforms: h, target: m, layout: v, latestValues: b } = u;
      if (!(!h || !m || !v)) {
        if (this !== u && this.layout && v && Vz(this.options.animationType, this.layout.layoutBox, v.layoutBox)) {
          m = this.target || Ci();
          const S = Ya(this.layout.layoutBox.x);
          m.x.min = u.target.x.min, m.x.max = m.x.min + S;
          const w = Ya(this.layout.layoutBox.y);
          m.y.min = u.target.y.min, m.y.max = m.y.min + w;
        }
        gs(h, m), ep(h, b), uv(this.projectionDeltaWithTransform, this.layoutCorrected, h, b);
      }
    }
    registerSharedNode(u, h) {
      this.sharedNodes.has(u) || this.sharedNodes.set(u, new uX()), this.sharedNodes.get(u).add(h);
      const v = h.options.initialPromotionConfig;
      h.promote({
        transition: v ? v.transition : void 0,
        preserveFollowOpacity: v && v.shouldPreserveFollowOpacity ? v.shouldPreserveFollowOpacity(h) : void 0
      });
    }
    isLead() {
      const u = this.getStack();
      return u ? u.lead === this : !0;
    }
    getLead() {
      var u;
      const { layoutId: h } = this.options;
      return h ? ((u = this.getStack()) === null || u === void 0 ? void 0 : u.lead) || this : this;
    }
    getPrevLead() {
      var u;
      const { layoutId: h } = this.options;
      return h ? (u = this.getStack()) === null || u === void 0 ? void 0 : u.prevLead : void 0;
    }
    getStack() {
      const { layoutId: u } = this.options;
      if (u)
        return this.root.sharedNodes.get(u);
    }
    promote({ needsReset: u, transition: h, preserveFollowOpacity: m } = {}) {
      const v = this.getStack();
      v && v.promote(this, m), u && (this.projectionDelta = void 0, this.needsReset = !0), h && this.setOptions({ transition: h });
    }
    relegate() {
      const u = this.getStack();
      return u ? u.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: u } = this.options;
      if (!u)
        return;
      let h = !1;
      const { latestValues: m } = u;
      if ((m.z || m.rotate || m.rotateX || m.rotateY || m.rotateZ || m.skewX || m.skewY) && (h = !0), !h)
        return;
      const v = {};
      m.z && RT("z", u, v, this.animationValues);
      for (let b = 0; b < DT.length; b++)
        RT(`rotate${DT[b]}`, u, v, this.animationValues), RT(`skew${DT[b]}`, u, v, this.animationValues);
      u.render();
      for (const b in v)
        u.setStaticValue(b, v[b]), this.animationValues && (this.animationValues[b] = v[b]);
      u.scheduleRender();
    }
    getProjectionStyles(u) {
      var h, m;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return fX;
      const v = {
        visibility: ""
      }, b = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, v.opacity = "", v.pointerEvents = Sx(u == null ? void 0 : u.pointerEvents) || "", v.transform = b ? b(this.latestValues, "") : "none", v;
      const S = this.getLead();
      if (!this.projectionDelta || !this.layout || !S.target) {
        const M = {};
        return this.options.layoutId && (M.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, M.pointerEvents = Sx(u == null ? void 0 : u.pointerEvents) || ""), this.hasProjected && !Nf(this.latestValues) && (M.transform = b ? b({}, "") : "none", this.hasProjected = !1), M;
      }
      const w = S.animationValues || S.latestValues;
      this.applyTransformsToTarget(), v.transform = cX(this.projectionDeltaWithTransform, this.treeScale, w), b && (v.transform = b(w, v.transform));
      const { x: E, y: R } = this.projectionDelta;
      v.transformOrigin = `${E.origin * 100}% ${R.origin * 100}% 0`, S.animationValues ? v.opacity = S === this ? (m = (h = w.opacity) !== null && h !== void 0 ? h : this.latestValues.opacity) !== null && m !== void 0 ? m : 1 : this.preserveOpacity ? this.latestValues.opacity : w.opacityExit : v.opacity = S === this ? w.opacity !== void 0 ? w.opacity : "" : w.opacityExit !== void 0 ? w.opacityExit : 0;
      for (const M in Ix) {
        if (w[M] === void 0)
          continue;
        const { correct: A, applyTo: P } = Ix[M], z = v.transform === "none" ? w[M] : A(w[M], S);
        if (P) {
          const B = P.length;
          for (let j = 0; j < B; j++)
            v[P[j]] = z;
        } else
          v[M] = z;
      }
      return this.options.layoutId && (v.pointerEvents = S === this ? Sx(u == null ? void 0 : u.pointerEvents) || "" : "none"), v;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((u) => {
        var h;
        return (h = u.currentAnimation) === null || h === void 0 ? void 0 : h.stop();
      }), this.root.nodes.forEach(GP), this.root.sharedNodes.clear();
    }
  };
}
function hX(t) {
  t.updateLayout();
}
function pX(t) {
  var e;
  const i = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && i && t.hasListeners("didUpdate")) {
    const { layoutBox: a, measuredBox: o } = t.layout, { animationType: c } = t.options, u = i.source !== t.layout.source;
    c === "size" ? vs((S) => {
      const w = u ? i.measuredBox[S] : i.layoutBox[S], E = Ya(w);
      w.min = a[S].min, w.max = w.min + E;
    }) : Vz(c, i.layoutBox, a) && vs((S) => {
      const w = u ? i.measuredBox[S] : i.layoutBox[S], E = Ya(a[S]);
      w.max = w.min + E, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[S].max = t.relativeTarget[S].min + E);
    });
    const h = Zh();
    uv(h, a, i.layoutBox);
    const m = Zh();
    u ? uv(m, t.applyTransform(o, !0), i.measuredBox) : uv(m, a, i.layoutBox);
    const v = !Lz(h);
    let b = !1;
    if (!t.resumeFrom) {
      const S = t.getClosestProjectingParent();
      if (S && !S.resumeFrom) {
        const { snapshot: w, layout: E } = S;
        if (w && E) {
          const R = Ci();
          cv(R, i.layoutBox, w.layoutBox);
          const M = Ci();
          cv(M, a, E.layoutBox), Nz(R, M) || (b = !0), S.options.layoutRoot && (t.relativeTarget = M, t.relativeTargetOrigin = R, t.relativeParent = S);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: a,
      snapshot: i,
      delta: m,
      layoutDelta: h,
      hasLayoutChanged: v,
      hasRelativeTargetChanged: b
    });
  } else if (t.isLead()) {
    const { onExitComplete: a } = t.options;
    a && a();
  }
  t.options.transition = void 0;
}
function mX(t) {
  ev && zf.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function gX(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function vX(t) {
  t.clearSnapshot();
}
function GP(t) {
  t.clearMeasurements();
}
function yX(t) {
  t.isLayoutDirty = !1;
}
function bX(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function KP(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function xX(t) {
  t.resolveTargetDelta();
}
function SX(t) {
  t.calcProjection();
}
function _X(t) {
  t.resetSkewAndRotation();
}
function wX(t) {
  t.removeLeadSnapshot();
}
function XP(t, e, i) {
  t.translate = si(e.translate, 0, i), t.scale = si(e.scale, 1, i), t.origin = e.origin, t.originPoint = e.originPoint;
}
function QP(t, e, i, a) {
  t.min = si(e.min, i.min, a), t.max = si(e.max, i.max, a);
}
function CX(t, e, i, a) {
  QP(t.x, e.x, i.x, a), QP(t.y, e.y, i.y, a);
}
function TX(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const EX = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, qP = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), ZP = qP("applewebkit/") && !qP("chrome/") ? Math.round : Ea;
function JP(t) {
  t.min = ZP(t.min), t.max = ZP(t.max);
}
function DX(t) {
  JP(t.x), JP(t.y);
}
function Vz(t, e, i) {
  return t === "position" || t === "preserve-aspect" && !MK($P(e), $P(i), 0.2);
}
function RX(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const kX = Fz({
  attachResizeListener: (t, e) => Mv(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), kT = {
  current: void 0
}, jz = Fz({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!kT.current) {
      const t = new kX({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), kT.current = t;
    }
    return kT.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), MX = {
  pan: {
    Feature: YK
  },
  drag: {
    Feature: WK,
    ProjectionNode: jz,
    MeasureLayout: Az
  }
};
function eL(t, e, i) {
  const { props: a } = t;
  t.animationState && a.whileHover && t.animationState.setActive("whileHover", i === "Start");
  const o = "onHover" + i, c = a[o];
  c && $n.postRender(() => c(e, Bv(e)));
}
class AX extends oc {
  mount() {
    const { current: e } = this.node;
    e && (this.unmount = M7(e, (i) => (eL(this.node, i, "Start"), (a) => eL(this.node, a, "End"))));
  }
  unmount() {
  }
}
class OX extends oc {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = jv(Mv(this.node.current, "focus", () => this.onFocus()), Mv(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function tL(t, e, i) {
  const { props: a } = t;
  t.animationState && a.whileTap && t.animationState.setActive("whileTap", i === "Start");
  const o = "onTap" + (i === "End" ? "" : i), c = a[o];
  c && $n.postRender(() => c(e, Bv(e)));
}
class PX extends oc {
  mount() {
    const { current: e } = this.node;
    e && (this.unmount = L7(e, (i) => (tL(this.node, i, "Start"), (a, { success: o }) => tL(this.node, a, o ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const DE = /* @__PURE__ */ new WeakMap(), MT = /* @__PURE__ */ new WeakMap(), LX = (t) => {
  const e = DE.get(t.target);
  e && e(t);
}, NX = (t) => {
  t.forEach(LX);
};
function zX({ root: t, ...e }) {
  const i = t || document;
  MT.has(i) || MT.set(i, {});
  const a = MT.get(i), o = JSON.stringify(e);
  return a[o] || (a[o] = new IntersectionObserver(NX, { root: t, ...e })), a[o];
}
function FX(t, e, i) {
  const a = zX(e);
  return DE.set(t, i), a.observe(t), () => {
    DE.delete(t), a.unobserve(t);
  };
}
const VX = {
  some: 0,
  all: 1
};
class jX extends oc {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: i, margin: a, amount: o = "some", once: c } = e, u = {
      root: i ? i.current : void 0,
      rootMargin: a,
      threshold: typeof o == "number" ? o : VX[o]
    }, h = (m) => {
      const { isIntersecting: v } = m;
      if (this.isInView === v || (this.isInView = v, c && !v && this.hasEnteredView))
        return;
      v && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", v);
      const { onViewportEnter: b, onViewportLeave: S } = this.node.getProps(), w = v ? b : S;
      w && w(m);
    };
    return FX(this.node.current, u, h);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: i } = this.node;
    ["amount", "margin", "root"].some(BX(e, i)) && this.startObserver();
  }
  unmount() {
  }
}
function BX({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (i) => t[i] !== e[i];
}
const HX = {
  inView: {
    Feature: jX
  },
  tap: {
    Feature: PX
  },
  focus: {
    Feature: OX
  },
  hover: {
    Feature: AX
  }
}, UX = {
  layout: {
    ProjectionNode: jz,
    MeasureLayout: Az
  }
}, RE = { current: null }, Bz = { current: !1 };
function IX() {
  if (Bz.current = !0, !!h1)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => RE.current = t.matches;
      t.addListener(e), e();
    } else
      RE.current = !1;
}
const $X = [...fz, Fr, rc], WX = (t) => $X.find(cz(t)), nL = /* @__PURE__ */ new WeakMap();
function YX(t, e, i) {
  for (const a in e) {
    const o = e[a], c = i[a];
    if (jr(o))
      t.addValue(a, o), process.env.NODE_ENV === "development" && vS(o.version === "11.18.2", `Attempting to mix Motion versions ${o.version} with 11.18.2 may not work as expected.`);
    else if (jr(c))
      t.addValue(a, Rv(o, { owner: t }));
    else if (c !== o)
      if (t.hasValue(a)) {
        const u = t.getValue(a);
        u.liveStyle === !0 ? u.jump(o) : u.hasAnimated || u.set(o);
      } else {
        const u = t.getStaticValue(a);
        t.addValue(a, Rv(u !== void 0 ? u : o, { owner: t }));
      }
  }
  for (const a in i)
    e[a] === void 0 && t.removeValue(a);
  return e;
}
const iL = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class GX {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, i, a) {
    return {};
  }
  constructor({ parent: e, props: i, presenceContext: a, reducedMotionConfig: o, blockInitialAnimation: c, visualState: u }, h = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = B1, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const E = Io.now();
      this.renderScheduledAt < E && (this.renderScheduledAt = E, $n.render(this.render, !1, !0));
    };
    const { latestValues: m, renderState: v, onUpdate: b } = u;
    this.onUpdate = b, this.latestValues = m, this.baseTarget = { ...m }, this.initialValues = i.initial ? { ...m } : {}, this.renderState = v, this.parent = e, this.props = i, this.presenceContext = a, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = o, this.options = h, this.blockInitialAnimation = !!c, this.isControllingVariants = xS(i), this.isVariantNode = b2(i), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: S, ...w } = this.scrapeMotionValuesFromProps(i, {}, this);
    for (const E in w) {
      const R = w[E];
      m[E] !== void 0 && jr(R) && R.set(m[E], !1);
    }
  }
  mount(e) {
    this.current = e, nL.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((i, a) => this.bindToMotionValue(a, i)), Bz.current || IX(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : RE.current, process.env.NODE_ENV !== "production" && vS(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    nL.delete(this.current), this.projection && this.projection.unmount(), ic(this.notifyUpdate), ic(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const i = this.features[e];
      i && (i.unmount(), i.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, i) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const a = Qf.has(e), o = i.on("change", (h) => {
      this.latestValues[e] = h, this.props.onUpdate && $n.preRender(this.notifyUpdate), a && this.projection && (this.projection.isTransformDirty = !0);
    }), c = i.on("renderRequest", this.scheduleRender);
    let u;
    window.MotionCheckAppearSync && (u = window.MotionCheckAppearSync(this, e, i)), this.valueSubscriptions.set(e, () => {
      o(), c(), u && u(), i.owner && i.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in hp) {
      const i = hp[e];
      if (!i)
        continue;
      const { isEnabled: a, Feature: o } = i;
      if (!this.features[e] && o && a(this.props) && (this.features[e] = new o(this)), this.features[e]) {
        const c = this.features[e];
        c.isMounted ? c.update() : (c.mount(), c.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ci();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, i) {
    this.latestValues[e] = i;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, i) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = i;
    for (let a = 0; a < iL.length; a++) {
      const o = iL[a];
      this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]);
      const c = "on" + o, u = e[c];
      u && (this.propEventSubscriptions[o] = this.on(o, u));
    }
    this.prevMotionValues = YX(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const i = this.getClosestVariantNode();
    if (i)
      return i.variantChildren && i.variantChildren.add(e), () => i.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, i) {
    const a = this.values.get(e);
    i !== a && (a && this.removeValue(e), this.bindToMotionValue(e, i), this.values.set(e, i), this.latestValues[e] = i.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const i = this.valueSubscriptions.get(e);
    i && (i(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, i) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let a = this.values.get(e);
    return a === void 0 && i !== void 0 && (a = Rv(i === null ? void 0 : i, { owner: this }), this.addValue(e, a)), a;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, i) {
    var a;
    let o = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (a = this.getBaseTargetFromProps(this.props, e)) !== null && a !== void 0 ? a : this.readValueFromInstance(this.current, e, this.options);
    return o != null && (typeof o == "string" && (lz(o) || J2(o)) ? o = parseFloat(o) : !WX(o) && rc.test(i) && (o = az(e, i)), this.setBaseTarget(e, jr(o) ? o.get() : o)), jr(o) ? o.get() : o;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, i) {
    this.baseTarget[e] = i;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var i;
    const { initial: a } = this.props;
    let o;
    if (typeof a == "string" || typeof a == "object") {
      const u = x1(this.props, a, (i = this.presenceContext) === null || i === void 0 ? void 0 : i.custom);
      u && (o = u[e]);
    }
    if (a && o !== void 0)
      return o;
    const c = this.getBaseTargetFromProps(this.props, e);
    return c !== void 0 && !jr(c) ? c : this.initialValues[e] !== void 0 && o === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, i) {
    return this.events[e] || (this.events[e] = new L1()), this.events[e].add(i);
  }
  notify(e, ...i) {
    this.events[e] && this.events[e].notify(...i);
  }
}
class Hz extends GX {
  constructor() {
    super(...arguments), this.KeyframeResolver = dz;
  }
  sortInstanceNodePosition(e, i) {
    return e.compareDocumentPosition(i) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, i) {
    return e.style ? e.style[i] : void 0;
  }
  removeValueFromRenderState(e, { vars: i, style: a }) {
    delete i[e], delete a[e];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    jr(e) && (this.childSubscription = e.on("change", (i) => {
      this.current && (this.current.textContent = `${i}`);
    }));
  }
}
function KX(t) {
  return window.getComputedStyle(t);
}
class XX extends Hz {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = R2;
  }
  readValueFromInstance(e, i) {
    if (Qf.has(i)) {
      const a = j1(i);
      return a && a.default || 0;
    } else {
      const a = KX(e), o = (T2(i) ? a.getPropertyValue(i) : a[i]) || 0;
      return typeof o == "string" ? o.trim() : o;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: i }) {
    return kz(e, i);
  }
  build(e, i, a) {
    w1(e, i, a.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, i, a) {
    return D1(e, i, a);
  }
}
class QX extends Hz {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Ci;
  }
  getBaseTargetFromProps(e, i) {
    return e[i];
  }
  readValueFromInstance(e, i) {
    if (Qf.has(i)) {
      const a = j1(i);
      return a && a.default || 0;
    }
    return i = k2.has(i) ? i : v1(i), e.getAttribute(i);
  }
  scrapeMotionValuesFromProps(e, i, a) {
    return O2(e, i, a);
  }
  build(e, i, a) {
    C1(e, i, this.isSVGTag, a.transformTemplate);
  }
  renderInstance(e, i, a, o) {
    M2(e, i, a, o);
  }
  mount(e) {
    this.isSVGTag = E1(e.tagName), super.mount(e);
  }
}
const qX = (t, e) => b1(t) ? new QX(e) : new XX(e, {
  allowProjection: t !== sL
}), ZX = /* @__PURE__ */ w7({
  ...SK,
  ...HX,
  ...MX,
  ...UX
}, qX), Uz = /* @__PURE__ */ V9(ZX), Iz = Wo(void 0), $z = ({
  children: t,
  onClose: e = () => {
  }
}) => {
  const [i, a] = En(!0), o = () => {
    a(!1), e();
  };
  return /* @__PURE__ */ Ae.jsx(Iz.Provider, { value: { handleClose: o, isVisible: i, setIsVisible: a }, children: t });
};
$z.displayName = "HToastPopupProvider";
const JX = ({ children: t, onClose: e }) => /* @__PURE__ */ Ae.jsx($z, { onClose: e, children: /* @__PURE__ */ Ae.jsx(
  Uz.div,
  {
    initial: { opacity: 0, y: 50, height: 0 },
    animate: { opacity: 1, y: 0, height: "auto" },
    exit: { opacity: 0, height: 0 },
    transition: { duration: 0.3 },
    layout: !0,
    children: t
  }
) });
JX.displayName = "HToastPopupArea";
const Wz = () => {
  const t = Oi(Iz);
  if (!t)
    throw new Error("useToastContext must be used within a ToastPopupProvider");
  return t;
}, eQ = ({
  duration: t = 3e3,
  className: e,
  children: i
}) => {
  const { setIsVisible: a, isVisible: o, handleClose: c } = Wz();
  return Xn(() => {
    const u = setTimeout(() => {
      a(!1), c();
    }, t);
    return () => clearTimeout(u);
  }, [t]), /* @__PURE__ */ Ae.jsx(m2, { children: o && /* @__PURE__ */ Ae.jsx(
    Uz.div,
    {
      initial: { opacity: 0, y: 50 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: 50 },
      transition: { duration: 0.3 },
      className: `rounded-lg shadow-lg overflow-hidden w-full md:w-96 text-[#888] bg-black/70 ${e}`,
      role: "alert",
      "aria-live": "assertive",
      children: i
    }
  ) });
};
eQ.displayName = "HToastPopup";
const tQ = ({ className: t, children: e, style: i }) => /* @__PURE__ */ Ae.jsx("div", { style: i, className: `fixed bottom-4 right-4 z-[200] p-4 space-y-4 flex flex-col ${t}`, children: /* @__PURE__ */ Ae.jsx(m2, { children: e }) });
tQ.displayName = "HToastPopupContainer";
const nQ = ({ children: t, className: e }) => {
  const { handleClose: i } = Wz();
  return /* @__PURE__ */ Ae.jsx(
    "button",
    {
      type: "button",
      onClick: i,
      className: `focus:outline-none focus:ring-2 focus:ring-gray-400 rounded-full p-1 text-[#fff] ${e}`,
      "aria-label": "Close",
      children: t
    }
  );
};
nQ.displayName = "HToastPopupCloseButton";
const iQ = ({ target: t, children: e, className: i, style: a }) => {
  const o = (h) => {
    var m;
    (m = t.current) == null || m.show(h);
  }, c = (h) => {
    var m;
    (m = t.current) == null || m.updatePosition(h);
  }, u = () => {
    var h;
    (h = t.current) == null || h.hide();
  };
  return /* @__PURE__ */ Ae.jsx(
    "div",
    {
      onMouseEnter: o,
      onMouseMove: c,
      onMouseLeave: u,
      className: i,
      style: a,
      children: e
    }
  );
};
iQ.displayName = "HTooltipArea";
const rQ = Av((t, e) => {
  const [i, a] = En(!1), [o, c] = En({
    x: 0,
    y: 0
  });
  Xx(e, () => ({
    show(h) {
      c({ x: h.clientX, y: h.clientY }), a(!0);
    },
    hide() {
      a(!1);
    },
    updatePosition(h) {
      i && c({ x: h.clientX, y: h.clientY });
    }
  }));
  const u = {
    position: "fixed",
    // Changed from 'absolute' to 'fixed'
    top: o.y + 10,
    // Slight offset for better visibility
    left: o.x + 10,
    backgroundColor: "#333",
    color: "#fff",
    padding: "8px",
    borderRadius: "4px",
    zIndex: 1e3,
    pointerEvents: "none"
    // Ensure tooltip doesn't intercept mouse events
  };
  return i ? /* @__PURE__ */ Ae.jsx(
    "div",
    {
      style: {
        ...u,
        ...t.style
      },
      className: t.className,
      children: t.children
    }
  ) : null;
});
rQ.displayName = "HTooltip";
const aQ = Av((t, e) => {
  const {
    backdrop: i,
    escBeforeFunc: a,
    escAfterFunc: o,
    onBackdropClick: c,
    children: u,
    className: h,
    style: m
  } = t, v = xn(null), b = async () => {
    v.current && v.current.close();
  }, S = () => {
    v.current && v.current.showModal();
  };
  Xx(e, () => ({
    open: S,
    closeFunc: b
  })), Xn(() => (i && document.documentElement.style.setProperty("--modal-backdrop-color", i), () => {
    i && document.documentElement.style.removeProperty("--modal-backdrop-color");
  }), [i]);
  const w = async (R) => {
    R.key === "Escape" && (R.preventDefault(), a && await a(), b(), o && await o());
  }, E = (R) => {
    R.target === v.current && (c == null || c(R));
  };
  return /* @__PURE__ */ Ae.jsx(
    "dialog",
    {
      ref: v,
      className: `h-modal ${h}`,
      onKeyDown: w,
      onClick: E,
      style: m,
      children: u && u(b)
    }
  );
});
aQ.displayName = "HModal";
const sQ = ({
  target: t,
  beforeFunc: e,
  afterFunc: i,
  children: a,
  className: o,
  style: c,
  disabled: u = !1
}) => {
  const h = async () => {
    var m;
    e && await e(), (m = t.current) == null || m.open(), i && i();
  };
  return /* @__PURE__ */ Ae.jsx("button", { onClick: h, type: "button", className: o, style: c, disabled: u, children: a || "모달 열기" });
};
sQ.displayName = "HModalOpenButton";
const oQ = ({
  target: t,
  beforeFunc: e,
  afterFunc: i,
  children: a,
  className: o,
  style: c
}) => {
  const u = async () => {
    var h;
    e && await e(), (h = t.current) == null || h.closeFunc(), i && i();
  };
  return /* @__PURE__ */ Ae.jsx("button", { onClick: u, type: "button", className: o, style: c, children: a || "닫기" });
};
oQ.displayName = "HModalCloseButton";
const lQ = "button", uQ = (t) => {
  const {
    isAuth: e,
    noAuthList: i,
    originalEventTarget: a = lQ,
    originalEventTargetEvent: o = null,
    onAuthVerificationResult: c,
    children: u
  } = t, h = xn(null), m = xn(), v = xn(null), b = () => e ? !(i != null && i.includes(e)) : !0;
  function S(R) {
    var A;
    console.debug(R);
    const M = (A = h.current) == null ? void 0 : A.querySelector(a);
    M && (M.removeEventListener("click", m.current, {
      capture: !0
    }), M.click(), M.addEventListener("click", m.current, {
      capture: !0
    }));
  }
  function w(R) {
    R.preventDefault(), R.stopPropagation();
    const M = b();
    c == null || c({
      event: R,
      result: M,
      originalFunc: S
    });
  }
  const E = (() => {
    if (!u || !aL(u)) return u;
    const R = u, M = R.props || {}, A = o ? M[o] : M.onClick;
    return v.current = A || null, VU(R, {
      // ...가능하면 onClick 다시 세팅, etc.
    });
  })();
  return Xn(() => {
    const R = h.current;
    if (!R) return;
    const M = R.querySelector(a);
    if (M)
      return m.current = w, M.addEventListener("click", m.current, {
        capture: !0
      }), () => {
        M.removeEventListener(
          "click",
          m.current,
          { capture: !0 }
        );
      };
  }, [e, i, a, o, c]), /* @__PURE__ */ Ae.jsx("div", { ref: h, children: E });
};
uQ.displayName = "AuthVerifyWrapper";
function cQ(t) {
  const {
    data: e,
    value: i,
    inputValue: a,
    onChange: o,
    name: c,
    className: u,
    labelClassName: h,
    inputClassName: m,
    labelStyle: v,
    disabled: b,
    readOnly: S,
    required: w,
    children: E
  } = t, R = Qx(), M = i.some((P) => dE(P, e)), A = () => {
    o(M ? i.filter((P) => !dE(P, e)) : [...i, e]);
  };
  return /* @__PURE__ */ Ae.jsxs("div", { className: u, children: [
    /* @__PURE__ */ Ae.jsx("label", { htmlFor: R, className: h, style: v, children: E }),
    /* @__PURE__ */ Ae.jsx(
      "input",
      {
        id: R,
        type: "checkbox",
        name: c,
        checked: M,
        onChange: A,
        disabled: b,
        readOnly: S,
        required: w,
        className: `h-input-checkbox ${m}`,
        value: a
      }
    )
  ] });
}
cQ.displayName = "HInputCheckbox";
const SQ = ({ children: t, style: e, className: i }) => /* @__PURE__ */ Ae.jsx("div", { style: { position: "relative", ...e }, className: i, children: t }), _Q = ({ value: t, style: e, className: i }) => /* @__PURE__ */ Ae.jsx("div", { style: {
  width: `${t}%`,
  height: "100%",
  ...e
}, className: i });
export {
  iN as CALENDAR_TYPES,
  bv as DATE_AREA_TYPE,
  vQ as HBarChart,
  uQ as HCheckAuth,
  RW as HDropdownArea,
  MW as HDropdownButton,
  kW as HDropdownItem,
  AW as HDropdownItemButton,
  j8 as HDropdownList,
  cQ as HInputCheckbox,
  aQ as HModal,
  oQ as HModalCloseButton,
  sQ as HModalOpenButton,
  bQ as HPieChart,
  SQ as HProgress,
  _Q as HProgressBar,
  e2 as HScrollbars,
  tW as HSingleDatePickerArea,
  nW as HSingleDatePickerCalendar,
  rW as HSingleDatePickerCalendarArea,
  iW as HSingleDatePickerCalendarDateButton,
  sW as HSingleDatePickerCalendarMonth,
  aW as HSingleDatePickerCalendarMonthArea,
  lW as HSingleDatePickerCalendarMonthButton,
  fW as HSingleDatePickerCalendarYear,
  mW as HSingleDatePickerCalendarYearArea,
  yW as HSingleDatePickerCalendarYearButton,
  CW as HSingleDatePickerInput,
  oW as HSingleDatePickerMonthButton,
  TW as HSingleDatePickerMonthNextButton,
  cW as HSingleDatePickerMonthPrevButton,
  EW as HSingleDatePickerMonthYearButton,
  hW as HSingleDatePickerNextButton,
  pW as HSingleDatePickerPrevButton,
  X4 as HSingleDatePickerRangeArea,
  gW as HSingleDatePickerYearButton,
  vW as HSingleDatePickerYearNextButton,
  DW as HSingleDatePickerYearPrevButton,
  eQ as HToastPopup,
  JX as HToastPopupArea,
  nQ as HToastPopupCloseButton,
  tQ as HToastPopupContainer,
  rQ as HTooltip,
  iQ as HTooltipArea,
  yQ as checkEqual
};
