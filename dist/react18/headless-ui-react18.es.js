var CU = Object.defineProperty;
var wU = (t, e, i) => e in t ? CU(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i;
var Fe = (t, e, i) => wU(t, typeof e != "symbol" ? e + "" : e, i);
import * as _E from "react";
import ip, { useRef as Sn, useEffect as Xn, createContext as Io, useState as Tn, useContext as ki, useMemo as Xs, forwardRef as pp, useImperativeHandle as $x, useId as Wx, useCallback as CE, Component as TU, useLayoutEffect as EU, useInsertionEffect as qP, Fragment as ZP, createElement as RU, Children as DU, isValidElement as JP, cloneElement as kU } from "react";
var Ab = { exports: {} }, Ng = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gM;
function MU() {
  if (gM) return Ng;
  gM = 1;
  var t = ip, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), a = Object.prototype.hasOwnProperty, o = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, f = { key: !0, ref: !0, __self: !0, __source: !0 };
  function u(h, m, v) {
    var b, S = {}, C = null, E = null;
    v !== void 0 && (C = "" + v), m.key !== void 0 && (C = "" + m.key), m.ref !== void 0 && (E = m.ref);
    for (b in m) a.call(m, b) && !f.hasOwnProperty(b) && (S[b] = m[b]);
    if (h && h.defaultProps) for (b in m = h.defaultProps, m) S[b] === void 0 && (S[b] = m[b]);
    return { $$typeof: e, type: h, key: C, ref: E, props: S, _owner: o.current };
  }
  return Ng.Fragment = i, Ng.jsx = u, Ng.jsxs = u, Ng;
}
var zg = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vM;
function AU() {
  return vM || (vM = 1, process.env.NODE_ENV !== "production" && function() {
    var t = ip, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), a = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), h = Symbol.for("react.context"), m = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), b = Symbol.for("react.suspense_list"), S = Symbol.for("react.memo"), C = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), D = Symbol.iterator, M = "@@iterator";
    function A(H) {
      if (H === null || typeof H != "object")
        return null;
      var ve = D && H[D] || H[M];
      return typeof ve == "function" ? ve : null;
    }
    var P = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function N(H) {
      {
        for (var ve = arguments.length, Be = new Array(ve > 1 ? ve - 1 : 0), ot = 1; ot < ve; ot++)
          Be[ot - 1] = arguments[ot];
        F("error", H, Be);
      }
    }
    function F(H, ve, Be) {
      {
        var ot = P.ReactDebugCurrentFrame, lt = ot.getStackAddendum();
        lt !== "" && (ve += "%s", Be = Be.concat([lt]));
        var wt = Be.map(function(Pt) {
          return String(Pt);
        });
        wt.unshift("Warning: " + ve), Function.prototype.apply.call(console[H], console, wt);
      }
    }
    var B = !1, V = !1, G = !1, Y = !1, K = !1, ae;
    ae = Symbol.for("react.module.reference");
    function ie(H) {
      return !!(typeof H == "string" || typeof H == "function" || H === a || H === f || K || H === o || H === v || H === b || Y || H === E || B || V || G || typeof H == "object" && H !== null && (H.$$typeof === C || H.$$typeof === S || H.$$typeof === u || H.$$typeof === h || H.$$typeof === m || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      H.$$typeof === ae || H.getModuleId !== void 0));
    }
    function ee(H, ve, Be) {
      var ot = H.displayName;
      if (ot)
        return ot;
      var lt = ve.displayName || ve.name || "";
      return lt !== "" ? Be + "(" + lt + ")" : Be;
    }
    function oe(H) {
      return H.displayName || "Context";
    }
    function se(H) {
      if (H == null)
        return null;
      if (typeof H.tag == "number" && N("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof H == "function")
        return H.displayName || H.name || null;
      if (typeof H == "string")
        return H;
      switch (H) {
        case a:
          return "Fragment";
        case i:
          return "Portal";
        case f:
          return "Profiler";
        case o:
          return "StrictMode";
        case v:
          return "Suspense";
        case b:
          return "SuspenseList";
      }
      if (typeof H == "object")
        switch (H.$$typeof) {
          case h:
            var ve = H;
            return oe(ve) + ".Consumer";
          case u:
            var Be = H;
            return oe(Be._context) + ".Provider";
          case m:
            return ee(H, H.render, "ForwardRef");
          case S:
            var ot = H.displayName || null;
            return ot !== null ? ot : se(H.type) || "Memo";
          case C: {
            var lt = H, wt = lt._payload, Pt = lt._init;
            try {
              return se(Pt(wt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Pe = Object.assign, Te = 0, Se, Oe, re, ge, me, fe, pe;
    function Ae() {
    }
    Ae.__reactDisabledLog = !0;
    function Ne() {
      {
        if (Te === 0) {
          Se = console.log, Oe = console.info, re = console.warn, ge = console.error, me = console.group, fe = console.groupCollapsed, pe = console.groupEnd;
          var H = {
            configurable: !0,
            enumerable: !0,
            value: Ae,
            writable: !0
          };
          Object.defineProperties(console, {
            info: H,
            log: H,
            warn: H,
            error: H,
            group: H,
            groupCollapsed: H,
            groupEnd: H
          });
        }
        Te++;
      }
    }
    function de() {
      {
        if (Te--, Te === 0) {
          var H = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Pe({}, H, {
              value: Se
            }),
            info: Pe({}, H, {
              value: Oe
            }),
            warn: Pe({}, H, {
              value: re
            }),
            error: Pe({}, H, {
              value: ge
            }),
            group: Pe({}, H, {
              value: me
            }),
            groupCollapsed: Pe({}, H, {
              value: fe
            }),
            groupEnd: Pe({}, H, {
              value: pe
            })
          });
        }
        Te < 0 && N("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ze = P.ReactCurrentDispatcher, De;
    function we(H, ve, Be) {
      {
        if (De === void 0)
          try {
            throw Error();
          } catch (lt) {
            var ot = lt.stack.trim().match(/\n( *(at )?)/);
            De = ot && ot[1] || "";
          }
        return `
` + De + H;
      }
    }
    var ct = !1, gt;
    {
      var pt = typeof WeakMap == "function" ? WeakMap : Map;
      gt = new pt();
    }
    function At(H, ve) {
      if (!H || ct)
        return "";
      {
        var Be = gt.get(H);
        if (Be !== void 0)
          return Be;
      }
      var ot;
      ct = !0;
      var lt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var wt;
      wt = ze.current, ze.current = null, Ne();
      try {
        if (ve) {
          var Pt = function() {
            throw Error();
          };
          if (Object.defineProperty(Pt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Pt, []);
            } catch (Ot) {
              ot = Ot;
            }
            Reflect.construct(H, [], Pt);
          } else {
            try {
              Pt.call();
            } catch (Ot) {
              ot = Ot;
            }
            H.call(Pt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ot) {
            ot = Ot;
          }
          H();
        }
      } catch (Ot) {
        if (Ot && ot && typeof Ot.stack == "string") {
          for (var Ft = Ot.stack.split(`
`), vi = ot.stack.split(`
`), On = Ft.length - 1, zn = vi.length - 1; On >= 1 && zn >= 0 && Ft[On] !== vi[zn]; )
            zn--;
          for (; On >= 1 && zn >= 0; On--, zn--)
            if (Ft[On] !== vi[zn]) {
              if (On !== 1 || zn !== 1)
                do
                  if (On--, zn--, zn < 0 || Ft[On] !== vi[zn]) {
                    var er = `
` + Ft[On].replace(" at new ", " at ");
                    return H.displayName && er.includes("<anonymous>") && (er = er.replace("<anonymous>", H.displayName)), typeof H == "function" && gt.set(H, er), er;
                  }
                while (On >= 1 && zn >= 0);
              break;
            }
        }
      } finally {
        ct = !1, ze.current = wt, de(), Error.prepareStackTrace = lt;
      }
      var ys = H ? H.displayName || H.name : "", bs = ys ? we(ys) : "";
      return typeof H == "function" && gt.set(H, bs), bs;
    }
    function xt(H, ve, Be) {
      return At(H, !1);
    }
    function tt(H) {
      var ve = H.prototype;
      return !!(ve && ve.isReactComponent);
    }
    function Et(H, ve, Be) {
      if (H == null)
        return "";
      if (typeof H == "function")
        return At(H, tt(H));
      if (typeof H == "string")
        return we(H);
      switch (H) {
        case v:
          return we("Suspense");
        case b:
          return we("SuspenseList");
      }
      if (typeof H == "object")
        switch (H.$$typeof) {
          case m:
            return xt(H.render);
          case S:
            return Et(H.type, ve, Be);
          case C: {
            var ot = H, lt = ot._payload, wt = ot._init;
            try {
              return Et(wt(lt), ve, Be);
            } catch {
            }
          }
        }
      return "";
    }
    var Wt = Object.prototype.hasOwnProperty, on = {}, ln = P.ReactDebugCurrentFrame;
    function Yt(H) {
      if (H) {
        var ve = H._owner, Be = Et(H.type, H._source, ve ? ve.type : null);
        ln.setExtraStackFrame(Be);
      } else
        ln.setExtraStackFrame(null);
    }
    function Xt(H, ve, Be, ot, lt) {
      {
        var wt = Function.call.bind(Wt);
        for (var Pt in H)
          if (wt(H, Pt)) {
            var Ft = void 0;
            try {
              if (typeof H[Pt] != "function") {
                var vi = Error((ot || "React class") + ": " + Be + " type `" + Pt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof H[Pt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw vi.name = "Invariant Violation", vi;
              }
              Ft = H[Pt](ve, Pt, ot, Be, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (On) {
              Ft = On;
            }
            Ft && !(Ft instanceof Error) && (Yt(lt), N("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ot || "React class", Be, Pt, typeof Ft), Yt(null)), Ft instanceof Error && !(Ft.message in on) && (on[Ft.message] = !0, Yt(lt), N("Failed %s type: %s", Be, Ft.message), Yt(null));
          }
      }
    }
    var Dt = Array.isArray;
    function Rt(H) {
      return Dt(H);
    }
    function Bt(H) {
      {
        var ve = typeof Symbol == "function" && Symbol.toStringTag, Be = ve && H[Symbol.toStringTag] || H.constructor.name || "Object";
        return Be;
      }
    }
    function Dn(H) {
      try {
        return An(H), !1;
      } catch {
        return !0;
      }
    }
    function An(H) {
      return "" + H;
    }
    function si(H) {
      if (Dn(H))
        return N("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Bt(H)), An(H);
    }
    var Ki = P.ReactCurrentOwner, wi = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ji, Le;
    function nt(H) {
      if (Wt.call(H, "ref")) {
        var ve = Object.getOwnPropertyDescriptor(H, "ref").get;
        if (ve && ve.isReactWarning)
          return !1;
      }
      return H.ref !== void 0;
    }
    function Ct(H) {
      if (Wt.call(H, "key")) {
        var ve = Object.getOwnPropertyDescriptor(H, "key").get;
        if (ve && ve.isReactWarning)
          return !1;
      }
      return H.key !== void 0;
    }
    function Qt(H, ve) {
      typeof H.ref == "string" && Ki.current;
    }
    function Vt(H, ve) {
      {
        var Be = function() {
          Ji || (Ji = !0, N("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ve));
        };
        Be.isReactWarning = !0, Object.defineProperty(H, "key", {
          get: Be,
          configurable: !0
        });
      }
    }
    function In(H, ve) {
      {
        var Be = function() {
          Le || (Le = !0, N("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ve));
        };
        Be.isReactWarning = !0, Object.defineProperty(H, "ref", {
          get: Be,
          configurable: !0
        });
      }
    }
    var dn = function(H, ve, Be, ot, lt, wt, Pt) {
      var Ft = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: H,
        key: ve,
        ref: Be,
        props: Pt,
        // Record the component responsible for creating this element.
        _owner: wt
      };
      return Ft._store = {}, Object.defineProperty(Ft._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ft, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ot
      }), Object.defineProperty(Ft, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: lt
      }), Object.freeze && (Object.freeze(Ft.props), Object.freeze(Ft)), Ft;
    };
    function _n(H, ve, Be, ot, lt) {
      {
        var wt, Pt = {}, Ft = null, vi = null;
        Be !== void 0 && (si(Be), Ft = "" + Be), Ct(ve) && (si(ve.key), Ft = "" + ve.key), nt(ve) && (vi = ve.ref, Qt(ve, lt));
        for (wt in ve)
          Wt.call(ve, wt) && !wi.hasOwnProperty(wt) && (Pt[wt] = ve[wt]);
        if (H && H.defaultProps) {
          var On = H.defaultProps;
          for (wt in On)
            Pt[wt] === void 0 && (Pt[wt] = On[wt]);
        }
        if (Ft || vi) {
          var zn = typeof H == "function" ? H.displayName || H.name || "Unknown" : H;
          Ft && Vt(Pt, zn), vi && In(Pt, zn);
        }
        return dn(H, Ft, vi, lt, ot, Ki.current, Pt);
      }
    }
    var Jt = P.ReactCurrentOwner, Gt = P.ReactDebugCurrentFrame;
    function qt(H) {
      if (H) {
        var ve = H._owner, Be = Et(H.type, H._source, ve ? ve.type : null);
        Gt.setExtraStackFrame(Be);
      } else
        Gt.setExtraStackFrame(null);
    }
    var Mi;
    Mi = !1;
    function Ai(H) {
      return typeof H == "object" && H !== null && H.$$typeof === e;
    }
    function He() {
      {
        if (Jt.current) {
          var H = se(Jt.current.type);
          if (H)
            return `

Check the render method of \`` + H + "`.";
        }
        return "";
      }
    }
    function Ve(H) {
      return "";
    }
    var Qe = {};
    function ft(H) {
      {
        var ve = He();
        if (!ve) {
          var Be = typeof H == "string" ? H : H.displayName || H.name;
          Be && (ve = `

Check the top-level render call using <` + Be + ">.");
        }
        return ve;
      }
    }
    function ce(H, ve) {
      {
        if (!H._store || H._store.validated || H.key != null)
          return;
        H._store.validated = !0;
        var Be = ft(ve);
        if (Qe[Be])
          return;
        Qe[Be] = !0;
        var ot = "";
        H && H._owner && H._owner !== Jt.current && (ot = " It was passed a child from " + se(H._owner.type) + "."), qt(H), N('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Be, ot), qt(null);
      }
    }
    function ye(H, ve) {
      {
        if (typeof H != "object")
          return;
        if (Rt(H))
          for (var Be = 0; Be < H.length; Be++) {
            var ot = H[Be];
            Ai(ot) && ce(ot, ve);
          }
        else if (Ai(H))
          H._store && (H._store.validated = !0);
        else if (H) {
          var lt = A(H);
          if (typeof lt == "function" && lt !== H.entries)
            for (var wt = lt.call(H), Pt; !(Pt = wt.next()).done; )
              Ai(Pt.value) && ce(Pt.value, ve);
        }
      }
    }
    function ke(H) {
      {
        var ve = H.type;
        if (ve == null || typeof ve == "string")
          return;
        var Be;
        if (typeof ve == "function")
          Be = ve.propTypes;
        else if (typeof ve == "object" && (ve.$$typeof === m || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ve.$$typeof === S))
          Be = ve.propTypes;
        else
          return;
        if (Be) {
          var ot = se(ve);
          Xt(Be, H.props, "prop", ot, H);
        } else if (ve.PropTypes !== void 0 && !Mi) {
          Mi = !0;
          var lt = se(ve);
          N("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", lt || "Unknown");
        }
        typeof ve.getDefaultProps == "function" && !ve.getDefaultProps.isReactClassApproved && N("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ge(H) {
      {
        for (var ve = Object.keys(H.props), Be = 0; Be < ve.length; Be++) {
          var ot = ve[Be];
          if (ot !== "children" && ot !== "key") {
            qt(H), N("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ot), qt(null);
            break;
          }
        }
        H.ref !== null && (qt(H), N("Invalid attribute `ref` supplied to `React.Fragment`."), qt(null));
      }
    }
    var yn = {};
    function $n(H, ve, Be, ot, lt, wt) {
      {
        var Pt = ie(H);
        if (!Pt) {
          var Ft = "";
          (H === void 0 || typeof H == "object" && H !== null && Object.keys(H).length === 0) && (Ft += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var vi = Ve();
          vi ? Ft += vi : Ft += He();
          var On;
          H === null ? On = "null" : Rt(H) ? On = "array" : H !== void 0 && H.$$typeof === e ? (On = "<" + (se(H.type) || "Unknown") + " />", Ft = " Did you accidentally export a JSX literal instead of a component?") : On = typeof H, N("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", On, Ft);
        }
        var zn = _n(H, ve, Be, lt, wt);
        if (zn == null)
          return zn;
        if (Pt) {
          var er = ve.children;
          if (er !== void 0)
            if (ot)
              if (Rt(er)) {
                for (var ys = 0; ys < er.length; ys++)
                  ye(er[ys], H);
                Object.freeze && Object.freeze(er);
              } else
                N("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ye(er, H);
        }
        if (Wt.call(ve, "key")) {
          var bs = se(H), Ot = Object.keys(ve).filter(function(uc) {
            return uc !== "key";
          }), Lt = Ot.length > 0 ? "{key: someKey, " + Ot.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yn[bs + Lt]) {
            var xs = Ot.length > 0 ? "{" + Ot.join(": ..., ") + ": ...}" : "{}";
            N(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Lt, bs, xs, bs), yn[bs + Lt] = !0;
          }
        }
        return H === a ? Ge(zn) : ke(zn), zn;
      }
    }
    function wa(H, ve, Be) {
      return $n(H, ve, Be, !0);
    }
    function Br(H, ve, Be) {
      return $n(H, ve, Be, !1);
    }
    var Ta = Br, Ea = wa;
    zg.Fragment = a, zg.jsx = Ta, zg.jsxs = Ea;
  }()), zg;
}
var yM;
function OU() {
  return yM || (yM = 1, process.env.NODE_ENV === "production" ? Ab.exports = MU() : Ab.exports = AU()), Ab.exports;
}
var Me = OU();
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function Rv(t) {
  return t + 0.5 | 0;
}
const Gu = (t, e, i) => Math.max(Math.min(t, i), e);
function $g(t) {
  return Gu(Rv(t * 2.55), 0, 255);
}
function qu(t) {
  return Gu(Rv(t * 255), 0, 255);
}
function Hl(t) {
  return Gu(Rv(t / 2.55) / 100, 0, 1);
}
function bM(t) {
  return Gu(Rv(t * 100), 0, 100);
}
const hs = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, wT = [..."0123456789ABCDEF"], PU = (t) => wT[t & 15], LU = (t) => wT[(t & 240) >> 4] + wT[t & 15], Ob = (t) => (t & 240) >> 4 === (t & 15), NU = (t) => Ob(t.r) && Ob(t.g) && Ob(t.b) && Ob(t.a);
function zU(t) {
  var e = t.length, i;
  return t[0] === "#" && (e === 4 || e === 5 ? i = {
    r: 255 & hs[t[1]] * 17,
    g: 255 & hs[t[2]] * 17,
    b: 255 & hs[t[3]] * 17,
    a: e === 5 ? hs[t[4]] * 17 : 255
  } : (e === 7 || e === 9) && (i = {
    r: hs[t[1]] << 4 | hs[t[2]],
    g: hs[t[3]] << 4 | hs[t[4]],
    b: hs[t[5]] << 4 | hs[t[6]],
    a: e === 9 ? hs[t[7]] << 4 | hs[t[8]] : 255
  })), i;
}
const FU = (t, e) => t < 255 ? e(t) : "";
function VU(t) {
  var e = NU(t) ? PU : LU;
  return t ? "#" + e(t.r) + e(t.g) + e(t.b) + FU(t.a, e) : void 0;
}
const jU = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function eL(t, e, i) {
  const a = e * Math.min(i, 1 - i), o = (f, u = (f + t / 30) % 12) => i - a * Math.max(Math.min(u - 3, 9 - u, 1), -1);
  return [o(0), o(8), o(4)];
}
function BU(t, e, i) {
  const a = (o, f = (o + t / 60) % 6) => i - i * e * Math.max(Math.min(f, 4 - f, 1), 0);
  return [a(5), a(3), a(1)];
}
function HU(t, e, i) {
  const a = eL(t, 1, 0.5);
  let o;
  for (e + i > 1 && (o = 1 / (e + i), e *= o, i *= o), o = 0; o < 3; o++)
    a[o] *= 1 - e - i, a[o] += e;
  return a;
}
function UU(t, e, i, a, o) {
  return t === o ? (e - i) / a + (e < i ? 6 : 0) : e === o ? (i - t) / a + 2 : (t - e) / a + 4;
}
function wE(t) {
  const i = t.r / 255, a = t.g / 255, o = t.b / 255, f = Math.max(i, a, o), u = Math.min(i, a, o), h = (f + u) / 2;
  let m, v, b;
  return f !== u && (b = f - u, v = h > 0.5 ? b / (2 - f - u) : b / (f + u), m = UU(i, a, o, b, f), m = m * 60 + 0.5), [m | 0, v || 0, h];
}
function TE(t, e, i, a) {
  return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, a)).map(qu);
}
function EE(t, e, i) {
  return TE(eL, t, e, i);
}
function IU(t, e, i) {
  return TE(HU, t, e, i);
}
function $U(t, e, i) {
  return TE(BU, t, e, i);
}
function tL(t) {
  return (t % 360 + 360) % 360;
}
function WU(t) {
  const e = jU.exec(t);
  let i = 255, a;
  if (!e)
    return;
  e[5] !== a && (i = e[6] ? $g(+e[5]) : qu(+e[5]));
  const o = tL(+e[2]), f = +e[3] / 100, u = +e[4] / 100;
  return e[1] === "hwb" ? a = IU(o, f, u) : e[1] === "hsv" ? a = $U(o, f, u) : a = EE(o, f, u), {
    r: a[0],
    g: a[1],
    b: a[2],
    a: i
  };
}
function YU(t, e) {
  var i = wE(t);
  i[0] = tL(i[0] + e), i = EE(i), t.r = i[0], t.g = i[1], t.b = i[2];
}
function GU(t) {
  if (!t)
    return;
  const e = wE(t), i = e[0], a = bM(e[1]), o = bM(e[2]);
  return t.a < 255 ? `hsla(${i}, ${a}%, ${o}%, ${Hl(t.a)})` : `hsl(${i}, ${a}%, ${o}%)`;
}
const xM = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, SM = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function KU() {
  const t = {}, e = Object.keys(SM), i = Object.keys(xM);
  let a, o, f, u, h;
  for (a = 0; a < e.length; a++) {
    for (u = h = e[a], o = 0; o < i.length; o++)
      f = i[o], h = h.replace(f, xM[f]);
    f = parseInt(SM[u], 16), t[h] = [f >> 16 & 255, f >> 8 & 255, f & 255];
  }
  return t;
}
let Pb;
function XU(t) {
  Pb || (Pb = KU(), Pb.transparent = [0, 0, 0, 0]);
  const e = Pb[t.toLowerCase()];
  return e && {
    r: e[0],
    g: e[1],
    b: e[2],
    a: e.length === 4 ? e[3] : 255
  };
}
const QU = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function qU(t) {
  const e = QU.exec(t);
  let i = 255, a, o, f;
  if (e) {
    if (e[7] !== a) {
      const u = +e[7];
      i = e[8] ? $g(u) : Gu(u * 255, 0, 255);
    }
    return a = +e[1], o = +e[3], f = +e[5], a = 255 & (e[2] ? $g(a) : Gu(a, 0, 255)), o = 255 & (e[4] ? $g(o) : Gu(o, 0, 255)), f = 255 & (e[6] ? $g(f) : Gu(f, 0, 255)), {
      r: a,
      g: o,
      b: f,
      a: i
    };
  }
}
function ZU(t) {
  return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Hl(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`);
}
const $w = (t) => t <= 31308e-7 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - 0.055, $h = (t) => t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
function JU(t, e, i) {
  const a = $h(Hl(t.r)), o = $h(Hl(t.g)), f = $h(Hl(t.b));
  return {
    r: qu($w(a + i * ($h(Hl(e.r)) - a))),
    g: qu($w(o + i * ($h(Hl(e.g)) - o))),
    b: qu($w(f + i * ($h(Hl(e.b)) - f))),
    a: t.a + i * (e.a - t.a)
  };
}
function Lb(t, e, i) {
  if (t) {
    let a = wE(t);
    a[e] = Math.max(0, Math.min(a[e] + a[e] * i, e === 0 ? 360 : 1)), a = EE(a), t.r = a[0], t.g = a[1], t.b = a[2];
  }
}
function nL(t, e) {
  return t && Object.assign(e || {}, t);
}
function _M(t) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = qu(t[3]))) : (e = nL(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = qu(e.a)), e;
}
function eI(t) {
  return t.charAt(0) === "r" ? qU(t) : WU(t);
}
class ov {
  constructor(e) {
    if (e instanceof ov)
      return e;
    const i = typeof e;
    let a;
    i === "object" ? a = _M(e) : i === "string" && (a = zU(e) || XU(e) || eI(e)), this._rgb = a, this._valid = !!a;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var e = nL(this._rgb);
    return e && (e.a = Hl(e.a)), e;
  }
  set rgb(e) {
    this._rgb = _M(e);
  }
  rgbString() {
    return this._valid ? ZU(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? VU(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? GU(this._rgb) : void 0;
  }
  mix(e, i) {
    if (e) {
      const a = this.rgb, o = e.rgb;
      let f;
      const u = i === f ? 0.5 : i, h = 2 * u - 1, m = a.a - o.a, v = ((h * m === -1 ? h : (h + m) / (1 + h * m)) + 1) / 2;
      f = 1 - v, a.r = 255 & v * a.r + f * o.r + 0.5, a.g = 255 & v * a.g + f * o.g + 0.5, a.b = 255 & v * a.b + f * o.b + 0.5, a.a = u * a.a + (1 - u) * o.a, this.rgb = a;
    }
    return this;
  }
  interpolate(e, i) {
    return e && (this._rgb = JU(this._rgb, e._rgb, i)), this;
  }
  clone() {
    return new ov(this.rgb);
  }
  alpha(e) {
    return this._rgb.a = qu(e), this;
  }
  clearer(e) {
    const i = this._rgb;
    return i.a *= 1 - e, this;
  }
  greyscale() {
    const e = this._rgb, i = Rv(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
    return e.r = e.g = e.b = i, this;
  }
  opaquer(e) {
    const i = this._rgb;
    return i.a *= 1 + e, this;
  }
  negate() {
    const e = this._rgb;
    return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
  }
  lighten(e) {
    return Lb(this._rgb, 2, e), this;
  }
  darken(e) {
    return Lb(this._rgb, 2, -e), this;
  }
  saturate(e) {
    return Lb(this._rgb, 1, e), this;
  }
  desaturate(e) {
    return Lb(this._rgb, 1, -e), this;
  }
  rotate(e) {
    return YU(this._rgb, e), this;
  }
}
/*!
 * Chart.js v4.4.5
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
function zl() {
}
const tI = /* @__PURE__ */ (() => {
  let t = 0;
  return () => t++;
})();
function sn(t) {
  return t === null || typeof t > "u";
}
function Kn(t) {
  if (Array.isArray && Array.isArray(t))
    return !0;
  const e = Object.prototype.toString.call(t);
  return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
}
function Kt(t) {
  return t !== null && Object.prototype.toString.call(t) === "[object Object]";
}
function gi(t) {
  return (typeof t == "number" || t instanceof Number) && isFinite(+t);
}
function ja(t, e) {
  return gi(t) ? t : e;
}
function zt(t, e) {
  return typeof t > "u" ? e : t;
}
const nI = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 : +t / e, iL = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;
function Nn(t, e, i) {
  if (t && typeof t.call == "function")
    return t.apply(i, e);
}
function xn(t, e, i, a) {
  let o, f, u;
  if (Kn(t))
    for (f = t.length, o = 0; o < f; o++)
      e.call(i, t[o], o);
  else if (Kt(t))
    for (u = Object.keys(t), f = u.length, o = 0; o < f; o++)
      e.call(i, t[u[o]], u[o]);
}
function bx(t, e) {
  let i, a, o, f;
  if (!t || !e || t.length !== e.length)
    return !1;
  for (i = 0, a = t.length; i < a; ++i)
    if (o = t[i], f = e[i], o.datasetIndex !== f.datasetIndex || o.index !== f.index)
      return !1;
  return !0;
}
function xx(t) {
  if (Kn(t))
    return t.map(xx);
  if (Kt(t)) {
    const e = /* @__PURE__ */ Object.create(null), i = Object.keys(t), a = i.length;
    let o = 0;
    for (; o < a; ++o)
      e[i[o]] = xx(t[i[o]]);
    return e;
  }
  return t;
}
function rL(t) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(t) === -1;
}
function iI(t, e, i, a) {
  if (!rL(t))
    return;
  const o = e[t], f = i[t];
  Kt(o) && Kt(f) ? lv(o, f, a) : e[t] = xx(f);
}
function lv(t, e, i) {
  const a = Kn(e) ? e : [
    e
  ], o = a.length;
  if (!Kt(t))
    return t;
  i = i || {};
  const f = i.merger || iI;
  let u;
  for (let h = 0; h < o; ++h) {
    if (u = a[h], !Kt(u))
      continue;
    const m = Object.keys(u);
    for (let v = 0, b = m.length; v < b; ++v)
      f(m[v], t, u, i);
  }
  return t;
}
function Zg(t, e) {
  return lv(t, e, {
    merger: rI
  });
}
function rI(t, e, i) {
  if (!rL(t))
    return;
  const a = e[t], o = i[t];
  Kt(a) && Kt(o) ? Zg(a, o) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = xx(o));
}
const CM = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (t) => t,
  // default resolvers
  x: (t) => t.x,
  y: (t) => t.y
};
function aI(t) {
  const e = t.split("."), i = [];
  let a = "";
  for (const o of e)
    a += o, a.endsWith("\\") ? a = a.slice(0, -1) + "." : (i.push(a), a = "");
  return i;
}
function sI(t) {
  const e = aI(t);
  return (i) => {
    for (const a of e) {
      if (a === "")
        break;
      i = i && i[a];
    }
    return i;
  };
}
function ec(t, e) {
  return (CM[e] || (CM[e] = sI(e)))(t);
}
function RE(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
const uv = (t) => typeof t < "u", tc = (t) => typeof t == "function", wM = (t, e) => {
  if (t.size !== e.size)
    return !1;
  for (const i of t)
    if (!e.has(i))
      return !1;
  return !0;
};
function oI(t) {
  return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu";
}
const Un = Math.PI, Hn = 2 * Un, lI = Hn + Un, Sx = Number.POSITIVE_INFINITY, uI = Un / 180, Ci = Un / 2, Df = Un / 4, TM = Un * 2 / 3, Ku = Math.log10, Fo = Math.sign;
function Jg(t, e, i) {
  return Math.abs(t - e) < i;
}
function EM(t) {
  const e = Math.round(t);
  t = Jg(t, e, t / 1e3) ? e : t;
  const i = Math.pow(10, Math.floor(Ku(t))), a = t / i;
  return (a <= 1 ? 1 : a <= 2 ? 2 : a <= 5 ? 5 : 10) * i;
}
function cI(t) {
  const e = [], i = Math.sqrt(t);
  let a;
  for (a = 1; a < i; a++)
    t % a === 0 && (e.push(a), e.push(t / a));
  return i === (i | 0) && e.push(i), e.sort((o, f) => o - f).pop(), e;
}
function rp(t) {
  return !isNaN(parseFloat(t)) && isFinite(t);
}
function fI(t, e) {
  const i = Math.round(t);
  return i - e <= t && i + e >= t;
}
function aL(t, e, i) {
  let a, o, f;
  for (a = 0, o = t.length; a < o; a++)
    f = t[a][i], isNaN(f) || (e.min = Math.min(e.min, f), e.max = Math.max(e.max, f));
}
function Gs(t) {
  return t * (Un / 180);
}
function DE(t) {
  return t * (180 / Un);
}
function RM(t) {
  if (!gi(t))
    return;
  let e = 1, i = 0;
  for (; Math.round(t * e) / e !== t; )
    e *= 10, i++;
  return i;
}
function sL(t, e) {
  const i = e.x - t.x, a = e.y - t.y, o = Math.sqrt(i * i + a * a);
  let f = Math.atan2(a, i);
  return f < -0.5 * Un && (f += Hn), {
    angle: f,
    distance: o
  };
}
function TT(t, e) {
  return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
function dI(t, e) {
  return (t - e + lI) % Hn - Un;
}
function Ha(t) {
  return (t % Hn + Hn) % Hn;
}
function cv(t, e, i, a) {
  const o = Ha(t), f = Ha(e), u = Ha(i), h = Ha(f - o), m = Ha(u - o), v = Ha(o - f), b = Ha(o - u);
  return o === f || o === u || a && f === u || h > m && v < b;
}
function Zi(t, e, i) {
  return Math.max(e, Math.min(i, t));
}
function hI(t) {
  return Zi(t, -32768, 32767);
}
function Ul(t, e, i, a = 1e-6) {
  return t >= Math.min(e, i) - a && t <= Math.max(e, i) + a;
}
function kE(t, e, i) {
  i = i || ((u) => t[u] < e);
  let a = t.length - 1, o = 0, f;
  for (; a - o > 1; )
    f = o + a >> 1, i(f) ? o = f : a = f;
  return {
    lo: o,
    hi: a
  };
}
const Il = (t, e, i, a) => kE(t, i, a ? (o) => {
  const f = t[o][e];
  return f < i || f === i && t[o + 1][e] === i;
} : (o) => t[o][e] < i), pI = (t, e, i) => kE(t, i, (a) => t[a][e] >= i);
function mI(t, e, i) {
  let a = 0, o = t.length;
  for (; a < o && t[a] < e; )
    a++;
  for (; o > a && t[o - 1] > i; )
    o--;
  return a > 0 || o < t.length ? t.slice(a, o) : t;
}
const oL = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function gI(t, e) {
  if (t._chartjs) {
    t._chartjs.listeners.push(e);
    return;
  }
  Object.defineProperty(t, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        e
      ]
    }
  }), oL.forEach((i) => {
    const a = "_onData" + RE(i), o = t[i];
    Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !1,
      value(...f) {
        const u = o.apply(this, f);
        return t._chartjs.listeners.forEach((h) => {
          typeof h[a] == "function" && h[a](...f);
        }), u;
      }
    });
  });
}
function DM(t, e) {
  const i = t._chartjs;
  if (!i)
    return;
  const a = i.listeners, o = a.indexOf(e);
  o !== -1 && a.splice(o, 1), !(a.length > 0) && (oL.forEach((f) => {
    delete t[f];
  }), delete t._chartjs);
}
function lL(t) {
  const e = new Set(t);
  return e.size === t.length ? t : Array.from(e);
}
const uL = function() {
  return typeof window > "u" ? function(t) {
    return t();
  } : window.requestAnimationFrame;
}();
function cL(t, e) {
  let i = [], a = !1;
  return function(...o) {
    i = o, a || (a = !0, uL.call(window, () => {
      a = !1, t.apply(e, i);
    }));
  };
}
function vI(t, e) {
  let i;
  return function(...a) {
    return e ? (clearTimeout(i), i = setTimeout(t, e, a)) : t.apply(this, a), e;
  };
}
const ME = (t) => t === "start" ? "left" : t === "end" ? "right" : "center", Nr = (t, e, i) => t === "start" ? e : t === "end" ? i : (e + i) / 2, yI = (t, e, i, a) => t === (a ? "left" : "right") ? i : t === "center" ? (e + i) / 2 : e;
function fL(t, e, i) {
  const a = e.length;
  let o = 0, f = a;
  if (t._sorted) {
    const { iScale: u, _parsed: h } = t, m = u.axis, { min: v, max: b, minDefined: S, maxDefined: C } = u.getUserBounds();
    S && (o = Zi(Math.min(
      // @ts-expect-error Need to type _parsed
      Il(h, m, v).lo,
      // @ts-expect-error Need to fix types on _lookupByKey
      i ? a : Il(e, m, u.getPixelForValue(v)).lo
    ), 0, a - 1)), C ? f = Zi(Math.max(
      // @ts-expect-error Need to type _parsed
      Il(h, u.axis, b, !0).hi + 1,
      // @ts-expect-error Need to fix types on _lookupByKey
      i ? 0 : Il(e, m, u.getPixelForValue(b), !0).hi + 1
    ), o, a) - o : f = a - o;
  }
  return {
    start: o,
    count: f
  };
}
function dL(t) {
  const { xScale: e, yScale: i, _scaleRanges: a } = t, o = {
    xmin: e.min,
    xmax: e.max,
    ymin: i.min,
    ymax: i.max
  };
  if (!a)
    return t._scaleRanges = o, !0;
  const f = a.xmin !== e.min || a.xmax !== e.max || a.ymin !== i.min || a.ymax !== i.max;
  return Object.assign(a, o), f;
}
const Nb = (t) => t === 0 || t === 1, kM = (t, e, i) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * Hn / i)), MM = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * Hn / i) + 1, ev = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * Ci) + 1,
  easeOutSine: (t) => Math.sin(t * Ci),
  easeInOutSine: (t) => -0.5 * (Math.cos(Un * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => Nb(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => Nb(t) ? t : kM(t, 0.075, 0.3),
  easeOutElastic: (t) => Nb(t) ? t : MM(t, 0.075, 0.3),
  easeInOutElastic(t) {
    return Nb(t) ? t : t < 0.5 ? 0.5 * kM(t * 2, 0.1125, 0.45) : 0.5 + 0.5 * MM(t * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(t) {
    return t * t * ((1.70158 + 1) * t - 1.70158);
  },
  easeOutBack(t) {
    return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1;
  },
  easeInOutBack(t) {
    let e = 1.70158;
    return (t /= 0.5) < 1 ? 0.5 * (t * t * (((e *= 1.525) + 1) * t - e)) : 0.5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2);
  },
  easeInBounce: (t) => 1 - ev.easeOutBounce(1 - t),
  easeOutBounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? ev.easeInBounce(t * 2) * 0.5 : ev.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function AE(t) {
  if (t && typeof t == "object") {
    const e = t.toString();
    return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
  }
  return !1;
}
function AM(t) {
  return AE(t) ? t : new ov(t);
}
function Ww(t) {
  return AE(t) ? t : new ov(t).saturate(0.5).darken(0.1).hexString();
}
const bI = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], xI = [
  "color",
  "borderColor",
  "backgroundColor"
];
function SI(t) {
  t.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), t.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
  }), t.set("animations", {
    colors: {
      type: "color",
      properties: xI
    },
    numbers: {
      type: "number",
      properties: bI
    }
  }), t.describe("animations", {
    _fallback: "animation"
  }), t.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (e) => e | 0
        }
      }
    }
  });
}
function _I(t) {
  t.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const OM = /* @__PURE__ */ new Map();
function CI(t, e) {
  e = e || {};
  const i = t + JSON.stringify(e);
  let a = OM.get(i);
  return a || (a = new Intl.NumberFormat(t, e), OM.set(i, a)), a;
}
function Dv(t, e, i) {
  return CI(e, i).format(t);
}
const hL = {
  values(t) {
    return Kn(t) ? t : "" + t;
  },
  numeric(t, e, i) {
    if (t === 0)
      return "0";
    const a = this.chart.options.locale;
    let o, f = t;
    if (i.length > 1) {
      const v = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
      (v < 1e-4 || v > 1e15) && (o = "scientific"), f = wI(t, i);
    }
    const u = Ku(Math.abs(f)), h = isNaN(u) ? 1 : Math.max(Math.min(-1 * Math.floor(u), 20), 0), m = {
      notation: o,
      minimumFractionDigits: h,
      maximumFractionDigits: h
    };
    return Object.assign(m, this.options.ticks.format), Dv(t, a, m);
  },
  logarithmic(t, e, i) {
    if (t === 0)
      return "0";
    const a = i[e].significand || t / Math.pow(10, Math.floor(Ku(t)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(a) || e > 0.8 * i.length ? hL.numeric.call(this, t, e, i) : "";
  }
};
function wI(t, e) {
  let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
  return Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t)), i;
}
var Yx = {
  formatters: hL
};
function TI(t) {
  t.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (e, i) => i.lineWidth,
      tickColor: (e, i) => i.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Yx.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", {
    _fallback: !1,
    _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
    _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
  }), t.describe("scales", {
    _fallback: "scale"
  }), t.describe("scale.ticks", {
    _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
    _indexable: (e) => e !== "backdropPadding"
  });
}
const Wf = /* @__PURE__ */ Object.create(null), ET = /* @__PURE__ */ Object.create(null);
function tv(t, e) {
  if (!e)
    return t;
  const i = e.split(".");
  for (let a = 0, o = i.length; a < o; ++a) {
    const f = i[a];
    t = t[f] || (t[f] = /* @__PURE__ */ Object.create(null));
  }
  return t;
}
function Yw(t, e, i) {
  return typeof e == "string" ? lv(tv(t, e), i) : lv(tv(t, ""), e);
}
class EI {
  constructor(e, i) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (a) => a.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (a, o) => Ww(o.backgroundColor), this.hoverBorderColor = (a, o) => Ww(o.borderColor), this.hoverColor = (a, o) => Ww(o.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(i);
  }
  set(e, i) {
    return Yw(this, e, i);
  }
  get(e) {
    return tv(this, e);
  }
  describe(e, i) {
    return Yw(ET, e, i);
  }
  override(e, i) {
    return Yw(Wf, e, i);
  }
  route(e, i, a, o) {
    const f = tv(this, e), u = tv(this, a), h = "_" + i;
    Object.defineProperties(f, {
      [h]: {
        value: f[i],
        writable: !0
      },
      [i]: {
        enumerable: !0,
        get() {
          const m = this[h], v = u[o];
          return Kt(m) ? Object.assign({}, v, m) : zt(m, v);
        },
        set(m) {
          this[h] = m;
        }
      }
    });
  }
  apply(e) {
    e.forEach((i) => i(this));
  }
}
var Qn = /* @__PURE__ */ new EI({
  _scriptable: (t) => !t.startsWith("on"),
  _indexable: (t) => t !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  SI,
  _I,
  TI
]);
function RI(t) {
  return !t || sn(t.size) || sn(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family;
}
function _x(t, e, i, a, o) {
  let f = e[o];
  return f || (f = e[o] = t.measureText(o).width, i.push(o)), f > a && (a = f), a;
}
function DI(t, e, i, a) {
  a = a || {};
  let o = a.data = a.data || {}, f = a.garbageCollect = a.garbageCollect || [];
  a.font !== e && (o = a.data = {}, f = a.garbageCollect = [], a.font = e), t.save(), t.font = e;
  let u = 0;
  const h = i.length;
  let m, v, b, S, C;
  for (m = 0; m < h; m++)
    if (S = i[m], S != null && !Kn(S))
      u = _x(t, o, f, u, S);
    else if (Kn(S))
      for (v = 0, b = S.length; v < b; v++)
        C = S[v], C != null && !Kn(C) && (u = _x(t, o, f, u, C));
  t.restore();
  const E = f.length / 2;
  if (E > i.length) {
    for (m = 0; m < E; m++)
      delete o[f[m]];
    f.splice(0, E);
  }
  return u;
}
function kf(t, e, i) {
  const a = t.currentDevicePixelRatio, o = i !== 0 ? Math.max(i / 2, 0.5) : 0;
  return Math.round((e - o) * a) / a + o;
}
function PM(t, e) {
  !e && !t || (e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore());
}
function RT(t, e, i, a) {
  pL(t, e, i, a, null);
}
function pL(t, e, i, a, o) {
  let f, u, h, m, v, b, S, C;
  const E = e.pointStyle, D = e.rotation, M = e.radius;
  let A = (D || 0) * uI;
  if (E && typeof E == "object" && (f = E.toString(), f === "[object HTMLImageElement]" || f === "[object HTMLCanvasElement]")) {
    t.save(), t.translate(i, a), t.rotate(A), t.drawImage(E, -E.width / 2, -E.height / 2, E.width, E.height), t.restore();
    return;
  }
  if (!(isNaN(M) || M <= 0)) {
    switch (t.beginPath(), E) {
      // Default includes circle
      default:
        o ? t.ellipse(i, a, o / 2, M, 0, 0, Hn) : t.arc(i, a, M, 0, Hn), t.closePath();
        break;
      case "triangle":
        b = o ? o / 2 : M, t.moveTo(i + Math.sin(A) * b, a - Math.cos(A) * M), A += TM, t.lineTo(i + Math.sin(A) * b, a - Math.cos(A) * M), A += TM, t.lineTo(i + Math.sin(A) * b, a - Math.cos(A) * M), t.closePath();
        break;
      case "rectRounded":
        v = M * 0.516, m = M - v, u = Math.cos(A + Df) * m, S = Math.cos(A + Df) * (o ? o / 2 - v : m), h = Math.sin(A + Df) * m, C = Math.sin(A + Df) * (o ? o / 2 - v : m), t.arc(i - S, a - h, v, A - Un, A - Ci), t.arc(i + C, a - u, v, A - Ci, A), t.arc(i + S, a + h, v, A, A + Ci), t.arc(i - C, a + u, v, A + Ci, A + Un), t.closePath();
        break;
      case "rect":
        if (!D) {
          m = Math.SQRT1_2 * M, b = o ? o / 2 : m, t.rect(i - b, a - m, 2 * b, 2 * m);
          break;
        }
        A += Df;
      /* falls through */
      case "rectRot":
        S = Math.cos(A) * (o ? o / 2 : M), u = Math.cos(A) * M, h = Math.sin(A) * M, C = Math.sin(A) * (o ? o / 2 : M), t.moveTo(i - S, a - h), t.lineTo(i + C, a - u), t.lineTo(i + S, a + h), t.lineTo(i - C, a + u), t.closePath();
        break;
      case "crossRot":
        A += Df;
      /* falls through */
      case "cross":
        S = Math.cos(A) * (o ? o / 2 : M), u = Math.cos(A) * M, h = Math.sin(A) * M, C = Math.sin(A) * (o ? o / 2 : M), t.moveTo(i - S, a - h), t.lineTo(i + S, a + h), t.moveTo(i + C, a - u), t.lineTo(i - C, a + u);
        break;
      case "star":
        S = Math.cos(A) * (o ? o / 2 : M), u = Math.cos(A) * M, h = Math.sin(A) * M, C = Math.sin(A) * (o ? o / 2 : M), t.moveTo(i - S, a - h), t.lineTo(i + S, a + h), t.moveTo(i + C, a - u), t.lineTo(i - C, a + u), A += Df, S = Math.cos(A) * (o ? o / 2 : M), u = Math.cos(A) * M, h = Math.sin(A) * M, C = Math.sin(A) * (o ? o / 2 : M), t.moveTo(i - S, a - h), t.lineTo(i + S, a + h), t.moveTo(i + C, a - u), t.lineTo(i - C, a + u);
        break;
      case "line":
        u = o ? o / 2 : Math.cos(A) * M, h = Math.sin(A) * M, t.moveTo(i - u, a - h), t.lineTo(i + u, a + h);
        break;
      case "dash":
        t.moveTo(i, a), t.lineTo(i + Math.cos(A) * (o ? o / 2 : M), a + Math.sin(A) * M);
        break;
      case !1:
        t.closePath();
        break;
    }
    t.fill(), e.borderWidth > 0 && t.stroke();
  }
}
function $l(t, e, i) {
  return i = i || 0.5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i;
}
function Gx(t, e) {
  t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();
}
function Kx(t) {
  t.restore();
}
function kI(t, e, i, a, o) {
  if (!e)
    return t.lineTo(i.x, i.y);
  if (o === "middle") {
    const f = (e.x + i.x) / 2;
    t.lineTo(f, e.y), t.lineTo(f, i.y);
  } else o === "after" != !!a ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
  t.lineTo(i.x, i.y);
}
function MI(t, e, i, a) {
  if (!e)
    return t.lineTo(i.x, i.y);
  t.bezierCurveTo(a ? e.cp1x : e.cp2x, a ? e.cp1y : e.cp2y, a ? i.cp2x : i.cp1x, a ? i.cp2y : i.cp1y, i.x, i.y);
}
function AI(t, e) {
  e.translation && t.translate(e.translation[0], e.translation[1]), sn(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline);
}
function OI(t, e, i, a, o) {
  if (o.strikethrough || o.underline) {
    const f = t.measureText(a), u = e - f.actualBoundingBoxLeft, h = e + f.actualBoundingBoxRight, m = i - f.actualBoundingBoxAscent, v = i + f.actualBoundingBoxDescent, b = o.strikethrough ? (m + v) / 2 : v;
    t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = o.decorationWidth || 2, t.moveTo(u, b), t.lineTo(h, b), t.stroke();
  }
}
function PI(t, e) {
  const i = t.fillStyle;
  t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i;
}
function Yf(t, e, i, a, o, f = {}) {
  const u = Kn(e) ? e : [
    e
  ], h = f.strokeWidth > 0 && f.strokeColor !== "";
  let m, v;
  for (t.save(), t.font = o.string, AI(t, f), m = 0; m < u.length; ++m)
    v = u[m], f.backdrop && PI(t, f.backdrop), h && (f.strokeColor && (t.strokeStyle = f.strokeColor), sn(f.strokeWidth) || (t.lineWidth = f.strokeWidth), t.strokeText(v, i, a, f.maxWidth)), t.fillText(v, i, a, f.maxWidth), OI(t, i, a, v, f), a += Number(o.lineHeight);
  t.restore();
}
function fv(t, e) {
  const { x: i, y: a, w: o, h: f, radius: u } = e;
  t.arc(i + u.topLeft, a + u.topLeft, u.topLeft, 1.5 * Un, Un, !0), t.lineTo(i, a + f - u.bottomLeft), t.arc(i + u.bottomLeft, a + f - u.bottomLeft, u.bottomLeft, Un, Ci, !0), t.lineTo(i + o - u.bottomRight, a + f), t.arc(i + o - u.bottomRight, a + f - u.bottomRight, u.bottomRight, Ci, 0, !0), t.lineTo(i + o, a + u.topRight), t.arc(i + o - u.topRight, a + u.topRight, u.topRight, 0, -Ci, !0), t.lineTo(i + u.topLeft, a);
}
const LI = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, NI = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function zI(t, e) {
  const i = ("" + t).match(LI);
  if (!i || i[1] === "normal")
    return e * 1.2;
  switch (t = +i[2], i[3]) {
    case "px":
      return t;
    case "%":
      t /= 100;
      break;
  }
  return e * t;
}
const FI = (t) => +t || 0;
function OE(t, e) {
  const i = {}, a = Kt(e), o = a ? Object.keys(e) : e, f = Kt(t) ? a ? (u) => zt(t[u], t[e[u]]) : (u) => t[u] : () => t;
  for (const u of o)
    i[u] = FI(f(u));
  return i;
}
function mL(t) {
  return OE(t, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Bf(t) {
  return OE(t, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function jr(t) {
  const e = mL(t);
  return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
}
function Yi(t, e) {
  t = t || {}, e = e || Qn.font;
  let i = zt(t.size, e.size);
  typeof i == "string" && (i = parseInt(i, 10));
  let a = zt(t.style, e.style);
  a && !("" + a).match(NI) && (console.warn('Invalid font style specified: "' + a + '"'), a = void 0);
  const o = {
    family: zt(t.family, e.family),
    lineHeight: zI(zt(t.lineHeight, e.lineHeight), i),
    size: i,
    style: a,
    weight: zt(t.weight, e.weight),
    string: ""
  };
  return o.string = RI(o), o;
}
function Wg(t, e, i, a) {
  let o, f, u;
  for (o = 0, f = t.length; o < f; ++o)
    if (u = t[o], u !== void 0 && u !== void 0)
      return u;
}
function VI(t, e, i) {
  const { min: a, max: o } = t, f = iL(e, (o - a) / 2), u = (h, m) => i && h === 0 ? 0 : h + m;
  return {
    min: u(a, -Math.abs(f)),
    max: u(o, f)
  };
}
function ac(t, e) {
  return Object.assign(Object.create(t), e);
}
function PE(t, e = [
  ""
], i, a, o = () => t[0]) {
  const f = i || t;
  typeof a > "u" && (a = bL("_fallback", t));
  const u = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: t,
    _rootScopes: f,
    _fallback: a,
    _getTarget: o,
    override: (h) => PE([
      h,
      ...t
    ], e, f, a)
  };
  return new Proxy(u, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(h, m) {
      return delete h[m], delete h._keys, delete t[0][m], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(h, m) {
      return vL(h, m, () => YI(m, e, t, h));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(h, m) {
      return Reflect.getOwnPropertyDescriptor(h._scopes[0], m);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(h, m) {
      return NM(h).includes(m);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(h) {
      return NM(h);
    },
    /**
    * A trap for setting property values.
    */
    set(h, m, v) {
      const b = h._storage || (h._storage = o());
      return h[m] = b[m] = v, delete h._keys, !0;
    }
  });
}
function ap(t, e, i, a) {
  const o = {
    _cacheable: !1,
    _proxy: t,
    _context: e,
    _subProxy: i,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: gL(t, a),
    setContext: (f) => ap(t, f, i, a),
    override: (f) => ap(t.override(f), e, i, a)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(f, u) {
      return delete f[u], delete t[u], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(f, u, h) {
      return vL(f, u, () => BI(f, u, h));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(f, u) {
      return f._descriptors.allKeys ? Reflect.has(t, u) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(t, u);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t);
    },
    /**
    * A trap for the in operator.
    */
    has(f, u) {
      return Reflect.has(t, u);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(t);
    },
    /**
    * A trap for setting property values.
    */
    set(f, u, h) {
      return t[u] = h, delete f[u], !0;
    }
  });
}
function gL(t, e = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: i = e.scriptable, _indexable: a = e.indexable, _allKeys: o = e.allKeys } = t;
  return {
    allKeys: o,
    scriptable: i,
    indexable: a,
    isScriptable: tc(i) ? i : () => i,
    isIndexable: tc(a) ? a : () => a
  };
}
const jI = (t, e) => t ? t + RE(e) : e, LE = (t, e) => Kt(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
function vL(t, e, i) {
  if (Object.prototype.hasOwnProperty.call(t, e) || e === "constructor")
    return t[e];
  const a = i();
  return t[e] = a, a;
}
function BI(t, e, i) {
  const { _proxy: a, _context: o, _subProxy: f, _descriptors: u } = t;
  let h = a[e];
  return tc(h) && u.isScriptable(e) && (h = HI(e, h, t, i)), Kn(h) && h.length && (h = UI(e, h, t, u.isIndexable)), LE(e, h) && (h = ap(h, o, f && f[e], u)), h;
}
function HI(t, e, i, a) {
  const { _proxy: o, _context: f, _subProxy: u, _stack: h } = i;
  if (h.has(t))
    throw new Error("Recursion detected: " + Array.from(h).join("->") + "->" + t);
  h.add(t);
  let m = e(f, u || a);
  return h.delete(t), LE(t, m) && (m = NE(o._scopes, o, t, m)), m;
}
function UI(t, e, i, a) {
  const { _proxy: o, _context: f, _subProxy: u, _descriptors: h } = i;
  if (typeof f.index < "u" && a(t))
    return e[f.index % e.length];
  if (Kt(e[0])) {
    const m = e, v = o._scopes.filter((b) => b !== m);
    e = [];
    for (const b of m) {
      const S = NE(v, o, t, b);
      e.push(ap(S, f, u && u[t], h));
    }
  }
  return e;
}
function yL(t, e, i) {
  return tc(t) ? t(e, i) : t;
}
const II = (t, e) => t === !0 ? e : typeof t == "string" ? ec(e, t) : void 0;
function $I(t, e, i, a, o) {
  for (const f of e) {
    const u = II(i, f);
    if (u) {
      t.add(u);
      const h = yL(u._fallback, i, o);
      if (typeof h < "u" && h !== i && h !== a)
        return h;
    } else if (u === !1 && typeof a < "u" && i !== a)
      return null;
  }
  return !1;
}
function NE(t, e, i, a) {
  const o = e._rootScopes, f = yL(e._fallback, i, a), u = [
    ...t,
    ...o
  ], h = /* @__PURE__ */ new Set();
  h.add(a);
  let m = LM(h, u, i, f || i, a);
  return m === null || typeof f < "u" && f !== i && (m = LM(h, u, f, m, a), m === null) ? !1 : PE(Array.from(h), [
    ""
  ], o, f, () => WI(e, i, a));
}
function LM(t, e, i, a, o) {
  for (; i; )
    i = $I(t, e, i, a, o);
  return i;
}
function WI(t, e, i) {
  const a = t._getTarget();
  e in a || (a[e] = {});
  const o = a[e];
  return Kn(o) && Kt(i) ? i : o || {};
}
function YI(t, e, i, a) {
  let o;
  for (const f of e)
    if (o = bL(jI(f, t), i), typeof o < "u")
      return LE(t, o) ? NE(i, a, t, o) : o;
}
function bL(t, e) {
  for (const i of e) {
    if (!i)
      continue;
    const a = i[t];
    if (typeof a < "u")
      return a;
  }
}
function NM(t) {
  let e = t._keys;
  return e || (e = t._keys = GI(t._scopes)), e;
}
function GI(t) {
  const e = /* @__PURE__ */ new Set();
  for (const i of t)
    for (const a of Object.keys(i).filter((o) => !o.startsWith("_")))
      e.add(a);
  return Array.from(e);
}
function xL(t, e, i, a) {
  const { iScale: o } = t, { key: f = "r" } = this._parsing, u = new Array(a);
  let h, m, v, b;
  for (h = 0, m = a; h < m; ++h)
    v = h + i, b = e[v], u[h] = {
      r: o.parse(ec(b, f), v)
    };
  return u;
}
const KI = Number.EPSILON || 1e-14, sp = (t, e) => e < t.length && !t[e].skip && t[e], SL = (t) => t === "x" ? "y" : "x";
function XI(t, e, i, a) {
  const o = t.skip ? e : t, f = e, u = i.skip ? e : i, h = TT(f, o), m = TT(u, f);
  let v = h / (h + m), b = m / (h + m);
  v = isNaN(v) ? 0 : v, b = isNaN(b) ? 0 : b;
  const S = a * v, C = a * b;
  return {
    previous: {
      x: f.x - S * (u.x - o.x),
      y: f.y - S * (u.y - o.y)
    },
    next: {
      x: f.x + C * (u.x - o.x),
      y: f.y + C * (u.y - o.y)
    }
  };
}
function QI(t, e, i) {
  const a = t.length;
  let o, f, u, h, m, v = sp(t, 0);
  for (let b = 0; b < a - 1; ++b)
    if (m = v, v = sp(t, b + 1), !(!m || !v)) {
      if (Jg(e[b], 0, KI)) {
        i[b] = i[b + 1] = 0;
        continue;
      }
      o = i[b] / e[b], f = i[b + 1] / e[b], h = Math.pow(o, 2) + Math.pow(f, 2), !(h <= 9) && (u = 3 / Math.sqrt(h), i[b] = o * u * e[b], i[b + 1] = f * u * e[b]);
    }
}
function qI(t, e, i = "x") {
  const a = SL(i), o = t.length;
  let f, u, h, m = sp(t, 0);
  for (let v = 0; v < o; ++v) {
    if (u = h, h = m, m = sp(t, v + 1), !h)
      continue;
    const b = h[i], S = h[a];
    u && (f = (b - u[i]) / 3, h[`cp1${i}`] = b - f, h[`cp1${a}`] = S - f * e[v]), m && (f = (m[i] - b) / 3, h[`cp2${i}`] = b + f, h[`cp2${a}`] = S + f * e[v]);
  }
}
function ZI(t, e = "x") {
  const i = SL(e), a = t.length, o = Array(a).fill(0), f = Array(a);
  let u, h, m, v = sp(t, 0);
  for (u = 0; u < a; ++u)
    if (h = m, m = v, v = sp(t, u + 1), !!m) {
      if (v) {
        const b = v[e] - m[e];
        o[u] = b !== 0 ? (v[i] - m[i]) / b : 0;
      }
      f[u] = h ? v ? Fo(o[u - 1]) !== Fo(o[u]) ? 0 : (o[u - 1] + o[u]) / 2 : o[u - 1] : o[u];
    }
  QI(t, o, f), qI(t, f, e);
}
function zb(t, e, i) {
  return Math.max(Math.min(t, i), e);
}
function JI(t, e) {
  let i, a, o, f, u, h = $l(t[0], e);
  for (i = 0, a = t.length; i < a; ++i)
    u = f, f = h, h = i < a - 1 && $l(t[i + 1], e), f && (o = t[i], u && (o.cp1x = zb(o.cp1x, e.left, e.right), o.cp1y = zb(o.cp1y, e.top, e.bottom)), h && (o.cp2x = zb(o.cp2x, e.left, e.right), o.cp2y = zb(o.cp2y, e.top, e.bottom)));
}
function e$(t, e, i, a, o) {
  let f, u, h, m;
  if (e.spanGaps && (t = t.filter((v) => !v.skip)), e.cubicInterpolationMode === "monotone")
    ZI(t, o);
  else {
    let v = a ? t[t.length - 1] : t[0];
    for (f = 0, u = t.length; f < u; ++f)
      h = t[f], m = XI(v, h, t[Math.min(f + 1, u - (a ? 0 : 1)) % u], e.tension), h.cp1x = m.previous.x, h.cp1y = m.previous.y, h.cp2x = m.next.x, h.cp2y = m.next.y, v = h;
  }
  e.capBezierPoints && JI(t, i);
}
function zE() {
  return typeof window < "u" && typeof document < "u";
}
function FE(t) {
  let e = t.parentNode;
  return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
}
function Cx(t, e, i) {
  let a;
  return typeof t == "string" ? (a = parseInt(t, 10), t.indexOf("%") !== -1 && (a = a / 100 * e.parentNode[i])) : a = t, a;
}
const Xx = (t) => t.ownerDocument.defaultView.getComputedStyle(t, null);
function t$(t, e) {
  return Xx(t).getPropertyValue(e);
}
const n$ = [
  "top",
  "right",
  "bottom",
  "left"
];
function Hf(t, e, i) {
  const a = {};
  i = i ? "-" + i : "";
  for (let o = 0; o < 4; o++) {
    const f = n$[o];
    a[f] = parseFloat(t[e + "-" + f + i]) || 0;
  }
  return a.width = a.left + a.right, a.height = a.top + a.bottom, a;
}
const i$ = (t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot);
function r$(t, e) {
  const i = t.touches, a = i && i.length ? i[0] : t, { offsetX: o, offsetY: f } = a;
  let u = !1, h, m;
  if (i$(o, f, t.target))
    h = o, m = f;
  else {
    const v = e.getBoundingClientRect();
    h = a.clientX - v.left, m = a.clientY - v.top, u = !0;
  }
  return {
    x: h,
    y: m,
    box: u
  };
}
function Pf(t, e) {
  if ("native" in t)
    return t;
  const { canvas: i, currentDevicePixelRatio: a } = e, o = Xx(i), f = o.boxSizing === "border-box", u = Hf(o, "padding"), h = Hf(o, "border", "width"), { x: m, y: v, box: b } = r$(t, i), S = u.left + (b && h.left), C = u.top + (b && h.top);
  let { width: E, height: D } = e;
  return f && (E -= u.width + h.width, D -= u.height + h.height), {
    x: Math.round((m - S) / E * i.width / a),
    y: Math.round((v - C) / D * i.height / a)
  };
}
function a$(t, e, i) {
  let a, o;
  if (e === void 0 || i === void 0) {
    const f = t && FE(t);
    if (!f)
      e = t.clientWidth, i = t.clientHeight;
    else {
      const u = f.getBoundingClientRect(), h = Xx(f), m = Hf(h, "border", "width"), v = Hf(h, "padding");
      e = u.width - v.width - m.width, i = u.height - v.height - m.height, a = Cx(h.maxWidth, f, "clientWidth"), o = Cx(h.maxHeight, f, "clientHeight");
    }
  }
  return {
    width: e,
    height: i,
    maxWidth: a || Sx,
    maxHeight: o || Sx
  };
}
const Fb = (t) => Math.round(t * 10) / 10;
function s$(t, e, i, a) {
  const o = Xx(t), f = Hf(o, "margin"), u = Cx(o.maxWidth, t, "clientWidth") || Sx, h = Cx(o.maxHeight, t, "clientHeight") || Sx, m = a$(t, e, i);
  let { width: v, height: b } = m;
  if (o.boxSizing === "content-box") {
    const C = Hf(o, "border", "width"), E = Hf(o, "padding");
    v -= E.width + C.width, b -= E.height + C.height;
  }
  return v = Math.max(0, v - f.width), b = Math.max(0, a ? v / a : b - f.height), v = Fb(Math.min(v, u, m.maxWidth)), b = Fb(Math.min(b, h, m.maxHeight)), v && !b && (b = Fb(v / 2)), (e !== void 0 || i !== void 0) && a && m.height && b > m.height && (b = m.height, v = Fb(Math.floor(b * a))), {
    width: v,
    height: b
  };
}
function zM(t, e, i) {
  const a = e || 1, o = Math.floor(t.height * a), f = Math.floor(t.width * a);
  t.height = Math.floor(t.height), t.width = Math.floor(t.width);
  const u = t.canvas;
  return u.style && (i || !u.style.height && !u.style.width) && (u.style.height = `${t.height}px`, u.style.width = `${t.width}px`), t.currentDevicePixelRatio !== a || u.height !== o || u.width !== f ? (t.currentDevicePixelRatio = a, u.height = o, u.width = f, t.ctx.setTransform(a, 0, 0, a, 0, 0), !0) : !1;
}
const o$ = function() {
  let t = !1;
  try {
    const e = {
      get passive() {
        return t = !0, !1;
      }
    };
    zE() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e));
  } catch {
  }
  return t;
}();
function FM(t, e) {
  const i = t$(t, e), a = i && i.match(/^(\d+)(\.\d+)?px$/);
  return a ? +a[1] : void 0;
}
function Lf(t, e, i, a) {
  return {
    x: t.x + i * (e.x - t.x),
    y: t.y + i * (e.y - t.y)
  };
}
function l$(t, e, i, a) {
  return {
    x: t.x + i * (e.x - t.x),
    y: a === "middle" ? i < 0.5 ? t.y : e.y : a === "after" ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y
  };
}
function u$(t, e, i, a) {
  const o = {
    x: t.cp2x,
    y: t.cp2y
  }, f = {
    x: e.cp1x,
    y: e.cp1y
  }, u = Lf(t, o, i), h = Lf(o, f, i), m = Lf(f, e, i), v = Lf(u, h, i), b = Lf(h, m, i);
  return Lf(v, b, i);
}
const c$ = function(t, e) {
  return {
    x(i) {
      return t + t + e - i;
    },
    setWidth(i) {
      e = i;
    },
    textAlign(i) {
      return i === "center" ? i : i === "right" ? "left" : "right";
    },
    xPlus(i, a) {
      return i - a;
    },
    leftForLtr(i, a) {
      return i - a;
    }
  };
}, f$ = function() {
  return {
    x(t) {
      return t;
    },
    setWidth(t) {
    },
    textAlign(t) {
      return t;
    },
    xPlus(t, e) {
      return t + e;
    },
    leftForLtr(t, e) {
      return t;
    }
  };
};
function ep(t, e, i) {
  return t ? c$(e, i) : f$();
}
function _L(t, e) {
  let i, a;
  (e === "ltr" || e === "rtl") && (i = t.canvas.style, a = [
    i.getPropertyValue("direction"),
    i.getPropertyPriority("direction")
  ], i.setProperty("direction", e, "important"), t.prevTextDirection = a);
}
function CL(t, e) {
  e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]));
}
function wL(t) {
  return t === "angle" ? {
    between: cv,
    compare: dI,
    normalize: Ha
  } : {
    between: Ul,
    compare: (e, i) => e - i,
    normalize: (e) => e
  };
}
function VM({ start: t, end: e, count: i, loop: a, style: o }) {
  return {
    start: t % i,
    end: e % i,
    loop: a && (e - t + 1) % i === 0,
    style: o
  };
}
function d$(t, e, i) {
  const { property: a, start: o, end: f } = i, { between: u, normalize: h } = wL(a), m = e.length;
  let { start: v, end: b, loop: S } = t, C, E;
  if (S) {
    for (v += m, b += m, C = 0, E = m; C < E && u(h(e[v % m][a]), o, f); ++C)
      v--, b--;
    v %= m, b %= m;
  }
  return b < v && (b += m), {
    start: v,
    end: b,
    loop: S,
    style: t.style
  };
}
function TL(t, e, i) {
  if (!i)
    return [
      t
    ];
  const { property: a, start: o, end: f } = i, u = e.length, { compare: h, between: m, normalize: v } = wL(a), { start: b, end: S, loop: C, style: E } = d$(t, e, i), D = [];
  let M = !1, A = null, P, N, F;
  const B = () => m(o, F, P) && h(o, F) !== 0, V = () => h(f, P) === 0 || m(f, F, P), G = () => M || B(), Y = () => !M || V();
  for (let K = b, ae = b; K <= S; ++K)
    N = e[K % u], !N.skip && (P = v(N[a]), P !== F && (M = m(P, o, f), A === null && G() && (A = h(P, o) === 0 ? K : ae), A !== null && Y() && (D.push(VM({
      start: A,
      end: K,
      loop: C,
      count: u,
      style: E
    })), A = null), ae = K, F = P));
  return A !== null && D.push(VM({
    start: A,
    end: S,
    loop: C,
    count: u,
    style: E
  })), D;
}
function EL(t, e) {
  const i = [], a = t.segments;
  for (let o = 0; o < a.length; o++) {
    const f = TL(a[o], t.points, e);
    f.length && i.push(...f);
  }
  return i;
}
function h$(t, e, i, a) {
  let o = 0, f = e - 1;
  if (i && !a)
    for (; o < e && !t[o].skip; )
      o++;
  for (; o < e && t[o].skip; )
    o++;
  for (o %= e, i && (f += o); f > o && t[f % e].skip; )
    f--;
  return f %= e, {
    start: o,
    end: f
  };
}
function p$(t, e, i, a) {
  const o = t.length, f = [];
  let u = e, h = t[e], m;
  for (m = e + 1; m <= i; ++m) {
    const v = t[m % o];
    v.skip || v.stop ? h.skip || (a = !1, f.push({
      start: e % o,
      end: (m - 1) % o,
      loop: a
    }), e = u = v.stop ? m : null) : (u = m, h.skip && (e = m)), h = v;
  }
  return u !== null && f.push({
    start: e % o,
    end: u % o,
    loop: a
  }), f;
}
function m$(t, e) {
  const i = t.points, a = t.options.spanGaps, o = i.length;
  if (!o)
    return [];
  const f = !!t._loop, { start: u, end: h } = h$(i, o, f, a);
  if (a === !0)
    return jM(t, [
      {
        start: u,
        end: h,
        loop: f
      }
    ], i, e);
  const m = h < u ? h + o : h, v = !!t._fullLoop && u === 0 && h === o - 1;
  return jM(t, p$(i, u, m, v), i, e);
}
function jM(t, e, i, a) {
  return !a || !a.setContext || !i ? e : g$(t, e, i, a);
}
function g$(t, e, i, a) {
  const o = t._chart.getContext(), f = BM(t.options), { _datasetIndex: u, options: { spanGaps: h } } = t, m = i.length, v = [];
  let b = f, S = e[0].start, C = S;
  function E(D, M, A, P) {
    const N = h ? -1 : 1;
    if (D !== M) {
      for (D += m; i[D % m].skip; )
        D -= N;
      for (; i[M % m].skip; )
        M += N;
      D % m !== M % m && (v.push({
        start: D % m,
        end: M % m,
        loop: A,
        style: P
      }), b = P, S = M % m);
    }
  }
  for (const D of e) {
    S = h ? S : D.start;
    let M = i[S % m], A;
    for (C = S + 1; C <= D.end; C++) {
      const P = i[C % m];
      A = BM(a.setContext(ac(o, {
        type: "segment",
        p0: M,
        p1: P,
        p0DataIndex: (C - 1) % m,
        p1DataIndex: C % m,
        datasetIndex: u
      }))), v$(A, b) && E(S, C - 1, D.loop, b), M = P, b = A;
    }
    S < C - 1 && E(S, C - 1, D.loop, b);
  }
  return v;
}
function BM(t) {
  return {
    backgroundColor: t.backgroundColor,
    borderCapStyle: t.borderCapStyle,
    borderDash: t.borderDash,
    borderDashOffset: t.borderDashOffset,
    borderJoinStyle: t.borderJoinStyle,
    borderWidth: t.borderWidth,
    borderColor: t.borderColor
  };
}
function v$(t, e) {
  if (!e)
    return !1;
  const i = [], a = function(o, f) {
    return AE(f) ? (i.includes(f) || i.push(f), i.indexOf(f)) : f;
  };
  return JSON.stringify(t, a) !== JSON.stringify(e, a);
}
/*!
 * Chart.js v4.4.5
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
class y$ {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(e, i, a, o) {
    const f = i.listeners[o], u = i.duration;
    f.forEach((h) => h({
      chart: e,
      initial: i.initial,
      numSteps: u,
      currentStep: Math.min(a - i.start, u)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = uL.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(e = Date.now()) {
    let i = 0;
    this._charts.forEach((a, o) => {
      if (!a.running || !a.items.length)
        return;
      const f = a.items;
      let u = f.length - 1, h = !1, m;
      for (; u >= 0; --u)
        m = f[u], m._active ? (m._total > a.duration && (a.duration = m._total), m.tick(e), h = !0) : (f[u] = f[f.length - 1], f.pop());
      h && (o.draw(), this._notify(o, a, e, "progress")), f.length || (a.running = !1, this._notify(o, a, e, "complete"), a.initial = !1), i += f.length;
    }), this._lastDate = e, i === 0 && (this._running = !1);
  }
  _getAnims(e) {
    const i = this._charts;
    let a = i.get(e);
    return a || (a = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, i.set(e, a)), a;
  }
  listen(e, i, a) {
    this._getAnims(e).listeners[i].push(a);
  }
  add(e, i) {
    !i || !i.length || this._getAnims(e).items.push(...i);
  }
  has(e) {
    return this._getAnims(e).items.length > 0;
  }
  start(e) {
    const i = this._charts.get(e);
    i && (i.running = !0, i.start = Date.now(), i.duration = i.items.reduce((a, o) => Math.max(a, o._duration), 0), this._refresh());
  }
  running(e) {
    if (!this._running)
      return !1;
    const i = this._charts.get(e);
    return !(!i || !i.running || !i.items.length);
  }
  stop(e) {
    const i = this._charts.get(e);
    if (!i || !i.items.length)
      return;
    const a = i.items;
    let o = a.length - 1;
    for (; o >= 0; --o)
      a[o].cancel();
    i.items = [], this._notify(e, i, Date.now(), "complete");
  }
  remove(e) {
    return this._charts.delete(e);
  }
}
var Fl = /* @__PURE__ */ new y$();
const HM = "transparent", b$ = {
  boolean(t, e, i) {
    return i > 0.5 ? e : t;
  },
  color(t, e, i) {
    const a = AM(t || HM), o = a.valid && AM(e || HM);
    return o && o.valid ? o.mix(a, i).hexString() : e;
  },
  number(t, e, i) {
    return t + (e - t) * i;
  }
};
class x$ {
  constructor(e, i, a, o) {
    const f = i[a];
    o = Wg([
      e.to,
      o,
      f,
      e.from
    ]);
    const u = Wg([
      e.from,
      f,
      o
    ]);
    this._active = !0, this._fn = e.fn || b$[e.type || typeof u], this._easing = ev[e.easing] || ev.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = i, this._prop = a, this._from = u, this._to = o, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(e, i, a) {
    if (this._active) {
      this._notify(!1);
      const o = this._target[this._prop], f = a - this._start, u = this._duration - f;
      this._start = a, this._duration = Math.floor(Math.max(u, e.duration)), this._total += f, this._loop = !!e.loop, this._to = Wg([
        e.to,
        i,
        o,
        e.from
      ]), this._from = Wg([
        e.from,
        o,
        i
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(e) {
    const i = e - this._start, a = this._duration, o = this._prop, f = this._from, u = this._loop, h = this._to;
    let m;
    if (this._active = f !== h && (u || i < a), !this._active) {
      this._target[o] = h, this._notify(!0);
      return;
    }
    if (i < 0) {
      this._target[o] = f;
      return;
    }
    m = i / a % 2, m = u && m > 1 ? 2 - m : m, m = this._easing(Math.min(1, Math.max(0, m))), this._target[o] = this._fn(f, h, m);
  }
  wait() {
    const e = this._promises || (this._promises = []);
    return new Promise((i, a) => {
      e.push({
        res: i,
        rej: a
      });
    });
  }
  _notify(e) {
    const i = e ? "res" : "rej", a = this._promises || [];
    for (let o = 0; o < a.length; o++)
      a[o][i]();
  }
}
class RL {
  constructor(e, i) {
    this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(i);
  }
  configure(e) {
    if (!Kt(e))
      return;
    const i = Object.keys(Qn.animation), a = this._properties;
    Object.getOwnPropertyNames(e).forEach((o) => {
      const f = e[o];
      if (!Kt(f))
        return;
      const u = {};
      for (const h of i)
        u[h] = f[h];
      (Kn(f.properties) && f.properties || [
        o
      ]).forEach((h) => {
        (h === o || !a.has(h)) && a.set(h, u);
      });
    });
  }
  _animateOptions(e, i) {
    const a = i.options, o = _$(e, a);
    if (!o)
      return [];
    const f = this._createAnimations(o, a);
    return a.$shared && S$(e.options.$animations, a).then(() => {
      e.options = a;
    }, () => {
    }), f;
  }
  _createAnimations(e, i) {
    const a = this._properties, o = [], f = e.$animations || (e.$animations = {}), u = Object.keys(i), h = Date.now();
    let m;
    for (m = u.length - 1; m >= 0; --m) {
      const v = u[m];
      if (v.charAt(0) === "$")
        continue;
      if (v === "options") {
        o.push(...this._animateOptions(e, i));
        continue;
      }
      const b = i[v];
      let S = f[v];
      const C = a.get(v);
      if (S)
        if (C && S.active()) {
          S.update(C, b, h);
          continue;
        } else
          S.cancel();
      if (!C || !C.duration) {
        e[v] = b;
        continue;
      }
      f[v] = S = new x$(C, e, v, b), o.push(S);
    }
    return o;
  }
  update(e, i) {
    if (this._properties.size === 0) {
      Object.assign(e, i);
      return;
    }
    const a = this._createAnimations(e, i);
    if (a.length)
      return Fl.add(this._chart, a), !0;
  }
}
function S$(t, e) {
  const i = [], a = Object.keys(e);
  for (let o = 0; o < a.length; o++) {
    const f = t[a[o]];
    f && f.active() && i.push(f.wait());
  }
  return Promise.all(i);
}
function _$(t, e) {
  if (!e)
    return;
  let i = t.options;
  if (!i) {
    t.options = e;
    return;
  }
  return i.$shared && (t.options = i = Object.assign({}, i, {
    $shared: !1,
    $animations: {}
  })), i;
}
function UM(t, e) {
  const i = t && t.options || {}, a = i.reverse, o = i.min === void 0 ? e : 0, f = i.max === void 0 ? e : 0;
  return {
    start: a ? f : o,
    end: a ? o : f
  };
}
function C$(t, e, i) {
  if (i === !1)
    return !1;
  const a = UM(t, i), o = UM(e, i);
  return {
    top: o.end,
    right: a.end,
    bottom: o.start,
    left: a.start
  };
}
function w$(t) {
  let e, i, a, o;
  return Kt(t) ? (e = t.top, i = t.right, a = t.bottom, o = t.left) : e = i = a = o = t, {
    top: e,
    right: i,
    bottom: a,
    left: o,
    disabled: t === !1
  };
}
function DL(t, e) {
  const i = [], a = t._getSortedDatasetMetas(e);
  let o, f;
  for (o = 0, f = a.length; o < f; ++o)
    i.push(a[o].index);
  return i;
}
function IM(t, e, i, a = {}) {
  const o = t.keys, f = a.mode === "single";
  let u, h, m, v;
  if (e !== null) {
    for (u = 0, h = o.length; u < h; ++u) {
      if (m = +o[u], m === i) {
        if (a.all)
          continue;
        break;
      }
      v = t.values[m], gi(v) && (f || e === 0 || Fo(e) === Fo(v)) && (e += v);
    }
    return e;
  }
}
function T$(t, e) {
  const { iScale: i, vScale: a } = e, o = i.axis === "x" ? "x" : "y", f = a.axis === "x" ? "x" : "y", u = Object.keys(t), h = new Array(u.length);
  let m, v, b;
  for (m = 0, v = u.length; m < v; ++m)
    b = u[m], h[m] = {
      [o]: b,
      [f]: t[b]
    };
  return h;
}
function Gw(t, e) {
  const i = t && t.options.stacked;
  return i || i === void 0 && e.stack !== void 0;
}
function E$(t, e, i) {
  return `${t.id}.${e.id}.${i.stack || i.type}`;
}
function R$(t) {
  const { min: e, max: i, minDefined: a, maxDefined: o } = t.getUserBounds();
  return {
    min: a ? e : Number.NEGATIVE_INFINITY,
    max: o ? i : Number.POSITIVE_INFINITY
  };
}
function D$(t, e, i) {
  const a = t[e] || (t[e] = {});
  return a[i] || (a[i] = {});
}
function $M(t, e, i, a) {
  for (const o of e.getMatchingVisibleMetas(a).reverse()) {
    const f = t[o.index];
    if (i && f > 0 || !i && f < 0)
      return o.index;
  }
  return null;
}
function WM(t, e) {
  const { chart: i, _cachedMeta: a } = t, o = i._stacks || (i._stacks = {}), { iScale: f, vScale: u, index: h } = a, m = f.axis, v = u.axis, b = E$(f, u, a), S = e.length;
  let C;
  for (let E = 0; E < S; ++E) {
    const D = e[E], { [m]: M, [v]: A } = D, P = D._stacks || (D._stacks = {});
    C = P[v] = D$(o, b, M), C[h] = A, C._top = $M(C, u, !0, a.type), C._bottom = $M(C, u, !1, a.type);
    const N = C._visualValues || (C._visualValues = {});
    N[h] = A;
  }
}
function Kw(t, e) {
  const i = t.scales;
  return Object.keys(i).filter((a) => i[a].axis === e).shift();
}
function k$(t, e) {
  return ac(t, {
    active: !1,
    dataset: void 0,
    datasetIndex: e,
    index: e,
    mode: "default",
    type: "dataset"
  });
}
function M$(t, e, i) {
  return ac(t, {
    active: !1,
    dataIndex: e,
    parsed: void 0,
    raw: void 0,
    element: i,
    index: e,
    mode: "default",
    type: "data"
  });
}
function Fg(t, e) {
  const i = t.controller.index, a = t.vScale && t.vScale.axis;
  if (a) {
    e = e || t._parsed;
    for (const o of e) {
      const f = o._stacks;
      if (!f || f[a] === void 0 || f[a][i] === void 0)
        return;
      delete f[a][i], f[a]._visualValues !== void 0 && f[a]._visualValues[i] !== void 0 && delete f[a]._visualValues[i];
    }
  }
}
const Xw = (t) => t === "reset" || t === "none", YM = (t, e) => e ? t : Object.assign({}, t), A$ = (t, e, i) => t && !e.hidden && e._stacked && {
  keys: DL(i, !0),
  values: null
};
class Ks {
  constructor(e, i) {
    this.chart = e, this._ctx = e.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const e = this._cachedMeta;
    this.configure(), this.linkScales(), e._stacked = Gw(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(e) {
    this.index !== e && Fg(this._cachedMeta), this.index = e;
  }
  linkScales() {
    const e = this.chart, i = this._cachedMeta, a = this.getDataset(), o = (S, C, E, D) => S === "x" ? C : S === "r" ? D : E, f = i.xAxisID = zt(a.xAxisID, Kw(e, "x")), u = i.yAxisID = zt(a.yAxisID, Kw(e, "y")), h = i.rAxisID = zt(a.rAxisID, Kw(e, "r")), m = i.indexAxis, v = i.iAxisID = o(m, f, u, h), b = i.vAxisID = o(m, u, f, h);
    i.xScale = this.getScaleForId(f), i.yScale = this.getScaleForId(u), i.rScale = this.getScaleForId(h), i.iScale = this.getScaleForId(v), i.vScale = this.getScaleForId(b);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(e) {
    return this.chart.scales[e];
  }
  _getOtherScale(e) {
    const i = this._cachedMeta;
    return e === i.iScale ? i.vScale : i.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const e = this._cachedMeta;
    this._data && DM(this._data, this), e._stacked && Fg(e);
  }
  _dataCheck() {
    const e = this.getDataset(), i = e.data || (e.data = []), a = this._data;
    if (Kt(i)) {
      const o = this._cachedMeta;
      this._data = T$(i, o);
    } else if (a !== i) {
      if (a) {
        DM(a, this);
        const o = this._cachedMeta;
        Fg(o), o._parsed = [];
      }
      i && Object.isExtensible(i) && gI(i, this), this._syncList = [], this._data = i;
    }
  }
  addElements() {
    const e = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(e) {
    const i = this._cachedMeta, a = this.getDataset();
    let o = !1;
    this._dataCheck();
    const f = i._stacked;
    i._stacked = Gw(i.vScale, i), i.stack !== a.stack && (o = !0, Fg(i), i.stack = a.stack), this._resyncElements(e), (o || f !== i._stacked) && (WM(this, i._parsed), i._stacked = Gw(i.vScale, i));
  }
  configure() {
    const e = this.chart.config, i = e.datasetScopeKeys(this._type), a = e.getOptionScopes(this.getDataset(), i, !0);
    this.options = e.createResolver(a, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(e, i) {
    const { _cachedMeta: a, _data: o } = this, { iScale: f, _stacked: u } = a, h = f.axis;
    let m = e === 0 && i === o.length ? !0 : a._sorted, v = e > 0 && a._parsed[e - 1], b, S, C;
    if (this._parsing === !1)
      a._parsed = o, a._sorted = !0, C = o;
    else {
      Kn(o[e]) ? C = this.parseArrayData(a, o, e, i) : Kt(o[e]) ? C = this.parseObjectData(a, o, e, i) : C = this.parsePrimitiveData(a, o, e, i);
      const E = () => S[h] === null || v && S[h] < v[h];
      for (b = 0; b < i; ++b)
        a._parsed[b + e] = S = C[b], m && (E() && (m = !1), v = S);
      a._sorted = m;
    }
    u && WM(this, C);
  }
  parsePrimitiveData(e, i, a, o) {
    const { iScale: f, vScale: u } = e, h = f.axis, m = u.axis, v = f.getLabels(), b = f === u, S = new Array(o);
    let C, E, D;
    for (C = 0, E = o; C < E; ++C)
      D = C + a, S[C] = {
        [h]: b || f.parse(v[D], D),
        [m]: u.parse(i[D], D)
      };
    return S;
  }
  parseArrayData(e, i, a, o) {
    const { xScale: f, yScale: u } = e, h = new Array(o);
    let m, v, b, S;
    for (m = 0, v = o; m < v; ++m)
      b = m + a, S = i[b], h[m] = {
        x: f.parse(S[0], b),
        y: u.parse(S[1], b)
      };
    return h;
  }
  parseObjectData(e, i, a, o) {
    const { xScale: f, yScale: u } = e, { xAxisKey: h = "x", yAxisKey: m = "y" } = this._parsing, v = new Array(o);
    let b, S, C, E;
    for (b = 0, S = o; b < S; ++b)
      C = b + a, E = i[C], v[b] = {
        x: f.parse(ec(E, h), C),
        y: u.parse(ec(E, m), C)
      };
    return v;
  }
  getParsed(e) {
    return this._cachedMeta._parsed[e];
  }
  getDataElement(e) {
    return this._cachedMeta.data[e];
  }
  applyStack(e, i, a) {
    const o = this.chart, f = this._cachedMeta, u = i[e.axis], h = {
      keys: DL(o, !0),
      values: i._stacks[e.axis]._visualValues
    };
    return IM(h, u, f.index, {
      mode: a
    });
  }
  updateRangeFromParsed(e, i, a, o) {
    const f = a[i.axis];
    let u = f === null ? NaN : f;
    const h = o && a._stacks[i.axis];
    o && h && (o.values = h, u = IM(o, f, this._cachedMeta.index)), e.min = Math.min(e.min, u), e.max = Math.max(e.max, u);
  }
  getMinMax(e, i) {
    const a = this._cachedMeta, o = a._parsed, f = a._sorted && e === a.iScale, u = o.length, h = this._getOtherScale(e), m = A$(i, a, this.chart), v = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: b, max: S } = R$(h);
    let C, E;
    function D() {
      E = o[C];
      const M = E[h.axis];
      return !gi(E[e.axis]) || b > M || S < M;
    }
    for (C = 0; C < u && !(!D() && (this.updateRangeFromParsed(v, e, E, m), f)); ++C)
      ;
    if (f) {
      for (C = u - 1; C >= 0; --C)
        if (!D()) {
          this.updateRangeFromParsed(v, e, E, m);
          break;
        }
    }
    return v;
  }
  getAllParsedValues(e) {
    const i = this._cachedMeta._parsed, a = [];
    let o, f, u;
    for (o = 0, f = i.length; o < f; ++o)
      u = i[o][e.axis], gi(u) && a.push(u);
    return a;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = i.iScale, o = i.vScale, f = this.getParsed(e);
    return {
      label: a ? "" + a.getLabelForValue(f[a.axis]) : "",
      value: o ? "" + o.getLabelForValue(f[o.axis]) : ""
    };
  }
  _update(e) {
    const i = this._cachedMeta;
    this.update(e || "default"), i._clip = w$(zt(this.options.clip, C$(i.xScale, i.yScale, this.getMaxOverflow())));
  }
  update(e) {
  }
  draw() {
    const e = this._ctx, i = this.chart, a = this._cachedMeta, o = a.data || [], f = i.chartArea, u = [], h = this._drawStart || 0, m = this._drawCount || o.length - h, v = this.options.drawActiveElementsOnTop;
    let b;
    for (a.dataset && a.dataset.draw(e, f, h, m), b = h; b < h + m; ++b) {
      const S = o[b];
      S.hidden || (S.active && v ? u.push(S) : S.draw(e, f));
    }
    for (b = 0; b < u.length; ++b)
      u[b].draw(e, f);
  }
  getStyle(e, i) {
    const a = i ? "active" : "default";
    return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(a) : this.resolveDataElementOptions(e || 0, a);
  }
  getContext(e, i, a) {
    const o = this.getDataset();
    let f;
    if (e >= 0 && e < this._cachedMeta.data.length) {
      const u = this._cachedMeta.data[e];
      f = u.$context || (u.$context = M$(this.getContext(), e, u)), f.parsed = this.getParsed(e), f.raw = o.data[e], f.index = f.dataIndex = e;
    } else
      f = this.$context || (this.$context = k$(this.chart.getContext(), this.index)), f.dataset = o, f.index = f.datasetIndex = this.index;
    return f.active = !!i, f.mode = a, f;
  }
  resolveDatasetElementOptions(e) {
    return this._resolveElementOptions(this.datasetElementType.id, e);
  }
  resolveDataElementOptions(e, i) {
    return this._resolveElementOptions(this.dataElementType.id, i, e);
  }
  _resolveElementOptions(e, i = "default", a) {
    const o = i === "active", f = this._cachedDataOpts, u = e + "-" + i, h = f[u], m = this.enableOptionSharing && uv(a);
    if (h)
      return YM(h, m);
    const v = this.chart.config, b = v.datasetElementScopeKeys(this._type, e), S = o ? [
      `${e}Hover`,
      "hover",
      e,
      ""
    ] : [
      e,
      ""
    ], C = v.getOptionScopes(this.getDataset(), b), E = Object.keys(Qn.elements[e]), D = () => this.getContext(a, o, i), M = v.resolveNamedOptions(C, E, D, S);
    return M.$shared && (M.$shared = m, f[u] = Object.freeze(YM(M, m))), M;
  }
  _resolveAnimations(e, i, a) {
    const o = this.chart, f = this._cachedDataOpts, u = `animation-${i}`, h = f[u];
    if (h)
      return h;
    let m;
    if (o.options.animation !== !1) {
      const b = this.chart.config, S = b.datasetAnimationScopeKeys(this._type, i), C = b.getOptionScopes(this.getDataset(), S);
      m = b.createResolver(C, this.getContext(e, a, i));
    }
    const v = new RL(o, m && m.animations);
    return m && m._cacheable && (f[u] = Object.freeze(v)), v;
  }
  getSharedOptions(e) {
    if (e.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
  }
  includeOptions(e, i) {
    return !i || Xw(e) || this.chart._animationsDisabled;
  }
  _getSharedOptions(e, i) {
    const a = this.resolveDataElementOptions(e, i), o = this._sharedOptions, f = this.getSharedOptions(a), u = this.includeOptions(i, f) || f !== o;
    return this.updateSharedOptions(f, i, a), {
      sharedOptions: f,
      includeOptions: u
    };
  }
  updateElement(e, i, a, o) {
    Xw(o) ? Object.assign(e, a) : this._resolveAnimations(i, o).update(e, a);
  }
  updateSharedOptions(e, i, a) {
    e && !Xw(i) && this._resolveAnimations(void 0, i).update(e, a);
  }
  _setStyle(e, i, a, o) {
    e.active = o;
    const f = this.getStyle(i, o);
    this._resolveAnimations(i, a, o).update(e, {
      options: !o && this.getSharedOptions(f) || f
    });
  }
  removeHoverStyle(e, i, a) {
    this._setStyle(e, a, "active", !1);
  }
  setHoverStyle(e, i, a) {
    this._setStyle(e, a, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !0);
  }
  _resyncElements(e) {
    const i = this._data, a = this._cachedMeta.data;
    for (const [h, m, v] of this._syncList)
      this[h](m, v);
    this._syncList = [];
    const o = a.length, f = i.length, u = Math.min(f, o);
    u && this.parse(0, u), f > o ? this._insertElements(o, f - o, e) : f < o && this._removeElements(f, o - f);
  }
  _insertElements(e, i, a = !0) {
    const o = this._cachedMeta, f = o.data, u = e + i;
    let h;
    const m = (v) => {
      for (v.length += i, h = v.length - 1; h >= u; h--)
        v[h] = v[h - i];
    };
    for (m(f), h = e; h < u; ++h)
      f[h] = new this.dataElementType();
    this._parsing && m(o._parsed), this.parse(e, i), a && this.updateElements(f, e, i, "reset");
  }
  updateElements(e, i, a, o) {
  }
  _removeElements(e, i) {
    const a = this._cachedMeta;
    if (this._parsing) {
      const o = a._parsed.splice(e, i);
      a._stacked && Fg(a, o);
    }
    a.data.splice(e, i);
  }
  _sync(e) {
    if (this._parsing)
      this._syncList.push(e);
    else {
      const [i, a, o] = e;
      this[i](a, o);
    }
    this.chart._dataChanges.push([
      this.index,
      ...e
    ]);
  }
  _onDataPush() {
    const e = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - e,
      e
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(e, i) {
    i && this._sync([
      "_removeElements",
      e,
      i
    ]);
    const a = arguments.length - 2;
    a && this._sync([
      "_insertElements",
      e,
      a
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
Fe(Ks, "defaults", {}), Fe(Ks, "datasetElementType", null), Fe(Ks, "dataElementType", null);
function O$(t, e) {
  if (!t._cache.$bar) {
    const i = t.getMatchingVisibleMetas(e);
    let a = [];
    for (let o = 0, f = i.length; o < f; o++)
      a = a.concat(i[o].controller.getAllParsedValues(t));
    t._cache.$bar = lL(a.sort((o, f) => o - f));
  }
  return t._cache.$bar;
}
function P$(t) {
  const e = t.iScale, i = O$(e, t.type);
  let a = e._length, o, f, u, h;
  const m = () => {
    u === 32767 || u === -32768 || (uv(h) && (a = Math.min(a, Math.abs(u - h) || a)), h = u);
  };
  for (o = 0, f = i.length; o < f; ++o)
    u = e.getPixelForValue(i[o]), m();
  for (h = void 0, o = 0, f = e.ticks.length; o < f; ++o)
    u = e.getPixelForTick(o), m();
  return a;
}
function L$(t, e, i, a) {
  const o = i.barThickness;
  let f, u;
  return sn(o) ? (f = e.min * i.categoryPercentage, u = i.barPercentage) : (f = o * a, u = 1), {
    chunk: f / a,
    ratio: u,
    start: e.pixels[t] - f / 2
  };
}
function N$(t, e, i, a) {
  const o = e.pixels, f = o[t];
  let u = t > 0 ? o[t - 1] : null, h = t < o.length - 1 ? o[t + 1] : null;
  const m = i.categoryPercentage;
  u === null && (u = f - (h === null ? e.end - e.start : h - f)), h === null && (h = f + f - u);
  const v = f - (f - Math.min(u, h)) / 2 * m;
  return {
    chunk: Math.abs(h - u) / 2 * m / a,
    ratio: i.barPercentage,
    start: v
  };
}
function z$(t, e, i, a) {
  const o = i.parse(t[0], a), f = i.parse(t[1], a), u = Math.min(o, f), h = Math.max(o, f);
  let m = u, v = h;
  Math.abs(u) > Math.abs(h) && (m = h, v = u), e[i.axis] = v, e._custom = {
    barStart: m,
    barEnd: v,
    start: o,
    end: f,
    min: u,
    max: h
  };
}
function kL(t, e, i, a) {
  return Kn(t) ? z$(t, e, i, a) : e[i.axis] = i.parse(t, a), e;
}
function GM(t, e, i, a) {
  const o = t.iScale, f = t.vScale, u = o.getLabels(), h = o === f, m = [];
  let v, b, S, C;
  for (v = i, b = i + a; v < b; ++v)
    C = e[v], S = {}, S[o.axis] = h || o.parse(u[v], v), m.push(kL(C, S, f, v));
  return m;
}
function Qw(t) {
  return t && t.barStart !== void 0 && t.barEnd !== void 0;
}
function F$(t, e, i) {
  return t !== 0 ? Fo(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1);
}
function V$(t) {
  let e, i, a, o, f;
  return t.horizontal ? (e = t.base > t.x, i = "left", a = "right") : (e = t.base < t.y, i = "bottom", a = "top"), e ? (o = "end", f = "start") : (o = "start", f = "end"), {
    start: i,
    end: a,
    reverse: e,
    top: o,
    bottom: f
  };
}
function j$(t, e, i, a) {
  let o = e.borderSkipped;
  const f = {};
  if (!o) {
    t.borderSkipped = f;
    return;
  }
  if (o === !0) {
    t.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: u, end: h, reverse: m, top: v, bottom: b } = V$(t);
  o === "middle" && i && (t.enableBorderRadius = !0, (i._top || 0) === a ? o = v : (i._bottom || 0) === a ? o = b : (f[KM(b, u, h, m)] = !0, o = v)), f[KM(o, u, h, m)] = !0, t.borderSkipped = f;
}
function KM(t, e, i, a) {
  return a ? (t = B$(t, e, i), t = XM(t, i, e)) : t = XM(t, e, i), t;
}
function B$(t, e, i) {
  return t === e ? i : t === i ? e : t;
}
function XM(t, e, i) {
  return t === "start" ? e : t === "end" ? i : t;
}
function H$(t, { inflateAmount: e }, i) {
  t.inflateAmount = e === "auto" ? i === 1 ? 0.33 : 0 : e;
}
class ix extends Ks {
  parsePrimitiveData(e, i, a, o) {
    return GM(e, i, a, o);
  }
  parseArrayData(e, i, a, o) {
    return GM(e, i, a, o);
  }
  parseObjectData(e, i, a, o) {
    const { iScale: f, vScale: u } = e, { xAxisKey: h = "x", yAxisKey: m = "y" } = this._parsing, v = f.axis === "x" ? h : m, b = u.axis === "x" ? h : m, S = [];
    let C, E, D, M;
    for (C = a, E = a + o; C < E; ++C)
      M = i[C], D = {}, D[f.axis] = f.parse(ec(M, v), C), S.push(kL(ec(M, b), D, u, C));
    return S;
  }
  updateRangeFromParsed(e, i, a, o) {
    super.updateRangeFromParsed(e, i, a, o);
    const f = a._custom;
    f && i === this._cachedMeta.vScale && (e.min = Math.min(e.min, f.min), e.max = Math.max(e.max, f.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, { iScale: a, vScale: o } = i, f = this.getParsed(e), u = f._custom, h = Qw(u) ? "[" + u.start + ", " + u.end + "]" : "" + o.getLabelForValue(f[o.axis]);
    return {
      label: "" + a.getLabelForValue(f[a.axis]),
      value: h
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const e = this._cachedMeta;
    e.stack = this.getDataset().stack;
  }
  update(e) {
    const i = this._cachedMeta;
    this.updateElements(i.data, 0, i.data.length, e);
  }
  updateElements(e, i, a, o) {
    const f = o === "reset", { index: u, _cachedMeta: { vScale: h } } = this, m = h.getBasePixel(), v = h.isHorizontal(), b = this._getRuler(), { sharedOptions: S, includeOptions: C } = this._getSharedOptions(i, o);
    for (let E = i; E < i + a; E++) {
      const D = this.getParsed(E), M = f || sn(D[h.axis]) ? {
        base: m,
        head: m
      } : this._calculateBarValuePixels(E), A = this._calculateBarIndexPixels(E, b), P = (D._stacks || {})[h.axis], N = {
        horizontal: v,
        base: M.base,
        enableBorderRadius: !P || Qw(D._custom) || u === P._top || u === P._bottom,
        x: v ? M.head : A.center,
        y: v ? A.center : M.head,
        height: v ? A.size : Math.abs(M.size),
        width: v ? Math.abs(M.size) : A.size
      };
      C && (N.options = S || this.resolveDataElementOptions(E, e[E].active ? "active" : o));
      const F = N.options || e[E].options;
      j$(N, F, P, u), H$(N, F, b.ratio), this.updateElement(e[E], E, N, o);
    }
  }
  _getStacks(e, i) {
    const { iScale: a } = this._cachedMeta, o = a.getMatchingVisibleMetas(this._type).filter((b) => b.controller.options.grouped), f = a.options.stacked, u = [], h = this._cachedMeta.controller.getParsed(i), m = h && h[a.axis], v = (b) => {
      const S = b._parsed.find((E) => E[a.axis] === m), C = S && S[b.vScale.axis];
      if (sn(C) || isNaN(C))
        return !0;
    };
    for (const b of o)
      if (!(i !== void 0 && v(b)) && ((f === !1 || u.indexOf(b.stack) === -1 || f === void 0 && b.stack === void 0) && u.push(b.stack), b.index === e))
        break;
    return u.length || u.push(void 0), u;
  }
  _getStackCount(e) {
    return this._getStacks(void 0, e).length;
  }
  _getStackIndex(e, i, a) {
    const o = this._getStacks(e, a), f = i !== void 0 ? o.indexOf(i) : -1;
    return f === -1 ? o.length - 1 : f;
  }
  _getRuler() {
    const e = this.options, i = this._cachedMeta, a = i.iScale, o = [];
    let f, u;
    for (f = 0, u = i.data.length; f < u; ++f)
      o.push(a.getPixelForValue(this.getParsed(f)[a.axis], f));
    const h = e.barThickness;
    return {
      min: h || P$(i),
      pixels: o,
      start: a._startPixel,
      end: a._endPixel,
      stackCount: this._getStackCount(),
      scale: a,
      grouped: e.grouped,
      ratio: h ? 1 : e.categoryPercentage * e.barPercentage
    };
  }
  _calculateBarValuePixels(e) {
    const { _cachedMeta: { vScale: i, _stacked: a, index: o }, options: { base: f, minBarLength: u } } = this, h = f || 0, m = this.getParsed(e), v = m._custom, b = Qw(v);
    let S = m[i.axis], C = 0, E = a ? this.applyStack(i, m, a) : S, D, M;
    E !== S && (C = E - S, E = S), b && (S = v.barStart, E = v.barEnd - v.barStart, S !== 0 && Fo(S) !== Fo(v.barEnd) && (C = 0), C += S);
    const A = !sn(f) && !b ? f : C;
    let P = i.getPixelForValue(A);
    if (this.chart.getDataVisibility(e) ? D = i.getPixelForValue(C + E) : D = P, M = D - P, Math.abs(M) < u) {
      M = F$(M, i, h) * u, S === h && (P -= M / 2);
      const N = i.getPixelForDecimal(0), F = i.getPixelForDecimal(1), B = Math.min(N, F), V = Math.max(N, F);
      P = Math.max(Math.min(P, V), B), D = P + M, a && !b && (m._stacks[i.axis]._visualValues[o] = i.getValueForPixel(D) - i.getValueForPixel(P));
    }
    if (P === i.getPixelForValue(h)) {
      const N = Fo(M) * i.getLineWidthForValue(h) / 2;
      P += N, M -= N;
    }
    return {
      size: M,
      base: P,
      head: D,
      center: D + M / 2
    };
  }
  _calculateBarIndexPixels(e, i) {
    const a = i.scale, o = this.options, f = o.skipNull, u = zt(o.maxBarThickness, 1 / 0);
    let h, m;
    if (i.grouped) {
      const v = f ? this._getStackCount(e) : i.stackCount, b = o.barThickness === "flex" ? N$(e, i, o, v) : L$(e, i, o, v), S = this._getStackIndex(this.index, this._cachedMeta.stack, f ? e : void 0);
      h = b.start + b.chunk * S + b.chunk / 2, m = Math.min(u, b.chunk * b.ratio);
    } else
      h = a.getPixelForValue(this.getParsed(e)[a.axis], e), m = Math.min(u, i.min * i.ratio);
    return {
      base: h - m / 2,
      head: h + m / 2,
      center: h,
      size: m
    };
  }
  draw() {
    const e = this._cachedMeta, i = e.vScale, a = e.data, o = a.length;
    let f = 0;
    for (; f < o; ++f)
      this.getParsed(f)[i.axis] !== null && !a[f].hidden && a[f].draw(this._ctx);
  }
}
Fe(ix, "id", "bar"), Fe(ix, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), Fe(ix, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
class rx extends Ks {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(e, i, a, o) {
    const f = super.parsePrimitiveData(e, i, a, o);
    for (let u = 0; u < f.length; u++)
      f[u]._custom = this.resolveDataElementOptions(u + a).radius;
    return f;
  }
  parseArrayData(e, i, a, o) {
    const f = super.parseArrayData(e, i, a, o);
    for (let u = 0; u < f.length; u++) {
      const h = i[a + u];
      f[u]._custom = zt(h[2], this.resolveDataElementOptions(u + a).radius);
    }
    return f;
  }
  parseObjectData(e, i, a, o) {
    const f = super.parseObjectData(e, i, a, o);
    for (let u = 0; u < f.length; u++) {
      const h = i[a + u];
      f[u]._custom = zt(h && h.r && +h.r, this.resolveDataElementOptions(u + a).radius);
    }
    return f;
  }
  getMaxOverflow() {
    const e = this._cachedMeta.data;
    let i = 0;
    for (let a = e.length - 1; a >= 0; --a)
      i = Math.max(i, e[a].size(this.resolveDataElementOptions(a)) / 2);
    return i > 0 && i;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = this.chart.data.labels || [], { xScale: o, yScale: f } = i, u = this.getParsed(e), h = o.getLabelForValue(u.x), m = f.getLabelForValue(u.y), v = u._custom;
    return {
      label: a[e] || "",
      value: "(" + h + ", " + m + (v ? ", " + v : "") + ")"
    };
  }
  update(e) {
    const i = this._cachedMeta.data;
    this.updateElements(i, 0, i.length, e);
  }
  updateElements(e, i, a, o) {
    const f = o === "reset", { iScale: u, vScale: h } = this._cachedMeta, { sharedOptions: m, includeOptions: v } = this._getSharedOptions(i, o), b = u.axis, S = h.axis;
    for (let C = i; C < i + a; C++) {
      const E = e[C], D = !f && this.getParsed(C), M = {}, A = M[b] = f ? u.getPixelForDecimal(0.5) : u.getPixelForValue(D[b]), P = M[S] = f ? h.getBasePixel() : h.getPixelForValue(D[S]);
      M.skip = isNaN(A) || isNaN(P), v && (M.options = m || this.resolveDataElementOptions(C, E.active ? "active" : o), f && (M.options.radius = 0)), this.updateElement(E, C, M, o);
    }
  }
  resolveDataElementOptions(e, i) {
    const a = this.getParsed(e);
    let o = super.resolveDataElementOptions(e, i);
    o.$shared && (o = Object.assign({}, o, {
      $shared: !1
    }));
    const f = o.radius;
    return i !== "active" && (o.radius = 0), o.radius += zt(a && a._custom, f), o;
  }
}
Fe(rx, "id", "bubble"), Fe(rx, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
}), Fe(rx, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function U$(t, e, i) {
  let a = 1, o = 1, f = 0, u = 0;
  if (e < Hn) {
    const h = t, m = h + e, v = Math.cos(h), b = Math.sin(h), S = Math.cos(m), C = Math.sin(m), E = (F, B, V) => cv(F, h, m, !0) ? 1 : Math.max(B, B * i, V, V * i), D = (F, B, V) => cv(F, h, m, !0) ? -1 : Math.min(B, B * i, V, V * i), M = E(0, v, S), A = E(Ci, b, C), P = D(Un, v, S), N = D(Un + Ci, b, C);
    a = (M - P) / 2, o = (A - N) / 2, f = -(M + P) / 2, u = -(A + N) / 2;
  }
  return {
    ratioX: a,
    ratioY: o,
    offsetX: f,
    offsetY: u
  };
}
class Ff extends Ks {
  constructor(e, i) {
    super(e, i), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(e, i) {
    const a = this.getDataset().data, o = this._cachedMeta;
    if (this._parsing === !1)
      o._parsed = a;
    else {
      let f = (m) => +a[m];
      if (Kt(a[e])) {
        const { key: m = "value" } = this._parsing;
        f = (v) => +ec(a[v], m);
      }
      let u, h;
      for (u = e, h = e + i; u < h; ++u)
        o._parsed[u] = f(u);
    }
  }
  _getRotation() {
    return Gs(this.options.rotation - 90);
  }
  _getCircumference() {
    return Gs(this.options.circumference);
  }
  _getRotationExtents() {
    let e = Hn, i = -Hn;
    for (let a = 0; a < this.chart.data.datasets.length; ++a)
      if (this.chart.isDatasetVisible(a) && this.chart.getDatasetMeta(a).type === this._type) {
        const o = this.chart.getDatasetMeta(a).controller, f = o._getRotation(), u = o._getCircumference();
        e = Math.min(e, f), i = Math.max(i, f + u);
      }
    return {
      rotation: e,
      circumference: i - e
    };
  }
  update(e) {
    const i = this.chart, { chartArea: a } = i, o = this._cachedMeta, f = o.data, u = this.getMaxBorderWidth() + this.getMaxOffset(f) + this.options.spacing, h = Math.max((Math.min(a.width, a.height) - u) / 2, 0), m = Math.min(nI(this.options.cutout, h), 1), v = this._getRingWeight(this.index), { circumference: b, rotation: S } = this._getRotationExtents(), { ratioX: C, ratioY: E, offsetX: D, offsetY: M } = U$(S, b, m), A = (a.width - u) / C, P = (a.height - u) / E, N = Math.max(Math.min(A, P) / 2, 0), F = iL(this.options.radius, N), B = Math.max(F * m, 0), V = (F - B) / this._getVisibleDatasetWeightTotal();
    this.offsetX = D * F, this.offsetY = M * F, o.total = this.calculateTotal(), this.outerRadius = F - V * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - V * v, 0), this.updateElements(f, 0, f.length, e);
  }
  _circumference(e, i) {
    const a = this.options, o = this._cachedMeta, f = this._getCircumference();
    return i && a.animation.animateRotate || !this.chart.getDataVisibility(e) || o._parsed[e] === null || o.data[e].hidden ? 0 : this.calculateCircumference(o._parsed[e] * f / Hn);
  }
  updateElements(e, i, a, o) {
    const f = o === "reset", u = this.chart, h = u.chartArea, v = u.options.animation, b = (h.left + h.right) / 2, S = (h.top + h.bottom) / 2, C = f && v.animateScale, E = C ? 0 : this.innerRadius, D = C ? 0 : this.outerRadius, { sharedOptions: M, includeOptions: A } = this._getSharedOptions(i, o);
    let P = this._getRotation(), N;
    for (N = 0; N < i; ++N)
      P += this._circumference(N, f);
    for (N = i; N < i + a; ++N) {
      const F = this._circumference(N, f), B = e[N], V = {
        x: b + this.offsetX,
        y: S + this.offsetY,
        startAngle: P,
        endAngle: P + F,
        circumference: F,
        outerRadius: D,
        innerRadius: E
      };
      A && (V.options = M || this.resolveDataElementOptions(N, B.active ? "active" : o)), P += F, this.updateElement(B, N, V, o);
    }
  }
  calculateTotal() {
    const e = this._cachedMeta, i = e.data;
    let a = 0, o;
    for (o = 0; o < i.length; o++) {
      const f = e._parsed[o];
      f !== null && !isNaN(f) && this.chart.getDataVisibility(o) && !i[o].hidden && (a += Math.abs(f));
    }
    return a;
  }
  calculateCircumference(e) {
    const i = this._cachedMeta.total;
    return i > 0 && !isNaN(e) ? Hn * (Math.abs(e) / i) : 0;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = this.chart, o = a.data.labels || [], f = Dv(i._parsed[e], a.options.locale);
    return {
      label: o[e] || "",
      value: f
    };
  }
  getMaxBorderWidth(e) {
    let i = 0;
    const a = this.chart;
    let o, f, u, h, m;
    if (!e) {
      for (o = 0, f = a.data.datasets.length; o < f; ++o)
        if (a.isDatasetVisible(o)) {
          u = a.getDatasetMeta(o), e = u.data, h = u.controller;
          break;
        }
    }
    if (!e)
      return 0;
    for (o = 0, f = e.length; o < f; ++o)
      m = h.resolveDataElementOptions(o), m.borderAlign !== "inner" && (i = Math.max(i, m.borderWidth || 0, m.hoverBorderWidth || 0));
    return i;
  }
  getMaxOffset(e) {
    let i = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const f = this.resolveDataElementOptions(a);
      i = Math.max(i, f.offset || 0, f.hoverOffset || 0);
    }
    return i;
  }
  _getRingWeightOffset(e) {
    let i = 0;
    for (let a = 0; a < e; ++a)
      this.chart.isDatasetVisible(a) && (i += this._getRingWeight(a));
    return i;
  }
  _getRingWeight(e) {
    return Math.max(zt(this.chart.data.datasets[e].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
Fe(Ff, "id", "doughnut"), Fe(Ff, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), Fe(Ff, "descriptors", {
  _scriptable: (e) => e !== "spacing",
  _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
}), Fe(Ff, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const i = e.data;
          if (i.labels.length && i.datasets.length) {
            const { labels: { pointStyle: a, color: o } } = e.legend.options;
            return i.labels.map((f, u) => {
              const m = e.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: f,
                fillStyle: m.backgroundColor,
                strokeStyle: m.borderColor,
                fontColor: o,
                lineWidth: m.borderWidth,
                pointStyle: a,
                hidden: !e.getDataVisibility(u),
                index: u
              };
            });
          }
          return [];
        }
      },
      onClick(e, i, a) {
        a.chart.toggleDataVisibility(i.index), a.chart.update();
      }
    }
  }
});
class ax extends Ks {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(e) {
    const i = this._cachedMeta, { dataset: a, data: o = [], _dataset: f } = i, u = this.chart._animationsDisabled;
    let { start: h, count: m } = fL(i, o, u);
    this._drawStart = h, this._drawCount = m, dL(i) && (h = 0, m = o.length), a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!f._decimated, a.points = o;
    const v = this.resolveDatasetElementOptions(e);
    this.options.showLine || (v.borderWidth = 0), v.segment = this.options.segment, this.updateElement(a, void 0, {
      animated: !u,
      options: v
    }, e), this.updateElements(o, h, m, e);
  }
  updateElements(e, i, a, o) {
    const f = o === "reset", { iScale: u, vScale: h, _stacked: m, _dataset: v } = this._cachedMeta, { sharedOptions: b, includeOptions: S } = this._getSharedOptions(i, o), C = u.axis, E = h.axis, { spanGaps: D, segment: M } = this.options, A = rp(D) ? D : Number.POSITIVE_INFINITY, P = this.chart._animationsDisabled || f || o === "none", N = i + a, F = e.length;
    let B = i > 0 && this.getParsed(i - 1);
    for (let V = 0; V < F; ++V) {
      const G = e[V], Y = P ? G : {};
      if (V < i || V >= N) {
        Y.skip = !0;
        continue;
      }
      const K = this.getParsed(V), ae = sn(K[E]), ie = Y[C] = u.getPixelForValue(K[C], V), ee = Y[E] = f || ae ? h.getBasePixel() : h.getPixelForValue(m ? this.applyStack(h, K, m) : K[E], V);
      Y.skip = isNaN(ie) || isNaN(ee) || ae, Y.stop = V > 0 && Math.abs(K[C] - B[C]) > A, M && (Y.parsed = K, Y.raw = v.data[V]), S && (Y.options = b || this.resolveDataElementOptions(V, G.active ? "active" : o)), P || this.updateElement(G, V, Y, o), B = K;
    }
  }
  getMaxOverflow() {
    const e = this._cachedMeta, i = e.dataset, a = i.options && i.options.borderWidth || 0, o = e.data || [];
    if (!o.length)
      return a;
    const f = o[0].size(this.resolveDataElementOptions(0)), u = o[o.length - 1].size(this.resolveDataElementOptions(o.length - 1));
    return Math.max(a, f, u) / 2;
  }
  draw() {
    const e = this._cachedMeta;
    e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw();
  }
}
Fe(ax, "id", "line"), Fe(ax, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), Fe(ax, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class nv extends Ks {
  constructor(e, i) {
    super(e, i), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = this.chart, o = a.data.labels || [], f = Dv(i._parsed[e].r, a.options.locale);
    return {
      label: o[e] || "",
      value: f
    };
  }
  parseObjectData(e, i, a, o) {
    return xL.bind(this)(e, i, a, o);
  }
  update(e) {
    const i = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(i, 0, i.length, e);
  }
  getMinMax() {
    const e = this._cachedMeta, i = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return e.data.forEach((a, o) => {
      const f = this.getParsed(o).r;
      !isNaN(f) && this.chart.getDataVisibility(o) && (f < i.min && (i.min = f), f > i.max && (i.max = f));
    }), i;
  }
  _updateRadius() {
    const e = this.chart, i = e.chartArea, a = e.options, o = Math.min(i.right - i.left, i.bottom - i.top), f = Math.max(o / 2, 0), u = Math.max(a.cutoutPercentage ? f / 100 * a.cutoutPercentage : 1, 0), h = (f - u) / e.getVisibleDatasetCount();
    this.outerRadius = f - h * this.index, this.innerRadius = this.outerRadius - h;
  }
  updateElements(e, i, a, o) {
    const f = o === "reset", u = this.chart, m = u.options.animation, v = this._cachedMeta.rScale, b = v.xCenter, S = v.yCenter, C = v.getIndexAngle(0) - 0.5 * Un;
    let E = C, D;
    const M = 360 / this.countVisibleElements();
    for (D = 0; D < i; ++D)
      E += this._computeAngle(D, o, M);
    for (D = i; D < i + a; D++) {
      const A = e[D];
      let P = E, N = E + this._computeAngle(D, o, M), F = u.getDataVisibility(D) ? v.getDistanceFromCenterForValue(this.getParsed(D).r) : 0;
      E = N, f && (m.animateScale && (F = 0), m.animateRotate && (P = N = C));
      const B = {
        x: b,
        y: S,
        innerRadius: 0,
        outerRadius: F,
        startAngle: P,
        endAngle: N,
        options: this.resolveDataElementOptions(D, A.active ? "active" : o)
      };
      this.updateElement(A, D, B, o);
    }
  }
  countVisibleElements() {
    const e = this._cachedMeta;
    let i = 0;
    return e.data.forEach((a, o) => {
      !isNaN(this.getParsed(o).r) && this.chart.getDataVisibility(o) && i++;
    }), i;
  }
  _computeAngle(e, i, a) {
    return this.chart.getDataVisibility(e) ? Gs(this.resolveDataElementOptions(e, i).angle || a) : 0;
  }
}
Fe(nv, "id", "polarArea"), Fe(nv, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), Fe(nv, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const i = e.data;
          if (i.labels.length && i.datasets.length) {
            const { labels: { pointStyle: a, color: o } } = e.legend.options;
            return i.labels.map((f, u) => {
              const m = e.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: f,
                fillStyle: m.backgroundColor,
                strokeStyle: m.borderColor,
                fontColor: o,
                lineWidth: m.borderWidth,
                pointStyle: a,
                hidden: !e.getDataVisibility(u),
                index: u
              };
            });
          }
          return [];
        }
      },
      onClick(e, i, a) {
        a.chart.toggleDataVisibility(i.index), a.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
class DT extends Ff {
}
Fe(DT, "id", "pie"), Fe(DT, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class sx extends Ks {
  getLabelAndValue(e) {
    const i = this._cachedMeta.vScale, a = this.getParsed(e);
    return {
      label: i.getLabels()[e],
      value: "" + i.getLabelForValue(a[i.axis])
    };
  }
  parseObjectData(e, i, a, o) {
    return xL.bind(this)(e, i, a, o);
  }
  update(e) {
    const i = this._cachedMeta, a = i.dataset, o = i.data || [], f = i.iScale.getLabels();
    if (a.points = o, e !== "resize") {
      const u = this.resolveDatasetElementOptions(e);
      this.options.showLine || (u.borderWidth = 0);
      const h = {
        _loop: !0,
        _fullLoop: f.length === o.length,
        options: u
      };
      this.updateElement(a, void 0, h, e);
    }
    this.updateElements(o, 0, o.length, e);
  }
  updateElements(e, i, a, o) {
    const f = this._cachedMeta.rScale, u = o === "reset";
    for (let h = i; h < i + a; h++) {
      const m = e[h], v = this.resolveDataElementOptions(h, m.active ? "active" : o), b = f.getPointPositionForValue(h, this.getParsed(h).r), S = u ? f.xCenter : b.x, C = u ? f.yCenter : b.y, E = {
        x: S,
        y: C,
        angle: b.angle,
        skip: isNaN(S) || isNaN(C),
        options: v
      };
      this.updateElement(m, h, E, o);
    }
  }
}
Fe(sx, "id", "radar"), Fe(sx, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
}), Fe(sx, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class ox extends Ks {
  getLabelAndValue(e) {
    const i = this._cachedMeta, a = this.chart.data.labels || [], { xScale: o, yScale: f } = i, u = this.getParsed(e), h = o.getLabelForValue(u.x), m = f.getLabelForValue(u.y);
    return {
      label: a[e] || "",
      value: "(" + h + ", " + m + ")"
    };
  }
  update(e) {
    const i = this._cachedMeta, { data: a = [] } = i, o = this.chart._animationsDisabled;
    let { start: f, count: u } = fL(i, a, o);
    if (this._drawStart = f, this._drawCount = u, dL(i) && (f = 0, u = a.length), this.options.showLine) {
      this.datasetElementType || this.addElements();
      const { dataset: h, _dataset: m } = i;
      h._chart = this.chart, h._datasetIndex = this.index, h._decimated = !!m._decimated, h.points = a;
      const v = this.resolveDatasetElementOptions(e);
      v.segment = this.options.segment, this.updateElement(h, void 0, {
        animated: !o,
        options: v
      }, e);
    } else this.datasetElementType && (delete i.dataset, this.datasetElementType = !1);
    this.updateElements(a, f, u, e);
  }
  addElements() {
    const { showLine: e } = this.options;
    !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
  }
  updateElements(e, i, a, o) {
    const f = o === "reset", { iScale: u, vScale: h, _stacked: m, _dataset: v } = this._cachedMeta, b = this.resolveDataElementOptions(i, o), S = this.getSharedOptions(b), C = this.includeOptions(o, S), E = u.axis, D = h.axis, { spanGaps: M, segment: A } = this.options, P = rp(M) ? M : Number.POSITIVE_INFINITY, N = this.chart._animationsDisabled || f || o === "none";
    let F = i > 0 && this.getParsed(i - 1);
    for (let B = i; B < i + a; ++B) {
      const V = e[B], G = this.getParsed(B), Y = N ? V : {}, K = sn(G[D]), ae = Y[E] = u.getPixelForValue(G[E], B), ie = Y[D] = f || K ? h.getBasePixel() : h.getPixelForValue(m ? this.applyStack(h, G, m) : G[D], B);
      Y.skip = isNaN(ae) || isNaN(ie) || K, Y.stop = B > 0 && Math.abs(G[E] - F[E]) > P, A && (Y.parsed = G, Y.raw = v.data[B]), C && (Y.options = S || this.resolveDataElementOptions(B, V.active ? "active" : o)), N || this.updateElement(V, B, Y, o), F = G;
    }
    this.updateSharedOptions(S, o, b);
  }
  getMaxOverflow() {
    const e = this._cachedMeta, i = e.data || [];
    if (!this.options.showLine) {
      let h = 0;
      for (let m = i.length - 1; m >= 0; --m)
        h = Math.max(h, i[m].size(this.resolveDataElementOptions(m)) / 2);
      return h > 0 && h;
    }
    const a = e.dataset, o = a.options && a.options.borderWidth || 0;
    if (!i.length)
      return o;
    const f = i[0].size(this.resolveDataElementOptions(0)), u = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
    return Math.max(o, f, u) / 2;
  }
}
Fe(ox, "id", "scatter"), Fe(ox, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
}), Fe(ox, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var I$ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: ix,
  BubbleController: rx,
  DoughnutController: Ff,
  LineController: ax,
  PieController: DT,
  PolarAreaController: nv,
  RadarController: sx,
  ScatterController: ox
});
function Mf() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class VE {
  constructor(e) {
    Fe(this, "options");
    this.options = e || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(e) {
    Object.assign(VE.prototype, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return Mf();
  }
  parse() {
    return Mf();
  }
  format() {
    return Mf();
  }
  add() {
    return Mf();
  }
  diff() {
    return Mf();
  }
  startOf() {
    return Mf();
  }
  endOf() {
    return Mf();
  }
}
var $$ = {
  _date: VE
};
function W$(t, e, i, a) {
  const { controller: o, data: f, _sorted: u } = t, h = o._cachedMeta.iScale;
  if (h && e === h.axis && e !== "r" && u && f.length) {
    const m = h._reversePixels ? pI : Il;
    if (a) {
      if (o._sharedOptions) {
        const v = f[0], b = typeof v.getRange == "function" && v.getRange(e);
        if (b) {
          const S = m(f, e, i - b), C = m(f, e, i + b);
          return {
            lo: S.lo,
            hi: C.hi
          };
        }
      }
    } else return m(f, e, i);
  }
  return {
    lo: 0,
    hi: f.length - 1
  };
}
function Qx(t, e, i, a, o) {
  const f = t.getSortedVisibleDatasetMetas(), u = i[e];
  for (let h = 0, m = f.length; h < m; ++h) {
    const { index: v, data: b } = f[h], { lo: S, hi: C } = W$(f[h], e, u, o);
    for (let E = S; E <= C; ++E) {
      const D = b[E];
      D.skip || a(D, v, E);
    }
  }
}
function Y$(t) {
  const e = t.indexOf("x") !== -1, i = t.indexOf("y") !== -1;
  return function(a, o) {
    const f = e ? Math.abs(a.x - o.x) : 0, u = i ? Math.abs(a.y - o.y) : 0;
    return Math.sqrt(Math.pow(f, 2) + Math.pow(u, 2));
  };
}
function qw(t, e, i, a, o) {
  const f = [];
  return !o && !t.isPointInArea(e) || Qx(t, i, e, function(h, m, v) {
    !o && !$l(h, t.chartArea, 0) || h.inRange(e.x, e.y, a) && f.push({
      element: h,
      datasetIndex: m,
      index: v
    });
  }, !0), f;
}
function G$(t, e, i, a) {
  let o = [];
  function f(u, h, m) {
    const { startAngle: v, endAngle: b } = u.getProps([
      "startAngle",
      "endAngle"
    ], a), { angle: S } = sL(u, {
      x: e.x,
      y: e.y
    });
    cv(S, v, b) && o.push({
      element: u,
      datasetIndex: h,
      index: m
    });
  }
  return Qx(t, i, e, f), o;
}
function K$(t, e, i, a, o, f) {
  let u = [];
  const h = Y$(i);
  let m = Number.POSITIVE_INFINITY;
  function v(b, S, C) {
    const E = b.inRange(e.x, e.y, o);
    if (a && !E)
      return;
    const D = b.getCenterPoint(o);
    if (!(!!f || t.isPointInArea(D)) && !E)
      return;
    const A = h(e, D);
    A < m ? (u = [
      {
        element: b,
        datasetIndex: S,
        index: C
      }
    ], m = A) : A === m && u.push({
      element: b,
      datasetIndex: S,
      index: C
    });
  }
  return Qx(t, i, e, v), u;
}
function Zw(t, e, i, a, o, f) {
  return !f && !t.isPointInArea(e) ? [] : i === "r" && !a ? G$(t, e, i, o) : K$(t, e, i, a, o, f);
}
function QM(t, e, i, a, o) {
  const f = [], u = i === "x" ? "inXRange" : "inYRange";
  let h = !1;
  return Qx(t, i, e, (m, v, b) => {
    m[u] && m[u](e[i], o) && (f.push({
      element: m,
      datasetIndex: v,
      index: b
    }), h = h || m.inRange(e.x, e.y, o));
  }), a && !h ? [] : f;
}
var X$ = {
  modes: {
    index(t, e, i, a) {
      const o = Pf(e, t), f = i.axis || "x", u = i.includeInvisible || !1, h = i.intersect ? qw(t, o, f, a, u) : Zw(t, o, f, !1, a, u), m = [];
      return h.length ? (t.getSortedVisibleDatasetMetas().forEach((v) => {
        const b = h[0].index, S = v.data[b];
        S && !S.skip && m.push({
          element: S,
          datasetIndex: v.index,
          index: b
        });
      }), m) : [];
    },
    dataset(t, e, i, a) {
      const o = Pf(e, t), f = i.axis || "xy", u = i.includeInvisible || !1;
      let h = i.intersect ? qw(t, o, f, a, u) : Zw(t, o, f, !1, a, u);
      if (h.length > 0) {
        const m = h[0].datasetIndex, v = t.getDatasetMeta(m).data;
        h = [];
        for (let b = 0; b < v.length; ++b)
          h.push({
            element: v[b],
            datasetIndex: m,
            index: b
          });
      }
      return h;
    },
    point(t, e, i, a) {
      const o = Pf(e, t), f = i.axis || "xy", u = i.includeInvisible || !1;
      return qw(t, o, f, a, u);
    },
    nearest(t, e, i, a) {
      const o = Pf(e, t), f = i.axis || "xy", u = i.includeInvisible || !1;
      return Zw(t, o, f, i.intersect, a, u);
    },
    x(t, e, i, a) {
      const o = Pf(e, t);
      return QM(t, o, "x", i.intersect, a);
    },
    y(t, e, i, a) {
      const o = Pf(e, t);
      return QM(t, o, "y", i.intersect, a);
    }
  }
};
const ML = [
  "left",
  "top",
  "right",
  "bottom"
];
function Vg(t, e) {
  return t.filter((i) => i.pos === e);
}
function qM(t, e) {
  return t.filter((i) => ML.indexOf(i.pos) === -1 && i.box.axis === e);
}
function jg(t, e) {
  return t.sort((i, a) => {
    const o = e ? a : i, f = e ? i : a;
    return o.weight === f.weight ? o.index - f.index : o.weight - f.weight;
  });
}
function Q$(t) {
  const e = [];
  let i, a, o, f, u, h;
  for (i = 0, a = (t || []).length; i < a; ++i)
    o = t[i], { position: f, options: { stack: u, stackWeight: h = 1 } } = o, e.push({
      index: i,
      box: o,
      pos: f,
      horizontal: o.isHorizontal(),
      weight: o.weight,
      stack: u && f + u,
      stackWeight: h
    });
  return e;
}
function q$(t) {
  const e = {};
  for (const i of t) {
    const { stack: a, pos: o, stackWeight: f } = i;
    if (!a || !ML.includes(o))
      continue;
    const u = e[a] || (e[a] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    u.count++, u.weight += f;
  }
  return e;
}
function Z$(t, e) {
  const i = q$(t), { vBoxMaxWidth: a, hBoxMaxHeight: o } = e;
  let f, u, h;
  for (f = 0, u = t.length; f < u; ++f) {
    h = t[f];
    const { fullSize: m } = h.box, v = i[h.stack], b = v && h.stackWeight / v.weight;
    h.horizontal ? (h.width = b ? b * a : m && e.availableWidth, h.height = o) : (h.width = a, h.height = b ? b * o : m && e.availableHeight);
  }
  return i;
}
function J$(t) {
  const e = Q$(t), i = jg(e.filter((v) => v.box.fullSize), !0), a = jg(Vg(e, "left"), !0), o = jg(Vg(e, "right")), f = jg(Vg(e, "top"), !0), u = jg(Vg(e, "bottom")), h = qM(e, "x"), m = qM(e, "y");
  return {
    fullSize: i,
    leftAndTop: a.concat(f),
    rightAndBottom: o.concat(m).concat(u).concat(h),
    chartArea: Vg(e, "chartArea"),
    vertical: a.concat(o).concat(m),
    horizontal: f.concat(u).concat(h)
  };
}
function ZM(t, e, i, a) {
  return Math.max(t[i], e[i]) + Math.max(t[a], e[a]);
}
function AL(t, e) {
  t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);
}
function e3(t, e, i, a) {
  const { pos: o, box: f } = i, u = t.maxPadding;
  if (!Kt(o)) {
    i.size && (t[o] -= i.size);
    const S = a[i.stack] || {
      size: 0,
      count: 1
    };
    S.size = Math.max(S.size, i.horizontal ? f.height : f.width), i.size = S.size / S.count, t[o] += i.size;
  }
  f.getPadding && AL(u, f.getPadding());
  const h = Math.max(0, e.outerWidth - ZM(u, t, "left", "right")), m = Math.max(0, e.outerHeight - ZM(u, t, "top", "bottom")), v = h !== t.w, b = m !== t.h;
  return t.w = h, t.h = m, i.horizontal ? {
    same: v,
    other: b
  } : {
    same: b,
    other: v
  };
}
function t3(t) {
  const e = t.maxPadding;
  function i(a) {
    const o = Math.max(e[a] - t[a], 0);
    return t[a] += o, o;
  }
  t.y += i("top"), t.x += i("left"), i("right"), i("bottom");
}
function n3(t, e) {
  const i = e.maxPadding;
  function a(o) {
    const f = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return o.forEach((u) => {
      f[u] = Math.max(e[u], i[u]);
    }), f;
  }
  return a(t ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Yg(t, e, i, a) {
  const o = [];
  let f, u, h, m, v, b;
  for (f = 0, u = t.length, v = 0; f < u; ++f) {
    h = t[f], m = h.box, m.update(h.width || e.w, h.height || e.h, n3(h.horizontal, e));
    const { same: S, other: C } = e3(e, i, h, a);
    v |= S && o.length, b = b || C, m.fullSize || o.push(h);
  }
  return v && Yg(o, e, i, a) || b;
}
function Vb(t, e, i, a, o) {
  t.top = i, t.left = e, t.right = e + a, t.bottom = i + o, t.width = a, t.height = o;
}
function JM(t, e, i, a) {
  const o = i.padding;
  let { x: f, y: u } = e;
  for (const h of t) {
    const m = h.box, v = a[h.stack] || {
      placed: 0,
      weight: 1
    }, b = h.stackWeight / v.weight || 1;
    if (h.horizontal) {
      const S = e.w * b, C = v.size || m.height;
      uv(v.start) && (u = v.start), m.fullSize ? Vb(m, o.left, u, i.outerWidth - o.right - o.left, C) : Vb(m, e.left + v.placed, u, S, C), v.start = u, v.placed += S, u = m.bottom;
    } else {
      const S = e.h * b, C = v.size || m.width;
      uv(v.start) && (f = v.start), m.fullSize ? Vb(m, f, o.top, C, i.outerHeight - o.bottom - o.top) : Vb(m, f, e.top + v.placed, C, S), v.start = f, v.placed += S, f = m.right;
    }
  }
  e.x = f, e.y = u;
}
var Fr = {
  addBox(t, e) {
    t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
      return [
        {
          z: 0,
          draw(i) {
            e.draw(i);
          }
        }
      ];
    }, t.boxes.push(e);
  },
  removeBox(t, e) {
    const i = t.boxes ? t.boxes.indexOf(e) : -1;
    i !== -1 && t.boxes.splice(i, 1);
  },
  configure(t, e, i) {
    e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight;
  },
  update(t, e, i, a) {
    if (!t)
      return;
    const o = jr(t.options.layout.padding), f = Math.max(e - o.width, 0), u = Math.max(i - o.height, 0), h = J$(t.boxes), m = h.vertical, v = h.horizontal;
    xn(t.boxes, (M) => {
      typeof M.beforeLayout == "function" && M.beforeLayout();
    });
    const b = m.reduce((M, A) => A.box.options && A.box.options.display === !1 ? M : M + 1, 0) || 1, S = Object.freeze({
      outerWidth: e,
      outerHeight: i,
      padding: o,
      availableWidth: f,
      availableHeight: u,
      vBoxMaxWidth: f / 2 / b,
      hBoxMaxHeight: u / 2
    }), C = Object.assign({}, o);
    AL(C, jr(a));
    const E = Object.assign({
      maxPadding: C,
      w: f,
      h: u,
      x: o.left,
      y: o.top
    }, o), D = Z$(m.concat(v), S);
    Yg(h.fullSize, E, S, D), Yg(m, E, S, D), Yg(v, E, S, D) && Yg(m, E, S, D), t3(E), JM(h.leftAndTop, E, S, D), E.x += E.w, E.y += E.h, JM(h.rightAndBottom, E, S, D), t.chartArea = {
      left: E.left,
      top: E.top,
      right: E.left + E.w,
      bottom: E.top + E.h,
      height: E.h,
      width: E.w
    }, xn(h.chartArea, (M) => {
      const A = M.box;
      Object.assign(A, t.chartArea), A.update(E.w, E.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class OL {
  acquireContext(e, i) {
  }
  releaseContext(e) {
    return !1;
  }
  addEventListener(e, i, a) {
  }
  removeEventListener(e, i, a) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(e, i, a, o) {
    return i = Math.max(0, i || e.width), a = a || e.height, {
      width: i,
      height: Math.max(0, o ? Math.floor(i / o) : a)
    };
  }
  isAttached(e) {
    return !0;
  }
  updateConfig(e) {
  }
}
class i3 extends OL {
  acquireContext(e) {
    return e && e.getContext && e.getContext("2d") || null;
  }
  updateConfig(e) {
    e.options.animation = !1;
  }
}
const lx = "$chartjs", r3 = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, eA = (t) => t === null || t === "";
function a3(t, e) {
  const i = t.style, a = t.getAttribute("height"), o = t.getAttribute("width");
  if (t[lx] = {
    initial: {
      height: a,
      width: o,
      style: {
        display: i.display,
        height: i.height,
        width: i.width
      }
    }
  }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", eA(o)) {
    const f = FM(t, "width");
    f !== void 0 && (t.width = f);
  }
  if (eA(a))
    if (t.style.height === "")
      t.height = t.width / (e || 2);
    else {
      const f = FM(t, "height");
      f !== void 0 && (t.height = f);
    }
  return t;
}
const PL = o$ ? {
  passive: !0
} : !1;
function s3(t, e, i) {
  t && t.addEventListener(e, i, PL);
}
function o3(t, e, i) {
  t && t.canvas && t.canvas.removeEventListener(e, i, PL);
}
function l3(t, e) {
  const i = r3[t.type] || t.type, { x: a, y: o } = Pf(t, e);
  return {
    type: i,
    chart: e,
    native: t,
    x: a !== void 0 ? a : null,
    y: o !== void 0 ? o : null
  };
}
function wx(t, e) {
  for (const i of t)
    if (i === e || i.contains(e))
      return !0;
}
function u3(t, e, i) {
  const a = t.canvas, o = new MutationObserver((f) => {
    let u = !1;
    for (const h of f)
      u = u || wx(h.addedNodes, a), u = u && !wx(h.removedNodes, a);
    u && i();
  });
  return o.observe(document, {
    childList: !0,
    subtree: !0
  }), o;
}
function c3(t, e, i) {
  const a = t.canvas, o = new MutationObserver((f) => {
    let u = !1;
    for (const h of f)
      u = u || wx(h.removedNodes, a), u = u && !wx(h.addedNodes, a);
    u && i();
  });
  return o.observe(document, {
    childList: !0,
    subtree: !0
  }), o;
}
const dv = /* @__PURE__ */ new Map();
let tA = 0;
function LL() {
  const t = window.devicePixelRatio;
  t !== tA && (tA = t, dv.forEach((e, i) => {
    i.currentDevicePixelRatio !== t && e();
  }));
}
function f3(t, e) {
  dv.size || window.addEventListener("resize", LL), dv.set(t, e);
}
function d3(t) {
  dv.delete(t), dv.size || window.removeEventListener("resize", LL);
}
function h3(t, e, i) {
  const a = t.canvas, o = a && FE(a);
  if (!o)
    return;
  const f = cL((h, m) => {
    const v = o.clientWidth;
    i(h, m), v < o.clientWidth && i();
  }, window), u = new ResizeObserver((h) => {
    const m = h[0], v = m.contentRect.width, b = m.contentRect.height;
    v === 0 && b === 0 || f(v, b);
  });
  return u.observe(o), f3(t, f), u;
}
function Jw(t, e, i) {
  i && i.disconnect(), e === "resize" && d3(t);
}
function p3(t, e, i) {
  const a = t.canvas, o = cL((f) => {
    t.ctx !== null && i(l3(f, t));
  }, t);
  return s3(a, e, o), o;
}
class m3 extends OL {
  acquireContext(e, i) {
    const a = e && e.getContext && e.getContext("2d");
    return a && a.canvas === e ? (a3(e, i), a) : null;
  }
  releaseContext(e) {
    const i = e.canvas;
    if (!i[lx])
      return !1;
    const a = i[lx].initial;
    [
      "height",
      "width"
    ].forEach((f) => {
      const u = a[f];
      sn(u) ? i.removeAttribute(f) : i.setAttribute(f, u);
    });
    const o = a.style || {};
    return Object.keys(o).forEach((f) => {
      i.style[f] = o[f];
    }), i.width = i.width, delete i[lx], !0;
  }
  addEventListener(e, i, a) {
    this.removeEventListener(e, i);
    const o = e.$proxies || (e.$proxies = {}), u = {
      attach: u3,
      detach: c3,
      resize: h3
    }[i] || p3;
    o[i] = u(e, i, a);
  }
  removeEventListener(e, i) {
    const a = e.$proxies || (e.$proxies = {}), o = a[i];
    if (!o)
      return;
    ({
      attach: Jw,
      detach: Jw,
      resize: Jw
    }[i] || o3)(e, i, o), a[i] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(e, i, a, o) {
    return s$(e, i, a, o);
  }
  isAttached(e) {
    const i = e && FE(e);
    return !!(i && i.isConnected);
  }
}
function g3(t) {
  return !zE() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? i3 : m3;
}
var nx;
let ql = (nx = class {
  constructor() {
    Fe(this, "x");
    Fe(this, "y");
    Fe(this, "active", !1);
    Fe(this, "options");
    Fe(this, "$animations");
  }
  tooltipPosition(e) {
    const { x: i, y: a } = this.getProps([
      "x",
      "y"
    ], e);
    return {
      x: i,
      y: a
    };
  }
  hasValue() {
    return rp(this.x) && rp(this.y);
  }
  getProps(e, i) {
    const a = this.$animations;
    if (!i || !a)
      return this;
    const o = {};
    return e.forEach((f) => {
      o[f] = a[f] && a[f].active() ? a[f]._to : this[f];
    }), o;
  }
}, Fe(nx, "defaults", {}), Fe(nx, "defaultRoutes"), nx);
function v3(t, e) {
  const i = t.options.ticks, a = y3(t), o = Math.min(i.maxTicksLimit || a, a), f = i.major.enabled ? x3(e) : [], u = f.length, h = f[0], m = f[u - 1], v = [];
  if (u > o)
    return S3(e, v, f, u / o), v;
  const b = b3(f, e, o);
  if (u > 0) {
    let S, C;
    const E = u > 1 ? Math.round((m - h) / (u - 1)) : null;
    for (jb(e, v, b, sn(E) ? 0 : h - E, h), S = 0, C = u - 1; S < C; S++)
      jb(e, v, b, f[S], f[S + 1]);
    return jb(e, v, b, m, sn(E) ? e.length : m + E), v;
  }
  return jb(e, v, b), v;
}
function y3(t) {
  const e = t.options.offset, i = t._tickSize(), a = t._length / i + (e ? 0 : 1), o = t._maxLength / i;
  return Math.floor(Math.min(a, o));
}
function b3(t, e, i) {
  const a = _3(t), o = e.length / i;
  if (!a)
    return Math.max(o, 1);
  const f = cI(a);
  for (let u = 0, h = f.length - 1; u < h; u++) {
    const m = f[u];
    if (m > o)
      return m;
  }
  return Math.max(o, 1);
}
function x3(t) {
  const e = [];
  let i, a;
  for (i = 0, a = t.length; i < a; i++)
    t[i].major && e.push(i);
  return e;
}
function S3(t, e, i, a) {
  let o = 0, f = i[0], u;
  for (a = Math.ceil(a), u = 0; u < t.length; u++)
    u === f && (e.push(t[u]), o++, f = i[o * a]);
}
function jb(t, e, i, a, o) {
  const f = zt(a, 0), u = Math.min(zt(o, t.length), t.length);
  let h = 0, m, v, b;
  for (i = Math.ceil(i), o && (m = o - a, i = m / Math.floor(m / i)), b = f; b < 0; )
    h++, b = Math.round(f + h * i);
  for (v = Math.max(f, 0); v < u; v++)
    v === b && (e.push(t[v]), h++, b = Math.round(f + h * i));
}
function _3(t) {
  const e = t.length;
  let i, a;
  if (e < 2)
    return !1;
  for (a = t[0], i = 1; i < e; ++i)
    if (t[i] - t[i - 1] !== a)
      return !1;
  return a;
}
const C3 = (t) => t === "left" ? "right" : t === "right" ? "left" : t, nA = (t, e, i) => e === "top" || e === "left" ? t[e] + i : t[e] - i, iA = (t, e) => Math.min(e || t, t);
function rA(t, e) {
  const i = [], a = t.length / e, o = t.length;
  let f = 0;
  for (; f < o; f += a)
    i.push(t[Math.floor(f)]);
  return i;
}
function w3(t, e, i) {
  const a = t.ticks.length, o = Math.min(e, a - 1), f = t._startPixel, u = t._endPixel, h = 1e-6;
  let m = t.getPixelForTick(o), v;
  if (!(i && (a === 1 ? v = Math.max(m - f, u - m) : e === 0 ? v = (t.getPixelForTick(1) - m) / 2 : v = (m - t.getPixelForTick(o - 1)) / 2, m += o < e ? v : -v, m < f - h || m > u + h)))
    return m;
}
function T3(t, e) {
  xn(t, (i) => {
    const a = i.gc, o = a.length / 2;
    let f;
    if (o > e) {
      for (f = 0; f < o; ++f)
        delete i.data[a[f]];
      a.splice(0, o);
    }
  });
}
function Bg(t) {
  return t.drawTicks ? t.tickLength : 0;
}
function aA(t, e) {
  if (!t.display)
    return 0;
  const i = Yi(t.font, e), a = jr(t.padding);
  return (Kn(t.text) ? t.text.length : 1) * i.lineHeight + a.height;
}
function E3(t, e) {
  return ac(t, {
    scale: e,
    type: "scale"
  });
}
function R3(t, e, i) {
  return ac(t, {
    tick: i,
    index: e,
    type: "tick"
  });
}
function D3(t, e, i) {
  let a = ME(t);
  return (i && e !== "right" || !i && e === "right") && (a = C3(a)), a;
}
function k3(t, e, i, a) {
  const { top: o, left: f, bottom: u, right: h, chart: m } = t, { chartArea: v, scales: b } = m;
  let S = 0, C, E, D;
  const M = u - o, A = h - f;
  if (t.isHorizontal()) {
    if (E = Nr(a, f, h), Kt(i)) {
      const P = Object.keys(i)[0], N = i[P];
      D = b[P].getPixelForValue(N) + M - e;
    } else i === "center" ? D = (v.bottom + v.top) / 2 + M - e : D = nA(t, i, e);
    C = h - f;
  } else {
    if (Kt(i)) {
      const P = Object.keys(i)[0], N = i[P];
      E = b[P].getPixelForValue(N) - A + e;
    } else i === "center" ? E = (v.left + v.right) / 2 - A + e : E = nA(t, i, e);
    D = Nr(a, u, o), S = i === "left" ? -Ci : Ci;
  }
  return {
    titleX: E,
    titleY: D,
    maxWidth: C,
    rotation: S
  };
}
class Kf extends ql {
  constructor(e) {
    super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(e) {
    this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
  }
  parse(e, i) {
    return e;
  }
  getUserBounds() {
    let { _userMin: e, _userMax: i, _suggestedMin: a, _suggestedMax: o } = this;
    return e = ja(e, Number.POSITIVE_INFINITY), i = ja(i, Number.NEGATIVE_INFINITY), a = ja(a, Number.POSITIVE_INFINITY), o = ja(o, Number.NEGATIVE_INFINITY), {
      min: ja(e, a),
      max: ja(i, o),
      minDefined: gi(e),
      maxDefined: gi(i)
    };
  }
  getMinMax(e) {
    let { min: i, max: a, minDefined: o, maxDefined: f } = this.getUserBounds(), u;
    if (o && f)
      return {
        min: i,
        max: a
      };
    const h = this.getMatchingVisibleMetas();
    for (let m = 0, v = h.length; m < v; ++m)
      u = h[m].controller.getMinMax(this, e), o || (i = Math.min(i, u.min)), f || (a = Math.max(a, u.max));
    return i = f && i > a ? a : i, a = o && i > a ? i : a, {
      min: ja(i, ja(a, i)),
      max: ja(a, ja(i, a))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const e = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
  }
  getLabelItems(e = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(e));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    Nn(this.options.beforeUpdate, [
      this
    ]);
  }
  update(e, i, a) {
    const { beginAtZero: o, grace: f, ticks: u } = this.options, h = u.sampleSize;
    this.beforeUpdate(), this.maxWidth = e, this.maxHeight = i, this._margins = a = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, a), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + a.left + a.right : this.height + a.top + a.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = VI(this, f, o), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const m = h < this.ticks.length;
    this._convertTicksToLabels(m ? rA(this.ticks, h) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), u.display && (u.autoSkip || u.source === "auto") && (this.ticks = v3(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), m && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let e = this.options.reverse, i, a;
    this.isHorizontal() ? (i = this.left, a = this.right) : (i = this.top, a = this.bottom, e = !e), this._startPixel = i, this._endPixel = a, this._reversePixels = e, this._length = a - i, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    Nn(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    Nn(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    Nn(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(e) {
    this.chart.notifyPlugins(e, this.getContext()), Nn(this.options[e], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    Nn(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(e) {
    const i = this.options.ticks;
    let a, o, f;
    for (a = 0, o = e.length; a < o; a++)
      f = e[a], f.label = Nn(i.callback, [
        f.value,
        a,
        e
      ], this);
  }
  afterTickToLabelConversion() {
    Nn(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    Nn(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const e = this.options, i = e.ticks, a = iA(this.ticks.length, e.ticks.maxTicksLimit), o = i.minRotation || 0, f = i.maxRotation;
    let u = o, h, m, v;
    if (!this._isVisible() || !i.display || o >= f || a <= 1 || !this.isHorizontal()) {
      this.labelRotation = o;
      return;
    }
    const b = this._getLabelSizes(), S = b.widest.width, C = b.highest.height, E = Zi(this.chart.width - S, 0, this.maxWidth);
    h = e.offset ? this.maxWidth / a : E / (a - 1), S + 6 > h && (h = E / (a - (e.offset ? 0.5 : 1)), m = this.maxHeight - Bg(e.grid) - i.padding - aA(e.title, this.chart.options.font), v = Math.sqrt(S * S + C * C), u = DE(Math.min(Math.asin(Zi((b.highest.height + 6) / h, -1, 1)), Math.asin(Zi(m / v, -1, 1)) - Math.asin(Zi(C / v, -1, 1)))), u = Math.max(o, Math.min(f, u))), this.labelRotation = u;
  }
  afterCalculateLabelRotation() {
    Nn(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    Nn(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const e = {
      width: 0,
      height: 0
    }, { chart: i, options: { ticks: a, title: o, grid: f } } = this, u = this._isVisible(), h = this.isHorizontal();
    if (u) {
      const m = aA(o, i.options.font);
      if (h ? (e.width = this.maxWidth, e.height = Bg(f) + m) : (e.height = this.maxHeight, e.width = Bg(f) + m), a.display && this.ticks.length) {
        const { first: v, last: b, widest: S, highest: C } = this._getLabelSizes(), E = a.padding * 2, D = Gs(this.labelRotation), M = Math.cos(D), A = Math.sin(D);
        if (h) {
          const P = a.mirror ? 0 : A * S.width + M * C.height;
          e.height = Math.min(this.maxHeight, e.height + P + E);
        } else {
          const P = a.mirror ? 0 : M * S.width + A * C.height;
          e.width = Math.min(this.maxWidth, e.width + P + E);
        }
        this._calculatePadding(v, b, A, M);
      }
    }
    this._handleMargins(), h ? (this.width = this._length = i.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = i.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(e, i, a, o) {
    const { ticks: { align: f, padding: u }, position: h } = this.options, m = this.labelRotation !== 0, v = h !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const b = this.getPixelForTick(0) - this.left, S = this.right - this.getPixelForTick(this.ticks.length - 1);
      let C = 0, E = 0;
      m ? v ? (C = o * e.width, E = a * i.height) : (C = a * e.height, E = o * i.width) : f === "start" ? E = i.width : f === "end" ? C = e.width : f !== "inner" && (C = e.width / 2, E = i.width / 2), this.paddingLeft = Math.max((C - b + u) * this.width / (this.width - b), 0), this.paddingRight = Math.max((E - S + u) * this.width / (this.width - S), 0);
    } else {
      let b = i.height / 2, S = e.height / 2;
      f === "start" ? (b = 0, S = e.height) : f === "end" && (b = i.height, S = 0), this.paddingTop = b + u, this.paddingBottom = S + u;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    Nn(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: e, position: i } = this.options;
    return i === "top" || i === "bottom" || e === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(e) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(e);
    let i, a;
    for (i = 0, a = e.length; i < a; i++)
      sn(e[i].label) && (e.splice(i, 1), a--, i--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let e = this._labelSizes;
    if (!e) {
      const i = this.options.ticks.sampleSize;
      let a = this.ticks;
      i < a.length && (a = rA(a, i)), this._labelSizes = e = this._computeLabelSizes(a, a.length, this.options.ticks.maxTicksLimit);
    }
    return e;
  }
  _computeLabelSizes(e, i, a) {
    const { ctx: o, _longestTextCache: f } = this, u = [], h = [], m = Math.floor(i / iA(i, a));
    let v = 0, b = 0, S, C, E, D, M, A, P, N, F, B, V;
    for (S = 0; S < i; S += m) {
      if (D = e[S].label, M = this._resolveTickFontOptions(S), o.font = A = M.string, P = f[A] = f[A] || {
        data: {},
        gc: []
      }, N = M.lineHeight, F = B = 0, !sn(D) && !Kn(D))
        F = _x(o, P.data, P.gc, F, D), B = N;
      else if (Kn(D))
        for (C = 0, E = D.length; C < E; ++C)
          V = D[C], !sn(V) && !Kn(V) && (F = _x(o, P.data, P.gc, F, V), B += N);
      u.push(F), h.push(B), v = Math.max(F, v), b = Math.max(B, b);
    }
    T3(f, i);
    const G = u.indexOf(v), Y = h.indexOf(b), K = (ae) => ({
      width: u[ae] || 0,
      height: h[ae] || 0
    });
    return {
      first: K(0),
      last: K(i - 1),
      widest: K(G),
      highest: K(Y),
      widths: u,
      heights: h
    };
  }
  getLabelForValue(e) {
    return e;
  }
  getPixelForValue(e, i) {
    return NaN;
  }
  getValueForPixel(e) {
  }
  getPixelForTick(e) {
    const i = this.ticks;
    return e < 0 || e > i.length - 1 ? null : this.getPixelForValue(i[e].value);
  }
  getPixelForDecimal(e) {
    this._reversePixels && (e = 1 - e);
    const i = this._startPixel + e * this._length;
    return hI(this._alignToPixels ? kf(this.chart, i, 0) : i);
  }
  getDecimalForPixel(e) {
    const i = (e - this._startPixel) / this._length;
    return this._reversePixels ? 1 - i : i;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: e, max: i } = this;
    return e < 0 && i < 0 ? i : e > 0 && i > 0 ? e : 0;
  }
  getContext(e) {
    const i = this.ticks || [];
    if (e >= 0 && e < i.length) {
      const a = i[e];
      return a.$context || (a.$context = R3(this.getContext(), e, a));
    }
    return this.$context || (this.$context = E3(this.chart.getContext(), this));
  }
  _tickSize() {
    const e = this.options.ticks, i = Gs(this.labelRotation), a = Math.abs(Math.cos(i)), o = Math.abs(Math.sin(i)), f = this._getLabelSizes(), u = e.autoSkipPadding || 0, h = f ? f.widest.width + u : 0, m = f ? f.highest.height + u : 0;
    return this.isHorizontal() ? m * a > h * o ? h / a : m / o : m * o < h * a ? m / a : h / o;
  }
  _isVisible() {
    const e = this.options.display;
    return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(e) {
    const i = this.axis, a = this.chart, o = this.options, { grid: f, position: u, border: h } = o, m = f.offset, v = this.isHorizontal(), S = this.ticks.length + (m ? 1 : 0), C = Bg(f), E = [], D = h.setContext(this.getContext()), M = D.display ? D.width : 0, A = M / 2, P = function(Se) {
      return kf(a, Se, M);
    };
    let N, F, B, V, G, Y, K, ae, ie, ee, oe, se;
    if (u === "top")
      N = P(this.bottom), Y = this.bottom - C, ae = N - A, ee = P(e.top) + A, se = e.bottom;
    else if (u === "bottom")
      N = P(this.top), ee = e.top, se = P(e.bottom) - A, Y = N + A, ae = this.top + C;
    else if (u === "left")
      N = P(this.right), G = this.right - C, K = N - A, ie = P(e.left) + A, oe = e.right;
    else if (u === "right")
      N = P(this.left), ie = e.left, oe = P(e.right) - A, G = N + A, K = this.left + C;
    else if (i === "x") {
      if (u === "center")
        N = P((e.top + e.bottom) / 2 + 0.5);
      else if (Kt(u)) {
        const Se = Object.keys(u)[0], Oe = u[Se];
        N = P(this.chart.scales[Se].getPixelForValue(Oe));
      }
      ee = e.top, se = e.bottom, Y = N + A, ae = Y + C;
    } else if (i === "y") {
      if (u === "center")
        N = P((e.left + e.right) / 2);
      else if (Kt(u)) {
        const Se = Object.keys(u)[0], Oe = u[Se];
        N = P(this.chart.scales[Se].getPixelForValue(Oe));
      }
      G = N - A, K = G - C, ie = e.left, oe = e.right;
    }
    const Pe = zt(o.ticks.maxTicksLimit, S), Te = Math.max(1, Math.ceil(S / Pe));
    for (F = 0; F < S; F += Te) {
      const Se = this.getContext(F), Oe = f.setContext(Se), re = h.setContext(Se), ge = Oe.lineWidth, me = Oe.color, fe = re.dash || [], pe = re.dashOffset, Ae = Oe.tickWidth, Ne = Oe.tickColor, de = Oe.tickBorderDash || [], ze = Oe.tickBorderDashOffset;
      B = w3(this, F, m), B !== void 0 && (V = kf(a, B, ge), v ? G = K = ie = oe = V : Y = ae = ee = se = V, E.push({
        tx1: G,
        ty1: Y,
        tx2: K,
        ty2: ae,
        x1: ie,
        y1: ee,
        x2: oe,
        y2: se,
        width: ge,
        color: me,
        borderDash: fe,
        borderDashOffset: pe,
        tickWidth: Ae,
        tickColor: Ne,
        tickBorderDash: de,
        tickBorderDashOffset: ze
      }));
    }
    return this._ticksLength = S, this._borderValue = N, E;
  }
  _computeLabelItems(e) {
    const i = this.axis, a = this.options, { position: o, ticks: f } = a, u = this.isHorizontal(), h = this.ticks, { align: m, crossAlign: v, padding: b, mirror: S } = f, C = Bg(a.grid), E = C + b, D = S ? -b : E, M = -Gs(this.labelRotation), A = [];
    let P, N, F, B, V, G, Y, K, ae, ie, ee, oe, se = "middle";
    if (o === "top")
      G = this.bottom - D, Y = this._getXAxisLabelAlignment();
    else if (o === "bottom")
      G = this.top + D, Y = this._getXAxisLabelAlignment();
    else if (o === "left") {
      const Te = this._getYAxisLabelAlignment(C);
      Y = Te.textAlign, V = Te.x;
    } else if (o === "right") {
      const Te = this._getYAxisLabelAlignment(C);
      Y = Te.textAlign, V = Te.x;
    } else if (i === "x") {
      if (o === "center")
        G = (e.top + e.bottom) / 2 + E;
      else if (Kt(o)) {
        const Te = Object.keys(o)[0], Se = o[Te];
        G = this.chart.scales[Te].getPixelForValue(Se) + E;
      }
      Y = this._getXAxisLabelAlignment();
    } else if (i === "y") {
      if (o === "center")
        V = (e.left + e.right) / 2 - E;
      else if (Kt(o)) {
        const Te = Object.keys(o)[0], Se = o[Te];
        V = this.chart.scales[Te].getPixelForValue(Se);
      }
      Y = this._getYAxisLabelAlignment(C).textAlign;
    }
    i === "y" && (m === "start" ? se = "top" : m === "end" && (se = "bottom"));
    const Pe = this._getLabelSizes();
    for (P = 0, N = h.length; P < N; ++P) {
      F = h[P], B = F.label;
      const Te = f.setContext(this.getContext(P));
      K = this.getPixelForTick(P) + f.labelOffset, ae = this._resolveTickFontOptions(P), ie = ae.lineHeight, ee = Kn(B) ? B.length : 1;
      const Se = ee / 2, Oe = Te.color, re = Te.textStrokeColor, ge = Te.textStrokeWidth;
      let me = Y;
      u ? (V = K, Y === "inner" && (P === N - 1 ? me = this.options.reverse ? "left" : "right" : P === 0 ? me = this.options.reverse ? "right" : "left" : me = "center"), o === "top" ? v === "near" || M !== 0 ? oe = -ee * ie + ie / 2 : v === "center" ? oe = -Pe.highest.height / 2 - Se * ie + ie : oe = -Pe.highest.height + ie / 2 : v === "near" || M !== 0 ? oe = ie / 2 : v === "center" ? oe = Pe.highest.height / 2 - Se * ie : oe = Pe.highest.height - ee * ie, S && (oe *= -1), M !== 0 && !Te.showLabelBackdrop && (V += ie / 2 * Math.sin(M))) : (G = K, oe = (1 - ee) * ie / 2);
      let fe;
      if (Te.showLabelBackdrop) {
        const pe = jr(Te.backdropPadding), Ae = Pe.heights[P], Ne = Pe.widths[P];
        let de = oe - pe.top, ze = 0 - pe.left;
        switch (se) {
          case "middle":
            de -= Ae / 2;
            break;
          case "bottom":
            de -= Ae;
            break;
        }
        switch (Y) {
          case "center":
            ze -= Ne / 2;
            break;
          case "right":
            ze -= Ne;
            break;
          case "inner":
            P === N - 1 ? ze -= Ne : P > 0 && (ze -= Ne / 2);
            break;
        }
        fe = {
          left: ze,
          top: de,
          width: Ne + pe.width,
          height: Ae + pe.height,
          color: Te.backdropColor
        };
      }
      A.push({
        label: B,
        font: ae,
        textOffset: oe,
        options: {
          rotation: M,
          color: Oe,
          strokeColor: re,
          strokeWidth: ge,
          textAlign: me,
          textBaseline: se,
          translation: [
            V,
            G
          ],
          backdrop: fe
        }
      });
    }
    return A;
  }
  _getXAxisLabelAlignment() {
    const { position: e, ticks: i } = this.options;
    if (-Gs(this.labelRotation))
      return e === "top" ? "left" : "right";
    let o = "center";
    return i.align === "start" ? o = "left" : i.align === "end" ? o = "right" : i.align === "inner" && (o = "inner"), o;
  }
  _getYAxisLabelAlignment(e) {
    const { position: i, ticks: { crossAlign: a, mirror: o, padding: f } } = this.options, u = this._getLabelSizes(), h = e + f, m = u.widest.width;
    let v, b;
    return i === "left" ? o ? (b = this.right + f, a === "near" ? v = "left" : a === "center" ? (v = "center", b += m / 2) : (v = "right", b += m)) : (b = this.right - h, a === "near" ? v = "right" : a === "center" ? (v = "center", b -= m / 2) : (v = "left", b = this.left)) : i === "right" ? o ? (b = this.left + f, a === "near" ? v = "right" : a === "center" ? (v = "center", b -= m / 2) : (v = "left", b -= m)) : (b = this.left + h, a === "near" ? v = "left" : a === "center" ? (v = "center", b += m / 2) : (v = "right", b = this.right)) : v = "right", {
      textAlign: v,
      x: b
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const e = this.chart, i = this.options.position;
    if (i === "left" || i === "right")
      return {
        top: 0,
        left: this.left,
        bottom: e.height,
        right: this.right
      };
    if (i === "top" || i === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: e.width
      };
  }
  drawBackground() {
    const { ctx: e, options: { backgroundColor: i }, left: a, top: o, width: f, height: u } = this;
    i && (e.save(), e.fillStyle = i, e.fillRect(a, o, f, u), e.restore());
  }
  getLineWidthForValue(e) {
    const i = this.options.grid;
    if (!this._isVisible() || !i.display)
      return 0;
    const o = this.ticks.findIndex((f) => f.value === e);
    return o >= 0 ? i.setContext(this.getContext(o)).lineWidth : 0;
  }
  drawGrid(e) {
    const i = this.options.grid, a = this.ctx, o = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
    let f, u;
    const h = (m, v, b) => {
      !b.width || !b.color || (a.save(), a.lineWidth = b.width, a.strokeStyle = b.color, a.setLineDash(b.borderDash || []), a.lineDashOffset = b.borderDashOffset, a.beginPath(), a.moveTo(m.x, m.y), a.lineTo(v.x, v.y), a.stroke(), a.restore());
    };
    if (i.display)
      for (f = 0, u = o.length; f < u; ++f) {
        const m = o[f];
        i.drawOnChartArea && h({
          x: m.x1,
          y: m.y1
        }, {
          x: m.x2,
          y: m.y2
        }, m), i.drawTicks && h({
          x: m.tx1,
          y: m.ty1
        }, {
          x: m.tx2,
          y: m.ty2
        }, {
          color: m.tickColor,
          width: m.tickWidth,
          borderDash: m.tickBorderDash,
          borderDashOffset: m.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: e, ctx: i, options: { border: a, grid: o } } = this, f = a.setContext(this.getContext()), u = a.display ? f.width : 0;
    if (!u)
      return;
    const h = o.setContext(this.getContext(0)).lineWidth, m = this._borderValue;
    let v, b, S, C;
    this.isHorizontal() ? (v = kf(e, this.left, u) - u / 2, b = kf(e, this.right, h) + h / 2, S = C = m) : (S = kf(e, this.top, u) - u / 2, C = kf(e, this.bottom, h) + h / 2, v = b = m), i.save(), i.lineWidth = f.width, i.strokeStyle = f.color, i.beginPath(), i.moveTo(v, S), i.lineTo(b, C), i.stroke(), i.restore();
  }
  drawLabels(e) {
    if (!this.options.ticks.display)
      return;
    const a = this.ctx, o = this._computeLabelArea();
    o && Gx(a, o);
    const f = this.getLabelItems(e);
    for (const u of f) {
      const h = u.options, m = u.font, v = u.label, b = u.textOffset;
      Yf(a, v, 0, b, m, h);
    }
    o && Kx(a);
  }
  drawTitle() {
    const { ctx: e, options: { position: i, title: a, reverse: o } } = this;
    if (!a.display)
      return;
    const f = Yi(a.font), u = jr(a.padding), h = a.align;
    let m = f.lineHeight / 2;
    i === "bottom" || i === "center" || Kt(i) ? (m += u.bottom, Kn(a.text) && (m += f.lineHeight * (a.text.length - 1))) : m += u.top;
    const { titleX: v, titleY: b, maxWidth: S, rotation: C } = k3(this, m, i, h);
    Yf(e, a.text, 0, 0, f, {
      color: a.color,
      maxWidth: S,
      rotation: C,
      textAlign: D3(h, i, o),
      textBaseline: "middle",
      translation: [
        v,
        b
      ]
    });
  }
  draw(e) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
  }
  _layers() {
    const e = this.options, i = e.ticks && e.ticks.z || 0, a = zt(e.grid && e.grid.z, -1), o = zt(e.border && e.border.z, 0);
    return !this._isVisible() || this.draw !== Kf.prototype.draw ? [
      {
        z: i,
        draw: (f) => {
          this.draw(f);
        }
      }
    ] : [
      {
        z: a,
        draw: (f) => {
          this.drawBackground(), this.drawGrid(f), this.drawTitle();
        }
      },
      {
        z: o,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: i,
        draw: (f) => {
          this.drawLabels(f);
        }
      }
    ];
  }
  getMatchingVisibleMetas(e) {
    const i = this.chart.getSortedVisibleDatasetMetas(), a = this.axis + "AxisID", o = [];
    let f, u;
    for (f = 0, u = i.length; f < u; ++f) {
      const h = i[f];
      h[a] === this.id && (!e || h.type === e) && o.push(h);
    }
    return o;
  }
  _resolveTickFontOptions(e) {
    const i = this.options.ticks.setContext(this.getContext(e));
    return Yi(i.font);
  }
  _maxDigits() {
    const e = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / e;
  }
}
class Bb {
  constructor(e, i, a) {
    this.type = e, this.scope = i, this.override = a, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(e) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
  }
  register(e) {
    const i = Object.getPrototypeOf(e);
    let a;
    O3(i) && (a = this.register(i));
    const o = this.items, f = e.id, u = this.scope + "." + f;
    if (!f)
      throw new Error("class does not have id: " + e);
    return f in o || (o[f] = e, M3(e, u, a), this.override && Qn.override(e.id, e.overrides)), u;
  }
  get(e) {
    return this.items[e];
  }
  unregister(e) {
    const i = this.items, a = e.id, o = this.scope;
    a in i && delete i[a], o && a in Qn[o] && (delete Qn[o][a], this.override && delete Wf[a]);
  }
}
function M3(t, e, i) {
  const a = lv(/* @__PURE__ */ Object.create(null), [
    i ? Qn.get(i) : {},
    Qn.get(e),
    t.defaults
  ]);
  Qn.set(e, a), t.defaultRoutes && A3(e, t.defaultRoutes), t.descriptors && Qn.describe(e, t.descriptors);
}
function A3(t, e) {
  Object.keys(e).forEach((i) => {
    const a = i.split("."), o = a.pop(), f = [
      t
    ].concat(a).join("."), u = e[i].split("."), h = u.pop(), m = u.join(".");
    Qn.route(f, o, m, h);
  });
}
function O3(t) {
  return "id" in t && "defaults" in t;
}
class P3 {
  constructor() {
    this.controllers = new Bb(Ks, "datasets", !0), this.elements = new Bb(ql, "elements"), this.plugins = new Bb(Object, "plugins"), this.scales = new Bb(Kf, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...e) {
    this._each("register", e);
  }
  remove(...e) {
    this._each("unregister", e);
  }
  addControllers(...e) {
    this._each("register", e, this.controllers);
  }
  addElements(...e) {
    this._each("register", e, this.elements);
  }
  addPlugins(...e) {
    this._each("register", e, this.plugins);
  }
  addScales(...e) {
    this._each("register", e, this.scales);
  }
  getController(e) {
    return this._get(e, this.controllers, "controller");
  }
  getElement(e) {
    return this._get(e, this.elements, "element");
  }
  getPlugin(e) {
    return this._get(e, this.plugins, "plugin");
  }
  getScale(e) {
    return this._get(e, this.scales, "scale");
  }
  removeControllers(...e) {
    this._each("unregister", e, this.controllers);
  }
  removeElements(...e) {
    this._each("unregister", e, this.elements);
  }
  removePlugins(...e) {
    this._each("unregister", e, this.plugins);
  }
  removeScales(...e) {
    this._each("unregister", e, this.scales);
  }
  _each(e, i, a) {
    [
      ...i
    ].forEach((o) => {
      const f = a || this._getRegistryForType(o);
      a || f.isForType(o) || f === this.plugins && o.id ? this._exec(e, f, o) : xn(o, (u) => {
        const h = a || this._getRegistryForType(u);
        this._exec(e, h, u);
      });
    });
  }
  _exec(e, i, a) {
    const o = RE(e);
    Nn(a["before" + o], [], a), i[e](a), Nn(a["after" + o], [], a);
  }
  _getRegistryForType(e) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const a = this._typedRegistries[i];
      if (a.isForType(e))
        return a;
    }
    return this.plugins;
  }
  _get(e, i, a) {
    const o = i.get(e);
    if (o === void 0)
      throw new Error('"' + e + '" is not a registered ' + a + ".");
    return o;
  }
}
var Po = /* @__PURE__ */ new P3();
class L3 {
  constructor() {
    this._init = [];
  }
  notify(e, i, a, o) {
    i === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install"));
    const f = o ? this._descriptors(e).filter(o) : this._descriptors(e), u = this._notify(f, e, i, a);
    return i === "afterDestroy" && (this._notify(f, e, "stop"), this._notify(this._init, e, "uninstall")), u;
  }
  _notify(e, i, a, o) {
    o = o || {};
    for (const f of e) {
      const u = f.plugin, h = u[a], m = [
        i,
        o,
        f.options
      ];
      if (Nn(h, m, u) === !1 && o.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    sn(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(e) {
    if (this._cache)
      return this._cache;
    const i = this._cache = this._createDescriptors(e);
    return this._notifyStateChanges(e), i;
  }
  _createDescriptors(e, i) {
    const a = e && e.config, o = zt(a.options && a.options.plugins, {}), f = N3(a);
    return o === !1 && !i ? [] : F3(e, f, o, i);
  }
  _notifyStateChanges(e) {
    const i = this._oldCache || [], a = this._cache, o = (f, u) => f.filter((h) => !u.some((m) => h.plugin.id === m.plugin.id));
    this._notify(o(i, a), e, "stop"), this._notify(o(a, i), e, "start");
  }
}
function N3(t) {
  const e = {}, i = [], a = Object.keys(Po.plugins.items);
  for (let f = 0; f < a.length; f++)
    i.push(Po.getPlugin(a[f]));
  const o = t.plugins || [];
  for (let f = 0; f < o.length; f++) {
    const u = o[f];
    i.indexOf(u) === -1 && (i.push(u), e[u.id] = !0);
  }
  return {
    plugins: i,
    localIds: e
  };
}
function z3(t, e) {
  return !e && t === !1 ? null : t === !0 ? {} : t;
}
function F3(t, { plugins: e, localIds: i }, a, o) {
  const f = [], u = t.getContext();
  for (const h of e) {
    const m = h.id, v = z3(a[m], o);
    v !== null && f.push({
      plugin: h,
      options: V3(t.config, {
        plugin: h,
        local: i[m]
      }, v, u)
    });
  }
  return f;
}
function V3(t, { plugin: e, local: i }, a, o) {
  const f = t.pluginScopeKeys(e), u = t.getOptionScopes(a, f);
  return i && e.defaults && u.push(e.defaults), t.createResolver(u, o, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function kT(t, e) {
  const i = Qn.datasets[t] || {};
  return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x";
}
function j3(t, e) {
  let i = t;
  return t === "_index_" ? i = e : t === "_value_" && (i = e === "x" ? "y" : "x"), i;
}
function B3(t, e) {
  return t === e ? "_index_" : "_value_";
}
function sA(t) {
  if (t === "x" || t === "y" || t === "r")
    return t;
}
function H3(t) {
  if (t === "top" || t === "bottom")
    return "x";
  if (t === "left" || t === "right")
    return "y";
}
function MT(t, ...e) {
  if (sA(t))
    return t;
  for (const i of e) {
    const a = i.axis || H3(i.position) || t.length > 1 && sA(t[0].toLowerCase());
    if (a)
      return a;
  }
  throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`);
}
function oA(t, e, i) {
  if (i[e + "AxisID"] === t)
    return {
      axis: e
    };
}
function U3(t, e) {
  if (e.data && e.data.datasets) {
    const i = e.data.datasets.filter((a) => a.xAxisID === t || a.yAxisID === t);
    if (i.length)
      return oA(t, "x", i[0]) || oA(t, "y", i[0]);
  }
  return {};
}
function I3(t, e) {
  const i = Wf[t.type] || {
    scales: {}
  }, a = e.scales || {}, o = kT(t.type, e), f = /* @__PURE__ */ Object.create(null);
  return Object.keys(a).forEach((u) => {
    const h = a[u];
    if (!Kt(h))
      return console.error(`Invalid scale configuration for scale: ${u}`);
    if (h._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${u}`);
    const m = MT(u, h, U3(u, t), Qn.scales[h.type]), v = B3(m, o), b = i.scales || {};
    f[u] = Zg(/* @__PURE__ */ Object.create(null), [
      {
        axis: m
      },
      h,
      b[m],
      b[v]
    ]);
  }), t.data.datasets.forEach((u) => {
    const h = u.type || t.type, m = u.indexAxis || kT(h, e), b = (Wf[h] || {}).scales || {};
    Object.keys(b).forEach((S) => {
      const C = j3(S, m), E = u[C + "AxisID"] || C;
      f[E] = f[E] || /* @__PURE__ */ Object.create(null), Zg(f[E], [
        {
          axis: C
        },
        a[E],
        b[S]
      ]);
    });
  }), Object.keys(f).forEach((u) => {
    const h = f[u];
    Zg(h, [
      Qn.scales[h.type],
      Qn.scale
    ]);
  }), f;
}
function NL(t) {
  const e = t.options || (t.options = {});
  e.plugins = zt(e.plugins, {}), e.scales = I3(t, e);
}
function zL(t) {
  return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t;
}
function $3(t) {
  return t = t || {}, t.data = zL(t.data), NL(t), t;
}
const lA = /* @__PURE__ */ new Map(), FL = /* @__PURE__ */ new Set();
function Hb(t, e) {
  let i = lA.get(t);
  return i || (i = e(), lA.set(t, i), FL.add(i)), i;
}
const Hg = (t, e, i) => {
  const a = ec(e, i);
  a !== void 0 && t.add(a);
};
class W3 {
  constructor(e) {
    this._config = $3(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(e) {
    this._config.type = e;
  }
  get data() {
    return this._config.data;
  }
  set data(e) {
    this._config.data = zL(e);
  }
  get options() {
    return this._config.options;
  }
  set options(e) {
    this._config.options = e;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const e = this._config;
    this.clearCache(), NL(e);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(e) {
    return Hb(e, () => [
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(e, i) {
    return Hb(`${e}.transition.${i}`, () => [
      [
        `datasets.${e}.transitions.${i}`,
        `transitions.${i}`
      ],
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(e, i) {
    return Hb(`${e}-${i}`, () => [
      [
        `datasets.${e}.elements.${i}`,
        `datasets.${e}`,
        `elements.${i}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(e) {
    const i = e.id, a = this.type;
    return Hb(`${a}-plugin-${i}`, () => [
      [
        `plugins.${i}`,
        ...e.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(e, i) {
    const a = this._scopeCache;
    let o = a.get(e);
    return (!o || i) && (o = /* @__PURE__ */ new Map(), a.set(e, o)), o;
  }
  getOptionScopes(e, i, a) {
    const { options: o, type: f } = this, u = this._cachedScopes(e, a), h = u.get(i);
    if (h)
      return h;
    const m = /* @__PURE__ */ new Set();
    i.forEach((b) => {
      e && (m.add(e), b.forEach((S) => Hg(m, e, S))), b.forEach((S) => Hg(m, o, S)), b.forEach((S) => Hg(m, Wf[f] || {}, S)), b.forEach((S) => Hg(m, Qn, S)), b.forEach((S) => Hg(m, ET, S));
    });
    const v = Array.from(m);
    return v.length === 0 && v.push(/* @__PURE__ */ Object.create(null)), FL.has(i) && u.set(i, v), v;
  }
  chartOptionScopes() {
    const { options: e, type: i } = this;
    return [
      e,
      Wf[i] || {},
      Qn.datasets[i] || {},
      {
        type: i
      },
      Qn,
      ET
    ];
  }
  resolveNamedOptions(e, i, a, o = [
    ""
  ]) {
    const f = {
      $shared: !0
    }, { resolver: u, subPrefixes: h } = uA(this._resolverCache, e, o);
    let m = u;
    if (G3(u, i)) {
      f.$shared = !1, a = tc(a) ? a() : a;
      const v = this.createResolver(e, a, h);
      m = ap(u, a, v);
    }
    for (const v of i)
      f[v] = m[v];
    return f;
  }
  createResolver(e, i, a = [
    ""
  ], o) {
    const { resolver: f } = uA(this._resolverCache, e, a);
    return Kt(i) ? ap(f, i, void 0, o) : f;
  }
}
function uA(t, e, i) {
  let a = t.get(e);
  a || (a = /* @__PURE__ */ new Map(), t.set(e, a));
  const o = i.join();
  let f = a.get(o);
  return f || (f = {
    resolver: PE(e, i),
    subPrefixes: i.filter((h) => !h.toLowerCase().includes("hover"))
  }, a.set(o, f)), f;
}
const Y3 = (t) => Kt(t) && Object.getOwnPropertyNames(t).some((e) => tc(t[e]));
function G3(t, e) {
  const { isScriptable: i, isIndexable: a } = gL(t);
  for (const o of e) {
    const f = i(o), u = a(o), h = (u || f) && t[o];
    if (f && (tc(h) || Y3(h)) || u && Kn(h))
      return !0;
  }
  return !1;
}
var K3 = "4.4.5";
const X3 = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function cA(t, e) {
  return t === "top" || t === "bottom" || X3.indexOf(t) === -1 && e === "x";
}
function fA(t, e) {
  return function(i, a) {
    return i[t] === a[t] ? i[e] - a[e] : i[t] - a[t];
  };
}
function dA(t) {
  const e = t.chart, i = e.options.animation;
  e.notifyPlugins("afterRender"), Nn(i && i.onComplete, [
    t
  ], e);
}
function Q3(t) {
  const e = t.chart, i = e.options.animation;
  Nn(i && i.onProgress, [
    t
  ], e);
}
function VL(t) {
  return zE() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;
}
const ux = {}, hA = (t) => {
  const e = VL(t);
  return Object.values(ux).filter((i) => i.canvas === e).pop();
};
function q3(t, e, i) {
  const a = Object.keys(t);
  for (const o of a) {
    const f = +o;
    if (f >= e) {
      const u = t[o];
      delete t[o], (i > 0 || f > e) && (t[f + i] = u);
    }
  }
}
function Z3(t, e, i, a) {
  return !i || t.type === "mouseout" ? null : a ? e : t;
}
function Ub(t, e, i) {
  return t.options.clip ? t[i] : e[i];
}
function J3(t, e) {
  const { xScale: i, yScale: a } = t;
  return i && a ? {
    left: Ub(i, e, "left"),
    right: Ub(i, e, "right"),
    top: Ub(a, e, "top"),
    bottom: Ub(a, e, "bottom")
  } : e;
}
class Lo {
  static register(...e) {
    Po.add(...e), pA();
  }
  static unregister(...e) {
    Po.remove(...e), pA();
  }
  constructor(e, i) {
    const a = this.config = new W3(i), o = VL(e), f = hA(o);
    if (f)
      throw new Error("Canvas is already in use. Chart with ID '" + f.id + "' must be destroyed before the canvas with ID '" + f.canvas.id + "' can be reused.");
    const u = a.createResolver(a.chartOptionScopes(), this.getContext());
    this.platform = new (a.platform || g3(o))(), this.platform.updateConfig(a);
    const h = this.platform.acquireContext(o, u.aspectRatio), m = h && h.canvas, v = m && m.height, b = m && m.width;
    if (this.id = tI(), this.ctx = h, this.canvas = m, this.width = b, this.height = v, this._options = u, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new L3(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = vI((S) => this.update(S), u.resizeDelay || 0), this._dataChanges = [], ux[this.id] = this, !h || !m) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Fl.listen(this, "complete", dA), Fl.listen(this, "progress", Q3), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: e, maintainAspectRatio: i }, width: a, height: o, _aspectRatio: f } = this;
    return sn(e) ? i && f ? f : o ? a / o : null : e;
  }
  get data() {
    return this.config.data;
  }
  set data(e) {
    this.config.data = e;
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this.config.options = e;
  }
  get registry() {
    return Po;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : zM(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return PM(this.canvas, this.ctx), this;
  }
  stop() {
    return Fl.stop(this), this;
  }
  resize(e, i) {
    Fl.running(this) ? this._resizeBeforeDraw = {
      width: e,
      height: i
    } : this._resize(e, i);
  }
  _resize(e, i) {
    const a = this.options, o = this.canvas, f = a.maintainAspectRatio && this.aspectRatio, u = this.platform.getMaximumSize(o, e, i, f), h = a.devicePixelRatio || this.platform.getDevicePixelRatio(), m = this.width ? "resize" : "attach";
    this.width = u.width, this.height = u.height, this._aspectRatio = this.aspectRatio, zM(this, h, !0) && (this.notifyPlugins("resize", {
      size: u
    }), Nn(a.onResize, [
      this,
      u
    ], this), this.attached && this._doResize(m) && this.render());
  }
  ensureScalesHaveIDs() {
    const i = this.options.scales || {};
    xn(i, (a, o) => {
      a.id = o;
    });
  }
  buildOrUpdateScales() {
    const e = this.options, i = e.scales, a = this.scales, o = Object.keys(a).reduce((u, h) => (u[h] = !1, u), {});
    let f = [];
    i && (f = f.concat(Object.keys(i).map((u) => {
      const h = i[u], m = MT(u, h), v = m === "r", b = m === "x";
      return {
        options: h,
        dposition: v ? "chartArea" : b ? "bottom" : "left",
        dtype: v ? "radialLinear" : b ? "category" : "linear"
      };
    }))), xn(f, (u) => {
      const h = u.options, m = h.id, v = MT(m, h), b = zt(h.type, u.dtype);
      (h.position === void 0 || cA(h.position, v) !== cA(u.dposition)) && (h.position = u.dposition), o[m] = !0;
      let S = null;
      if (m in a && a[m].type === b)
        S = a[m];
      else {
        const C = Po.getScale(b);
        S = new C({
          id: m,
          type: b,
          ctx: this.ctx,
          chart: this
        }), a[S.id] = S;
      }
      S.init(h, e);
    }), xn(o, (u, h) => {
      u || delete a[h];
    }), xn(a, (u) => {
      Fr.configure(this, u, u.options), Fr.addBox(this, u);
    });
  }
  _updateMetasets() {
    const e = this._metasets, i = this.data.datasets.length, a = e.length;
    if (e.sort((o, f) => o.index - f.index), a > i) {
      for (let o = i; o < a; ++o)
        this._destroyDatasetMeta(o);
      e.splice(i, a - i);
    }
    this._sortedMetasets = e.slice(0).sort(fA("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: e, data: { datasets: i } } = this;
    e.length > i.length && delete this._stacks, e.forEach((a, o) => {
      i.filter((f) => f === a._dataset).length === 0 && this._destroyDatasetMeta(o);
    });
  }
  buildOrUpdateControllers() {
    const e = [], i = this.data.datasets;
    let a, o;
    for (this._removeUnreferencedMetasets(), a = 0, o = i.length; a < o; a++) {
      const f = i[a];
      let u = this.getDatasetMeta(a);
      const h = f.type || this.config.type;
      if (u.type && u.type !== h && (this._destroyDatasetMeta(a), u = this.getDatasetMeta(a)), u.type = h, u.indexAxis = f.indexAxis || kT(h, this.options), u.order = f.order || 0, u.index = a, u.label = "" + f.label, u.visible = this.isDatasetVisible(a), u.controller)
        u.controller.updateIndex(a), u.controller.linkScales();
      else {
        const m = Po.getController(h), { datasetElementType: v, dataElementType: b } = Qn.datasets[h];
        Object.assign(m, {
          dataElementType: Po.getElement(b),
          datasetElementType: v && Po.getElement(v)
        }), u.controller = new m(this, a), e.push(u.controller);
      }
    }
    return this._updateMetasets(), e;
  }
  _resetElements() {
    xn(this.data.datasets, (e, i) => {
      this.getDatasetMeta(i).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(e) {
    const i = this.config;
    i.update();
    const a = this._options = i.createResolver(i.chartOptionScopes(), this.getContext()), o = this._animationsDisabled = !a.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: e,
      cancelable: !0
    }) === !1)
      return;
    const f = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let u = 0;
    for (let v = 0, b = this.data.datasets.length; v < b; v++) {
      const { controller: S } = this.getDatasetMeta(v), C = !o && f.indexOf(S) === -1;
      S.buildOrUpdateElements(C), u = Math.max(+S.getMaxOverflow(), u);
    }
    u = this._minPadding = a.layout.autoPadding ? u : 0, this._updateLayout(u), o || xn(f, (v) => {
      v.reset();
    }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
      mode: e
    }), this._layers.sort(fA("z", "_idx"));
    const { _active: h, _lastEvent: m } = this;
    m ? this._eventHandler(m, !0) : h.length && this._updateHoverStyles(h, h, !0), this.render();
  }
  _updateScales() {
    xn(this.scales, (e) => {
      Fr.removeBox(this, e);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const e = this.options, i = new Set(Object.keys(this._listeners)), a = new Set(e.events);
    (!wM(i, a) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: e } = this, i = this._getUniformDataChanges() || [];
    for (const { method: a, start: o, count: f } of i) {
      const u = a === "_removeElements" ? -f : f;
      q3(e, o, u);
    }
  }
  _getUniformDataChanges() {
    const e = this._dataChanges;
    if (!e || !e.length)
      return;
    this._dataChanges = [];
    const i = this.data.datasets.length, a = (f) => new Set(e.filter((u) => u[0] === f).map((u, h) => h + "," + u.splice(1).join(","))), o = a(0);
    for (let f = 1; f < i; f++)
      if (!wM(o, a(f)))
        return;
    return Array.from(o).map((f) => f.split(",")).map((f) => ({
      method: f[1],
      start: +f[2],
      count: +f[3]
    }));
  }
  _updateLayout(e) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    Fr.update(this, this.width, this.height, e);
    const i = this.chartArea, a = i.width <= 0 || i.height <= 0;
    this._layers = [], xn(this.boxes, (o) => {
      a && o.position === "chartArea" || (o.configure && o.configure(), this._layers.push(...o._layers()));
    }, this), this._layers.forEach((o, f) => {
      o._idx = f;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(e) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: e,
      cancelable: !0
    }) !== !1) {
      for (let i = 0, a = this.data.datasets.length; i < a; ++i)
        this.getDatasetMeta(i).controller.configure();
      for (let i = 0, a = this.data.datasets.length; i < a; ++i)
        this._updateDataset(i, tc(e) ? e({
          datasetIndex: i
        }) : e);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: e
      });
    }
  }
  _updateDataset(e, i) {
    const a = this.getDatasetMeta(e), o = {
      meta: a,
      index: e,
      mode: i,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", o) !== !1 && (a.controller._update(i), o.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", o));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Fl.has(this) ? this.attached && !Fl.running(this) && Fl.start(this) : (this.draw(), dA({
      chart: this
    })));
  }
  draw() {
    let e;
    if (this._resizeBeforeDraw) {
      const { width: a, height: o } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(a, o);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this._layers;
    for (e = 0; e < i.length && i[e].z <= 0; ++e)
      i[e].draw(this.chartArea);
    for (this._drawDatasets(); e < i.length; ++e)
      i[e].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(e) {
    const i = this._sortedMetasets, a = [];
    let o, f;
    for (o = 0, f = i.length; o < f; ++o) {
      const u = i[o];
      (!e || u.visible) && a.push(u);
    }
    return a;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const e = this.getSortedVisibleDatasetMetas();
    for (let i = e.length - 1; i >= 0; --i)
      this._drawDataset(e[i]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(e) {
    const i = this.ctx, a = e._clip, o = !a.disabled, f = J3(e, this.chartArea), u = {
      meta: e,
      index: e.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", u) !== !1 && (o && Gx(i, {
      left: a.left === !1 ? 0 : f.left - a.left,
      right: a.right === !1 ? this.width : f.right + a.right,
      top: a.top === !1 ? 0 : f.top - a.top,
      bottom: a.bottom === !1 ? this.height : f.bottom + a.bottom
    }), e.controller.draw(), o && Kx(i), u.cancelable = !1, this.notifyPlugins("afterDatasetDraw", u));
  }
  isPointInArea(e) {
    return $l(e, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, i, a, o) {
    const f = X$.modes[i];
    return typeof f == "function" ? f(this, e, a, o) : [];
  }
  getDatasetMeta(e) {
    const i = this.data.datasets[e], a = this._metasets;
    let o = a.filter((f) => f && f._dataset === i).pop();
    return o || (o = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: i && i.order || 0,
      index: e,
      _dataset: i,
      _parsed: [],
      _sorted: !1
    }, a.push(o)), o;
  }
  getContext() {
    return this.$context || (this.$context = ac(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(e) {
    const i = this.data.datasets[e];
    if (!i)
      return !1;
    const a = this.getDatasetMeta(e);
    return typeof a.hidden == "boolean" ? !a.hidden : !i.hidden;
  }
  setDatasetVisibility(e, i) {
    const a = this.getDatasetMeta(e);
    a.hidden = !i;
  }
  toggleDataVisibility(e) {
    this._hiddenIndices[e] = !this._hiddenIndices[e];
  }
  getDataVisibility(e) {
    return !this._hiddenIndices[e];
  }
  _updateVisibility(e, i, a) {
    const o = a ? "show" : "hide", f = this.getDatasetMeta(e), u = f.controller._resolveAnimations(void 0, o);
    uv(i) ? (f.data[i].hidden = !a, this.update()) : (this.setDatasetVisibility(e, a), u.update(f, {
      visible: a
    }), this.update((h) => h.datasetIndex === e ? o : void 0));
  }
  hide(e, i) {
    this._updateVisibility(e, i, !1);
  }
  show(e, i) {
    this._updateVisibility(e, i, !0);
  }
  _destroyDatasetMeta(e) {
    const i = this._metasets[e];
    i && i.controller && i.controller._destroy(), delete this._metasets[e];
  }
  _stop() {
    let e, i;
    for (this.stop(), Fl.remove(this), e = 0, i = this.data.datasets.length; e < i; ++e)
      this._destroyDatasetMeta(e);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: e, ctx: i } = this;
    this._stop(), this.config.clearCache(), e && (this.unbindEvents(), PM(e, i), this.platform.releaseContext(i), this.canvas = null, this.ctx = null), delete ux[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...e) {
    return this.canvas.toDataURL(...e);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const e = this._listeners, i = this.platform, a = (f, u) => {
      i.addEventListener(this, f, u), e[f] = u;
    }, o = (f, u, h) => {
      f.offsetX = u, f.offsetY = h, this._eventHandler(f);
    };
    xn(this.options.events, (f) => a(f, o));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const e = this._responsiveListeners, i = this.platform, a = (m, v) => {
      i.addEventListener(this, m, v), e[m] = v;
    }, o = (m, v) => {
      e[m] && (i.removeEventListener(this, m, v), delete e[m]);
    }, f = (m, v) => {
      this.canvas && this.resize(m, v);
    };
    let u;
    const h = () => {
      o("attach", h), this.attached = !0, this.resize(), a("resize", f), a("detach", u);
    };
    u = () => {
      this.attached = !1, o("resize", f), this._stop(), this._resize(0, 0), a("attach", h);
    }, i.isAttached(this.canvas) ? h() : u();
  }
  unbindEvents() {
    xn(this._listeners, (e, i) => {
      this.platform.removeEventListener(this, i, e);
    }), this._listeners = {}, xn(this._responsiveListeners, (e, i) => {
      this.platform.removeEventListener(this, i, e);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(e, i, a) {
    const o = a ? "set" : "remove";
    let f, u, h, m;
    for (i === "dataset" && (f = this.getDatasetMeta(e[0].datasetIndex), f.controller["_" + o + "DatasetHoverStyle"]()), h = 0, m = e.length; h < m; ++h) {
      u = e[h];
      const v = u && this.getDatasetMeta(u.datasetIndex).controller;
      v && v[o + "HoverStyle"](u.element, u.datasetIndex, u.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e) {
    const i = this._active || [], a = e.map(({ datasetIndex: f, index: u }) => {
      const h = this.getDatasetMeta(f);
      if (!h)
        throw new Error("No dataset found at index " + f);
      return {
        datasetIndex: f,
        element: h.data[u],
        index: u
      };
    });
    !bx(a, i) && (this._active = a, this._lastEvent = null, this._updateHoverStyles(a, i));
  }
  notifyPlugins(e, i, a) {
    return this._plugins.notify(this, e, i, a);
  }
  isPluginEnabled(e) {
    return this._plugins._cache.filter((i) => i.plugin.id === e).length === 1;
  }
  _updateHoverStyles(e, i, a) {
    const o = this.options.hover, f = (m, v) => m.filter((b) => !v.some((S) => b.datasetIndex === S.datasetIndex && b.index === S.index)), u = f(i, e), h = a ? e : f(e, i);
    u.length && this.updateHoverStyle(u, o.mode, !1), h.length && o.mode && this.updateHoverStyle(h, o.mode, !0);
  }
  _eventHandler(e, i) {
    const a = {
      event: e,
      replay: i,
      cancelable: !0,
      inChartArea: this.isPointInArea(e)
    }, o = (u) => (u.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", a, o) === !1)
      return;
    const f = this._handleEvent(e, i, a.inChartArea);
    return a.cancelable = !1, this.notifyPlugins("afterEvent", a, o), (f || a.changed) && this.render(), this;
  }
  _handleEvent(e, i, a) {
    const { _active: o = [], options: f } = this, u = i, h = this._getActiveElements(e, o, a, u), m = oI(e), v = Z3(e, this._lastEvent, a, m);
    a && (this._lastEvent = null, Nn(f.onHover, [
      e,
      h,
      this
    ], this), m && Nn(f.onClick, [
      e,
      h,
      this
    ], this));
    const b = !bx(h, o);
    return (b || i) && (this._active = h, this._updateHoverStyles(h, o, i)), this._lastEvent = v, b;
  }
  _getActiveElements(e, i, a, o) {
    if (e.type === "mouseout")
      return [];
    if (!a)
      return i;
    const f = this.options.hover;
    return this.getElementsAtEventForMode(e, f.mode, f, o);
  }
}
Fe(Lo, "defaults", Qn), Fe(Lo, "instances", ux), Fe(Lo, "overrides", Wf), Fe(Lo, "registry", Po), Fe(Lo, "version", K3), Fe(Lo, "getChart", hA);
function pA() {
  return xn(Lo.instances, (t) => t._plugins.invalidate());
}
function e5(t, e, i) {
  const { startAngle: a, pixelMargin: o, x: f, y: u, outerRadius: h, innerRadius: m } = e;
  let v = o / h;
  t.beginPath(), t.arc(f, u, h, a - v, i + v), m > o ? (v = o / m, t.arc(f, u, m, i + v, a - v, !0)) : t.arc(f, u, o, i + Ci, a - Ci), t.closePath(), t.clip();
}
function t5(t) {
  return OE(t, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function n5(t, e, i, a) {
  const o = t5(t.options.borderRadius), f = (i - e) / 2, u = Math.min(f, a * e / 2), h = (m) => {
    const v = (i - Math.min(f, m)) * a / 2;
    return Zi(m, 0, Math.min(f, v));
  };
  return {
    outerStart: h(o.outerStart),
    outerEnd: h(o.outerEnd),
    innerStart: Zi(o.innerStart, 0, u),
    innerEnd: Zi(o.innerEnd, 0, u)
  };
}
function Wh(t, e, i, a) {
  return {
    x: i + t * Math.cos(e),
    y: a + t * Math.sin(e)
  };
}
function Tx(t, e, i, a, o, f) {
  const { x: u, y: h, startAngle: m, pixelMargin: v, innerRadius: b } = e, S = Math.max(e.outerRadius + a + i - v, 0), C = b > 0 ? b + a + i + v : 0;
  let E = 0;
  const D = o - m;
  if (a) {
    const Te = b > 0 ? b - a : 0, Se = S > 0 ? S - a : 0, Oe = (Te + Se) / 2, re = Oe !== 0 ? D * Oe / (Oe + a) : D;
    E = (D - re) / 2;
  }
  const M = Math.max(1e-3, D * S - i / Un) / S, A = (D - M) / 2, P = m + A + E, N = o - A - E, { outerStart: F, outerEnd: B, innerStart: V, innerEnd: G } = n5(e, C, S, N - P), Y = S - F, K = S - B, ae = P + F / Y, ie = N - B / K, ee = C + V, oe = C + G, se = P + V / ee, Pe = N - G / oe;
  if (t.beginPath(), f) {
    const Te = (ae + ie) / 2;
    if (t.arc(u, h, S, ae, Te), t.arc(u, h, S, Te, ie), B > 0) {
      const ge = Wh(K, ie, u, h);
      t.arc(ge.x, ge.y, B, ie, N + Ci);
    }
    const Se = Wh(oe, N, u, h);
    if (t.lineTo(Se.x, Se.y), G > 0) {
      const ge = Wh(oe, Pe, u, h);
      t.arc(ge.x, ge.y, G, N + Ci, Pe + Math.PI);
    }
    const Oe = (N - G / C + (P + V / C)) / 2;
    if (t.arc(u, h, C, N - G / C, Oe, !0), t.arc(u, h, C, Oe, P + V / C, !0), V > 0) {
      const ge = Wh(ee, se, u, h);
      t.arc(ge.x, ge.y, V, se + Math.PI, P - Ci);
    }
    const re = Wh(Y, P, u, h);
    if (t.lineTo(re.x, re.y), F > 0) {
      const ge = Wh(Y, ae, u, h);
      t.arc(ge.x, ge.y, F, P - Ci, ae);
    }
  } else {
    t.moveTo(u, h);
    const Te = Math.cos(ae) * S + u, Se = Math.sin(ae) * S + h;
    t.lineTo(Te, Se);
    const Oe = Math.cos(ie) * S + u, re = Math.sin(ie) * S + h;
    t.lineTo(Oe, re);
  }
  t.closePath();
}
function i5(t, e, i, a, o) {
  const { fullCircles: f, startAngle: u, circumference: h } = e;
  let m = e.endAngle;
  if (f) {
    Tx(t, e, i, a, m, o);
    for (let v = 0; v < f; ++v)
      t.fill();
    isNaN(h) || (m = u + (h % Hn || Hn));
  }
  return Tx(t, e, i, a, m, o), t.fill(), m;
}
function r5(t, e, i, a, o) {
  const { fullCircles: f, startAngle: u, circumference: h, options: m } = e, { borderWidth: v, borderJoinStyle: b, borderDash: S, borderDashOffset: C } = m, E = m.borderAlign === "inner";
  if (!v)
    return;
  t.setLineDash(S || []), t.lineDashOffset = C, E ? (t.lineWidth = v * 2, t.lineJoin = b || "round") : (t.lineWidth = v, t.lineJoin = b || "bevel");
  let D = e.endAngle;
  if (f) {
    Tx(t, e, i, a, D, o);
    for (let M = 0; M < f; ++M)
      t.stroke();
    isNaN(h) || (D = u + (h % Hn || Hn));
  }
  E && e5(t, e, D), f || (Tx(t, e, i, a, D, o), t.stroke());
}
class Gg extends ql {
  constructor(i) {
    super();
    Fe(this, "circumference");
    Fe(this, "endAngle");
    Fe(this, "fullCircles");
    Fe(this, "innerRadius");
    Fe(this, "outerRadius");
    Fe(this, "pixelMargin");
    Fe(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, i && Object.assign(this, i);
  }
  inRange(i, a, o) {
    const f = this.getProps([
      "x",
      "y"
    ], o), { angle: u, distance: h } = sL(f, {
      x: i,
      y: a
    }), { startAngle: m, endAngle: v, innerRadius: b, outerRadius: S, circumference: C } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], o), E = (this.options.spacing + this.options.borderWidth) / 2, D = zt(C, v - m), M = cv(u, m, v) && m !== v, A = D >= Hn || M, P = Ul(h, b + E, S + E);
    return A && P;
  }
  getCenterPoint(i) {
    const { x: a, y: o, startAngle: f, endAngle: u, innerRadius: h, outerRadius: m } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], i), { offset: v, spacing: b } = this.options, S = (f + u) / 2, C = (h + m + b + v) / 2;
    return {
      x: a + Math.cos(S) * C,
      y: o + Math.sin(S) * C
    };
  }
  tooltipPosition(i) {
    return this.getCenterPoint(i);
  }
  draw(i) {
    const { options: a, circumference: o } = this, f = (a.offset || 0) / 4, u = (a.spacing || 0) / 2, h = a.circular;
    if (this.pixelMargin = a.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = o > Hn ? Math.floor(o / Hn) : 0, o === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    i.save();
    const m = (this.startAngle + this.endAngle) / 2;
    i.translate(Math.cos(m) * f, Math.sin(m) * f);
    const v = 1 - Math.sin(Math.min(Un, o || 0)), b = f * v;
    i.fillStyle = a.backgroundColor, i.strokeStyle = a.borderColor, i5(i, this, b, u, h), r5(i, this, b, u, h), i.restore();
  }
}
Fe(Gg, "id", "arc"), Fe(Gg, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
}), Fe(Gg, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), Fe(Gg, "descriptors", {
  _scriptable: !0,
  _indexable: (i) => i !== "borderDash"
});
function jL(t, e, i = e) {
  t.lineCap = zt(i.borderCapStyle, e.borderCapStyle), t.setLineDash(zt(i.borderDash, e.borderDash)), t.lineDashOffset = zt(i.borderDashOffset, e.borderDashOffset), t.lineJoin = zt(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = zt(i.borderWidth, e.borderWidth), t.strokeStyle = zt(i.borderColor, e.borderColor);
}
function a5(t, e, i) {
  t.lineTo(i.x, i.y);
}
function s5(t) {
  return t.stepped ? kI : t.tension || t.cubicInterpolationMode === "monotone" ? MI : a5;
}
function BL(t, e, i = {}) {
  const a = t.length, { start: o = 0, end: f = a - 1 } = i, { start: u, end: h } = e, m = Math.max(o, u), v = Math.min(f, h), b = o < u && f < u || o > h && f > h;
  return {
    count: a,
    start: m,
    loop: e.loop,
    ilen: v < m && !b ? a + v - m : v - m
  };
}
function o5(t, e, i, a) {
  const { points: o, options: f } = e, { count: u, start: h, loop: m, ilen: v } = BL(o, i, a), b = s5(f);
  let { move: S = !0, reverse: C } = a || {}, E, D, M;
  for (E = 0; E <= v; ++E)
    D = o[(h + (C ? v - E : E)) % u], !D.skip && (S ? (t.moveTo(D.x, D.y), S = !1) : b(t, M, D, C, f.stepped), M = D);
  return m && (D = o[(h + (C ? v : 0)) % u], b(t, M, D, C, f.stepped)), !!m;
}
function l5(t, e, i, a) {
  const o = e.points, { count: f, start: u, ilen: h } = BL(o, i, a), { move: m = !0, reverse: v } = a || {};
  let b = 0, S = 0, C, E, D, M, A, P;
  const N = (B) => (u + (v ? h - B : B)) % f, F = () => {
    M !== A && (t.lineTo(b, A), t.lineTo(b, M), t.lineTo(b, P));
  };
  for (m && (E = o[N(0)], t.moveTo(E.x, E.y)), C = 0; C <= h; ++C) {
    if (E = o[N(C)], E.skip)
      continue;
    const B = E.x, V = E.y, G = B | 0;
    G === D ? (V < M ? M = V : V > A && (A = V), b = (S * b + B) / ++S) : (F(), t.lineTo(B, V), D = G, S = 0, M = A = V), P = V;
  }
  F();
}
function AT(t) {
  const e = t.options, i = e.borderDash && e.borderDash.length;
  return !t._decimated && !t._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !i ? l5 : o5;
}
function u5(t) {
  return t.stepped ? l$ : t.tension || t.cubicInterpolationMode === "monotone" ? u$ : Lf;
}
function c5(t, e, i, a) {
  let o = e._path;
  o || (o = e._path = new Path2D(), e.path(o, i, a) && o.closePath()), jL(t, e.options), t.stroke(o);
}
function f5(t, e, i, a) {
  const { segments: o, options: f } = e, u = AT(e);
  for (const h of o)
    jL(t, f, h.style), t.beginPath(), u(t, e, h, {
      start: i,
      end: i + a - 1
    }) && t.closePath(), t.stroke();
}
const d5 = typeof Path2D == "function";
function h5(t, e, i, a) {
  d5 && !e.options.segment ? c5(t, e, i, a) : f5(t, e, i, a);
}
class Xu extends ql {
  constructor(e) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e);
  }
  updateControlPoints(e, i) {
    const a = this.options;
    if ((a.tension || a.cubicInterpolationMode === "monotone") && !a.stepped && !this._pointsUpdated) {
      const o = a.spanGaps ? this._loop : this._fullLoop;
      e$(this._points, a, e, o, i), this._pointsUpdated = !0;
    }
  }
  set points(e) {
    this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = m$(this, this.options.segment));
  }
  first() {
    const e = this.segments, i = this.points;
    return e.length && i[e[0].start];
  }
  last() {
    const e = this.segments, i = this.points, a = e.length;
    return a && i[e[a - 1].end];
  }
  interpolate(e, i) {
    const a = this.options, o = e[i], f = this.points, u = EL(this, {
      property: i,
      start: o,
      end: o
    });
    if (!u.length)
      return;
    const h = [], m = u5(a);
    let v, b;
    for (v = 0, b = u.length; v < b; ++v) {
      const { start: S, end: C } = u[v], E = f[S], D = f[C];
      if (E === D) {
        h.push(E);
        continue;
      }
      const M = Math.abs((o - E[i]) / (D[i] - E[i])), A = m(E, D, M, a.stepped);
      A[i] = e[i], h.push(A);
    }
    return h.length === 1 ? h[0] : h;
  }
  pathSegment(e, i, a) {
    return AT(this)(e, this, i, a);
  }
  path(e, i, a) {
    const o = this.segments, f = AT(this);
    let u = this._loop;
    i = i || 0, a = a || this.points.length - i;
    for (const h of o)
      u &= f(e, this, h, {
        start: i,
        end: i + a - 1
      });
    return !!u;
  }
  draw(e, i, a, o) {
    const f = this.options || {};
    (this.points || []).length && f.borderWidth && (e.save(), h5(e, this, a, o), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
Fe(Xu, "id", "line"), Fe(Xu, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), Fe(Xu, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), Fe(Xu, "descriptors", {
  _scriptable: !0,
  _indexable: (e) => e !== "borderDash" && e !== "fill"
});
function mA(t, e, i, a) {
  const o = t.options, { [i]: f } = t.getProps([
    i
  ], a);
  return Math.abs(e - f) < o.radius + o.hitRadius;
}
class cx extends ql {
  constructor(i) {
    super();
    Fe(this, "parsed");
    Fe(this, "skip");
    Fe(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, i && Object.assign(this, i);
  }
  inRange(i, a, o) {
    const f = this.options, { x: u, y: h } = this.getProps([
      "x",
      "y"
    ], o);
    return Math.pow(i - u, 2) + Math.pow(a - h, 2) < Math.pow(f.hitRadius + f.radius, 2);
  }
  inXRange(i, a) {
    return mA(this, i, "x", a);
  }
  inYRange(i, a) {
    return mA(this, i, "y", a);
  }
  getCenterPoint(i) {
    const { x: a, y: o } = this.getProps([
      "x",
      "y"
    ], i);
    return {
      x: a,
      y: o
    };
  }
  size(i) {
    i = i || this.options || {};
    let a = i.radius || 0;
    a = Math.max(a, a && i.hoverRadius || 0);
    const o = a && i.borderWidth || 0;
    return (a + o) * 2;
  }
  draw(i, a) {
    const o = this.options;
    this.skip || o.radius < 0.1 || !$l(this, a, this.size(o) / 2) || (i.strokeStyle = o.borderColor, i.lineWidth = o.borderWidth, i.fillStyle = o.backgroundColor, RT(i, o, this.x, this.y));
  }
  getRange() {
    const i = this.options || {};
    return i.radius + i.hitRadius;
  }
}
Fe(cx, "id", "point"), /**
* @type {any}
*/
Fe(cx, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
Fe(cx, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function HL(t, e) {
  const { x: i, y: a, base: o, width: f, height: u } = t.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], e);
  let h, m, v, b, S;
  return t.horizontal ? (S = u / 2, h = Math.min(i, o), m = Math.max(i, o), v = a - S, b = a + S) : (S = f / 2, h = i - S, m = i + S, v = Math.min(a, o), b = Math.max(a, o)), {
    left: h,
    top: v,
    right: m,
    bottom: b
  };
}
function Qu(t, e, i, a) {
  return t ? 0 : Zi(e, i, a);
}
function p5(t, e, i) {
  const a = t.options.borderWidth, o = t.borderSkipped, f = mL(a);
  return {
    t: Qu(o.top, f.top, 0, i),
    r: Qu(o.right, f.right, 0, e),
    b: Qu(o.bottom, f.bottom, 0, i),
    l: Qu(o.left, f.left, 0, e)
  };
}
function m5(t, e, i) {
  const { enableBorderRadius: a } = t.getProps([
    "enableBorderRadius"
  ]), o = t.options.borderRadius, f = Bf(o), u = Math.min(e, i), h = t.borderSkipped, m = a || Kt(o);
  return {
    topLeft: Qu(!m || h.top || h.left, f.topLeft, 0, u),
    topRight: Qu(!m || h.top || h.right, f.topRight, 0, u),
    bottomLeft: Qu(!m || h.bottom || h.left, f.bottomLeft, 0, u),
    bottomRight: Qu(!m || h.bottom || h.right, f.bottomRight, 0, u)
  };
}
function g5(t) {
  const e = HL(t), i = e.right - e.left, a = e.bottom - e.top, o = p5(t, i / 2, a / 2), f = m5(t, i / 2, a / 2);
  return {
    outer: {
      x: e.left,
      y: e.top,
      w: i,
      h: a,
      radius: f
    },
    inner: {
      x: e.left + o.l,
      y: e.top + o.t,
      w: i - o.l - o.r,
      h: a - o.t - o.b,
      radius: {
        topLeft: Math.max(0, f.topLeft - Math.max(o.t, o.l)),
        topRight: Math.max(0, f.topRight - Math.max(o.t, o.r)),
        bottomLeft: Math.max(0, f.bottomLeft - Math.max(o.b, o.l)),
        bottomRight: Math.max(0, f.bottomRight - Math.max(o.b, o.r))
      }
    }
  };
}
function eT(t, e, i, a) {
  const o = e === null, f = i === null, h = t && !(o && f) && HL(t, a);
  return h && (o || Ul(e, h.left, h.right)) && (f || Ul(i, h.top, h.bottom));
}
function v5(t) {
  return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight;
}
function y5(t, e) {
  t.rect(e.x, e.y, e.w, e.h);
}
function tT(t, e, i = {}) {
  const a = t.x !== i.x ? -e : 0, o = t.y !== i.y ? -e : 0, f = (t.x + t.w !== i.x + i.w ? e : 0) - a, u = (t.y + t.h !== i.y + i.h ? e : 0) - o;
  return {
    x: t.x + a,
    y: t.y + o,
    w: t.w + f,
    h: t.h + u,
    radius: t.radius
  };
}
class fx extends ql {
  constructor(e) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e);
  }
  draw(e) {
    const { inflateAmount: i, options: { borderColor: a, backgroundColor: o } } = this, { inner: f, outer: u } = g5(this), h = v5(u.radius) ? fv : y5;
    e.save(), (u.w !== f.w || u.h !== f.h) && (e.beginPath(), h(e, tT(u, i, f)), e.clip(), h(e, tT(f, -i, u)), e.fillStyle = a, e.fill("evenodd")), e.beginPath(), h(e, tT(f, i)), e.fillStyle = o, e.fill(), e.restore();
  }
  inRange(e, i, a) {
    return eT(this, e, i, a);
  }
  inXRange(e, i) {
    return eT(this, e, null, i);
  }
  inYRange(e, i) {
    return eT(this, null, e, i);
  }
  getCenterPoint(e) {
    const { x: i, y: a, base: o, horizontal: f } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], e);
    return {
      x: f ? (i + o) / 2 : i,
      y: f ? a : (a + o) / 2
    };
  }
  getRange(e) {
    return e === "x" ? this.width / 2 : this.height / 2;
  }
}
Fe(fx, "id", "bar"), Fe(fx, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), Fe(fx, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var b5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: Gg,
  BarElement: fx,
  LineElement: Xu,
  PointElement: cx
});
const OT = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
], gA = /* @__PURE__ */ OT.map((t) => t.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function UL(t) {
  return OT[t % OT.length];
}
function IL(t) {
  return gA[t % gA.length];
}
function x5(t, e) {
  return t.borderColor = UL(e), t.backgroundColor = IL(e), ++e;
}
function S5(t, e) {
  return t.backgroundColor = t.data.map(() => UL(e++)), e;
}
function _5(t, e) {
  return t.backgroundColor = t.data.map(() => IL(e++)), e;
}
function C5(t) {
  let e = 0;
  return (i, a) => {
    const o = t.getDatasetMeta(a).controller;
    o instanceof Ff ? e = S5(i, e) : o instanceof nv ? e = _5(i, e) : o && (e = x5(i, e));
  };
}
function vA(t) {
  let e;
  for (e in t)
    if (t[e].borderColor || t[e].backgroundColor)
      return !0;
  return !1;
}
function w5(t) {
  return t && (t.borderColor || t.backgroundColor);
}
function T5() {
  return Qn.borderColor !== "rgba(0,0,0,0.1)" || Qn.backgroundColor !== "rgba(0,0,0,0.1)";
}
var E5 = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(t, e, i) {
    if (!i.enabled)
      return;
    const { data: { datasets: a }, options: o } = t.config, { elements: f } = o, u = vA(a) || w5(o) || f && vA(f) || T5();
    if (!i.forceOverride && u)
      return;
    const h = C5(t);
    a.forEach(h);
  }
};
function R5(t, e, i, a, o) {
  const f = o.samples || a;
  if (f >= i)
    return t.slice(e, e + i);
  const u = [], h = (i - 2) / (f - 2);
  let m = 0;
  const v = e + i - 1;
  let b = e, S, C, E, D, M;
  for (u[m++] = t[b], S = 0; S < f - 2; S++) {
    let A = 0, P = 0, N;
    const F = Math.floor((S + 1) * h) + 1 + e, B = Math.min(Math.floor((S + 2) * h) + 1, i) + e, V = B - F;
    for (N = F; N < B; N++)
      A += t[N].x, P += t[N].y;
    A /= V, P /= V;
    const G = Math.floor(S * h) + 1 + e, Y = Math.min(Math.floor((S + 1) * h) + 1, i) + e, { x: K, y: ae } = t[b];
    for (E = D = -1, N = G; N < Y; N++)
      D = 0.5 * Math.abs((K - A) * (t[N].y - ae) - (K - t[N].x) * (P - ae)), D > E && (E = D, C = t[N], M = N);
    u[m++] = C, b = M;
  }
  return u[m++] = t[v], u;
}
function D5(t, e, i, a) {
  let o = 0, f = 0, u, h, m, v, b, S, C, E, D, M;
  const A = [], P = e + i - 1, N = t[e].x, B = t[P].x - N;
  for (u = e; u < e + i; ++u) {
    h = t[u], m = (h.x - N) / B * a, v = h.y;
    const V = m | 0;
    if (V === b)
      v < D ? (D = v, S = u) : v > M && (M = v, C = u), o = (f * o + h.x) / ++f;
    else {
      const G = u - 1;
      if (!sn(S) && !sn(C)) {
        const Y = Math.min(S, C), K = Math.max(S, C);
        Y !== E && Y !== G && A.push({
          ...t[Y],
          x: o
        }), K !== E && K !== G && A.push({
          ...t[K],
          x: o
        });
      }
      u > 0 && G !== E && A.push(t[G]), A.push(h), b = V, f = 0, D = M = v, S = C = E = u;
    }
  }
  return A;
}
function $L(t) {
  if (t._decimated) {
    const e = t._data;
    delete t._decimated, delete t._data, Object.defineProperty(t, "data", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: e
    });
  }
}
function yA(t) {
  t.data.datasets.forEach((e) => {
    $L(e);
  });
}
function k5(t, e) {
  const i = e.length;
  let a = 0, o;
  const { iScale: f } = t, { min: u, max: h, minDefined: m, maxDefined: v } = f.getUserBounds();
  return m && (a = Zi(Il(e, f.axis, u).lo, 0, i - 1)), v ? o = Zi(Il(e, f.axis, h).hi + 1, a, i) - a : o = i - a, {
    start: a,
    count: o
  };
}
var M5 = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (t, e, i) => {
    if (!i.enabled) {
      yA(t);
      return;
    }
    const a = t.width;
    t.data.datasets.forEach((o, f) => {
      const { _data: u, indexAxis: h } = o, m = t.getDatasetMeta(f), v = u || o.data;
      if (Wg([
        h,
        t.options.indexAxis
      ]) === "y" || !m.controller.supportsDecimation)
        return;
      const b = t.scales[m.xAxisID];
      if (b.type !== "linear" && b.type !== "time" || t.options.parsing)
        return;
      let { start: S, count: C } = k5(m, v);
      const E = i.threshold || 4 * a;
      if (C <= E) {
        $L(o);
        return;
      }
      sn(u) && (o._data = v, delete o.data, Object.defineProperty(o, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(M) {
          this._data = M;
        }
      }));
      let D;
      switch (i.algorithm) {
        case "lttb":
          D = R5(v, S, C, a, i);
          break;
        case "min-max":
          D = D5(v, S, C, a);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`);
      }
      o._decimated = D;
    });
  },
  destroy(t) {
    yA(t);
  }
};
function A5(t, e, i) {
  const a = t.segments, o = t.points, f = e.points, u = [];
  for (const h of a) {
    let { start: m, end: v } = h;
    v = jE(m, v, o);
    const b = PT(i, o[m], o[v], h.loop);
    if (!e.segments) {
      u.push({
        source: h,
        target: b,
        start: o[m],
        end: o[v]
      });
      continue;
    }
    const S = EL(e, b);
    for (const C of S) {
      const E = PT(i, f[C.start], f[C.end], C.loop), D = TL(h, o, E);
      for (const M of D)
        u.push({
          source: M,
          target: C,
          start: {
            [i]: bA(b, E, "start", Math.max)
          },
          end: {
            [i]: bA(b, E, "end", Math.min)
          }
        });
    }
  }
  return u;
}
function PT(t, e, i, a) {
  if (a)
    return;
  let o = e[t], f = i[t];
  return t === "angle" && (o = Ha(o), f = Ha(f)), {
    property: t,
    start: o,
    end: f
  };
}
function O5(t, e) {
  const { x: i = null, y: a = null } = t || {}, o = e.points, f = [];
  return e.segments.forEach(({ start: u, end: h }) => {
    h = jE(u, h, o);
    const m = o[u], v = o[h];
    a !== null ? (f.push({
      x: m.x,
      y: a
    }), f.push({
      x: v.x,
      y: a
    })) : i !== null && (f.push({
      x: i,
      y: m.y
    }), f.push({
      x: i,
      y: v.y
    }));
  }), f;
}
function jE(t, e, i) {
  for (; e > t; e--) {
    const a = i[e];
    if (!isNaN(a.x) && !isNaN(a.y))
      break;
  }
  return e;
}
function bA(t, e, i, a) {
  return t && e ? a(t[i], e[i]) : t ? t[i] : e ? e[i] : 0;
}
function WL(t, e) {
  let i = [], a = !1;
  return Kn(t) ? (a = !0, i = t) : i = O5(t, e), i.length ? new Xu({
    points: i,
    options: {
      tension: 0
    },
    _loop: a,
    _fullLoop: a
  }) : null;
}
function xA(t) {
  return t && t.fill !== !1;
}
function P5(t, e, i) {
  let o = t[e].fill;
  const f = [
    e
  ];
  let u;
  if (!i)
    return o;
  for (; o !== !1 && f.indexOf(o) === -1; ) {
    if (!gi(o))
      return o;
    if (u = t[o], !u)
      return !1;
    if (u.visible)
      return o;
    f.push(o), o = u.fill;
  }
  return !1;
}
function L5(t, e, i) {
  const a = V5(t);
  if (Kt(a))
    return isNaN(a.value) ? !1 : a;
  let o = parseFloat(a);
  return gi(o) && Math.floor(o) === o ? N5(a[0], e, o, i) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(a) >= 0 && a;
}
function N5(t, e, i, a) {
  return (t === "-" || t === "+") && (i = e + i), i === e || i < 0 || i >= a ? !1 : i;
}
function z5(t, e) {
  let i = null;
  return t === "start" ? i = e.bottom : t === "end" ? i = e.top : Kt(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i;
}
function F5(t, e, i) {
  let a;
  return t === "start" ? a = i : t === "end" ? a = e.options.reverse ? e.min : e.max : Kt(t) ? a = t.value : a = e.getBaseValue(), a;
}
function V5(t) {
  const e = t.options, i = e.fill;
  let a = zt(i && i.target, i);
  return a === void 0 && (a = !!e.backgroundColor), a === !1 || a === null ? !1 : a === !0 ? "origin" : a;
}
function j5(t) {
  const { scale: e, index: i, line: a } = t, o = [], f = a.segments, u = a.points, h = B5(e, i);
  h.push(WL({
    x: null,
    y: e.bottom
  }, a));
  for (let m = 0; m < f.length; m++) {
    const v = f[m];
    for (let b = v.start; b <= v.end; b++)
      H5(o, u[b], h);
  }
  return new Xu({
    points: o,
    options: {}
  });
}
function B5(t, e) {
  const i = [], a = t.getMatchingVisibleMetas("line");
  for (let o = 0; o < a.length; o++) {
    const f = a[o];
    if (f.index === e)
      break;
    f.hidden || i.unshift(f.dataset);
  }
  return i;
}
function H5(t, e, i) {
  const a = [];
  for (let o = 0; o < i.length; o++) {
    const f = i[o], { first: u, last: h, point: m } = U5(f, e, "x");
    if (!(!m || u && h)) {
      if (u)
        a.unshift(m);
      else if (t.push(m), !h)
        break;
    }
  }
  t.push(...a);
}
function U5(t, e, i) {
  const a = t.interpolate(e, i);
  if (!a)
    return {};
  const o = a[i], f = t.segments, u = t.points;
  let h = !1, m = !1;
  for (let v = 0; v < f.length; v++) {
    const b = f[v], S = u[b.start][i], C = u[b.end][i];
    if (Ul(o, S, C)) {
      h = o === S, m = o === C;
      break;
    }
  }
  return {
    first: h,
    last: m,
    point: a
  };
}
class YL {
  constructor(e) {
    this.x = e.x, this.y = e.y, this.radius = e.radius;
  }
  pathSegment(e, i, a) {
    const { x: o, y: f, radius: u } = this;
    return i = i || {
      start: 0,
      end: Hn
    }, e.arc(o, f, u, i.end, i.start, !0), !a.bounds;
  }
  interpolate(e) {
    const { x: i, y: a, radius: o } = this, f = e.angle;
    return {
      x: i + Math.cos(f) * o,
      y: a + Math.sin(f) * o,
      angle: f
    };
  }
}
function I5(t) {
  const { chart: e, fill: i, line: a } = t;
  if (gi(i))
    return $5(e, i);
  if (i === "stack")
    return j5(t);
  if (i === "shape")
    return !0;
  const o = W5(t);
  return o instanceof YL ? o : WL(o, a);
}
function $5(t, e) {
  const i = t.getDatasetMeta(e);
  return i && t.isDatasetVisible(e) ? i.dataset : null;
}
function W5(t) {
  return (t.scale || {}).getPointPositionForValue ? G5(t) : Y5(t);
}
function Y5(t) {
  const { scale: e = {}, fill: i } = t, a = z5(i, e);
  if (gi(a)) {
    const o = e.isHorizontal();
    return {
      x: o ? a : null,
      y: o ? null : a
    };
  }
  return null;
}
function G5(t) {
  const { scale: e, fill: i } = t, a = e.options, o = e.getLabels().length, f = a.reverse ? e.max : e.min, u = F5(i, e, f), h = [];
  if (a.grid.circular) {
    const m = e.getPointPositionForValue(0, f);
    return new YL({
      x: m.x,
      y: m.y,
      radius: e.getDistanceFromCenterForValue(u)
    });
  }
  for (let m = 0; m < o; ++m)
    h.push(e.getPointPositionForValue(m, u));
  return h;
}
function nT(t, e, i) {
  const a = I5(e), { line: o, scale: f, axis: u } = e, h = o.options, m = h.fill, v = h.backgroundColor, { above: b = v, below: S = v } = m || {};
  a && o.points.length && (Gx(t, i), K5(t, {
    line: o,
    target: a,
    above: b,
    below: S,
    area: i,
    scale: f,
    axis: u
  }), Kx(t));
}
function K5(t, e) {
  const { line: i, target: a, above: o, below: f, area: u, scale: h } = e, m = i._loop ? "angle" : e.axis;
  t.save(), m === "x" && f !== o && (SA(t, a, u.top), _A(t, {
    line: i,
    target: a,
    color: o,
    scale: h,
    property: m
  }), t.restore(), t.save(), SA(t, a, u.bottom)), _A(t, {
    line: i,
    target: a,
    color: f,
    scale: h,
    property: m
  }), t.restore();
}
function SA(t, e, i) {
  const { segments: a, points: o } = e;
  let f = !0, u = !1;
  t.beginPath();
  for (const h of a) {
    const { start: m, end: v } = h, b = o[m], S = o[jE(m, v, o)];
    f ? (t.moveTo(b.x, b.y), f = !1) : (t.lineTo(b.x, i), t.lineTo(b.x, b.y)), u = !!e.pathSegment(t, h, {
      move: u
    }), u ? t.closePath() : t.lineTo(S.x, i);
  }
  t.lineTo(e.first().x, i), t.closePath(), t.clip();
}
function _A(t, e) {
  const { line: i, target: a, property: o, color: f, scale: u } = e, h = A5(i, a, o);
  for (const { source: m, target: v, start: b, end: S } of h) {
    const { style: { backgroundColor: C = f } = {} } = m, E = a !== !0;
    t.save(), t.fillStyle = C, X5(t, u, E && PT(o, b, S)), t.beginPath();
    const D = !!i.pathSegment(t, m);
    let M;
    if (E) {
      D ? t.closePath() : CA(t, a, S, o);
      const A = !!a.pathSegment(t, v, {
        move: D,
        reverse: !0
      });
      M = D && A, M || CA(t, a, b, o);
    }
    t.closePath(), t.fill(M ? "evenodd" : "nonzero"), t.restore();
  }
}
function X5(t, e, i) {
  const { top: a, bottom: o } = e.chart.chartArea, { property: f, start: u, end: h } = i || {};
  f === "x" && (t.beginPath(), t.rect(u, a, h - u, o - a), t.clip());
}
function CA(t, e, i, a) {
  const o = e.interpolate(i, a);
  o && t.lineTo(o.x, o.y);
}
var Q5 = {
  id: "filler",
  afterDatasetsUpdate(t, e, i) {
    const a = (t.data.datasets || []).length, o = [];
    let f, u, h, m;
    for (u = 0; u < a; ++u)
      f = t.getDatasetMeta(u), h = f.dataset, m = null, h && h.options && h instanceof Xu && (m = {
        visible: t.isDatasetVisible(u),
        index: u,
        fill: L5(h, u, a),
        chart: t,
        axis: f.controller.options.indexAxis,
        scale: f.vScale,
        line: h
      }), f.$filler = m, o.push(m);
    for (u = 0; u < a; ++u)
      m = o[u], !(!m || m.fill === !1) && (m.fill = P5(o, u, i.propagate));
  },
  beforeDraw(t, e, i) {
    const a = i.drawTime === "beforeDraw", o = t.getSortedVisibleDatasetMetas(), f = t.chartArea;
    for (let u = o.length - 1; u >= 0; --u) {
      const h = o[u].$filler;
      h && (h.line.updateControlPoints(f, h.axis), a && h.fill && nT(t.ctx, h, f));
    }
  },
  beforeDatasetsDraw(t, e, i) {
    if (i.drawTime !== "beforeDatasetsDraw")
      return;
    const a = t.getSortedVisibleDatasetMetas();
    for (let o = a.length - 1; o >= 0; --o) {
      const f = a[o].$filler;
      xA(f) && nT(t.ctx, f, t.chartArea);
    }
  },
  beforeDatasetDraw(t, e, i) {
    const a = e.meta.$filler;
    !xA(a) || i.drawTime !== "beforeDatasetDraw" || nT(t.ctx, a, t.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const wA = (t, e) => {
  let { boxHeight: i = e, boxWidth: a = e } = t;
  return t.usePointStyle && (i = Math.min(i, e), a = t.pointStyleWidth || Math.min(a, e)), {
    boxWidth: a,
    boxHeight: i,
    itemHeight: Math.max(e, i)
  };
}, q5 = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index;
class TA extends ql {
  constructor(e) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, i, a) {
    this.maxWidth = e, this.maxHeight = i, this._margins = a, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const e = this.options.labels || {};
    let i = Nn(e.generateLabels, [
      this.chart
    ], this) || [];
    e.filter && (i = i.filter((a) => e.filter(a, this.chart.data))), e.sort && (i = i.sort((a, o) => e.sort(a, o, this.chart.data))), this.options.reverse && i.reverse(), this.legendItems = i;
  }
  fit() {
    const { options: e, ctx: i } = this;
    if (!e.display) {
      this.width = this.height = 0;
      return;
    }
    const a = e.labels, o = Yi(a.font), f = o.size, u = this._computeTitleHeight(), { boxWidth: h, itemHeight: m } = wA(a, f);
    let v, b;
    i.font = o.string, this.isHorizontal() ? (v = this.maxWidth, b = this._fitRows(u, f, h, m) + 10) : (b = this.maxHeight, v = this._fitCols(u, o, h, m) + 10), this.width = Math.min(v, e.maxWidth || this.maxWidth), this.height = Math.min(b, e.maxHeight || this.maxHeight);
  }
  _fitRows(e, i, a, o) {
    const { ctx: f, maxWidth: u, options: { labels: { padding: h } } } = this, m = this.legendHitBoxes = [], v = this.lineWidths = [
      0
    ], b = o + h;
    let S = e;
    f.textAlign = "left", f.textBaseline = "middle";
    let C = -1, E = -b;
    return this.legendItems.forEach((D, M) => {
      const A = a + i / 2 + f.measureText(D.text).width;
      (M === 0 || v[v.length - 1] + A + 2 * h > u) && (S += b, v[v.length - (M > 0 ? 0 : 1)] = 0, E += b, C++), m[M] = {
        left: 0,
        top: E,
        row: C,
        width: A,
        height: o
      }, v[v.length - 1] += A + h;
    }), S;
  }
  _fitCols(e, i, a, o) {
    const { ctx: f, maxHeight: u, options: { labels: { padding: h } } } = this, m = this.legendHitBoxes = [], v = this.columnSizes = [], b = u - e;
    let S = h, C = 0, E = 0, D = 0, M = 0;
    return this.legendItems.forEach((A, P) => {
      const { itemWidth: N, itemHeight: F } = Z5(a, i, f, A, o);
      P > 0 && E + F + 2 * h > b && (S += C + h, v.push({
        width: C,
        height: E
      }), D += C + h, M++, C = E = 0), m[P] = {
        left: D,
        top: E,
        col: M,
        width: N,
        height: F
      }, C = Math.max(C, N), E += F + h;
    }), S += C, v.push({
      width: C,
      height: E
    }), S;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const e = this._computeTitleHeight(), { legendHitBoxes: i, options: { align: a, labels: { padding: o }, rtl: f } } = this, u = ep(f, this.left, this.width);
    if (this.isHorizontal()) {
      let h = 0, m = Nr(a, this.left + o, this.right - this.lineWidths[h]);
      for (const v of i)
        h !== v.row && (h = v.row, m = Nr(a, this.left + o, this.right - this.lineWidths[h])), v.top += this.top + e + o, v.left = u.leftForLtr(u.x(m), v.width), m += v.width + o;
    } else {
      let h = 0, m = Nr(a, this.top + e + o, this.bottom - this.columnSizes[h].height);
      for (const v of i)
        v.col !== h && (h = v.col, m = Nr(a, this.top + e + o, this.bottom - this.columnSizes[h].height)), v.top = m, v.left += this.left + o, v.left = u.leftForLtr(u.x(v.left), v.width), m += v.height + o;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const e = this.ctx;
      Gx(e, this), this._draw(), Kx(e);
    }
  }
  _draw() {
    const { options: e, columnSizes: i, lineWidths: a, ctx: o } = this, { align: f, labels: u } = e, h = Qn.color, m = ep(e.rtl, this.left, this.width), v = Yi(u.font), { padding: b } = u, S = v.size, C = S / 2;
    let E;
    this.drawTitle(), o.textAlign = m.textAlign("left"), o.textBaseline = "middle", o.lineWidth = 0.5, o.font = v.string;
    const { boxWidth: D, boxHeight: M, itemHeight: A } = wA(u, S), P = function(G, Y, K) {
      if (isNaN(D) || D <= 0 || isNaN(M) || M < 0)
        return;
      o.save();
      const ae = zt(K.lineWidth, 1);
      if (o.fillStyle = zt(K.fillStyle, h), o.lineCap = zt(K.lineCap, "butt"), o.lineDashOffset = zt(K.lineDashOffset, 0), o.lineJoin = zt(K.lineJoin, "miter"), o.lineWidth = ae, o.strokeStyle = zt(K.strokeStyle, h), o.setLineDash(zt(K.lineDash, [])), u.usePointStyle) {
        const ie = {
          radius: M * Math.SQRT2 / 2,
          pointStyle: K.pointStyle,
          rotation: K.rotation,
          borderWidth: ae
        }, ee = m.xPlus(G, D / 2), oe = Y + C;
        pL(o, ie, ee, oe, u.pointStyleWidth && D);
      } else {
        const ie = Y + Math.max((S - M) / 2, 0), ee = m.leftForLtr(G, D), oe = Bf(K.borderRadius);
        o.beginPath(), Object.values(oe).some((se) => se !== 0) ? fv(o, {
          x: ee,
          y: ie,
          w: D,
          h: M,
          radius: oe
        }) : o.rect(ee, ie, D, M), o.fill(), ae !== 0 && o.stroke();
      }
      o.restore();
    }, N = function(G, Y, K) {
      Yf(o, K.text, G, Y + A / 2, v, {
        strikethrough: K.hidden,
        textAlign: m.textAlign(K.textAlign)
      });
    }, F = this.isHorizontal(), B = this._computeTitleHeight();
    F ? E = {
      x: Nr(f, this.left + b, this.right - a[0]),
      y: this.top + b + B,
      line: 0
    } : E = {
      x: this.left + b,
      y: Nr(f, this.top + B + b, this.bottom - i[0].height),
      line: 0
    }, _L(this.ctx, e.textDirection);
    const V = A + b;
    this.legendItems.forEach((G, Y) => {
      o.strokeStyle = G.fontColor, o.fillStyle = G.fontColor;
      const K = o.measureText(G.text).width, ae = m.textAlign(G.textAlign || (G.textAlign = u.textAlign)), ie = D + C + K;
      let ee = E.x, oe = E.y;
      m.setWidth(this.width), F ? Y > 0 && ee + ie + b > this.right && (oe = E.y += V, E.line++, ee = E.x = Nr(f, this.left + b, this.right - a[E.line])) : Y > 0 && oe + V > this.bottom && (ee = E.x = ee + i[E.line].width + b, E.line++, oe = E.y = Nr(f, this.top + B + b, this.bottom - i[E.line].height));
      const se = m.x(ee);
      if (P(se, oe, G), ee = yI(ae, ee + D + C, F ? ee + ie : this.right, e.rtl), N(m.x(ee), oe, G), F)
        E.x += ie + b;
      else if (typeof G.text != "string") {
        const Pe = v.lineHeight;
        E.y += GL(G, Pe) + b;
      } else
        E.y += V;
    }), CL(this.ctx, e.textDirection);
  }
  drawTitle() {
    const e = this.options, i = e.title, a = Yi(i.font), o = jr(i.padding);
    if (!i.display)
      return;
    const f = ep(e.rtl, this.left, this.width), u = this.ctx, h = i.position, m = a.size / 2, v = o.top + m;
    let b, S = this.left, C = this.width;
    if (this.isHorizontal())
      C = Math.max(...this.lineWidths), b = this.top + v, S = Nr(e.align, S, this.right - C);
    else {
      const D = this.columnSizes.reduce((M, A) => Math.max(M, A.height), 0);
      b = v + Nr(e.align, this.top, this.bottom - D - e.labels.padding - this._computeTitleHeight());
    }
    const E = Nr(h, S, S + C);
    u.textAlign = f.textAlign(ME(h)), u.textBaseline = "middle", u.strokeStyle = i.color, u.fillStyle = i.color, u.font = a.string, Yf(u, i.text, E, b, a);
  }
  _computeTitleHeight() {
    const e = this.options.title, i = Yi(e.font), a = jr(e.padding);
    return e.display ? i.lineHeight + a.height : 0;
  }
  _getLegendItemAt(e, i) {
    let a, o, f;
    if (Ul(e, this.left, this.right) && Ul(i, this.top, this.bottom)) {
      for (f = this.legendHitBoxes, a = 0; a < f.length; ++a)
        if (o = f[a], Ul(e, o.left, o.left + o.width) && Ul(i, o.top, o.top + o.height))
          return this.legendItems[a];
    }
    return null;
  }
  handleEvent(e) {
    const i = this.options;
    if (!t4(e.type, i))
      return;
    const a = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const o = this._hoveredItem, f = q5(o, a);
      o && !f && Nn(i.onLeave, [
        e,
        o,
        this
      ], this), this._hoveredItem = a, a && !f && Nn(i.onHover, [
        e,
        a,
        this
      ], this);
    } else a && Nn(i.onClick, [
      e,
      a,
      this
    ], this);
  }
}
function Z5(t, e, i, a, o) {
  const f = J5(a, t, e, i), u = e4(o, a, e.lineHeight);
  return {
    itemWidth: f,
    itemHeight: u
  };
}
function J5(t, e, i, a) {
  let o = t.text;
  return o && typeof o != "string" && (o = o.reduce((f, u) => f.length > u.length ? f : u)), e + i.size / 2 + a.measureText(o).width;
}
function e4(t, e, i) {
  let a = t;
  return typeof e.text != "string" && (a = GL(e, i)), a;
}
function GL(t, e) {
  const i = t.text ? t.text.length : 0;
  return e * i;
}
function t4(t, e) {
  return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup"));
}
var n4 = {
  id: "legend",
  _element: TA,
  start(t, e, i) {
    const a = t.legend = new TA({
      ctx: t.ctx,
      options: i,
      chart: t
    });
    Fr.configure(t, a, i), Fr.addBox(t, a);
  },
  stop(t) {
    Fr.removeBox(t, t.legend), delete t.legend;
  },
  beforeUpdate(t, e, i) {
    const a = t.legend;
    Fr.configure(t, a, i), a.options = i;
  },
  afterUpdate(t) {
    const e = t.legend;
    e.buildLabels(), e.adjustHitBoxes();
  },
  afterEvent(t, e) {
    e.replay || t.legend.handleEvent(e.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(t, e, i) {
      const a = e.datasetIndex, o = i.chart;
      o.isDatasetVisible(a) ? (o.hide(a), e.hidden = !0) : (o.show(a), e.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (t) => t.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(t) {
        const e = t.data.datasets, { labels: { usePointStyle: i, pointStyle: a, textAlign: o, color: f, useBorderRadius: u, borderRadius: h } } = t.legend.options;
        return t._getSortedDatasetMetas().map((m) => {
          const v = m.controller.getStyle(i ? 0 : void 0), b = jr(v.borderWidth);
          return {
            text: e[m.index].label,
            fillStyle: v.backgroundColor,
            fontColor: f,
            hidden: !m.visible,
            lineCap: v.borderCapStyle,
            lineDash: v.borderDash,
            lineDashOffset: v.borderDashOffset,
            lineJoin: v.borderJoinStyle,
            lineWidth: (b.width + b.height) / 4,
            strokeStyle: v.borderColor,
            pointStyle: a || v.pointStyle,
            rotation: v.rotation,
            textAlign: o || v.textAlign,
            borderRadius: u && (h || v.borderRadius),
            datasetIndex: m.index
          };
        }, this);
      }
    },
    title: {
      color: (t) => t.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (t) => !t.startsWith("on"),
    labels: {
      _scriptable: (t) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(t)
    }
  }
};
class BE extends ql {
  constructor(e) {
    super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, i) {
    const a = this.options;
    if (this.left = 0, this.top = 0, !a.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = e, this.height = this.bottom = i;
    const o = Kn(a.text) ? a.text.length : 1;
    this._padding = jr(a.padding);
    const f = o * Yi(a.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = f : this.width = f;
  }
  isHorizontal() {
    const e = this.options.position;
    return e === "top" || e === "bottom";
  }
  _drawArgs(e) {
    const { top: i, left: a, bottom: o, right: f, options: u } = this, h = u.align;
    let m = 0, v, b, S;
    return this.isHorizontal() ? (b = Nr(h, a, f), S = i + e, v = f - a) : (u.position === "left" ? (b = a + e, S = Nr(h, o, i), m = Un * -0.5) : (b = f - e, S = Nr(h, i, o), m = Un * 0.5), v = o - i), {
      titleX: b,
      titleY: S,
      maxWidth: v,
      rotation: m
    };
  }
  draw() {
    const e = this.ctx, i = this.options;
    if (!i.display)
      return;
    const a = Yi(i.font), f = a.lineHeight / 2 + this._padding.top, { titleX: u, titleY: h, maxWidth: m, rotation: v } = this._drawArgs(f);
    Yf(e, i.text, 0, 0, a, {
      color: i.color,
      maxWidth: m,
      rotation: v,
      textAlign: ME(i.align),
      textBaseline: "middle",
      translation: [
        u,
        h
      ]
    });
  }
}
function i4(t, e) {
  const i = new BE({
    ctx: t.ctx,
    options: e,
    chart: t
  });
  Fr.configure(t, i, e), Fr.addBox(t, i), t.titleBlock = i;
}
var r4 = {
  id: "title",
  _element: BE,
  start(t, e, i) {
    i4(t, i);
  },
  stop(t) {
    const e = t.titleBlock;
    Fr.removeBox(t, e), delete t.titleBlock;
  },
  beforeUpdate(t, e, i) {
    const a = t.titleBlock;
    Fr.configure(t, a, i), a.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Ib = /* @__PURE__ */ new WeakMap();
var a4 = {
  id: "subtitle",
  start(t, e, i) {
    const a = new BE({
      ctx: t.ctx,
      options: i,
      chart: t
    });
    Fr.configure(t, a, i), Fr.addBox(t, a), Ib.set(t, a);
  },
  stop(t) {
    Fr.removeBox(t, Ib.get(t)), Ib.delete(t);
  },
  beforeUpdate(t, e, i) {
    const a = Ib.get(t);
    Fr.configure(t, a, i), a.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Kg = {
  average(t) {
    if (!t.length)
      return !1;
    let e, i, a = /* @__PURE__ */ new Set(), o = 0, f = 0;
    for (e = 0, i = t.length; e < i; ++e) {
      const h = t[e].element;
      if (h && h.hasValue()) {
        const m = h.tooltipPosition();
        a.add(m.x), o += m.y, ++f;
      }
    }
    return f === 0 || a.size === 0 ? !1 : {
      x: [
        ...a
      ].reduce((h, m) => h + m) / a.size,
      y: o / f
    };
  },
  nearest(t, e) {
    if (!t.length)
      return !1;
    let i = e.x, a = e.y, o = Number.POSITIVE_INFINITY, f, u, h;
    for (f = 0, u = t.length; f < u; ++f) {
      const m = t[f].element;
      if (m && m.hasValue()) {
        const v = m.getCenterPoint(), b = TT(e, v);
        b < o && (o = b, h = m);
      }
    }
    if (h) {
      const m = h.tooltipPosition();
      i = m.x, a = m.y;
    }
    return {
      x: i,
      y: a
    };
  }
};
function Ao(t, e) {
  return e && (Kn(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
}
function Vl(t) {
  return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t;
}
function s4(t, e) {
  const { element: i, datasetIndex: a, index: o } = e, f = t.getDatasetMeta(a).controller, { label: u, value: h } = f.getLabelAndValue(o);
  return {
    chart: t,
    label: u,
    parsed: f.getParsed(o),
    raw: t.data.datasets[a].data[o],
    formattedValue: h,
    dataset: f.getDataset(),
    dataIndex: o,
    datasetIndex: a,
    element: i
  };
}
function EA(t, e) {
  const i = t.chart.ctx, { body: a, footer: o, title: f } = t, { boxWidth: u, boxHeight: h } = e, m = Yi(e.bodyFont), v = Yi(e.titleFont), b = Yi(e.footerFont), S = f.length, C = o.length, E = a.length, D = jr(e.padding);
  let M = D.height, A = 0, P = a.reduce((B, V) => B + V.before.length + V.lines.length + V.after.length, 0);
  if (P += t.beforeBody.length + t.afterBody.length, S && (M += S * v.lineHeight + (S - 1) * e.titleSpacing + e.titleMarginBottom), P) {
    const B = e.displayColors ? Math.max(h, m.lineHeight) : m.lineHeight;
    M += E * B + (P - E) * m.lineHeight + (P - 1) * e.bodySpacing;
  }
  C && (M += e.footerMarginTop + C * b.lineHeight + (C - 1) * e.footerSpacing);
  let N = 0;
  const F = function(B) {
    A = Math.max(A, i.measureText(B).width + N);
  };
  return i.save(), i.font = v.string, xn(t.title, F), i.font = m.string, xn(t.beforeBody.concat(t.afterBody), F), N = e.displayColors ? u + 2 + e.boxPadding : 0, xn(a, (B) => {
    xn(B.before, F), xn(B.lines, F), xn(B.after, F);
  }), N = 0, i.font = b.string, xn(t.footer, F), i.restore(), A += D.width, {
    width: A,
    height: M
  };
}
function o4(t, e) {
  const { y: i, height: a } = e;
  return i < a / 2 ? "top" : i > t.height - a / 2 ? "bottom" : "center";
}
function l4(t, e, i, a) {
  const { x: o, width: f } = a, u = i.caretSize + i.caretPadding;
  if (t === "left" && o + f + u > e.width || t === "right" && o - f - u < 0)
    return !0;
}
function u4(t, e, i, a) {
  const { x: o, width: f } = i, { width: u, chartArea: { left: h, right: m } } = t;
  let v = "center";
  return a === "center" ? v = o <= (h + m) / 2 ? "left" : "right" : o <= f / 2 ? v = "left" : o >= u - f / 2 && (v = "right"), l4(v, t, e, i) && (v = "center"), v;
}
function RA(t, e, i) {
  const a = i.yAlign || e.yAlign || o4(t, i);
  return {
    xAlign: i.xAlign || e.xAlign || u4(t, e, i, a),
    yAlign: a
  };
}
function c4(t, e) {
  let { x: i, width: a } = t;
  return e === "right" ? i -= a : e === "center" && (i -= a / 2), i;
}
function f4(t, e, i) {
  let { y: a, height: o } = t;
  return e === "top" ? a += i : e === "bottom" ? a -= o + i : a -= o / 2, a;
}
function DA(t, e, i, a) {
  const { caretSize: o, caretPadding: f, cornerRadius: u } = t, { xAlign: h, yAlign: m } = i, v = o + f, { topLeft: b, topRight: S, bottomLeft: C, bottomRight: E } = Bf(u);
  let D = c4(e, h);
  const M = f4(e, m, v);
  return m === "center" ? h === "left" ? D += v : h === "right" && (D -= v) : h === "left" ? D -= Math.max(b, C) + o : h === "right" && (D += Math.max(S, E) + o), {
    x: Zi(D, 0, a.width - e.width),
    y: Zi(M, 0, a.height - e.height)
  };
}
function $b(t, e, i) {
  const a = jr(i.padding);
  return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - a.right : t.x + a.left;
}
function kA(t) {
  return Ao([], Vl(t));
}
function d4(t, e, i) {
  return ac(t, {
    tooltip: e,
    tooltipItems: i,
    type: "tooltip"
  });
}
function MA(t, e) {
  const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
  return i ? t.override(i) : t;
}
const KL = {
  beforeTitle: zl,
  title(t) {
    if (t.length > 0) {
      const e = t[0], i = e.chart.data.labels, a = i ? i.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return e.dataset.label || "";
      if (e.label)
        return e.label;
      if (a > 0 && e.dataIndex < a)
        return i[e.dataIndex];
    }
    return "";
  },
  afterTitle: zl,
  beforeBody: zl,
  beforeLabel: zl,
  label(t) {
    if (this && this.options && this.options.mode === "dataset")
      return t.label + ": " + t.formattedValue || t.formattedValue;
    let e = t.dataset.label || "";
    e && (e += ": ");
    const i = t.formattedValue;
    return sn(i) || (e += i), e;
  },
  labelColor(t) {
    const i = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
    return {
      borderColor: i.borderColor,
      backgroundColor: i.backgroundColor,
      borderWidth: i.borderWidth,
      borderDash: i.borderDash,
      borderDashOffset: i.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(t) {
    const i = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
    return {
      pointStyle: i.pointStyle,
      rotation: i.rotation
    };
  },
  afterLabel: zl,
  afterBody: zl,
  beforeFooter: zl,
  footer: zl,
  afterFooter: zl
};
function va(t, e, i, a) {
  const o = t[e].call(i, a);
  return typeof o > "u" ? KL[e].call(i, a) : o;
}
class LT extends ql {
  constructor(e) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(e) {
    this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const e = this._cachedAnimations;
    if (e)
      return e;
    const i = this.chart, a = this.options.setContext(this.getContext()), o = a.enabled && i.options.animation && a.animations, f = new RL(this.chart, o);
    return o._cacheable && (this._cachedAnimations = Object.freeze(f)), f;
  }
  getContext() {
    return this.$context || (this.$context = d4(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(e, i) {
    const { callbacks: a } = i, o = va(a, "beforeTitle", this, e), f = va(a, "title", this, e), u = va(a, "afterTitle", this, e);
    let h = [];
    return h = Ao(h, Vl(o)), h = Ao(h, Vl(f)), h = Ao(h, Vl(u)), h;
  }
  getBeforeBody(e, i) {
    return kA(va(i.callbacks, "beforeBody", this, e));
  }
  getBody(e, i) {
    const { callbacks: a } = i, o = [];
    return xn(e, (f) => {
      const u = {
        before: [],
        lines: [],
        after: []
      }, h = MA(a, f);
      Ao(u.before, Vl(va(h, "beforeLabel", this, f))), Ao(u.lines, va(h, "label", this, f)), Ao(u.after, Vl(va(h, "afterLabel", this, f))), o.push(u);
    }), o;
  }
  getAfterBody(e, i) {
    return kA(va(i.callbacks, "afterBody", this, e));
  }
  getFooter(e, i) {
    const { callbacks: a } = i, o = va(a, "beforeFooter", this, e), f = va(a, "footer", this, e), u = va(a, "afterFooter", this, e);
    let h = [];
    return h = Ao(h, Vl(o)), h = Ao(h, Vl(f)), h = Ao(h, Vl(u)), h;
  }
  _createItems(e) {
    const i = this._active, a = this.chart.data, o = [], f = [], u = [];
    let h = [], m, v;
    for (m = 0, v = i.length; m < v; ++m)
      h.push(s4(this.chart, i[m]));
    return e.filter && (h = h.filter((b, S, C) => e.filter(b, S, C, a))), e.itemSort && (h = h.sort((b, S) => e.itemSort(b, S, a))), xn(h, (b) => {
      const S = MA(e.callbacks, b);
      o.push(va(S, "labelColor", this, b)), f.push(va(S, "labelPointStyle", this, b)), u.push(va(S, "labelTextColor", this, b));
    }), this.labelColors = o, this.labelPointStyles = f, this.labelTextColors = u, this.dataPoints = h, h;
  }
  update(e, i) {
    const a = this.options.setContext(this.getContext()), o = this._active;
    let f, u = [];
    if (!o.length)
      this.opacity !== 0 && (f = {
        opacity: 0
      });
    else {
      const h = Kg[a.position].call(this, o, this._eventPosition);
      u = this._createItems(a), this.title = this.getTitle(u, a), this.beforeBody = this.getBeforeBody(u, a), this.body = this.getBody(u, a), this.afterBody = this.getAfterBody(u, a), this.footer = this.getFooter(u, a);
      const m = this._size = EA(this, a), v = Object.assign({}, h, m), b = RA(this.chart, a, v), S = DA(a, v, b, this.chart);
      this.xAlign = b.xAlign, this.yAlign = b.yAlign, f = {
        opacity: 1,
        x: S.x,
        y: S.y,
        width: m.width,
        height: m.height,
        caretX: h.x,
        caretY: h.y
      };
    }
    this._tooltipItems = u, this.$context = void 0, f && this._resolveAnimations().update(this, f), e && a.external && a.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: i
    });
  }
  drawCaret(e, i, a, o) {
    const f = this.getCaretPosition(e, a, o);
    i.lineTo(f.x1, f.y1), i.lineTo(f.x2, f.y2), i.lineTo(f.x3, f.y3);
  }
  getCaretPosition(e, i, a) {
    const { xAlign: o, yAlign: f } = this, { caretSize: u, cornerRadius: h } = a, { topLeft: m, topRight: v, bottomLeft: b, bottomRight: S } = Bf(h), { x: C, y: E } = e, { width: D, height: M } = i;
    let A, P, N, F, B, V;
    return f === "center" ? (B = E + M / 2, o === "left" ? (A = C, P = A - u, F = B + u, V = B - u) : (A = C + D, P = A + u, F = B - u, V = B + u), N = A) : (o === "left" ? P = C + Math.max(m, b) + u : o === "right" ? P = C + D - Math.max(v, S) - u : P = this.caretX, f === "top" ? (F = E, B = F - u, A = P - u, N = P + u) : (F = E + M, B = F + u, A = P + u, N = P - u), V = F), {
      x1: A,
      x2: P,
      x3: N,
      y1: F,
      y2: B,
      y3: V
    };
  }
  drawTitle(e, i, a) {
    const o = this.title, f = o.length;
    let u, h, m;
    if (f) {
      const v = ep(a.rtl, this.x, this.width);
      for (e.x = $b(this, a.titleAlign, a), i.textAlign = v.textAlign(a.titleAlign), i.textBaseline = "middle", u = Yi(a.titleFont), h = a.titleSpacing, i.fillStyle = a.titleColor, i.font = u.string, m = 0; m < f; ++m)
        i.fillText(o[m], v.x(e.x), e.y + u.lineHeight / 2), e.y += u.lineHeight + h, m + 1 === f && (e.y += a.titleMarginBottom - h);
    }
  }
  _drawColorBox(e, i, a, o, f) {
    const u = this.labelColors[a], h = this.labelPointStyles[a], { boxHeight: m, boxWidth: v } = f, b = Yi(f.bodyFont), S = $b(this, "left", f), C = o.x(S), E = m < b.lineHeight ? (b.lineHeight - m) / 2 : 0, D = i.y + E;
    if (f.usePointStyle) {
      const M = {
        radius: Math.min(v, m) / 2,
        pointStyle: h.pointStyle,
        rotation: h.rotation,
        borderWidth: 1
      }, A = o.leftForLtr(C, v) + v / 2, P = D + m / 2;
      e.strokeStyle = f.multiKeyBackground, e.fillStyle = f.multiKeyBackground, RT(e, M, A, P), e.strokeStyle = u.borderColor, e.fillStyle = u.backgroundColor, RT(e, M, A, P);
    } else {
      e.lineWidth = Kt(u.borderWidth) ? Math.max(...Object.values(u.borderWidth)) : u.borderWidth || 1, e.strokeStyle = u.borderColor, e.setLineDash(u.borderDash || []), e.lineDashOffset = u.borderDashOffset || 0;
      const M = o.leftForLtr(C, v), A = o.leftForLtr(o.xPlus(C, 1), v - 2), P = Bf(u.borderRadius);
      Object.values(P).some((N) => N !== 0) ? (e.beginPath(), e.fillStyle = f.multiKeyBackground, fv(e, {
        x: M,
        y: D,
        w: v,
        h: m,
        radius: P
      }), e.fill(), e.stroke(), e.fillStyle = u.backgroundColor, e.beginPath(), fv(e, {
        x: A,
        y: D + 1,
        w: v - 2,
        h: m - 2,
        radius: P
      }), e.fill()) : (e.fillStyle = f.multiKeyBackground, e.fillRect(M, D, v, m), e.strokeRect(M, D, v, m), e.fillStyle = u.backgroundColor, e.fillRect(A, D + 1, v - 2, m - 2));
    }
    e.fillStyle = this.labelTextColors[a];
  }
  drawBody(e, i, a) {
    const { body: o } = this, { bodySpacing: f, bodyAlign: u, displayColors: h, boxHeight: m, boxWidth: v, boxPadding: b } = a, S = Yi(a.bodyFont);
    let C = S.lineHeight, E = 0;
    const D = ep(a.rtl, this.x, this.width), M = function(K) {
      i.fillText(K, D.x(e.x + E), e.y + C / 2), e.y += C + f;
    }, A = D.textAlign(u);
    let P, N, F, B, V, G, Y;
    for (i.textAlign = u, i.textBaseline = "middle", i.font = S.string, e.x = $b(this, A, a), i.fillStyle = a.bodyColor, xn(this.beforeBody, M), E = h && A !== "right" ? u === "center" ? v / 2 + b : v + 2 + b : 0, B = 0, G = o.length; B < G; ++B) {
      for (P = o[B], N = this.labelTextColors[B], i.fillStyle = N, xn(P.before, M), F = P.lines, h && F.length && (this._drawColorBox(i, e, B, D, a), C = Math.max(S.lineHeight, m)), V = 0, Y = F.length; V < Y; ++V)
        M(F[V]), C = S.lineHeight;
      xn(P.after, M);
    }
    E = 0, C = S.lineHeight, xn(this.afterBody, M), e.y -= f;
  }
  drawFooter(e, i, a) {
    const o = this.footer, f = o.length;
    let u, h;
    if (f) {
      const m = ep(a.rtl, this.x, this.width);
      for (e.x = $b(this, a.footerAlign, a), e.y += a.footerMarginTop, i.textAlign = m.textAlign(a.footerAlign), i.textBaseline = "middle", u = Yi(a.footerFont), i.fillStyle = a.footerColor, i.font = u.string, h = 0; h < f; ++h)
        i.fillText(o[h], m.x(e.x), e.y + u.lineHeight / 2), e.y += u.lineHeight + a.footerSpacing;
    }
  }
  drawBackground(e, i, a, o) {
    const { xAlign: f, yAlign: u } = this, { x: h, y: m } = e, { width: v, height: b } = a, { topLeft: S, topRight: C, bottomLeft: E, bottomRight: D } = Bf(o.cornerRadius);
    i.fillStyle = o.backgroundColor, i.strokeStyle = o.borderColor, i.lineWidth = o.borderWidth, i.beginPath(), i.moveTo(h + S, m), u === "top" && this.drawCaret(e, i, a, o), i.lineTo(h + v - C, m), i.quadraticCurveTo(h + v, m, h + v, m + C), u === "center" && f === "right" && this.drawCaret(e, i, a, o), i.lineTo(h + v, m + b - D), i.quadraticCurveTo(h + v, m + b, h + v - D, m + b), u === "bottom" && this.drawCaret(e, i, a, o), i.lineTo(h + E, m + b), i.quadraticCurveTo(h, m + b, h, m + b - E), u === "center" && f === "left" && this.drawCaret(e, i, a, o), i.lineTo(h, m + S), i.quadraticCurveTo(h, m, h + S, m), i.closePath(), i.fill(), o.borderWidth > 0 && i.stroke();
  }
  _updateAnimationTarget(e) {
    const i = this.chart, a = this.$animations, o = a && a.x, f = a && a.y;
    if (o || f) {
      const u = Kg[e.position].call(this, this._active, this._eventPosition);
      if (!u)
        return;
      const h = this._size = EA(this, e), m = Object.assign({}, u, this._size), v = RA(i, e, m), b = DA(e, m, v, i);
      (o._to !== b.x || f._to !== b.y) && (this.xAlign = v.xAlign, this.yAlign = v.yAlign, this.width = h.width, this.height = h.height, this.caretX = u.x, this.caretY = u.y, this._resolveAnimations().update(this, b));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(e) {
    const i = this.options.setContext(this.getContext());
    let a = this.opacity;
    if (!a)
      return;
    this._updateAnimationTarget(i);
    const o = {
      width: this.width,
      height: this.height
    }, f = {
      x: this.x,
      y: this.y
    };
    a = Math.abs(a) < 1e-3 ? 0 : a;
    const u = jr(i.padding), h = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    i.enabled && h && (e.save(), e.globalAlpha = a, this.drawBackground(f, e, o, i), _L(e, i.textDirection), f.y += u.top, this.drawTitle(f, e, i), this.drawBody(f, e, i), this.drawFooter(f, e, i), CL(e, i.textDirection), e.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e, i) {
    const a = this._active, o = e.map(({ datasetIndex: h, index: m }) => {
      const v = this.chart.getDatasetMeta(h);
      if (!v)
        throw new Error("Cannot find a dataset at index " + h);
      return {
        datasetIndex: h,
        element: v.data[m],
        index: m
      };
    }), f = !bx(a, o), u = this._positionChanged(o, i);
    (f || u) && (this._active = o, this._eventPosition = i, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(e, i, a = !0) {
    if (i && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const o = this.options, f = this._active || [], u = this._getActiveElements(e, f, i, a), h = this._positionChanged(u, e), m = i || !bx(u, f) || h;
    return m && (this._active = u, (o.enabled || o.external) && (this._eventPosition = {
      x: e.x,
      y: e.y
    }, this.update(!0, i))), m;
  }
  _getActiveElements(e, i, a, o) {
    const f = this.options;
    if (e.type === "mouseout")
      return [];
    if (!o)
      return i.filter((h) => this.chart.data.datasets[h.datasetIndex] && this.chart.getDatasetMeta(h.datasetIndex).controller.getParsed(h.index) !== void 0);
    const u = this.chart.getElementsAtEventForMode(e, f.mode, f, a);
    return f.reverse && u.reverse(), u;
  }
  _positionChanged(e, i) {
    const { caretX: a, caretY: o, options: f } = this, u = Kg[f.position].call(this, e, i);
    return u !== !1 && (a !== u.x || o !== u.y);
  }
}
Fe(LT, "positioners", Kg);
var h4 = {
  id: "tooltip",
  _element: LT,
  positioners: Kg,
  afterInit(t, e, i) {
    i && (t.tooltip = new LT({
      chart: t,
      options: i
    }));
  },
  beforeUpdate(t, e, i) {
    t.tooltip && t.tooltip.initialize(i);
  },
  reset(t, e, i) {
    t.tooltip && t.tooltip.initialize(i);
  },
  afterDraw(t) {
    const e = t.tooltip;
    if (e && e._willRender()) {
      const i = {
        tooltip: e
      };
      if (t.notifyPlugins("beforeTooltipDraw", {
        ...i,
        cancelable: !0
      }) === !1)
        return;
      e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i);
    }
  },
  afterEvent(t, e) {
    if (t.tooltip) {
      const i = e.replay;
      t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (t, e) => e.bodyFont.size,
    boxWidth: (t, e) => e.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: KL
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (t) => t !== "filter" && t !== "itemSort" && t !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
}, p4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: E5,
  Decimation: M5,
  Filler: Q5,
  Legend: n4,
  SubTitle: a4,
  Title: r4,
  Tooltip: h4
});
const m4 = (t, e, i, a) => (typeof e == "string" ? (i = t.push(e) - 1, a.unshift({
  index: i,
  label: e
})) : isNaN(e) && (i = null), i);
function g4(t, e, i, a) {
  const o = t.indexOf(e);
  if (o === -1)
    return m4(t, e, i, a);
  const f = t.lastIndexOf(e);
  return o !== f ? i : o;
}
const v4 = (t, e) => t === null ? null : Zi(Math.round(t), 0, e);
function AA(t) {
  const e = this.getLabels();
  return t >= 0 && t < e.length ? e[t] : t;
}
class NT extends Kf {
  constructor(e) {
    super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(e) {
    const i = this._addedLabels;
    if (i.length) {
      const a = this.getLabels();
      for (const { index: o, label: f } of i)
        a[o] === f && a.splice(o, 1);
      this._addedLabels = [];
    }
    super.init(e);
  }
  parse(e, i) {
    if (sn(e))
      return null;
    const a = this.getLabels();
    return i = isFinite(i) && a[i] === e ? i : g4(a, e, zt(i, e), this._addedLabels), v4(i, a.length - 1);
  }
  determineDataLimits() {
    const { minDefined: e, maxDefined: i } = this.getUserBounds();
    let { min: a, max: o } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (e || (a = 0), i || (o = this.getLabels().length - 1)), this.min = a, this.max = o;
  }
  buildTicks() {
    const e = this.min, i = this.max, a = this.options.offset, o = [];
    let f = this.getLabels();
    f = e === 0 && i === f.length - 1 ? f : f.slice(e, i + 1), this._valueRange = Math.max(f.length - (a ? 0 : 1), 1), this._startValue = this.min - (a ? 0.5 : 0);
    for (let u = e; u <= i; u++)
      o.push({
        value: u
      });
    return o;
  }
  getLabelForValue(e) {
    return AA.call(this, e);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(e) {
    return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getPixelForTick(e) {
    const i = this.ticks;
    return e < 0 || e > i.length - 1 ? null : this.getPixelForValue(i[e].value);
  }
  getValueForPixel(e) {
    return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
Fe(NT, "id", "category"), Fe(NT, "defaults", {
  ticks: {
    callback: AA
  }
});
function y4(t, e) {
  const i = [], { bounds: o, step: f, min: u, max: h, precision: m, count: v, maxTicks: b, maxDigits: S, includeBounds: C } = t, E = f || 1, D = b - 1, { min: M, max: A } = e, P = !sn(u), N = !sn(h), F = !sn(v), B = (A - M) / (S + 1);
  let V = EM((A - M) / D / E) * E, G, Y, K, ae;
  if (V < 1e-14 && !P && !N)
    return [
      {
        value: M
      },
      {
        value: A
      }
    ];
  ae = Math.ceil(A / V) - Math.floor(M / V), ae > D && (V = EM(ae * V / D / E) * E), sn(m) || (G = Math.pow(10, m), V = Math.ceil(V * G) / G), o === "ticks" ? (Y = Math.floor(M / V) * V, K = Math.ceil(A / V) * V) : (Y = M, K = A), P && N && f && fI((h - u) / f, V / 1e3) ? (ae = Math.round(Math.min((h - u) / V, b)), V = (h - u) / ae, Y = u, K = h) : F ? (Y = P ? u : Y, K = N ? h : K, ae = v - 1, V = (K - Y) / ae) : (ae = (K - Y) / V, Jg(ae, Math.round(ae), V / 1e3) ? ae = Math.round(ae) : ae = Math.ceil(ae));
  const ie = Math.max(RM(V), RM(Y));
  G = Math.pow(10, sn(m) ? ie : m), Y = Math.round(Y * G) / G, K = Math.round(K * G) / G;
  let ee = 0;
  for (P && (C && Y !== u ? (i.push({
    value: u
  }), Y < u && ee++, Jg(Math.round((Y + ee * V) * G) / G, u, OA(u, B, t)) && ee++) : Y < u && ee++); ee < ae; ++ee) {
    const oe = Math.round((Y + ee * V) * G) / G;
    if (N && oe > h)
      break;
    i.push({
      value: oe
    });
  }
  return N && C && K !== h ? i.length && Jg(i[i.length - 1].value, h, OA(h, B, t)) ? i[i.length - 1].value = h : i.push({
    value: h
  }) : (!N || K === h) && i.push({
    value: K
  }), i;
}
function OA(t, e, { horizontal: i, minRotation: a }) {
  const o = Gs(a), f = (i ? Math.sin(o) : Math.cos(o)) || 1e-3, u = 0.75 * e * ("" + t).length;
  return Math.min(e / f, u);
}
class Ex extends Kf {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(e, i) {
    return sn(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e;
  }
  handleTickRangeOptions() {
    const { beginAtZero: e } = this.options, { minDefined: i, maxDefined: a } = this.getUserBounds();
    let { min: o, max: f } = this;
    const u = (m) => o = i ? o : m, h = (m) => f = a ? f : m;
    if (e) {
      const m = Fo(o), v = Fo(f);
      m < 0 && v < 0 ? h(0) : m > 0 && v > 0 && u(0);
    }
    if (o === f) {
      let m = f === 0 ? 1 : Math.abs(f * 0.05);
      h(f + m), e || u(o - m);
    }
    this.min = o, this.max = f;
  }
  getTickLimit() {
    const e = this.options.ticks;
    let { maxTicksLimit: i, stepSize: a } = e, o;
    return a ? (o = Math.ceil(this.max / a) - Math.floor(this.min / a) + 1, o > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${a} would result generating up to ${o} ticks. Limiting to 1000.`), o = 1e3)) : (o = this.computeTickLimit(), i = i || 11), i && (o = Math.min(i, o)), o;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const e = this.options, i = e.ticks;
    let a = this.getTickLimit();
    a = Math.max(2, a);
    const o = {
      maxTicks: a,
      bounds: e.bounds,
      min: e.min,
      max: e.max,
      precision: i.precision,
      step: i.stepSize,
      count: i.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: i.minRotation || 0,
      includeBounds: i.includeBounds !== !1
    }, f = this._range || this, u = y4(o, f);
    return e.bounds === "ticks" && aL(u, this, "value"), e.reverse ? (u.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), u;
  }
  configure() {
    const e = this.ticks;
    let i = this.min, a = this.max;
    if (super.configure(), this.options.offset && e.length) {
      const o = (a - i) / Math.max(e.length - 1, 1) / 2;
      i -= o, a += o;
    }
    this._startValue = i, this._endValue = a, this._valueRange = a - i;
  }
  getLabelForValue(e) {
    return Dv(e, this.chart.options.locale, this.options.ticks.format);
  }
}
class zT extends Ex {
  determineDataLimits() {
    const { min: e, max: i } = this.getMinMax(!0);
    this.min = gi(e) ? e : 0, this.max = gi(i) ? i : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const e = this.isHorizontal(), i = e ? this.width : this.height, a = Gs(this.options.ticks.minRotation), o = (e ? Math.sin(a) : Math.cos(a)) || 1e-3, f = this._resolveTickFontOptions(0);
    return Math.ceil(i / Math.min(40, f.lineHeight / o));
  }
  getPixelForValue(e) {
    return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    return this._startValue + this.getDecimalForPixel(e) * this._valueRange;
  }
}
Fe(zT, "id", "linear"), Fe(zT, "defaults", {
  ticks: {
    callback: Yx.formatters.numeric
  }
});
const hv = (t) => Math.floor(Ku(t)), Af = (t, e) => Math.pow(10, hv(t) + e);
function PA(t) {
  return t / Math.pow(10, hv(t)) === 1;
}
function LA(t, e, i) {
  const a = Math.pow(10, i), o = Math.floor(t / a);
  return Math.ceil(e / a) - o;
}
function b4(t, e) {
  const i = e - t;
  let a = hv(i);
  for (; LA(t, e, a) > 10; )
    a++;
  for (; LA(t, e, a) < 10; )
    a--;
  return Math.min(a, hv(t));
}
function x4(t, { min: e, max: i }) {
  e = ja(t.min, e);
  const a = [], o = hv(e);
  let f = b4(e, i), u = f < 0 ? Math.pow(10, Math.abs(f)) : 1;
  const h = Math.pow(10, f), m = o > f ? Math.pow(10, o) : 0, v = Math.round((e - m) * u) / u, b = Math.floor((e - m) / h / 10) * h * 10;
  let S = Math.floor((v - b) / Math.pow(10, f)), C = ja(t.min, Math.round((m + b + S * Math.pow(10, f)) * u) / u);
  for (; C < i; )
    a.push({
      value: C,
      major: PA(C),
      significand: S
    }), S >= 10 ? S = S < 15 ? 15 : 20 : S++, S >= 20 && (f++, S = 2, u = f >= 0 ? 1 : u), C = Math.round((m + b + S * Math.pow(10, f)) * u) / u;
  const E = ja(t.max, C);
  return a.push({
    value: E,
    major: PA(E),
    significand: S
  }), a;
}
class FT extends Kf {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(e, i) {
    const a = Ex.prototype.parse.apply(this, [
      e,
      i
    ]);
    if (a === 0) {
      this._zero = !0;
      return;
    }
    return gi(a) && a > 0 ? a : null;
  }
  determineDataLimits() {
    const { min: e, max: i } = this.getMinMax(!0);
    this.min = gi(e) ? Math.max(0, e) : null, this.max = gi(i) ? Math.max(0, i) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !gi(this._userMin) && (this.min = e === Af(this.min, 0) ? Af(this.min, -1) : Af(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: e, maxDefined: i } = this.getUserBounds();
    let a = this.min, o = this.max;
    const f = (h) => a = e ? a : h, u = (h) => o = i ? o : h;
    a === o && (a <= 0 ? (f(1), u(10)) : (f(Af(a, -1)), u(Af(o, 1)))), a <= 0 && f(Af(o, -1)), o <= 0 && u(Af(a, 1)), this.min = a, this.max = o;
  }
  buildTicks() {
    const e = this.options, i = {
      min: this._userMin,
      max: this._userMax
    }, a = x4(i, this);
    return e.bounds === "ticks" && aL(a, this, "value"), e.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a;
  }
  getLabelForValue(e) {
    return e === void 0 ? "0" : Dv(e, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const e = this.min;
    super.configure(), this._startValue = Ku(e), this._valueRange = Ku(this.max) - Ku(e);
  }
  getPixelForValue(e) {
    return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (Ku(e) - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    const i = this.getDecimalForPixel(e);
    return Math.pow(10, this._startValue + i * this._valueRange);
  }
}
Fe(FT, "id", "logarithmic"), Fe(FT, "defaults", {
  ticks: {
    callback: Yx.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function VT(t) {
  const e = t.ticks;
  if (e.display && t.display) {
    const i = jr(e.backdropPadding);
    return zt(e.font && e.font.size, Qn.font.size) + i.height;
  }
  return 0;
}
function S4(t, e, i) {
  return i = Kn(i) ? i : [
    i
  ], {
    w: DI(t, e.string, i),
    h: i.length * e.lineHeight
  };
}
function NA(t, e, i, a, o) {
  return t === a || t === o ? {
    start: e - i / 2,
    end: e + i / 2
  } : t < a || t > o ? {
    start: e - i,
    end: e
  } : {
    start: e,
    end: e + i
  };
}
function _4(t) {
  const e = {
    l: t.left + t._padding.left,
    r: t.right - t._padding.right,
    t: t.top + t._padding.top,
    b: t.bottom - t._padding.bottom
  }, i = Object.assign({}, e), a = [], o = [], f = t._pointLabels.length, u = t.options.pointLabels, h = u.centerPointLabels ? Un / f : 0;
  for (let m = 0; m < f; m++) {
    const v = u.setContext(t.getPointLabelContext(m));
    o[m] = v.padding;
    const b = t.getPointPosition(m, t.drawingArea + o[m], h), S = Yi(v.font), C = S4(t.ctx, S, t._pointLabels[m]);
    a[m] = C;
    const E = Ha(t.getIndexAngle(m) + h), D = Math.round(DE(E)), M = NA(D, b.x, C.w, 0, 180), A = NA(D, b.y, C.h, 90, 270);
    C4(i, e, E, M, A);
  }
  t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = E4(t, a, o);
}
function C4(t, e, i, a, o) {
  const f = Math.abs(Math.sin(i)), u = Math.abs(Math.cos(i));
  let h = 0, m = 0;
  a.start < e.l ? (h = (e.l - a.start) / f, t.l = Math.min(t.l, e.l - h)) : a.end > e.r && (h = (a.end - e.r) / f, t.r = Math.max(t.r, e.r + h)), o.start < e.t ? (m = (e.t - o.start) / u, t.t = Math.min(t.t, e.t - m)) : o.end > e.b && (m = (o.end - e.b) / u, t.b = Math.max(t.b, e.b + m));
}
function w4(t, e, i) {
  const a = t.drawingArea, { extra: o, additionalAngle: f, padding: u, size: h } = i, m = t.getPointPosition(e, a + o + u, f), v = Math.round(DE(Ha(m.angle + Ci))), b = k4(m.y, h.h, v), S = R4(v), C = D4(m.x, h.w, S);
  return {
    visible: !0,
    x: m.x,
    y: b,
    textAlign: S,
    left: C,
    top: b,
    right: C + h.w,
    bottom: b + h.h
  };
}
function T4(t, e) {
  if (!e)
    return !0;
  const { left: i, top: a, right: o, bottom: f } = t;
  return !($l({
    x: i,
    y: a
  }, e) || $l({
    x: i,
    y: f
  }, e) || $l({
    x: o,
    y: a
  }, e) || $l({
    x: o,
    y: f
  }, e));
}
function E4(t, e, i) {
  const a = [], o = t._pointLabels.length, f = t.options, { centerPointLabels: u, display: h } = f.pointLabels, m = {
    extra: VT(f) / 2,
    additionalAngle: u ? Un / o : 0
  };
  let v;
  for (let b = 0; b < o; b++) {
    m.padding = i[b], m.size = e[b];
    const S = w4(t, b, m);
    a.push(S), h === "auto" && (S.visible = T4(S, v), S.visible && (v = S));
  }
  return a;
}
function R4(t) {
  return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right";
}
function D4(t, e, i) {
  return i === "right" ? t -= e : i === "center" && (t -= e / 2), t;
}
function k4(t, e, i) {
  return i === 90 || i === 270 ? t -= e / 2 : (i > 270 || i < 90) && (t -= e), t;
}
function M4(t, e, i) {
  const { left: a, top: o, right: f, bottom: u } = i, { backdropColor: h } = e;
  if (!sn(h)) {
    const m = Bf(e.borderRadius), v = jr(e.backdropPadding);
    t.fillStyle = h;
    const b = a - v.left, S = o - v.top, C = f - a + v.width, E = u - o + v.height;
    Object.values(m).some((D) => D !== 0) ? (t.beginPath(), fv(t, {
      x: b,
      y: S,
      w: C,
      h: E,
      radius: m
    }), t.fill()) : t.fillRect(b, S, C, E);
  }
}
function A4(t, e) {
  const { ctx: i, options: { pointLabels: a } } = t;
  for (let o = e - 1; o >= 0; o--) {
    const f = t._pointLabelItems[o];
    if (!f.visible)
      continue;
    const u = a.setContext(t.getPointLabelContext(o));
    M4(i, u, f);
    const h = Yi(u.font), { x: m, y: v, textAlign: b } = f;
    Yf(i, t._pointLabels[o], m, v + h.lineHeight / 2, h, {
      color: u.color,
      textAlign: b,
      textBaseline: "middle"
    });
  }
}
function XL(t, e, i, a) {
  const { ctx: o } = t;
  if (i)
    o.arc(t.xCenter, t.yCenter, e, 0, Hn);
  else {
    let f = t.getPointPosition(0, e);
    o.moveTo(f.x, f.y);
    for (let u = 1; u < a; u++)
      f = t.getPointPosition(u, e), o.lineTo(f.x, f.y);
  }
}
function O4(t, e, i, a, o) {
  const f = t.ctx, u = e.circular, { color: h, lineWidth: m } = e;
  !u && !a || !h || !m || i < 0 || (f.save(), f.strokeStyle = h, f.lineWidth = m, f.setLineDash(o.dash || []), f.lineDashOffset = o.dashOffset, f.beginPath(), XL(t, i, u, a), f.closePath(), f.stroke(), f.restore());
}
function P4(t, e, i) {
  return ac(t, {
    label: i,
    index: e,
    type: "pointLabel"
  });
}
class Xg extends Ex {
  constructor(e) {
    super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const e = this._padding = jr(VT(this.options) / 2), i = this.width = this.maxWidth - e.width, a = this.height = this.maxHeight - e.height;
    this.xCenter = Math.floor(this.left + i / 2 + e.left), this.yCenter = Math.floor(this.top + a / 2 + e.top), this.drawingArea = Math.floor(Math.min(i, a) / 2);
  }
  determineDataLimits() {
    const { min: e, max: i } = this.getMinMax(!1);
    this.min = gi(e) && !isNaN(e) ? e : 0, this.max = gi(i) && !isNaN(i) ? i : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / VT(this.options));
  }
  generateTickLabels(e) {
    Ex.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((i, a) => {
      const o = Nn(this.options.pointLabels.callback, [
        i,
        a
      ], this);
      return o || o === 0 ? o : "";
    }).filter((i, a) => this.chart.getDataVisibility(a));
  }
  fit() {
    const e = this.options;
    e.display && e.pointLabels.display ? _4(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(e, i, a, o) {
    this.xCenter += Math.floor((e - i) / 2), this.yCenter += Math.floor((a - o) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, i, a, o));
  }
  getIndexAngle(e) {
    const i = Hn / (this._pointLabels.length || 1), a = this.options.startAngle || 0;
    return Ha(e * i + Gs(a));
  }
  getDistanceFromCenterForValue(e) {
    if (sn(e))
      return NaN;
    const i = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - e) * i : (e - this.min) * i;
  }
  getValueForDistanceFromCenter(e) {
    if (sn(e))
      return NaN;
    const i = e / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - i : this.min + i;
  }
  getPointLabelContext(e) {
    const i = this._pointLabels || [];
    if (e >= 0 && e < i.length) {
      const a = i[e];
      return P4(this.getContext(), e, a);
    }
  }
  getPointPosition(e, i, a = 0) {
    const o = this.getIndexAngle(e) - Ci + a;
    return {
      x: Math.cos(o) * i + this.xCenter,
      y: Math.sin(o) * i + this.yCenter,
      angle: o
    };
  }
  getPointPositionForValue(e, i) {
    return this.getPointPosition(e, this.getDistanceFromCenterForValue(i));
  }
  getBasePosition(e) {
    return this.getPointPositionForValue(e || 0, this.getBaseValue());
  }
  getPointLabelPosition(e) {
    const { left: i, top: a, right: o, bottom: f } = this._pointLabelItems[e];
    return {
      left: i,
      top: a,
      right: o,
      bottom: f
    };
  }
  drawBackground() {
    const { backgroundColor: e, grid: { circular: i } } = this.options;
    if (e) {
      const a = this.ctx;
      a.save(), a.beginPath(), XL(this, this.getDistanceFromCenterForValue(this._endValue), i, this._pointLabels.length), a.closePath(), a.fillStyle = e, a.fill(), a.restore();
    }
  }
  drawGrid() {
    const e = this.ctx, i = this.options, { angleLines: a, grid: o, border: f } = i, u = this._pointLabels.length;
    let h, m, v;
    if (i.pointLabels.display && A4(this, u), o.display && this.ticks.forEach((b, S) => {
      if (S !== 0 || S === 0 && this.min < 0) {
        m = this.getDistanceFromCenterForValue(b.value);
        const C = this.getContext(S), E = o.setContext(C), D = f.setContext(C);
        O4(this, E, m, u, D);
      }
    }), a.display) {
      for (e.save(), h = u - 1; h >= 0; h--) {
        const b = a.setContext(this.getPointLabelContext(h)), { color: S, lineWidth: C } = b;
        !C || !S || (e.lineWidth = C, e.strokeStyle = S, e.setLineDash(b.borderDash), e.lineDashOffset = b.borderDashOffset, m = this.getDistanceFromCenterForValue(i.reverse ? this.min : this.max), v = this.getPointPosition(h, m), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(v.x, v.y), e.stroke());
      }
      e.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const e = this.ctx, i = this.options, a = i.ticks;
    if (!a.display)
      return;
    const o = this.getIndexAngle(0);
    let f, u;
    e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(o), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((h, m) => {
      if (m === 0 && this.min >= 0 && !i.reverse)
        return;
      const v = a.setContext(this.getContext(m)), b = Yi(v.font);
      if (f = this.getDistanceFromCenterForValue(this.ticks[m].value), v.showLabelBackdrop) {
        e.font = b.string, u = e.measureText(h.label).width, e.fillStyle = v.backdropColor;
        const S = jr(v.backdropPadding);
        e.fillRect(-u / 2 - S.left, -f - b.size / 2 - S.top, u + S.width, b.size + S.height);
      }
      Yf(e, h.label, 0, -f, b, {
        color: v.color,
        strokeColor: v.textStrokeColor,
        strokeWidth: v.textStrokeWidth
      });
    }), e.restore();
  }
  drawTitle() {
  }
}
Fe(Xg, "id", "radialLinear"), Fe(Xg, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: Yx.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(e) {
      return e;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), Fe(Xg, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), Fe(Xg, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const qx = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, _a = /* @__PURE__ */ Object.keys(qx);
function zA(t, e) {
  return t - e;
}
function FA(t, e) {
  if (sn(e))
    return null;
  const i = t._adapter, { parser: a, round: o, isoWeekday: f } = t._parseOpts;
  let u = e;
  return typeof a == "function" && (u = a(u)), gi(u) || (u = typeof a == "string" ? i.parse(u, a) : i.parse(u)), u === null ? null : (o && (u = o === "week" && (rp(f) || f === !0) ? i.startOf(u, "isoWeek", f) : i.startOf(u, o)), +u);
}
function VA(t, e, i, a) {
  const o = _a.length;
  for (let f = _a.indexOf(t); f < o - 1; ++f) {
    const u = qx[_a[f]], h = u.steps ? u.steps : Number.MAX_SAFE_INTEGER;
    if (u.common && Math.ceil((i - e) / (h * u.size)) <= a)
      return _a[f];
  }
  return _a[o - 1];
}
function L4(t, e, i, a, o) {
  for (let f = _a.length - 1; f >= _a.indexOf(i); f--) {
    const u = _a[f];
    if (qx[u].common && t._adapter.diff(o, a, u) >= e - 1)
      return u;
  }
  return _a[i ? _a.indexOf(i) : 0];
}
function N4(t) {
  for (let e = _a.indexOf(t) + 1, i = _a.length; e < i; ++e)
    if (qx[_a[e]].common)
      return _a[e];
}
function jA(t, e, i) {
  if (!i)
    t[e] = !0;
  else if (i.length) {
    const { lo: a, hi: o } = kE(i, e), f = i[a] >= e ? i[a] : i[o];
    t[f] = !0;
  }
}
function z4(t, e, i, a) {
  const o = t._adapter, f = +o.startOf(e[0].value, a), u = e[e.length - 1].value;
  let h, m;
  for (h = f; h <= u; h = +o.add(h, 1, a))
    m = i[h], m >= 0 && (e[m].major = !0);
  return e;
}
function BA(t, e, i) {
  const a = [], o = {}, f = e.length;
  let u, h;
  for (u = 0; u < f; ++u)
    h = e[u], o[h] = u, a.push({
      value: h,
      major: !1
    });
  return f === 0 || !i ? a : z4(t, a, o, i);
}
class pv extends Kf {
  constructor(e) {
    super(e), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(e, i = {}) {
    const a = e.time || (e.time = {}), o = this._adapter = new $$._date(e.adapters.date);
    o.init(i), Zg(a.displayFormats, o.formats()), this._parseOpts = {
      parser: a.parser,
      round: a.round,
      isoWeekday: a.isoWeekday
    }, super.init(e), this._normalized = i.normalized;
  }
  parse(e, i) {
    return e === void 0 ? null : FA(this, e);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const e = this.options, i = this._adapter, a = e.time.unit || "day";
    let { min: o, max: f, minDefined: u, maxDefined: h } = this.getUserBounds();
    function m(v) {
      !u && !isNaN(v.min) && (o = Math.min(o, v.min)), !h && !isNaN(v.max) && (f = Math.max(f, v.max));
    }
    (!u || !h) && (m(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && m(this.getMinMax(!1))), o = gi(o) && !isNaN(o) ? o : +i.startOf(Date.now(), a), f = gi(f) && !isNaN(f) ? f : +i.endOf(Date.now(), a) + 1, this.min = Math.min(o, f - 1), this.max = Math.max(o + 1, f);
  }
  _getLabelBounds() {
    const e = this.getLabelTimestamps();
    let i = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY;
    return e.length && (i = e[0], a = e[e.length - 1]), {
      min: i,
      max: a
    };
  }
  buildTicks() {
    const e = this.options, i = e.time, a = e.ticks, o = a.source === "labels" ? this.getLabelTimestamps() : this._generate();
    e.bounds === "ticks" && o.length && (this.min = this._userMin || o[0], this.max = this._userMax || o[o.length - 1]);
    const f = this.min, u = this.max, h = mI(o, f, u);
    return this._unit = i.unit || (a.autoSkip ? VA(i.minUnit, this.min, this.max, this._getLabelCapacity(f)) : L4(this, h.length, i.minUnit, this.min, this.max)), this._majorUnit = !a.major.enabled || this._unit === "year" ? void 0 : N4(this._unit), this.initOffsets(o), e.reverse && h.reverse(), BA(this, h, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
  }
  initOffsets(e = []) {
    let i = 0, a = 0, o, f;
    this.options.offset && e.length && (o = this.getDecimalForValue(e[0]), e.length === 1 ? i = 1 - o : i = (this.getDecimalForValue(e[1]) - o) / 2, f = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? a = f : a = (f - this.getDecimalForValue(e[e.length - 2])) / 2);
    const u = e.length < 3 ? 0.5 : 0.25;
    i = Zi(i, 0, u), a = Zi(a, 0, u), this._offsets = {
      start: i,
      end: a,
      factor: 1 / (i + 1 + a)
    };
  }
  _generate() {
    const e = this._adapter, i = this.min, a = this.max, o = this.options, f = o.time, u = f.unit || VA(f.minUnit, i, a, this._getLabelCapacity(i)), h = zt(o.ticks.stepSize, 1), m = u === "week" ? f.isoWeekday : !1, v = rp(m) || m === !0, b = {};
    let S = i, C, E;
    if (v && (S = +e.startOf(S, "isoWeek", m)), S = +e.startOf(S, v ? "day" : u), e.diff(a, i, u) > 1e5 * h)
      throw new Error(i + " and " + a + " are too far apart with stepSize of " + h + " " + u);
    const D = o.ticks.source === "data" && this.getDataTimestamps();
    for (C = S, E = 0; C < a; C = +e.add(C, h, u), E++)
      jA(b, C, D);
    return (C === a || o.bounds === "ticks" || E === 1) && jA(b, C, D), Object.keys(b).sort(zA).map((M) => +M);
  }
  getLabelForValue(e) {
    const i = this._adapter, a = this.options.time;
    return a.tooltipFormat ? i.format(e, a.tooltipFormat) : i.format(e, a.displayFormats.datetime);
  }
  format(e, i) {
    const o = this.options.time.displayFormats, f = this._unit, u = i || o[f];
    return this._adapter.format(e, u);
  }
  _tickFormatFunction(e, i, a, o) {
    const f = this.options, u = f.ticks.callback;
    if (u)
      return Nn(u, [
        e,
        i,
        a
      ], this);
    const h = f.time.displayFormats, m = this._unit, v = this._majorUnit, b = m && h[m], S = v && h[v], C = a[i], E = v && S && C && C.major;
    return this._adapter.format(e, o || (E ? S : b));
  }
  generateTickLabels(e) {
    let i, a, o;
    for (i = 0, a = e.length; i < a; ++i)
      o = e[i], o.label = this._tickFormatFunction(o.value, i, e);
  }
  getDecimalForValue(e) {
    return e === null ? NaN : (e - this.min) / (this.max - this.min);
  }
  getPixelForValue(e) {
    const i = this._offsets, a = this.getDecimalForValue(e);
    return this.getPixelForDecimal((i.start + a) * i.factor);
  }
  getValueForPixel(e) {
    const i = this._offsets, a = this.getDecimalForPixel(e) / i.factor - i.end;
    return this.min + a * (this.max - this.min);
  }
  _getLabelSize(e) {
    const i = this.options.ticks, a = this.ctx.measureText(e).width, o = Gs(this.isHorizontal() ? i.maxRotation : i.minRotation), f = Math.cos(o), u = Math.sin(o), h = this._resolveTickFontOptions(0).size;
    return {
      w: a * f + h * u,
      h: a * u + h * f
    };
  }
  _getLabelCapacity(e) {
    const i = this.options.time, a = i.displayFormats, o = a[i.unit] || a.millisecond, f = this._tickFormatFunction(e, 0, BA(this, [
      e
    ], this._majorUnit), o), u = this._getLabelSize(f), h = Math.floor(this.isHorizontal() ? this.width / u.w : this.height / u.h) - 1;
    return h > 0 ? h : 1;
  }
  getDataTimestamps() {
    let e = this._cache.data || [], i, a;
    if (e.length)
      return e;
    const o = this.getMatchingVisibleMetas();
    if (this._normalized && o.length)
      return this._cache.data = o[0].controller.getAllParsedValues(this);
    for (i = 0, a = o.length; i < a; ++i)
      e = e.concat(o[i].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(e);
  }
  getLabelTimestamps() {
    const e = this._cache.labels || [];
    let i, a;
    if (e.length)
      return e;
    const o = this.getLabels();
    for (i = 0, a = o.length; i < a; ++i)
      e.push(FA(this, o[i]));
    return this._cache.labels = this._normalized ? e : this.normalize(e);
  }
  normalize(e) {
    return lL(e.sort(zA));
  }
}
Fe(pv, "id", "time"), Fe(pv, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function Wb(t, e, i) {
  let a = 0, o = t.length - 1, f, u, h, m;
  i ? (e >= t[a].pos && e <= t[o].pos && ({ lo: a, hi: o } = Il(t, "pos", e)), { pos: f, time: h } = t[a], { pos: u, time: m } = t[o]) : (e >= t[a].time && e <= t[o].time && ({ lo: a, hi: o } = Il(t, "time", e)), { time: f, pos: h } = t[a], { time: u, pos: m } = t[o]);
  const v = u - f;
  return v ? h + (m - h) * (e - f) / v : h;
}
class jT extends pv {
  constructor(e) {
    super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const e = this._getTimestampsForTable(), i = this._table = this.buildLookupTable(e);
    this._minPos = Wb(i, this.min), this._tableRange = Wb(i, this.max) - this._minPos, super.initOffsets(e);
  }
  buildLookupTable(e) {
    const { min: i, max: a } = this, o = [], f = [];
    let u, h, m, v, b;
    for (u = 0, h = e.length; u < h; ++u)
      v = e[u], v >= i && v <= a && o.push(v);
    if (o.length < 2)
      return [
        {
          time: i,
          pos: 0
        },
        {
          time: a,
          pos: 1
        }
      ];
    for (u = 0, h = o.length; u < h; ++u)
      b = o[u + 1], m = o[u - 1], v = o[u], Math.round((b + m) / 2) !== v && f.push({
        time: v,
        pos: u / (h - 1)
      });
    return f;
  }
  _generate() {
    const e = this.min, i = this.max;
    let a = super.getDataTimestamps();
    return (!a.includes(e) || !a.length) && a.splice(0, 0, e), (!a.includes(i) || a.length === 1) && a.push(i), a.sort((o, f) => o - f);
  }
  _getTimestampsForTable() {
    let e = this._cache.all || [];
    if (e.length)
      return e;
    const i = this.getDataTimestamps(), a = this.getLabelTimestamps();
    return i.length && a.length ? e = this.normalize(i.concat(a)) : e = i.length ? i : a, e = this._cache.all = e, e;
  }
  getDecimalForValue(e) {
    return (Wb(this._table, e) - this._minPos) / this._tableRange;
  }
  getValueForPixel(e) {
    const i = this._offsets, a = this.getDecimalForPixel(e) / i.factor - i.end;
    return Wb(this._table, a * this._tableRange + this._minPos, !0);
  }
}
Fe(jT, "id", "timeseries"), Fe(jT, "defaults", pv.defaults);
var F4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: NT,
  LinearScale: zT,
  LogarithmicScale: FT,
  RadialLinearScale: Xg,
  TimeScale: pv,
  TimeSeriesScale: jT
});
const V4 = [
  I$,
  b5,
  p4,
  F4
];
Lo.register(...V4);
const aQ = ({
  data: t,
  backgroundColor: e,
  borderColor: i,
  borderWidth: a,
  barThickness: o,
  labelFillStyle: f,
  xTicksColor: u,
  yTicksColor: h,
  className: m = "",
  style: v = {}
}) => {
  const b = Sn(null), S = Sn(null);
  return Xn(() => {
    var M;
    S.current && S.current.destroy();
    const C = (M = b.current) == null ? void 0 : M.getContext("2d"), E = Math.max(...t.map((A) => A.value)), D = Math.ceil(E / 100) * 100 + 50;
    if (C)
      return S.current = new Lo(C, {
        type: "bar",
        data: {
          labels: t.map((A) => A.label),
          datasets: [
            {
              data: t.map((A) => A.value),
              backgroundColor: e || Array.from({ length: t.length }, (A, P) => P % 2 === 0 ? "#4CAF50" : "#2196F3"),
              borderColor: i || Array.from({ length: t.length }, (A, P) => P % 2 === 0 ? "#45a049" : "#1e88e5"),
              borderWidth: a || 1,
              barThickness: o || 20
            }
          ]
        },
        options: {
          responsive: !0,
          maintainAspectRatio: !1,
          plugins: {
            legend: {
              display: !1
            },
            tooltip: {
              enabled: !0,
              callbacks: {
                label: (A) => `${A.parsed.y}`
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: u || "#000"
              }
            },
            y: {
              beginAtZero: !0,
              max: D,
              ticks: {
                stepSize: D / 4,
                // Adjusted step size
                callback: (A) => A.toLocaleString(),
                color: h || "#000"
              }
            }
          },
          animation: {
            duration: 1e3,
            easing: "easeInOutQuart"
          },
          layout: {
            padding: {
              top: 20,
              // Increased top padding
              right: 10,
              bottom: 10,
              left: 10
            }
          }
        },
        plugins: [{
          id: "data-labels",
          afterDraw: (A) => {
            const P = A.ctx;
            A.data.datasets.forEach((N, F) => {
              A.getDatasetMeta(F).data.forEach((V, G) => {
                const Y = N.data[G] + "";
                P.fillStyle = f || "#000000", P.textAlign = "center", P.textBaseline = "bottom", P.font = "10px Arial", P.fillText(Y, V.x, V.y - 5);
              });
            });
          }
        }]
      }), () => {
        S.current && S.current.destroy();
      };
  }, [t]), /* @__PURE__ */ Me.jsx("canvas", { ref: b, className: m, style: v });
}, wn = (t) => {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      t();
    });
  });
}, HE = (t, e, i, a) => e + i > a ? {
  top: "auto",
  bottom: `${a - t}px`,
  marginBottom: "-1px"
} : {
  top: `${e}px`,
  bottom: "auto",
  marginTop: "-1px"
}, UE = (t, e, i, a, o) => e + i - o > a ? {
  left: "auto",
  right: `${a - e}px`
} : {
  left: `${t}px`,
  right: "auto"
};
function ps(t) {
  const [e, i, a] = t.split(".").map((f) => parseInt(f, 10)), o = new Date(e, i - 1, a);
  return o && o.getFullYear() === e && o.getMonth() === i - 1 && o.getDate() === a;
}
function Yh(t = 0) {
  const e = /* @__PURE__ */ new Date();
  e.setDate(e.getDate() + t);
  const i = e.getFullYear(), a = String(e.getMonth() + 1).padStart(2, "0"), o = String(e.getDate()).padStart(2, "0");
  return `${i}.${a}.${o}`;
}
var QL = /* @__PURE__ */ ((t) => (t.DEFAULT = "default", t.TYPE1 = "type1", t))(QL || {}), mv = /* @__PURE__ */ ((t) => (t.START_DATE = "startDate", t.END_DATE = "endDate", t))(mv || {});
const qL = Io(void 0), j4 = ({
  children: t,
  selectedValue: e = [Yh(), Yh()],
  updateSelectedValue: i,
  afterUpdate: a,
  className: o = "",
  style: f = {},
  ...u
}) => {
  const [h, m] = Tn(e[0]), [v, b] = Tn(e[1]);
  Xn(() => {
    m(e[0]), b(e[1]);
  }, [e]);
  const S = [h, v], C = [`${v}~`], E = [`~${h}`], D = (N) => {
    i(N);
  }, P = {
    setStartDateRange: (N) => {
      m(N), D([N, v]), a == null || a([N, v], "START");
    },
    setEndDateRange: (N) => {
      b(N), D([h, N]), a == null || a([h, N], "END");
    },
    selectedRange: S
  };
  return /* @__PURE__ */ Me.jsx(qL.Provider, { value: P, children: /* @__PURE__ */ Me.jsx("div", { className: `h_single_datepicker_range_area ${o}`, style: f, ...u, children: t({
    startDate: h,
    setStartDate: m,
    endDate: v,
    setEndDate: b,
    startDisableDatesRange: C,
    endDisabledDatesRange: E
  }) }) });
};
j4.displayName = "HSingleDatePickerRangeArea";
const ZL = () => ki(qL) || {
  setStartDateRange: () => {
  },
  setEndDateRange: () => {
  },
  selectedRange: []
};
var Yb = { exports: {} }, ya = {}, Gb = { exports: {} }, iT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HA;
function B4() {
  return HA || (HA = 1, function(t) {
    function e(re, ge) {
      var me = re.length;
      re.push(ge);
      e: for (; 0 < me; ) {
        var fe = me - 1 >>> 1, pe = re[fe];
        if (0 < o(pe, ge)) re[fe] = ge, re[me] = pe, me = fe;
        else break e;
      }
    }
    function i(re) {
      return re.length === 0 ? null : re[0];
    }
    function a(re) {
      if (re.length === 0) return null;
      var ge = re[0], me = re.pop();
      if (me !== ge) {
        re[0] = me;
        e: for (var fe = 0, pe = re.length, Ae = pe >>> 1; fe < Ae; ) {
          var Ne = 2 * (fe + 1) - 1, de = re[Ne], ze = Ne + 1, De = re[ze];
          if (0 > o(de, me)) ze < pe && 0 > o(De, de) ? (re[fe] = De, re[ze] = me, fe = ze) : (re[fe] = de, re[Ne] = me, fe = Ne);
          else if (ze < pe && 0 > o(De, me)) re[fe] = De, re[ze] = me, fe = ze;
          else break e;
        }
      }
      return ge;
    }
    function o(re, ge) {
      var me = re.sortIndex - ge.sortIndex;
      return me !== 0 ? me : re.id - ge.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var f = performance;
      t.unstable_now = function() {
        return f.now();
      };
    } else {
      var u = Date, h = u.now();
      t.unstable_now = function() {
        return u.now() - h;
      };
    }
    var m = [], v = [], b = 1, S = null, C = 3, E = !1, D = !1, M = !1, A = typeof setTimeout == "function" ? setTimeout : null, P = typeof clearTimeout == "function" ? clearTimeout : null, N = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function F(re) {
      for (var ge = i(v); ge !== null; ) {
        if (ge.callback === null) a(v);
        else if (ge.startTime <= re) a(v), ge.sortIndex = ge.expirationTime, e(m, ge);
        else break;
        ge = i(v);
      }
    }
    function B(re) {
      if (M = !1, F(re), !D) if (i(m) !== null) D = !0, Se(V);
      else {
        var ge = i(v);
        ge !== null && Oe(B, ge.startTime - re);
      }
    }
    function V(re, ge) {
      D = !1, M && (M = !1, P(K), K = -1), E = !0;
      var me = C;
      try {
        for (F(ge), S = i(m); S !== null && (!(S.expirationTime > ge) || re && !ee()); ) {
          var fe = S.callback;
          if (typeof fe == "function") {
            S.callback = null, C = S.priorityLevel;
            var pe = fe(S.expirationTime <= ge);
            ge = t.unstable_now(), typeof pe == "function" ? S.callback = pe : S === i(m) && a(m), F(ge);
          } else a(m);
          S = i(m);
        }
        if (S !== null) var Ae = !0;
        else {
          var Ne = i(v);
          Ne !== null && Oe(B, Ne.startTime - ge), Ae = !1;
        }
        return Ae;
      } finally {
        S = null, C = me, E = !1;
      }
    }
    var G = !1, Y = null, K = -1, ae = 5, ie = -1;
    function ee() {
      return !(t.unstable_now() - ie < ae);
    }
    function oe() {
      if (Y !== null) {
        var re = t.unstable_now();
        ie = re;
        var ge = !0;
        try {
          ge = Y(!0, re);
        } finally {
          ge ? se() : (G = !1, Y = null);
        }
      } else G = !1;
    }
    var se;
    if (typeof N == "function") se = function() {
      N(oe);
    };
    else if (typeof MessageChannel < "u") {
      var Pe = new MessageChannel(), Te = Pe.port2;
      Pe.port1.onmessage = oe, se = function() {
        Te.postMessage(null);
      };
    } else se = function() {
      A(oe, 0);
    };
    function Se(re) {
      Y = re, G || (G = !0, se());
    }
    function Oe(re, ge) {
      K = A(function() {
        re(t.unstable_now());
      }, ge);
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(re) {
      re.callback = null;
    }, t.unstable_continueExecution = function() {
      D || E || (D = !0, Se(V));
    }, t.unstable_forceFrameRate = function(re) {
      0 > re || 125 < re ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ae = 0 < re ? Math.floor(1e3 / re) : 5;
    }, t.unstable_getCurrentPriorityLevel = function() {
      return C;
    }, t.unstable_getFirstCallbackNode = function() {
      return i(m);
    }, t.unstable_next = function(re) {
      switch (C) {
        case 1:
        case 2:
        case 3:
          var ge = 3;
          break;
        default:
          ge = C;
      }
      var me = C;
      C = ge;
      try {
        return re();
      } finally {
        C = me;
      }
    }, t.unstable_pauseExecution = function() {
    }, t.unstable_requestPaint = function() {
    }, t.unstable_runWithPriority = function(re, ge) {
      switch (re) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          re = 3;
      }
      var me = C;
      C = re;
      try {
        return ge();
      } finally {
        C = me;
      }
    }, t.unstable_scheduleCallback = function(re, ge, me) {
      var fe = t.unstable_now();
      switch (typeof me == "object" && me !== null ? (me = me.delay, me = typeof me == "number" && 0 < me ? fe + me : fe) : me = fe, re) {
        case 1:
          var pe = -1;
          break;
        case 2:
          pe = 250;
          break;
        case 5:
          pe = 1073741823;
          break;
        case 4:
          pe = 1e4;
          break;
        default:
          pe = 5e3;
      }
      return pe = me + pe, re = { id: b++, callback: ge, priorityLevel: re, startTime: me, expirationTime: pe, sortIndex: -1 }, me > fe ? (re.sortIndex = me, e(v, re), i(m) === null && re === i(v) && (M ? (P(K), K = -1) : M = !0, Oe(B, me - fe))) : (re.sortIndex = pe, e(m, re), D || E || (D = !0, Se(V))), re;
    }, t.unstable_shouldYield = ee, t.unstable_wrapCallback = function(re) {
      var ge = C;
      return function() {
        var me = C;
        C = ge;
        try {
          return re.apply(this, arguments);
        } finally {
          C = me;
        }
      };
    };
  }(iT)), iT;
}
var rT = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UA;
function H4() {
  return UA || (UA = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, i = 5;
      function a(Le, nt) {
        var Ct = Le.length;
        Le.push(nt), u(Le, nt, Ct);
      }
      function o(Le) {
        return Le.length === 0 ? null : Le[0];
      }
      function f(Le) {
        if (Le.length === 0)
          return null;
        var nt = Le[0], Ct = Le.pop();
        return Ct !== nt && (Le[0] = Ct, h(Le, Ct, 0)), nt;
      }
      function u(Le, nt, Ct) {
        for (var Qt = Ct; Qt > 0; ) {
          var Vt = Qt - 1 >>> 1, In = Le[Vt];
          if (m(In, nt) > 0)
            Le[Vt] = nt, Le[Qt] = In, Qt = Vt;
          else
            return;
        }
      }
      function h(Le, nt, Ct) {
        for (var Qt = Ct, Vt = Le.length, In = Vt >>> 1; Qt < In; ) {
          var dn = (Qt + 1) * 2 - 1, _n = Le[dn], Jt = dn + 1, Gt = Le[Jt];
          if (m(_n, nt) < 0)
            Jt < Vt && m(Gt, _n) < 0 ? (Le[Qt] = Gt, Le[Jt] = nt, Qt = Jt) : (Le[Qt] = _n, Le[dn] = nt, Qt = dn);
          else if (Jt < Vt && m(Gt, nt) < 0)
            Le[Qt] = Gt, Le[Jt] = nt, Qt = Jt;
          else
            return;
        }
      }
      function m(Le, nt) {
        var Ct = Le.sortIndex - nt.sortIndex;
        return Ct !== 0 ? Ct : Le.id - nt.id;
      }
      var v = 1, b = 2, S = 3, C = 4, E = 5;
      function D(Le, nt) {
      }
      var M = typeof performance == "object" && typeof performance.now == "function";
      if (M) {
        var A = performance;
        t.unstable_now = function() {
          return A.now();
        };
      } else {
        var P = Date, N = P.now();
        t.unstable_now = function() {
          return P.now() - N;
        };
      }
      var F = 1073741823, B = -1, V = 250, G = 5e3, Y = 1e4, K = F, ae = [], ie = [], ee = 1, oe = null, se = S, Pe = !1, Te = !1, Se = !1, Oe = typeof setTimeout == "function" ? setTimeout : null, re = typeof clearTimeout == "function" ? clearTimeout : null, ge = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function me(Le) {
        for (var nt = o(ie); nt !== null; ) {
          if (nt.callback === null)
            f(ie);
          else if (nt.startTime <= Le)
            f(ie), nt.sortIndex = nt.expirationTime, a(ae, nt);
          else
            return;
          nt = o(ie);
        }
      }
      function fe(Le) {
        if (Se = !1, me(Le), !Te)
          if (o(ae) !== null)
            Te = !0, An(pe);
          else {
            var nt = o(ie);
            nt !== null && si(fe, nt.startTime - Le);
          }
      }
      function pe(Le, nt) {
        Te = !1, Se && (Se = !1, Ki()), Pe = !0;
        var Ct = se;
        try {
          var Qt;
          if (!e) return Ae(Le, nt);
        } finally {
          oe = null, se = Ct, Pe = !1;
        }
      }
      function Ae(Le, nt) {
        var Ct = nt;
        for (me(Ct), oe = o(ae); oe !== null && !(oe.expirationTime > Ct && (!Le || ln())); ) {
          var Qt = oe.callback;
          if (typeof Qt == "function") {
            oe.callback = null, se = oe.priorityLevel;
            var Vt = oe.expirationTime <= Ct, In = Qt(Vt);
            Ct = t.unstable_now(), typeof In == "function" ? oe.callback = In : oe === o(ae) && f(ae), me(Ct);
          } else
            f(ae);
          oe = o(ae);
        }
        if (oe !== null)
          return !0;
        var dn = o(ie);
        return dn !== null && si(fe, dn.startTime - Ct), !1;
      }
      function Ne(Le, nt) {
        switch (Le) {
          case v:
          case b:
          case S:
          case C:
          case E:
            break;
          default:
            Le = S;
        }
        var Ct = se;
        se = Le;
        try {
          return nt();
        } finally {
          se = Ct;
        }
      }
      function de(Le) {
        var nt;
        switch (se) {
          case v:
          case b:
          case S:
            nt = S;
            break;
          default:
            nt = se;
            break;
        }
        var Ct = se;
        se = nt;
        try {
          return Le();
        } finally {
          se = Ct;
        }
      }
      function ze(Le) {
        var nt = se;
        return function() {
          var Ct = se;
          se = nt;
          try {
            return Le.apply(this, arguments);
          } finally {
            se = Ct;
          }
        };
      }
      function De(Le, nt, Ct) {
        var Qt = t.unstable_now(), Vt;
        if (typeof Ct == "object" && Ct !== null) {
          var In = Ct.delay;
          typeof In == "number" && In > 0 ? Vt = Qt + In : Vt = Qt;
        } else
          Vt = Qt;
        var dn;
        switch (Le) {
          case v:
            dn = B;
            break;
          case b:
            dn = V;
            break;
          case E:
            dn = K;
            break;
          case C:
            dn = Y;
            break;
          case S:
          default:
            dn = G;
            break;
        }
        var _n = Vt + dn, Jt = {
          id: ee++,
          callback: nt,
          priorityLevel: Le,
          startTime: Vt,
          expirationTime: _n,
          sortIndex: -1
        };
        return Vt > Qt ? (Jt.sortIndex = Vt, a(ie, Jt), o(ae) === null && Jt === o(ie) && (Se ? Ki() : Se = !0, si(fe, Vt - Qt))) : (Jt.sortIndex = _n, a(ae, Jt), !Te && !Pe && (Te = !0, An(pe))), Jt;
      }
      function we() {
      }
      function ct() {
        !Te && !Pe && (Te = !0, An(pe));
      }
      function gt() {
        return o(ae);
      }
      function pt(Le) {
        Le.callback = null;
      }
      function At() {
        return se;
      }
      var xt = !1, tt = null, Et = -1, Wt = i, on = -1;
      function ln() {
        var Le = t.unstable_now() - on;
        return !(Le < Wt);
      }
      function Yt() {
      }
      function Xt(Le) {
        if (Le < 0 || Le > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Le > 0 ? Wt = Math.floor(1e3 / Le) : Wt = i;
      }
      var Dt = function() {
        if (tt !== null) {
          var Le = t.unstable_now();
          on = Le;
          var nt = !0, Ct = !0;
          try {
            Ct = tt(nt, Le);
          } finally {
            Ct ? Rt() : (xt = !1, tt = null);
          }
        } else
          xt = !1;
      }, Rt;
      if (typeof ge == "function")
        Rt = function() {
          ge(Dt);
        };
      else if (typeof MessageChannel < "u") {
        var Bt = new MessageChannel(), Dn = Bt.port2;
        Bt.port1.onmessage = Dt, Rt = function() {
          Dn.postMessage(null);
        };
      } else
        Rt = function() {
          Oe(Dt, 0);
        };
      function An(Le) {
        tt = Le, xt || (xt = !0, Rt());
      }
      function si(Le, nt) {
        Et = Oe(function() {
          Le(t.unstable_now());
        }, nt);
      }
      function Ki() {
        re(Et), Et = -1;
      }
      var wi = Yt, Ji = null;
      t.unstable_IdlePriority = E, t.unstable_ImmediatePriority = v, t.unstable_LowPriority = C, t.unstable_NormalPriority = S, t.unstable_Profiling = Ji, t.unstable_UserBlockingPriority = b, t.unstable_cancelCallback = pt, t.unstable_continueExecution = ct, t.unstable_forceFrameRate = Xt, t.unstable_getCurrentPriorityLevel = At, t.unstable_getFirstCallbackNode = gt, t.unstable_next = de, t.unstable_pauseExecution = we, t.unstable_requestPaint = wi, t.unstable_runWithPriority = Ne, t.unstable_scheduleCallback = De, t.unstable_shouldYield = ln, t.unstable_wrapCallback = ze, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(rT)), rT;
}
var IA;
function JL() {
  return IA || (IA = 1, process.env.NODE_ENV === "production" ? Gb.exports = B4() : Gb.exports = H4()), Gb.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $A;
function U4() {
  if ($A) return ya;
  $A = 1;
  var t = ip, e = JL();
  function i(s) {
    for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, p = 1; p < arguments.length; p++) l += "&args[]=" + encodeURIComponent(arguments[p]);
    return "Minified React error #" + s + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var a = /* @__PURE__ */ new Set(), o = {};
  function f(s, l) {
    u(s, l), u(s + "Capture", l);
  }
  function u(s, l) {
    for (o[s] = l, s = 0; s < l.length; s++) a.add(l[s]);
  }
  var h = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), m = Object.prototype.hasOwnProperty, v = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, b = {}, S = {};
  function C(s) {
    return m.call(S, s) ? !0 : m.call(b, s) ? !1 : v.test(s) ? S[s] = !0 : (b[s] = !0, !1);
  }
  function E(s, l, p, y) {
    if (p !== null && p.type === 0) return !1;
    switch (typeof l) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return y ? !1 : p !== null ? !p.acceptsBooleans : (s = s.toLowerCase().slice(0, 5), s !== "data-" && s !== "aria-");
      default:
        return !1;
    }
  }
  function D(s, l, p, y) {
    if (l === null || typeof l > "u" || E(s, l, p, y)) return !0;
    if (y) return !1;
    if (p !== null) switch (p.type) {
      case 3:
        return !l;
      case 4:
        return l === !1;
      case 5:
        return isNaN(l);
      case 6:
        return isNaN(l) || 1 > l;
    }
    return !1;
  }
  function M(s, l, p, y, _, T, O) {
    this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = y, this.attributeNamespace = _, this.mustUseProperty = p, this.propertyName = s, this.type = l, this.sanitizeURL = T, this.removeEmptyString = O;
  }
  var A = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s) {
    A[s] = new M(s, 0, !1, s, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
    var l = s[0];
    A[l] = new M(l, 1, !1, s[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
    A[s] = new M(s, 2, !1, s.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
    A[s] = new M(s, 2, !1, s, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s) {
    A[s] = new M(s, 3, !1, s.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(s) {
    A[s] = new M(s, 3, !0, s, null, !1, !1);
  }), ["capture", "download"].forEach(function(s) {
    A[s] = new M(s, 4, !1, s, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(s) {
    A[s] = new M(s, 6, !1, s, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(s) {
    A[s] = new M(s, 5, !1, s.toLowerCase(), null, !1, !1);
  });
  var P = /[\-:]([a-z])/g;
  function N(s) {
    return s[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s) {
    var l = s.replace(
      P,
      N
    );
    A[l] = new M(l, 1, !1, s, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s) {
    var l = s.replace(P, N);
    A[l] = new M(l, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(s) {
    var l = s.replace(P, N);
    A[l] = new M(l, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(s) {
    A[s] = new M(s, 1, !1, s.toLowerCase(), null, !1, !1);
  }), A.xlinkHref = new M("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(s) {
    A[s] = new M(s, 1, !1, s.toLowerCase(), null, !0, !0);
  });
  function F(s, l, p, y) {
    var _ = A.hasOwnProperty(l) ? A[l] : null;
    (_ !== null ? _.type !== 0 : y || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (D(l, p, _, y) && (p = null), y || _ === null ? C(l) && (p === null ? s.removeAttribute(l) : s.setAttribute(l, "" + p)) : _.mustUseProperty ? s[_.propertyName] = p === null ? _.type === 3 ? !1 : "" : p : (l = _.attributeName, y = _.attributeNamespace, p === null ? s.removeAttribute(l) : (_ = _.type, p = _ === 3 || _ === 4 && p === !0 ? "" : "" + p, y ? s.setAttributeNS(y, l, p) : s.setAttribute(l, p))));
  }
  var B = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, V = Symbol.for("react.element"), G = Symbol.for("react.portal"), Y = Symbol.for("react.fragment"), K = Symbol.for("react.strict_mode"), ae = Symbol.for("react.profiler"), ie = Symbol.for("react.provider"), ee = Symbol.for("react.context"), oe = Symbol.for("react.forward_ref"), se = Symbol.for("react.suspense"), Pe = Symbol.for("react.suspense_list"), Te = Symbol.for("react.memo"), Se = Symbol.for("react.lazy"), Oe = Symbol.for("react.offscreen"), re = Symbol.iterator;
  function ge(s) {
    return s === null || typeof s != "object" ? null : (s = re && s[re] || s["@@iterator"], typeof s == "function" ? s : null);
  }
  var me = Object.assign, fe;
  function pe(s) {
    if (fe === void 0) try {
      throw Error();
    } catch (p) {
      var l = p.stack.trim().match(/\n( *(at )?)/);
      fe = l && l[1] || "";
    }
    return `
` + fe + s;
  }
  var Ae = !1;
  function Ne(s, l) {
    if (!s || Ae) return "";
    Ae = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (l) if (l = function() {
        throw Error();
      }, Object.defineProperty(l.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(l, []);
        } catch (te) {
          var y = te;
        }
        Reflect.construct(s, [], l);
      } else {
        try {
          l.call();
        } catch (te) {
          y = te;
        }
        s.call(l.prototype);
      }
      else {
        try {
          throw Error();
        } catch (te) {
          y = te;
        }
        s();
      }
    } catch (te) {
      if (te && y && typeof te.stack == "string") {
        for (var _ = te.stack.split(`
`), T = y.stack.split(`
`), O = _.length - 1, j = T.length - 1; 1 <= O && 0 <= j && _[O] !== T[j]; ) j--;
        for (; 1 <= O && 0 <= j; O--, j--) if (_[O] !== T[j]) {
          if (O !== 1 || j !== 1)
            do
              if (O--, j--, 0 > j || _[O] !== T[j]) {
                var U = `
` + _[O].replace(" at new ", " at ");
                return s.displayName && U.includes("<anonymous>") && (U = U.replace("<anonymous>", s.displayName)), U;
              }
            while (1 <= O && 0 <= j);
          break;
        }
      }
    } finally {
      Ae = !1, Error.prepareStackTrace = p;
    }
    return (s = s ? s.displayName || s.name : "") ? pe(s) : "";
  }
  function de(s) {
    switch (s.tag) {
      case 5:
        return pe(s.type);
      case 16:
        return pe("Lazy");
      case 13:
        return pe("Suspense");
      case 19:
        return pe("SuspenseList");
      case 0:
      case 2:
      case 15:
        return s = Ne(s.type, !1), s;
      case 11:
        return s = Ne(s.type.render, !1), s;
      case 1:
        return s = Ne(s.type, !0), s;
      default:
        return "";
    }
  }
  function ze(s) {
    if (s == null) return null;
    if (typeof s == "function") return s.displayName || s.name || null;
    if (typeof s == "string") return s;
    switch (s) {
      case Y:
        return "Fragment";
      case G:
        return "Portal";
      case ae:
        return "Profiler";
      case K:
        return "StrictMode";
      case se:
        return "Suspense";
      case Pe:
        return "SuspenseList";
    }
    if (typeof s == "object") switch (s.$$typeof) {
      case ee:
        return (s.displayName || "Context") + ".Consumer";
      case ie:
        return (s._context.displayName || "Context") + ".Provider";
      case oe:
        var l = s.render;
        return s = s.displayName, s || (s = l.displayName || l.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
      case Te:
        return l = s.displayName || null, l !== null ? l : ze(s.type) || "Memo";
      case Se:
        l = s._payload, s = s._init;
        try {
          return ze(s(l));
        } catch {
        }
    }
    return null;
  }
  function De(s) {
    var l = s.type;
    switch (s.tag) {
      case 24:
        return "Cache";
      case 9:
        return (l.displayName || "Context") + ".Consumer";
      case 10:
        return (l._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return s = l.render, s = s.displayName || s.name || "", l.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return l;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return ze(l);
      case 8:
        return l === K ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof l == "function") return l.displayName || l.name || null;
        if (typeof l == "string") return l;
    }
    return null;
  }
  function we(s) {
    switch (typeof s) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return s;
      case "object":
        return s;
      default:
        return "";
    }
  }
  function ct(s) {
    var l = s.type;
    return (s = s.nodeName) && s.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function gt(s) {
    var l = ct(s) ? "checked" : "value", p = Object.getOwnPropertyDescriptor(s.constructor.prototype, l), y = "" + s[l];
    if (!s.hasOwnProperty(l) && typeof p < "u" && typeof p.get == "function" && typeof p.set == "function") {
      var _ = p.get, T = p.set;
      return Object.defineProperty(s, l, { configurable: !0, get: function() {
        return _.call(this);
      }, set: function(O) {
        y = "" + O, T.call(this, O);
      } }), Object.defineProperty(s, l, { enumerable: p.enumerable }), { getValue: function() {
        return y;
      }, setValue: function(O) {
        y = "" + O;
      }, stopTracking: function() {
        s._valueTracker = null, delete s[l];
      } };
    }
  }
  function pt(s) {
    s._valueTracker || (s._valueTracker = gt(s));
  }
  function At(s) {
    if (!s) return !1;
    var l = s._valueTracker;
    if (!l) return !0;
    var p = l.getValue(), y = "";
    return s && (y = ct(s) ? s.checked ? "true" : "false" : s.value), s = y, s !== p ? (l.setValue(s), !0) : !1;
  }
  function xt(s) {
    if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
    try {
      return s.activeElement || s.body;
    } catch {
      return s.body;
    }
  }
  function tt(s, l) {
    var p = l.checked;
    return me({}, l, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: p ?? s._wrapperState.initialChecked });
  }
  function Et(s, l) {
    var p = l.defaultValue == null ? "" : l.defaultValue, y = l.checked != null ? l.checked : l.defaultChecked;
    p = we(l.value != null ? l.value : p), s._wrapperState = { initialChecked: y, initialValue: p, controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null };
  }
  function Wt(s, l) {
    l = l.checked, l != null && F(s, "checked", l, !1);
  }
  function on(s, l) {
    Wt(s, l);
    var p = we(l.value), y = l.type;
    if (p != null) y === "number" ? (p === 0 && s.value === "" || s.value != p) && (s.value = "" + p) : s.value !== "" + p && (s.value = "" + p);
    else if (y === "submit" || y === "reset") {
      s.removeAttribute("value");
      return;
    }
    l.hasOwnProperty("value") ? Yt(s, l.type, p) : l.hasOwnProperty("defaultValue") && Yt(s, l.type, we(l.defaultValue)), l.checked == null && l.defaultChecked != null && (s.defaultChecked = !!l.defaultChecked);
  }
  function ln(s, l, p) {
    if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
      var y = l.type;
      if (!(y !== "submit" && y !== "reset" || l.value !== void 0 && l.value !== null)) return;
      l = "" + s._wrapperState.initialValue, p || l === s.value || (s.value = l), s.defaultValue = l;
    }
    p = s.name, p !== "" && (s.name = ""), s.defaultChecked = !!s._wrapperState.initialChecked, p !== "" && (s.name = p);
  }
  function Yt(s, l, p) {
    (l !== "number" || xt(s.ownerDocument) !== s) && (p == null ? s.defaultValue = "" + s._wrapperState.initialValue : s.defaultValue !== "" + p && (s.defaultValue = "" + p));
  }
  var Xt = Array.isArray;
  function Dt(s, l, p, y) {
    if (s = s.options, l) {
      l = {};
      for (var _ = 0; _ < p.length; _++) l["$" + p[_]] = !0;
      for (p = 0; p < s.length; p++) _ = l.hasOwnProperty("$" + s[p].value), s[p].selected !== _ && (s[p].selected = _), _ && y && (s[p].defaultSelected = !0);
    } else {
      for (p = "" + we(p), l = null, _ = 0; _ < s.length; _++) {
        if (s[_].value === p) {
          s[_].selected = !0, y && (s[_].defaultSelected = !0);
          return;
        }
        l !== null || s[_].disabled || (l = s[_]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function Rt(s, l) {
    if (l.dangerouslySetInnerHTML != null) throw Error(i(91));
    return me({}, l, { value: void 0, defaultValue: void 0, children: "" + s._wrapperState.initialValue });
  }
  function Bt(s, l) {
    var p = l.value;
    if (p == null) {
      if (p = l.children, l = l.defaultValue, p != null) {
        if (l != null) throw Error(i(92));
        if (Xt(p)) {
          if (1 < p.length) throw Error(i(93));
          p = p[0];
        }
        l = p;
      }
      l == null && (l = ""), p = l;
    }
    s._wrapperState = { initialValue: we(p) };
  }
  function Dn(s, l) {
    var p = we(l.value), y = we(l.defaultValue);
    p != null && (p = "" + p, p !== s.value && (s.value = p), l.defaultValue == null && s.defaultValue !== p && (s.defaultValue = p)), y != null && (s.defaultValue = "" + y);
  }
  function An(s) {
    var l = s.textContent;
    l === s._wrapperState.initialValue && l !== "" && l !== null && (s.value = l);
  }
  function si(s) {
    switch (s) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Ki(s, l) {
    return s == null || s === "http://www.w3.org/1999/xhtml" ? si(l) : s === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s;
  }
  var wi, Ji = function(s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, p, y, _) {
      MSApp.execUnsafeLocalFunction(function() {
        return s(l, p, y, _);
      });
    } : s;
  }(function(s, l) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s) s.innerHTML = l;
    else {
      for (wi = wi || document.createElement("div"), wi.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = wi.firstChild; s.firstChild; ) s.removeChild(s.firstChild);
      for (; l.firstChild; ) s.appendChild(l.firstChild);
    }
  });
  function Le(s, l) {
    if (l) {
      var p = s.firstChild;
      if (p && p === s.lastChild && p.nodeType === 3) {
        p.nodeValue = l;
        return;
      }
    }
    s.textContent = l;
  }
  var nt = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Ct = ["Webkit", "ms", "Moz", "O"];
  Object.keys(nt).forEach(function(s) {
    Ct.forEach(function(l) {
      l = l + s.charAt(0).toUpperCase() + s.substring(1), nt[l] = nt[s];
    });
  });
  function Qt(s, l, p) {
    return l == null || typeof l == "boolean" || l === "" ? "" : p || typeof l != "number" || l === 0 || nt.hasOwnProperty(s) && nt[s] ? ("" + l).trim() : l + "px";
  }
  function Vt(s, l) {
    s = s.style;
    for (var p in l) if (l.hasOwnProperty(p)) {
      var y = p.indexOf("--") === 0, _ = Qt(p, l[p], y);
      p === "float" && (p = "cssFloat"), y ? s.setProperty(p, _) : s[p] = _;
    }
  }
  var In = me({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function dn(s, l) {
    if (l) {
      if (In[s] && (l.children != null || l.dangerouslySetInnerHTML != null)) throw Error(i(137, s));
      if (l.dangerouslySetInnerHTML != null) {
        if (l.children != null) throw Error(i(60));
        if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML)) throw Error(i(61));
      }
      if (l.style != null && typeof l.style != "object") throw Error(i(62));
    }
  }
  function _n(s, l) {
    if (s.indexOf("-") === -1) return typeof l.is == "string";
    switch (s) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Jt = null;
  function Gt(s) {
    return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s;
  }
  var qt = null, Mi = null, Ai = null;
  function He(s) {
    if (s = at(s)) {
      if (typeof qt != "function") throw Error(i(280));
      var l = s.stateNode;
      l && (l = qn(l), qt(s.stateNode, s.type, l));
    }
  }
  function Ve(s) {
    Mi ? Ai ? Ai.push(s) : Ai = [s] : Mi = s;
  }
  function Qe() {
    if (Mi) {
      var s = Mi, l = Ai;
      if (Ai = Mi = null, He(s), l) for (s = 0; s < l.length; s++) He(l[s]);
    }
  }
  function ft(s, l) {
    return s(l);
  }
  function ce() {
  }
  var ye = !1;
  function ke(s, l, p) {
    if (ye) return s(l, p);
    ye = !0;
    try {
      return ft(s, l, p);
    } finally {
      ye = !1, (Mi !== null || Ai !== null) && (ce(), Qe());
    }
  }
  function Ge(s, l) {
    var p = s.stateNode;
    if (p === null) return null;
    var y = qn(p);
    if (y === null) return null;
    p = y[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (y = !y.disabled) || (s = s.type, y = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !y;
        break e;
      default:
        s = !1;
    }
    if (s) return null;
    if (p && typeof p != "function") throw Error(i(231, l, typeof p));
    return p;
  }
  var yn = !1;
  if (h) try {
    var $n = {};
    Object.defineProperty($n, "passive", { get: function() {
      yn = !0;
    } }), window.addEventListener("test", $n, $n), window.removeEventListener("test", $n, $n);
  } catch {
    yn = !1;
  }
  function wa(s, l, p, y, _, T, O, j, U) {
    var te = Array.prototype.slice.call(arguments, 3);
    try {
      l.apply(p, te);
    } catch (_e) {
      this.onError(_e);
    }
  }
  var Br = !1, Ta = null, Ea = !1, H = null, ve = { onError: function(s) {
    Br = !0, Ta = s;
  } };
  function Be(s, l, p, y, _, T, O, j, U) {
    Br = !1, Ta = null, wa.apply(ve, arguments);
  }
  function ot(s, l, p, y, _, T, O, j, U) {
    if (Be.apply(this, arguments), Br) {
      if (Br) {
        var te = Ta;
        Br = !1, Ta = null;
      } else throw Error(i(198));
      Ea || (Ea = !0, H = te);
    }
  }
  function lt(s) {
    var l = s, p = s;
    if (s.alternate) for (; l.return; ) l = l.return;
    else {
      s = l;
      do
        l = s, l.flags & 4098 && (p = l.return), s = l.return;
      while (s);
    }
    return l.tag === 3 ? p : null;
  }
  function wt(s) {
    if (s.tag === 13) {
      var l = s.memoizedState;
      if (l === null && (s = s.alternate, s !== null && (l = s.memoizedState)), l !== null) return l.dehydrated;
    }
    return null;
  }
  function Pt(s) {
    if (lt(s) !== s) throw Error(i(188));
  }
  function Ft(s) {
    var l = s.alternate;
    if (!l) {
      if (l = lt(s), l === null) throw Error(i(188));
      return l !== s ? null : s;
    }
    for (var p = s, y = l; ; ) {
      var _ = p.return;
      if (_ === null) break;
      var T = _.alternate;
      if (T === null) {
        if (y = _.return, y !== null) {
          p = y;
          continue;
        }
        break;
      }
      if (_.child === T.child) {
        for (T = _.child; T; ) {
          if (T === p) return Pt(_), s;
          if (T === y) return Pt(_), l;
          T = T.sibling;
        }
        throw Error(i(188));
      }
      if (p.return !== y.return) p = _, y = T;
      else {
        for (var O = !1, j = _.child; j; ) {
          if (j === p) {
            O = !0, p = _, y = T;
            break;
          }
          if (j === y) {
            O = !0, y = _, p = T;
            break;
          }
          j = j.sibling;
        }
        if (!O) {
          for (j = T.child; j; ) {
            if (j === p) {
              O = !0, p = T, y = _;
              break;
            }
            if (j === y) {
              O = !0, y = T, p = _;
              break;
            }
            j = j.sibling;
          }
          if (!O) throw Error(i(189));
        }
      }
      if (p.alternate !== y) throw Error(i(190));
    }
    if (p.tag !== 3) throw Error(i(188));
    return p.stateNode.current === p ? s : l;
  }
  function vi(s) {
    return s = Ft(s), s !== null ? On(s) : null;
  }
  function On(s) {
    if (s.tag === 5 || s.tag === 6) return s;
    for (s = s.child; s !== null; ) {
      var l = On(s);
      if (l !== null) return l;
      s = s.sibling;
    }
    return null;
  }
  var zn = e.unstable_scheduleCallback, er = e.unstable_cancelCallback, ys = e.unstable_shouldYield, bs = e.unstable_requestPaint, Ot = e.unstable_now, Lt = e.unstable_getCurrentPriorityLevel, xs = e.unstable_ImmediatePriority, uc = e.unstable_UserBlockingPriority, cc = e.unstable_NormalPriority, Nv = e.unstable_LowPriority, bp = e.unstable_IdlePriority, fc = null, Ra = null;
  function zv(s) {
    if (Ra && typeof Ra.onCommitFiberRoot == "function") try {
      Ra.onCommitFiberRoot(fc, s, void 0, (s.current.flags & 128) === 128);
    } catch {
    }
  }
  var Jr = Math.clz32 ? Math.clz32 : xp, yS = Math.log, bS = Math.LN2;
  function xp(s) {
    return s >>>= 0, s === 0 ? 32 : 31 - (yS(s) / bS | 0) | 0;
  }
  var eu = 64, Da = 4194304;
  function Wo(s) {
    switch (s & -s) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return s & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return s;
    }
  }
  function Yo(s, l) {
    var p = s.pendingLanes;
    if (p === 0) return 0;
    var y = 0, _ = s.suspendedLanes, T = s.pingedLanes, O = p & 268435455;
    if (O !== 0) {
      var j = O & ~_;
      j !== 0 ? y = Wo(j) : (T &= O, T !== 0 && (y = Wo(T)));
    } else O = p & ~_, O !== 0 ? y = Wo(O) : T !== 0 && (y = Wo(T));
    if (y === 0) return 0;
    if (l !== 0 && l !== y && !(l & _) && (_ = y & -y, T = l & -l, _ >= T || _ === 16 && (T & 4194240) !== 0)) return l;
    if (y & 4 && (y |= p & 16), l = s.entangledLanes, l !== 0) for (s = s.entanglements, l &= y; 0 < l; ) p = 31 - Jr(l), _ = 1 << p, y |= s[p], l &= ~_;
    return y;
  }
  function xS(s, l) {
    switch (s) {
      case 1:
      case 2:
      case 4:
        return l + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Sp(s, l) {
    for (var p = s.suspendedLanes, y = s.pingedLanes, _ = s.expirationTimes, T = s.pendingLanes; 0 < T; ) {
      var O = 31 - Jr(T), j = 1 << O, U = _[O];
      U === -1 ? (!(j & p) || j & y) && (_[O] = xS(j, l)) : U <= l && (s.expiredLanes |= j), T &= ~j;
    }
  }
  function _p(s) {
    return s = s.pendingLanes & -1073741825, s !== 0 ? s : s & 1073741824 ? 1073741824 : 0;
  }
  function qf() {
    var s = eu;
    return eu <<= 1, !(eu & 4194240) && (eu = 64), s;
  }
  function Cp(s) {
    for (var l = [], p = 0; 31 > p; p++) l.push(s);
    return l;
  }
  function Go(s, l, p) {
    s.pendingLanes |= l, l !== 536870912 && (s.suspendedLanes = 0, s.pingedLanes = 0), s = s.eventTimes, l = 31 - Jr(l), s[l] = p;
  }
  function SS(s, l) {
    var p = s.pendingLanes & ~l;
    s.pendingLanes = l, s.suspendedLanes = 0, s.pingedLanes = 0, s.expiredLanes &= l, s.mutableReadLanes &= l, s.entangledLanes &= l, l = s.entanglements;
    var y = s.eventTimes;
    for (s = s.expirationTimes; 0 < p; ) {
      var _ = 31 - Jr(p), T = 1 << _;
      l[_] = 0, y[_] = -1, s[_] = -1, p &= ~T;
    }
  }
  function Zf(s, l) {
    var p = s.entangledLanes |= l;
    for (s = s.entanglements; p; ) {
      var y = 31 - Jr(p), _ = 1 << y;
      _ & l | s[y] & l && (s[y] |= l), p &= ~_;
    }
  }
  var hn = 0;
  function wp(s) {
    return s &= -s, 1 < s ? 4 < s ? s & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var pn, Tp, Ep, kt, Rp, tr = !1, qs = [], ea = null, Zs = null, Wn = null, kn = /* @__PURE__ */ new Map(), dc = /* @__PURE__ */ new Map(), Oi = [], ta = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Ss(s, l) {
    switch (s) {
      case "focusin":
      case "focusout":
        ea = null;
        break;
      case "dragenter":
      case "dragleave":
        Zs = null;
        break;
      case "mouseover":
      case "mouseout":
        Wn = null;
        break;
      case "pointerover":
      case "pointerout":
        kn.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        dc.delete(l.pointerId);
    }
  }
  function hc(s, l, p, y, _, T) {
    return s === null || s.nativeEvent !== T ? (s = { blockedOn: l, domEventName: p, eventSystemFlags: y, nativeEvent: T, targetContainers: [_] }, l !== null && (l = at(l), l !== null && Tp(l)), s) : (s.eventSystemFlags |= y, l = s.targetContainers, _ !== null && l.indexOf(_) === -1 && l.push(_), s);
  }
  function Dp(s, l, p, y, _) {
    switch (l) {
      case "focusin":
        return ea = hc(ea, s, l, p, y, _), !0;
      case "dragenter":
        return Zs = hc(Zs, s, l, p, y, _), !0;
      case "mouseover":
        return Wn = hc(Wn, s, l, p, y, _), !0;
      case "pointerover":
        var T = _.pointerId;
        return kn.set(T, hc(kn.get(T) || null, s, l, p, y, _)), !0;
      case "gotpointercapture":
        return T = _.pointerId, dc.set(T, hc(dc.get(T) || null, s, l, p, y, _)), !0;
    }
    return !1;
  }
  function kp(s) {
    var l = il(s.target);
    if (l !== null) {
      var p = lt(l);
      if (p !== null) {
        if (l = p.tag, l === 13) {
          if (l = wt(p), l !== null) {
            s.blockedOn = l, Rp(s.priority, function() {
              Ep(p);
            });
            return;
          }
        } else if (l === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          s.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    s.blockedOn = null;
  }
  function pc(s) {
    if (s.blockedOn !== null) return !1;
    for (var l = s.targetContainers; 0 < l.length; ) {
      var p = ed(s.domEventName, s.eventSystemFlags, l[0], s.nativeEvent);
      if (p === null) {
        p = s.nativeEvent;
        var y = new p.constructor(p.type, p);
        Jt = y, p.target.dispatchEvent(y), Jt = null;
      } else return l = at(p), l !== null && Tp(l), s.blockedOn = p, !1;
      l.shift();
    }
    return !0;
  }
  function Fv(s, l, p) {
    pc(s) && p.delete(l);
  }
  function _S() {
    tr = !1, ea !== null && pc(ea) && (ea = null), Zs !== null && pc(Zs) && (Zs = null), Wn !== null && pc(Wn) && (Wn = null), kn.forEach(Fv), dc.forEach(Fv);
  }
  function mc(s, l) {
    s.blockedOn === l && (s.blockedOn = null, tr || (tr = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, _S)));
  }
  function Js(s) {
    function l(_) {
      return mc(_, s);
    }
    if (0 < qs.length) {
      mc(qs[0], s);
      for (var p = 1; p < qs.length; p++) {
        var y = qs[p];
        y.blockedOn === s && (y.blockedOn = null);
      }
    }
    for (ea !== null && mc(ea, s), Zs !== null && mc(Zs, s), Wn !== null && mc(Wn, s), kn.forEach(l), dc.forEach(l), p = 0; p < Oi.length; p++) y = Oi[p], y.blockedOn === s && (y.blockedOn = null);
    for (; 0 < Oi.length && (p = Oi[0], p.blockedOn === null); ) kp(p), p.blockedOn === null && Oi.shift();
  }
  var Ko = B.ReactCurrentBatchConfig, Xo = !0;
  function Vv(s, l, p, y) {
    var _ = hn, T = Ko.transition;
    Ko.transition = null;
    try {
      hn = 1, Jf(s, l, p, y);
    } finally {
      hn = _, Ko.transition = T;
    }
  }
  function jv(s, l, p, y) {
    var _ = hn, T = Ko.transition;
    Ko.transition = null;
    try {
      hn = 4, Jf(s, l, p, y);
    } finally {
      hn = _, Ko.transition = T;
    }
  }
  function Jf(s, l, p, y) {
    if (Xo) {
      var _ = ed(s, l, p, y);
      if (_ === null) yd(s, l, y, gc, p), Ss(s, y);
      else if (Dp(_, s, l, p, y)) y.stopPropagation();
      else if (Ss(s, y), l & 4 && -1 < ta.indexOf(s)) {
        for (; _ !== null; ) {
          var T = at(_);
          if (T !== null && pn(T), T = ed(s, l, p, y), T === null && yd(s, l, y, gc, p), T === _) break;
          _ = T;
        }
        _ !== null && y.stopPropagation();
      } else yd(s, l, y, null, p);
    }
  }
  var gc = null;
  function ed(s, l, p, y) {
    if (gc = null, s = Gt(y), s = il(s), s !== null) if (l = lt(s), l === null) s = null;
    else if (p = l.tag, p === 13) {
      if (s = wt(l), s !== null) return s;
      s = null;
    } else if (p === 3) {
      if (l.stateNode.current.memoizedState.isDehydrated) return l.tag === 3 ? l.stateNode.containerInfo : null;
      s = null;
    } else l !== s && (s = null);
    return gc = s, null;
  }
  function td(s) {
    switch (s) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Lt()) {
          case xs:
            return 1;
          case uc:
            return 4;
          case cc:
          case Nv:
            return 16;
          case bp:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var _s = null, nd = null, tu = null;
  function Mp() {
    if (tu) return tu;
    var s, l = nd, p = l.length, y, _ = "value" in _s ? _s.value : _s.textContent, T = _.length;
    for (s = 0; s < p && l[s] === _[s]; s++) ;
    var O = p - s;
    for (y = 1; y <= O && l[p - y] === _[T - y]; y++) ;
    return tu = _.slice(s, 1 < y ? 1 - y : void 0);
  }
  function id(s) {
    var l = s.keyCode;
    return "charCode" in s ? (s = s.charCode, s === 0 && l === 13 && (s = 13)) : s = l, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0;
  }
  function rd() {
    return !0;
  }
  function ad() {
    return !1;
  }
  function yr(s) {
    function l(p, y, _, T, O) {
      this._reactName = p, this._targetInst = _, this.type = y, this.nativeEvent = T, this.target = O, this.currentTarget = null;
      for (var j in s) s.hasOwnProperty(j) && (p = s[j], this[j] = p ? p(T) : T[j]);
      return this.isDefaultPrevented = (T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1) ? rd : ad, this.isPropagationStopped = ad, this;
    }
    return me(l.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var p = this.nativeEvent;
      p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = rd);
    }, stopPropagation: function() {
      var p = this.nativeEvent;
      p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = rd);
    }, persist: function() {
    }, isPersistent: rd }), l;
  }
  var Qo = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(s) {
    return s.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, sd = yr(Qo), nu = me({}, Qo, { view: 0, detail: 0 }), CS = yr(nu), Ap, Pi, qo, vc = me({}, nu, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zp, button: 0, buttons: 0, relatedTarget: function(s) {
    return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget;
  }, movementX: function(s) {
    return "movementX" in s ? s.movementX : (s !== qo && (qo && s.type === "mousemove" ? (Ap = s.screenX - qo.screenX, Pi = s.screenY - qo.screenY) : Pi = Ap = 0, qo = s), Ap);
  }, movementY: function(s) {
    return "movementY" in s ? s.movementY : Pi;
  } }), Op = yr(vc), wS = me({}, vc, { dataTransfer: 0 }), iu = yr(wS), Pp = me({}, nu, { relatedTarget: 0 }), od = yr(Pp), TS = me({}, Qo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), ES = yr(TS), RS = me({}, Qo, { clipboardData: function(s) {
    return "clipboardData" in s ? s.clipboardData : window.clipboardData;
  } }), Bv = yr(RS), Lp = me({}, Qo, { data: 0 }), Np = yr(Lp), Hv = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Uv = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, DS = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Cs(s) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(s) : (s = DS[s]) ? !!l[s] : !1;
  }
  function zp() {
    return Cs;
  }
  var Fp = me({}, nu, { key: function(s) {
    if (s.key) {
      var l = Hv[s.key] || s.key;
      if (l !== "Unidentified") return l;
    }
    return s.type === "keypress" ? (s = id(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? Uv[s.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zp, charCode: function(s) {
    return s.type === "keypress" ? id(s) : 0;
  }, keyCode: function(s) {
    return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
  }, which: function(s) {
    return s.type === "keypress" ? id(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
  } }), Vp = yr(Fp), jp = me({}, vc, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Iv = yr(jp), ld = me({}, nu, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zp }), $v = yr(ld), br = me({}, Qo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), ws = yr(br), oi = me({}, vc, {
    deltaX: function(s) {
      return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
    },
    deltaY: function(s) {
      return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Ts = yr(oi), Bp = [9, 13, 27, 32], ru = h && "CompositionEvent" in window, yc = null;
  h && "documentMode" in document && (yc = document.documentMode);
  var bc = h && "TextEvent" in window && !yc, Wv = h && (!ru || yc && 8 < yc && 11 >= yc), Yv = " ", ud = !1;
  function Gv(s, l) {
    switch (s) {
      case "keyup":
        return Bp.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Kv(s) {
    return s = s.detail, typeof s == "object" && "data" in s ? s.data : null;
  }
  var au = !1;
  function Xv(s, l) {
    switch (s) {
      case "compositionend":
        return Kv(l);
      case "keypress":
        return l.which !== 32 ? null : (ud = !0, Yv);
      case "textInput":
        return s = l.data, s === Yv && ud ? null : s;
      default:
        return null;
    }
  }
  function kS(s, l) {
    if (au) return s === "compositionend" || !ru && Gv(s, l) ? (s = Mp(), tu = nd = _s = null, au = !1, s) : null;
    switch (s) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length) return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return Wv && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var MS = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Qv(s) {
    var l = s && s.nodeName && s.nodeName.toLowerCase();
    return l === "input" ? !!MS[s.type] : l === "textarea";
  }
  function Hp(s, l, p, y) {
    Ve(y), l = Tc(l, "onChange"), 0 < l.length && (p = new sd("onChange", "change", null, p, y), s.push({ event: p, listeners: l }));
  }
  var Ga = null, Zo = null;
  function qv(s) {
    tl(s, 0);
  }
  function xc(s) {
    var l = Ma(s);
    if (At(l)) return s;
  }
  function AS(s, l) {
    if (s === "change") return l;
  }
  var Zv = !1;
  if (h) {
    var Up;
    if (h) {
      var Ip = "oninput" in document;
      if (!Ip) {
        var Jv = document.createElement("div");
        Jv.setAttribute("oninput", "return;"), Ip = typeof Jv.oninput == "function";
      }
      Up = Ip;
    } else Up = !1;
    Zv = Up && (!document.documentMode || 9 < document.documentMode);
  }
  function ey() {
    Ga && (Ga.detachEvent("onpropertychange", ty), Zo = Ga = null);
  }
  function ty(s) {
    if (s.propertyName === "value" && xc(Zo)) {
      var l = [];
      Hp(l, Zo, s, Gt(s)), ke(qv, l);
    }
  }
  function OS(s, l, p) {
    s === "focusin" ? (ey(), Ga = l, Zo = p, Ga.attachEvent("onpropertychange", ty)) : s === "focusout" && ey();
  }
  function ny(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown") return xc(Zo);
  }
  function PS(s, l) {
    if (s === "click") return xc(l);
  }
  function iy(s, l) {
    if (s === "input" || s === "change") return xc(l);
  }
  function LS(s, l) {
    return s === l && (s !== 0 || 1 / s === 1 / l) || s !== s && l !== l;
  }
  var ka = typeof Object.is == "function" ? Object.is : LS;
  function Sc(s, l) {
    if (ka(s, l)) return !0;
    if (typeof s != "object" || s === null || typeof l != "object" || l === null) return !1;
    var p = Object.keys(s), y = Object.keys(l);
    if (p.length !== y.length) return !1;
    for (y = 0; y < p.length; y++) {
      var _ = p[y];
      if (!m.call(l, _) || !ka(s[_], l[_])) return !1;
    }
    return !0;
  }
  function ry(s) {
    for (; s && s.firstChild; ) s = s.firstChild;
    return s;
  }
  function cd(s, l) {
    var p = ry(s);
    s = 0;
    for (var y; p; ) {
      if (p.nodeType === 3) {
        if (y = s + p.textContent.length, s <= l && y >= l) return { node: p, offset: l - s };
        s = y;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = ry(p);
    }
  }
  function eo(s, l) {
    return s && l ? s === l ? !0 : s && s.nodeType === 3 ? !1 : l && l.nodeType === 3 ? eo(s, l.parentNode) : "contains" in s ? s.contains(l) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function _c() {
    for (var s = window, l = xt(); l instanceof s.HTMLIFrameElement; ) {
      try {
        var p = typeof l.contentWindow.location.href == "string";
      } catch {
        p = !1;
      }
      if (p) s = l.contentWindow;
      else break;
      l = xt(s.document);
    }
    return l;
  }
  function fd(s) {
    var l = s && s.nodeName && s.nodeName.toLowerCase();
    return l && (l === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || l === "textarea" || s.contentEditable === "true");
  }
  function su(s) {
    var l = _c(), p = s.focusedElem, y = s.selectionRange;
    if (l !== p && p && p.ownerDocument && eo(p.ownerDocument.documentElement, p)) {
      if (y !== null && fd(p)) {
        if (l = y.start, s = y.end, s === void 0 && (s = l), "selectionStart" in p) p.selectionStart = l, p.selectionEnd = Math.min(s, p.value.length);
        else if (s = (l = p.ownerDocument || document) && l.defaultView || window, s.getSelection) {
          s = s.getSelection();
          var _ = p.textContent.length, T = Math.min(y.start, _);
          y = y.end === void 0 ? T : Math.min(y.end, _), !s.extend && T > y && (_ = y, y = T, T = _), _ = cd(p, T);
          var O = cd(
            p,
            y
          );
          _ && O && (s.rangeCount !== 1 || s.anchorNode !== _.node || s.anchorOffset !== _.offset || s.focusNode !== O.node || s.focusOffset !== O.offset) && (l = l.createRange(), l.setStart(_.node, _.offset), s.removeAllRanges(), T > y ? (s.addRange(l), s.extend(O.node, O.offset)) : (l.setEnd(O.node, O.offset), s.addRange(l)));
        }
      }
      for (l = [], s = p; s = s.parentNode; ) s.nodeType === 1 && l.push({ element: s, left: s.scrollLeft, top: s.scrollTop });
      for (typeof p.focus == "function" && p.focus(), p = 0; p < l.length; p++) s = l[p], s.element.scrollLeft = s.left, s.element.scrollTop = s.top;
    }
  }
  var NS = h && "documentMode" in document && 11 >= document.documentMode, ou = null, $p = null, Cc = null, Wp = !1;
  function Yp(s, l, p) {
    var y = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    Wp || ou == null || ou !== xt(y) || (y = ou, "selectionStart" in y && fd(y) ? y = { start: y.selectionStart, end: y.selectionEnd } : (y = (y.ownerDocument && y.ownerDocument.defaultView || window).getSelection(), y = { anchorNode: y.anchorNode, anchorOffset: y.anchorOffset, focusNode: y.focusNode, focusOffset: y.focusOffset }), Cc && Sc(Cc, y) || (Cc = y, y = Tc($p, "onSelect"), 0 < y.length && (l = new sd("onSelect", "select", null, l, p), s.push({ event: l, listeners: y }), l.target = ou)));
  }
  function dd(s, l) {
    var p = {};
    return p[s.toLowerCase()] = l.toLowerCase(), p["Webkit" + s] = "webkit" + l, p["Moz" + s] = "moz" + l, p;
  }
  var Jo = { animationend: dd("Animation", "AnimationEnd"), animationiteration: dd("Animation", "AnimationIteration"), animationstart: dd("Animation", "AnimationStart"), transitionend: dd("Transition", "TransitionEnd") }, Li = {}, Gp = {};
  h && (Gp = document.createElement("div").style, "AnimationEvent" in window || (delete Jo.animationend.animation, delete Jo.animationiteration.animation, delete Jo.animationstart.animation), "TransitionEvent" in window || delete Jo.transitionend.transition);
  function hd(s) {
    if (Li[s]) return Li[s];
    if (!Jo[s]) return s;
    var l = Jo[s], p;
    for (p in l) if (l.hasOwnProperty(p) && p in Gp) return Li[s] = l[p];
    return s;
  }
  var ay = hd("animationend"), sy = hd("animationiteration"), oy = hd("animationstart"), ly = hd("transitionend"), Kp = /* @__PURE__ */ new Map(), pd = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function na(s, l) {
    Kp.set(s, l), f(l, [s]);
  }
  for (var Xp = 0; Xp < pd.length; Xp++) {
    var el = pd[Xp], zS = el.toLowerCase(), FS = el[0].toUpperCase() + el.slice(1);
    na(zS, "on" + FS);
  }
  na(ay, "onAnimationEnd"), na(sy, "onAnimationIteration"), na(oy, "onAnimationStart"), na("dblclick", "onDoubleClick"), na("focusin", "onFocus"), na("focusout", "onBlur"), na(ly, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), f("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), f("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), f("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), f("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var wc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Qp = new Set("cancel close invalid load scroll toggle".split(" ").concat(wc));
  function md(s, l, p) {
    var y = s.type || "unknown-event";
    s.currentTarget = p, ot(y, l, void 0, s), s.currentTarget = null;
  }
  function tl(s, l) {
    l = (l & 4) !== 0;
    for (var p = 0; p < s.length; p++) {
      var y = s[p], _ = y.event;
      y = y.listeners;
      e: {
        var T = void 0;
        if (l) for (var O = y.length - 1; 0 <= O; O--) {
          var j = y[O], U = j.instance, te = j.currentTarget;
          if (j = j.listener, U !== T && _.isPropagationStopped()) break e;
          md(_, j, te), T = U;
        }
        else for (O = 0; O < y.length; O++) {
          if (j = y[O], U = j.instance, te = j.currentTarget, j = j.listener, U !== T && _.isPropagationStopped()) break e;
          md(_, j, te), T = U;
        }
      }
    }
    if (Ea) throw s = H, Ea = !1, H = null, s;
  }
  function un(s, l) {
    var p = l[Dc];
    p === void 0 && (p = l[Dc] = /* @__PURE__ */ new Set());
    var y = s + "__bubble";
    p.has(y) || (uy(l, s, 2, !1), p.add(y));
  }
  function gd(s, l, p) {
    var y = 0;
    l && (y |= 4), uy(p, s, y, l);
  }
  var vd = "_reactListening" + Math.random().toString(36).slice(2);
  function lu(s) {
    if (!s[vd]) {
      s[vd] = !0, a.forEach(function(p) {
        p !== "selectionchange" && (Qp.has(p) || gd(p, !1, s), gd(p, !0, s));
      });
      var l = s.nodeType === 9 ? s : s.ownerDocument;
      l === null || l[vd] || (l[vd] = !0, gd("selectionchange", !1, l));
    }
  }
  function uy(s, l, p, y) {
    switch (td(l)) {
      case 1:
        var _ = Vv;
        break;
      case 4:
        _ = jv;
        break;
      default:
        _ = Jf;
    }
    p = _.bind(null, l, p, s), _ = void 0, !yn || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (_ = !0), y ? _ !== void 0 ? s.addEventListener(l, p, { capture: !0, passive: _ }) : s.addEventListener(l, p, !0) : _ !== void 0 ? s.addEventListener(l, p, { passive: _ }) : s.addEventListener(l, p, !1);
  }
  function yd(s, l, p, y, _) {
    var T = y;
    if (!(l & 1) && !(l & 2) && y !== null) e: for (; ; ) {
      if (y === null) return;
      var O = y.tag;
      if (O === 3 || O === 4) {
        var j = y.stateNode.containerInfo;
        if (j === _ || j.nodeType === 8 && j.parentNode === _) break;
        if (O === 4) for (O = y.return; O !== null; ) {
          var U = O.tag;
          if ((U === 3 || U === 4) && (U = O.stateNode.containerInfo, U === _ || U.nodeType === 8 && U.parentNode === _)) return;
          O = O.return;
        }
        for (; j !== null; ) {
          if (O = il(j), O === null) return;
          if (U = O.tag, U === 5 || U === 6) {
            y = T = O;
            continue e;
          }
          j = j.parentNode;
        }
      }
      y = y.return;
    }
    ke(function() {
      var te = T, _e = Gt(p), Ee = [];
      e: {
        var xe = Kp.get(s);
        if (xe !== void 0) {
          var We = sd, qe = s;
          switch (s) {
            case "keypress":
              if (id(p) === 0) break e;
            case "keydown":
            case "keyup":
              We = Vp;
              break;
            case "focusin":
              qe = "focus", We = od;
              break;
            case "focusout":
              qe = "blur", We = od;
              break;
            case "beforeblur":
            case "afterblur":
              We = od;
              break;
            case "click":
              if (p.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              We = Op;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              We = iu;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              We = $v;
              break;
            case ay:
            case sy:
            case oy:
              We = ES;
              break;
            case ly:
              We = ws;
              break;
            case "scroll":
              We = CS;
              break;
            case "wheel":
              We = Ts;
              break;
            case "copy":
            case "cut":
            case "paste":
              We = Bv;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              We = Iv;
          }
          var et = (l & 4) !== 0, ni = !et && s === "scroll", X = et ? xe !== null ? xe + "Capture" : null : xe;
          et = [];
          for (var $ = te, Z; $ !== null; ) {
            Z = $;
            var Ce = Z.stateNode;
            if (Z.tag === 5 && Ce !== null && (Z = Ce, X !== null && (Ce = Ge($, X), Ce != null && et.push(uu($, Ce, Z)))), ni) break;
            $ = $.return;
          }
          0 < et.length && (xe = new We(xe, qe, null, p, _e), Ee.push({ event: xe, listeners: et }));
        }
      }
      if (!(l & 7)) {
        e: {
          if (xe = s === "mouseover" || s === "pointerover", We = s === "mouseout" || s === "pointerout", xe && p !== Jt && (qe = p.relatedTarget || p.fromElement) && (il(qe) || qe[Es])) break e;
          if ((We || xe) && (xe = _e.window === _e ? _e : (xe = _e.ownerDocument) ? xe.defaultView || xe.parentWindow : window, We ? (qe = p.relatedTarget || p.toElement, We = te, qe = qe ? il(qe) : null, qe !== null && (ni = lt(qe), qe !== ni || qe.tag !== 5 && qe.tag !== 6) && (qe = null)) : (We = null, qe = te), We !== qe)) {
            if (et = Op, Ce = "onMouseLeave", X = "onMouseEnter", $ = "mouse", (s === "pointerout" || s === "pointerover") && (et = Iv, Ce = "onPointerLeave", X = "onPointerEnter", $ = "pointer"), ni = We == null ? xe : Ma(We), Z = qe == null ? xe : Ma(qe), xe = new et(Ce, $ + "leave", We, p, _e), xe.target = ni, xe.relatedTarget = Z, Ce = null, il(_e) === te && (et = new et(X, $ + "enter", qe, p, _e), et.target = Z, et.relatedTarget = ni, Ce = et), ni = Ce, We && qe) t: {
              for (et = We, X = qe, $ = 0, Z = et; Z; Z = to(Z)) $++;
              for (Z = 0, Ce = X; Ce; Ce = to(Ce)) Z++;
              for (; 0 < $ - Z; ) et = to(et), $--;
              for (; 0 < Z - $; ) X = to(X), Z--;
              for (; $--; ) {
                if (et === X || X !== null && et === X.alternate) break t;
                et = to(et), X = to(X);
              }
              et = null;
            }
            else et = null;
            We !== null && cy(Ee, xe, We, et, !1), qe !== null && ni !== null && cy(Ee, ni, qe, et, !0);
          }
        }
        e: {
          if (xe = te ? Ma(te) : window, We = xe.nodeName && xe.nodeName.toLowerCase(), We === "select" || We === "input" && xe.type === "file") var Ze = AS;
          else if (Qv(xe)) if (Zv) Ze = iy;
          else {
            Ze = ny;
            var dt = OS;
          }
          else (We = xe.nodeName) && We.toLowerCase() === "input" && (xe.type === "checkbox" || xe.type === "radio") && (Ze = PS);
          if (Ze && (Ze = Ze(s, te))) {
            Hp(Ee, Ze, p, _e);
            break e;
          }
          dt && dt(s, xe, te), s === "focusout" && (dt = xe._wrapperState) && dt.controlled && xe.type === "number" && Yt(xe, "number", xe.value);
        }
        switch (dt = te ? Ma(te) : window, s) {
          case "focusin":
            (Qv(dt) || dt.contentEditable === "true") && (ou = dt, $p = te, Cc = null);
            break;
          case "focusout":
            Cc = $p = ou = null;
            break;
          case "mousedown":
            Wp = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Wp = !1, Yp(Ee, p, _e);
            break;
          case "selectionchange":
            if (NS) break;
          case "keydown":
          case "keyup":
            Yp(Ee, p, _e);
        }
        var ht;
        if (ru) e: {
          switch (s) {
            case "compositionstart":
              var yt = "onCompositionStart";
              break e;
            case "compositionend":
              yt = "onCompositionEnd";
              break e;
            case "compositionupdate":
              yt = "onCompositionUpdate";
              break e;
          }
          yt = void 0;
        }
        else au ? Gv(s, p) && (yt = "onCompositionEnd") : s === "keydown" && p.keyCode === 229 && (yt = "onCompositionStart");
        yt && (Wv && p.locale !== "ko" && (au || yt !== "onCompositionStart" ? yt === "onCompositionEnd" && au && (ht = Mp()) : (_s = _e, nd = "value" in _s ? _s.value : _s.textContent, au = !0)), dt = Tc(te, yt), 0 < dt.length && (yt = new Np(yt, s, null, p, _e), Ee.push({ event: yt, listeners: dt }), ht ? yt.data = ht : (ht = Kv(p), ht !== null && (yt.data = ht)))), (ht = bc ? Xv(s, p) : kS(s, p)) && (te = Tc(te, "onBeforeInput"), 0 < te.length && (_e = new Np("onBeforeInput", "beforeinput", null, p, _e), Ee.push({ event: _e, listeners: te }), _e.data = ht));
      }
      tl(Ee, l);
    });
  }
  function uu(s, l, p) {
    return { instance: s, listener: l, currentTarget: p };
  }
  function Tc(s, l) {
    for (var p = l + "Capture", y = []; s !== null; ) {
      var _ = s, T = _.stateNode;
      _.tag === 5 && T !== null && (_ = T, T = Ge(s, p), T != null && y.unshift(uu(s, T, _)), T = Ge(s, l), T != null && y.push(uu(s, T, _))), s = s.return;
    }
    return y;
  }
  function to(s) {
    if (s === null) return null;
    do
      s = s.return;
    while (s && s.tag !== 5);
    return s || null;
  }
  function cy(s, l, p, y, _) {
    for (var T = l._reactName, O = []; p !== null && p !== y; ) {
      var j = p, U = j.alternate, te = j.stateNode;
      if (U !== null && U === y) break;
      j.tag === 5 && te !== null && (j = te, _ ? (U = Ge(p, T), U != null && O.unshift(uu(p, U, j))) : _ || (U = Ge(p, T), U != null && O.push(uu(p, U, j)))), p = p.return;
    }
    O.length !== 0 && s.push({ event: l, listeners: O });
  }
  var fy = /\r\n?/g, VS = /\u0000|\uFFFD/g;
  function dy(s) {
    return (typeof s == "string" ? s : "" + s).replace(fy, `
`).replace(VS, "");
  }
  function bd(s, l, p) {
    if (l = dy(l), dy(s) !== l && p) throw Error(i(425));
  }
  function no() {
  }
  var Ec = null, nl = null;
  function xd(s, l) {
    return s === "textarea" || s === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var Sd = typeof setTimeout == "function" ? setTimeout : void 0, qp = typeof clearTimeout == "function" ? clearTimeout : void 0, hy = typeof Promise == "function" ? Promise : void 0, cu = typeof queueMicrotask == "function" ? queueMicrotask : typeof hy < "u" ? function(s) {
    return hy.resolve(null).then(s).catch(_d);
  } : Sd;
  function _d(s) {
    setTimeout(function() {
      throw s;
    });
  }
  function fu(s, l) {
    var p = l, y = 0;
    do {
      var _ = p.nextSibling;
      if (s.removeChild(p), _ && _.nodeType === 8) if (p = _.data, p === "/$") {
        if (y === 0) {
          s.removeChild(_), Js(l);
          return;
        }
        y--;
      } else p !== "$" && p !== "$?" && p !== "$!" || y++;
      p = _;
    } while (p);
    Js(l);
  }
  function Ka(s) {
    for (; s != null; s = s.nextSibling) {
      var l = s.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (l = s.data, l === "$" || l === "$!" || l === "$?") break;
        if (l === "/$") return null;
      }
    }
    return s;
  }
  function py(s) {
    s = s.previousSibling;
    for (var l = 0; s; ) {
      if (s.nodeType === 8) {
        var p = s.data;
        if (p === "$" || p === "$!" || p === "$?") {
          if (l === 0) return s;
          l--;
        } else p === "/$" && l++;
      }
      s = s.previousSibling;
    }
    return null;
  }
  var io = Math.random().toString(36).slice(2), Xa = "__reactFiber$" + io, Rc = "__reactProps$" + io, Es = "__reactContainer$" + io, Dc = "__reactEvents$" + io, du = "__reactListeners$" + io, jS = "__reactHandles$" + io;
  function il(s) {
    var l = s[Xa];
    if (l) return l;
    for (var p = s.parentNode; p; ) {
      if (l = p[Es] || p[Xa]) {
        if (p = l.alternate, l.child !== null || p !== null && p.child !== null) for (s = py(s); s !== null; ) {
          if (p = s[Xa]) return p;
          s = py(s);
        }
        return l;
      }
      s = p, p = s.parentNode;
    }
    return null;
  }
  function at(s) {
    return s = s[Xa] || s[Es], !s || s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3 ? null : s;
  }
  function Ma(s) {
    if (s.tag === 5 || s.tag === 6) return s.stateNode;
    throw Error(i(33));
  }
  function qn(s) {
    return s[Rc] || null;
  }
  var Ht = [], ia = -1;
  function Aa(s) {
    return { current: s };
  }
  function Cn(s) {
    0 > ia || (s.current = Ht[ia], Ht[ia] = null, ia--);
  }
  function rt(s, l) {
    ia++, Ht[ia] = s.current, s.current = l;
  }
  var xr = {}, Yn = Aa(xr), yi = Aa(!1), Sr = xr;
  function ra(s, l) {
    var p = s.type.contextTypes;
    if (!p) return xr;
    var y = s.stateNode;
    if (y && y.__reactInternalMemoizedUnmaskedChildContext === l) return y.__reactInternalMemoizedMaskedChildContext;
    var _ = {}, T;
    for (T in p) _[T] = l[T];
    return y && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = l, s.__reactInternalMemoizedMaskedChildContext = _), _;
  }
  function li(s) {
    return s = s.childContextTypes, s != null;
  }
  function hu() {
    Cn(yi), Cn(Yn);
  }
  function my(s, l, p) {
    if (Yn.current !== xr) throw Error(i(168));
    rt(Yn, l), rt(yi, p);
  }
  function kc(s, l, p) {
    var y = s.stateNode;
    if (l = l.childContextTypes, typeof y.getChildContext != "function") return p;
    y = y.getChildContext();
    for (var _ in y) if (!(_ in l)) throw Error(i(108, De(s) || "Unknown", _));
    return me({}, p, y);
  }
  function _r(s) {
    return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || xr, Sr = Yn.current, rt(Yn, s), rt(yi, yi.current), !0;
  }
  function Cd(s, l, p) {
    var y = s.stateNode;
    if (!y) throw Error(i(169));
    p ? (s = kc(s, l, Sr), y.__reactInternalMemoizedMergedChildContext = s, Cn(yi), Cn(Yn), rt(Yn, s)) : Cn(yi), rt(yi, p);
  }
  var Qa = null, pu = !1, Rs = !1;
  function wd(s) {
    Qa === null ? Qa = [s] : Qa.push(s);
  }
  function ro(s) {
    pu = !0, wd(s);
  }
  function qa() {
    if (!Rs && Qa !== null) {
      Rs = !0;
      var s = 0, l = hn;
      try {
        var p = Qa;
        for (hn = 1; s < p.length; s++) {
          var y = p[s];
          do
            y = y(!0);
          while (y !== null);
        }
        Qa = null, pu = !1;
      } catch (_) {
        throw Qa !== null && (Qa = Qa.slice(s + 1)), zn(xs, qa), _;
      } finally {
        hn = l, Rs = !1;
      }
    }
    return null;
  }
  var ao = [], so = 0, oo = null, Ds = 0, ui = [], aa = 0, Hr = null, Za = 1, Ja = "";
  function rl(s, l) {
    ao[so++] = Ds, ao[so++] = oo, oo = s, Ds = l;
  }
  function gy(s, l, p) {
    ui[aa++] = Za, ui[aa++] = Ja, ui[aa++] = Hr, Hr = s;
    var y = Za;
    s = Ja;
    var _ = 32 - Jr(y) - 1;
    y &= ~(1 << _), p += 1;
    var T = 32 - Jr(l) + _;
    if (30 < T) {
      var O = _ - _ % 5;
      T = (y & (1 << O) - 1).toString(32), y >>= O, _ -= O, Za = 1 << 32 - Jr(l) + _ | p << _ | y, Ja = T + s;
    } else Za = 1 << T | p << _ | y, Ja = s;
  }
  function Td(s) {
    s.return !== null && (rl(s, 1), gy(s, 1, 0));
  }
  function Ed(s) {
    for (; s === oo; ) oo = ao[--so], ao[so] = null, Ds = ao[--so], ao[so] = null;
    for (; s === Hr; ) Hr = ui[--aa], ui[aa] = null, Ja = ui[--aa], ui[aa] = null, Za = ui[--aa], ui[aa] = null;
  }
  var Cr = null, wr = null, Pn = !1, sa = null;
  function Zp(s, l) {
    var p = fa(5, null, null, 0);
    p.elementType = "DELETED", p.stateNode = l, p.return = s, l = s.deletions, l === null ? (s.deletions = [p], s.flags |= 16) : l.push(p);
  }
  function vy(s, l) {
    switch (s.tag) {
      case 5:
        var p = s.type;
        return l = l.nodeType !== 1 || p.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (s.stateNode = l, Cr = s, wr = Ka(l.firstChild), !0) : !1;
      case 6:
        return l = s.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (s.stateNode = l, Cr = s, wr = null, !0) : !1;
      case 13:
        return l = l.nodeType !== 8 ? null : l, l !== null ? (p = Hr !== null ? { id: Za, overflow: Ja } : null, s.memoizedState = { dehydrated: l, treeContext: p, retryLane: 1073741824 }, p = fa(18, null, null, 0), p.stateNode = l, p.return = s, s.child = p, Cr = s, wr = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Jp(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0;
  }
  function em(s) {
    if (Pn) {
      var l = wr;
      if (l) {
        var p = l;
        if (!vy(s, l)) {
          if (Jp(s)) throw Error(i(418));
          l = Ka(p.nextSibling);
          var y = Cr;
          l && vy(s, l) ? Zp(y, p) : (s.flags = s.flags & -4097 | 2, Pn = !1, Cr = s);
        }
      } else {
        if (Jp(s)) throw Error(i(418));
        s.flags = s.flags & -4097 | 2, Pn = !1, Cr = s;
      }
    }
  }
  function bi(s) {
    for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; ) s = s.return;
    Cr = s;
  }
  function Rd(s) {
    if (s !== Cr) return !1;
    if (!Pn) return bi(s), Pn = !0, !1;
    var l;
    if ((l = s.tag !== 3) && !(l = s.tag !== 5) && (l = s.type, l = l !== "head" && l !== "body" && !xd(s.type, s.memoizedProps)), l && (l = wr)) {
      if (Jp(s)) throw Mc(), Error(i(418));
      for (; l; ) Zp(s, l), l = Ka(l.nextSibling);
    }
    if (bi(s), s.tag === 13) {
      if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(i(317));
      e: {
        for (s = s.nextSibling, l = 0; s; ) {
          if (s.nodeType === 8) {
            var p = s.data;
            if (p === "/$") {
              if (l === 0) {
                wr = Ka(s.nextSibling);
                break e;
              }
              l--;
            } else p !== "$" && p !== "$!" && p !== "$?" || l++;
          }
          s = s.nextSibling;
        }
        wr = null;
      }
    } else wr = Cr ? Ka(s.stateNode.nextSibling) : null;
    return !0;
  }
  function Mc() {
    for (var s = wr; s; ) s = Ka(s.nextSibling);
  }
  function lo() {
    wr = Cr = null, Pn = !1;
  }
  function ks(s) {
    sa === null ? sa = [s] : sa.push(s);
  }
  var BS = B.ReactCurrentBatchConfig;
  function al(s, l, p) {
    if (s = p.ref, s !== null && typeof s != "function" && typeof s != "object") {
      if (p._owner) {
        if (p = p._owner, p) {
          if (p.tag !== 1) throw Error(i(309));
          var y = p.stateNode;
        }
        if (!y) throw Error(i(147, s));
        var _ = y, T = "" + s;
        return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === T ? l.ref : (l = function(O) {
          var j = _.refs;
          O === null ? delete j[T] : j[T] = O;
        }, l._stringRef = T, l);
      }
      if (typeof s != "string") throw Error(i(284));
      if (!p._owner) throw Error(i(290, s));
    }
    return s;
  }
  function Dd(s, l) {
    throw s = Object.prototype.toString.call(l), Error(i(31, s === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : s));
  }
  function yy(s) {
    var l = s._init;
    return l(s._payload);
  }
  function sl(s) {
    function l(X, $) {
      if (s) {
        var Z = X.deletions;
        Z === null ? (X.deletions = [$], X.flags |= 16) : Z.push($);
      }
    }
    function p(X, $) {
      if (!s) return null;
      for (; $ !== null; ) l(X, $), $ = $.sibling;
      return null;
    }
    function y(X, $) {
      for (X = /* @__PURE__ */ new Map(); $ !== null; ) $.key !== null ? X.set($.key, $) : X.set($.index, $), $ = $.sibling;
      return X;
    }
    function _(X, $) {
      return X = vo(X, $), X.index = 0, X.sibling = null, X;
    }
    function T(X, $, Z) {
      return X.index = Z, s ? (Z = X.alternate, Z !== null ? (Z = Z.index, Z < $ ? (X.flags |= 2, $) : Z) : (X.flags |= 2, $)) : (X.flags |= 1048576, $);
    }
    function O(X) {
      return s && X.alternate === null && (X.flags |= 2), X;
    }
    function j(X, $, Z, Ce) {
      return $ === null || $.tag !== 6 ? ($ = Am(Z, X.mode, Ce), $.return = X, $) : ($ = _($, Z), $.return = X, $);
    }
    function U(X, $, Z, Ce) {
      var Ze = Z.type;
      return Ze === Y ? _e(X, $, Z.props.children, Ce, Z.key) : $ !== null && ($.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === Se && yy(Ze) === $.type) ? (Ce = _($, Z.props), Ce.ref = al(X, $, Z), Ce.return = X, Ce) : (Ce = of(Z.type, Z.key, Z.props, null, X.mode, Ce), Ce.ref = al(X, $, Z), Ce.return = X, Ce);
    }
    function te(X, $, Z, Ce) {
      return $ === null || $.tag !== 4 || $.stateNode.containerInfo !== Z.containerInfo || $.stateNode.implementation !== Z.implementation ? ($ = oh(Z, X.mode, Ce), $.return = X, $) : ($ = _($, Z.children || []), $.return = X, $);
    }
    function _e(X, $, Z, Ce, Ze) {
      return $ === null || $.tag !== 7 ? ($ = Ns(Z, X.mode, Ce, Ze), $.return = X, $) : ($ = _($, Z), $.return = X, $);
    }
    function Ee(X, $, Z) {
      if (typeof $ == "string" && $ !== "" || typeof $ == "number") return $ = Am("" + $, X.mode, Z), $.return = X, $;
      if (typeof $ == "object" && $ !== null) {
        switch ($.$$typeof) {
          case V:
            return Z = of($.type, $.key, $.props, null, X.mode, Z), Z.ref = al(X, null, $), Z.return = X, Z;
          case G:
            return $ = oh($, X.mode, Z), $.return = X, $;
          case Se:
            var Ce = $._init;
            return Ee(X, Ce($._payload), Z);
        }
        if (Xt($) || ge($)) return $ = Ns($, X.mode, Z, null), $.return = X, $;
        Dd(X, $);
      }
      return null;
    }
    function xe(X, $, Z, Ce) {
      var Ze = $ !== null ? $.key : null;
      if (typeof Z == "string" && Z !== "" || typeof Z == "number") return Ze !== null ? null : j(X, $, "" + Z, Ce);
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case V:
            return Z.key === Ze ? U(X, $, Z, Ce) : null;
          case G:
            return Z.key === Ze ? te(X, $, Z, Ce) : null;
          case Se:
            return Ze = Z._init, xe(
              X,
              $,
              Ze(Z._payload),
              Ce
            );
        }
        if (Xt(Z) || ge(Z)) return Ze !== null ? null : _e(X, $, Z, Ce, null);
        Dd(X, Z);
      }
      return null;
    }
    function We(X, $, Z, Ce, Ze) {
      if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number") return X = X.get(Z) || null, j($, X, "" + Ce, Ze);
      if (typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case V:
            return X = X.get(Ce.key === null ? Z : Ce.key) || null, U($, X, Ce, Ze);
          case G:
            return X = X.get(Ce.key === null ? Z : Ce.key) || null, te($, X, Ce, Ze);
          case Se:
            var dt = Ce._init;
            return We(X, $, Z, dt(Ce._payload), Ze);
        }
        if (Xt(Ce) || ge(Ce)) return X = X.get(Z) || null, _e($, X, Ce, Ze, null);
        Dd($, Ce);
      }
      return null;
    }
    function qe(X, $, Z, Ce) {
      for (var Ze = null, dt = null, ht = $, yt = $ = 0, Ri = null; ht !== null && yt < Z.length; yt++) {
        ht.index > yt ? (Ri = ht, ht = null) : Ri = ht.sibling;
        var nn = xe(X, ht, Z[yt], Ce);
        if (nn === null) {
          ht === null && (ht = Ri);
          break;
        }
        s && ht && nn.alternate === null && l(X, ht), $ = T(nn, $, yt), dt === null ? Ze = nn : dt.sibling = nn, dt = nn, ht = Ri;
      }
      if (yt === Z.length) return p(X, ht), Pn && rl(X, yt), Ze;
      if (ht === null) {
        for (; yt < Z.length; yt++) ht = Ee(X, Z[yt], Ce), ht !== null && ($ = T(ht, $, yt), dt === null ? Ze = ht : dt.sibling = ht, dt = ht);
        return Pn && rl(X, yt), Ze;
      }
      for (ht = y(X, ht); yt < Z.length; yt++) Ri = We(ht, X, yt, Z[yt], Ce), Ri !== null && (s && Ri.alternate !== null && ht.delete(Ri.key === null ? yt : Ri.key), $ = T(Ri, $, yt), dt === null ? Ze = Ri : dt.sibling = Ri, dt = Ri);
      return s && ht.forEach(function(xo) {
        return l(X, xo);
      }), Pn && rl(X, yt), Ze;
    }
    function et(X, $, Z, Ce) {
      var Ze = ge(Z);
      if (typeof Ze != "function") throw Error(i(150));
      if (Z = Ze.call(Z), Z == null) throw Error(i(151));
      for (var dt = Ze = null, ht = $, yt = $ = 0, Ri = null, nn = Z.next(); ht !== null && !nn.done; yt++, nn = Z.next()) {
        ht.index > yt ? (Ri = ht, ht = null) : Ri = ht.sibling;
        var xo = xe(X, ht, nn.value, Ce);
        if (xo === null) {
          ht === null && (ht = Ri);
          break;
        }
        s && ht && xo.alternate === null && l(X, ht), $ = T(xo, $, yt), dt === null ? Ze = xo : dt.sibling = xo, dt = xo, ht = Ri;
      }
      if (nn.done) return p(
        X,
        ht
      ), Pn && rl(X, yt), Ze;
      if (ht === null) {
        for (; !nn.done; yt++, nn = Z.next()) nn = Ee(X, nn.value, Ce), nn !== null && ($ = T(nn, $, yt), dt === null ? Ze = nn : dt.sibling = nn, dt = nn);
        return Pn && rl(X, yt), Ze;
      }
      for (ht = y(X, ht); !nn.done; yt++, nn = Z.next()) nn = We(ht, X, yt, nn.value, Ce), nn !== null && (s && nn.alternate !== null && ht.delete(nn.key === null ? yt : nn.key), $ = T(nn, $, yt), dt === null ? Ze = nn : dt.sibling = nn, dt = nn);
      return s && ht.forEach(function(e0) {
        return l(X, e0);
      }), Pn && rl(X, yt), Ze;
    }
    function ni(X, $, Z, Ce) {
      if (typeof Z == "object" && Z !== null && Z.type === Y && Z.key === null && (Z = Z.props.children), typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case V:
            e: {
              for (var Ze = Z.key, dt = $; dt !== null; ) {
                if (dt.key === Ze) {
                  if (Ze = Z.type, Ze === Y) {
                    if (dt.tag === 7) {
                      p(X, dt.sibling), $ = _(dt, Z.props.children), $.return = X, X = $;
                      break e;
                    }
                  } else if (dt.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === Se && yy(Ze) === dt.type) {
                    p(X, dt.sibling), $ = _(dt, Z.props), $.ref = al(X, dt, Z), $.return = X, X = $;
                    break e;
                  }
                  p(X, dt);
                  break;
                } else l(X, dt);
                dt = dt.sibling;
              }
              Z.type === Y ? ($ = Ns(Z.props.children, X.mode, Ce, Z.key), $.return = X, X = $) : (Ce = of(Z.type, Z.key, Z.props, null, X.mode, Ce), Ce.ref = al(X, $, Z), Ce.return = X, X = Ce);
            }
            return O(X);
          case G:
            e: {
              for (dt = Z.key; $ !== null; ) {
                if ($.key === dt) if ($.tag === 4 && $.stateNode.containerInfo === Z.containerInfo && $.stateNode.implementation === Z.implementation) {
                  p(X, $.sibling), $ = _($, Z.children || []), $.return = X, X = $;
                  break e;
                } else {
                  p(X, $);
                  break;
                }
                else l(X, $);
                $ = $.sibling;
              }
              $ = oh(Z, X.mode, Ce), $.return = X, X = $;
            }
            return O(X);
          case Se:
            return dt = Z._init, ni(X, $, dt(Z._payload), Ce);
        }
        if (Xt(Z)) return qe(X, $, Z, Ce);
        if (ge(Z)) return et(X, $, Z, Ce);
        Dd(X, Z);
      }
      return typeof Z == "string" && Z !== "" || typeof Z == "number" ? (Z = "" + Z, $ !== null && $.tag === 6 ? (p(X, $.sibling), $ = _($, Z), $.return = X, X = $) : (p(X, $), $ = Am(Z, X.mode, Ce), $.return = X, X = $), O(X)) : p(X, $);
    }
    return ni;
  }
  var Zn = sl(!0), Ue = sl(!1), Ur = Aa(null), Tr = null, mu = null, tm = null;
  function nm() {
    tm = mu = Tr = null;
  }
  function im(s) {
    var l = Ur.current;
    Cn(Ur), s._currentValue = l;
  }
  function rm(s, l, p) {
    for (; s !== null; ) {
      var y = s.alternate;
      if ((s.childLanes & l) !== l ? (s.childLanes |= l, y !== null && (y.childLanes |= l)) : y !== null && (y.childLanes & l) !== l && (y.childLanes |= l), s === p) break;
      s = s.return;
    }
  }
  function Fn(s, l) {
    Tr = s, tm = mu = null, s = s.dependencies, s !== null && s.firstContext !== null && (s.lanes & l && (fi = !0), s.firstContext = null);
  }
  function oa(s) {
    var l = s._currentValue;
    if (tm !== s) if (s = { context: s, memoizedValue: l, next: null }, mu === null) {
      if (Tr === null) throw Error(i(308));
      mu = s, Tr.dependencies = { lanes: 0, firstContext: s };
    } else mu = mu.next = s;
    return l;
  }
  var ol = null;
  function am(s) {
    ol === null ? ol = [s] : ol.push(s);
  }
  function sm(s, l, p, y) {
    var _ = l.interleaved;
    return _ === null ? (p.next = p, am(l)) : (p.next = _.next, _.next = p), l.interleaved = p, Ir(s, y);
  }
  function Ir(s, l) {
    s.lanes |= l;
    var p = s.alternate;
    for (p !== null && (p.lanes |= l), p = s, s = s.return; s !== null; ) s.childLanes |= l, p = s.alternate, p !== null && (p.childLanes |= l), p = s, s = s.return;
    return p.tag === 3 ? p.stateNode : null;
  }
  var $r = !1;
  function om(s) {
    s.updateQueue = { baseState: s.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function by(s, l) {
    s = s.updateQueue, l.updateQueue === s && (l.updateQueue = { baseState: s.baseState, firstBaseUpdate: s.firstBaseUpdate, lastBaseUpdate: s.lastBaseUpdate, shared: s.shared, effects: s.effects });
  }
  function Ms(s, l) {
    return { eventTime: s, lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function uo(s, l, p) {
    var y = s.updateQueue;
    if (y === null) return null;
    if (y = y.shared, Ut & 2) {
      var _ = y.pending;
      return _ === null ? l.next = l : (l.next = _.next, _.next = l), y.pending = l, Ir(s, p);
    }
    return _ = y.interleaved, _ === null ? (l.next = l, am(y)) : (l.next = _.next, _.next = l), y.interleaved = l, Ir(s, p);
  }
  function kd(s, l, p) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (p & 4194240) !== 0)) {
      var y = l.lanes;
      y &= s.pendingLanes, p |= y, l.lanes = p, Zf(s, p);
    }
  }
  function xy(s, l) {
    var p = s.updateQueue, y = s.alternate;
    if (y !== null && (y = y.updateQueue, p === y)) {
      var _ = null, T = null;
      if (p = p.firstBaseUpdate, p !== null) {
        do {
          var O = { eventTime: p.eventTime, lane: p.lane, tag: p.tag, payload: p.payload, callback: p.callback, next: null };
          T === null ? _ = T = O : T = T.next = O, p = p.next;
        } while (p !== null);
        T === null ? _ = T = l : T = T.next = l;
      } else _ = T = l;
      p = { baseState: y.baseState, firstBaseUpdate: _, lastBaseUpdate: T, shared: y.shared, effects: y.effects }, s.updateQueue = p;
      return;
    }
    s = p.lastBaseUpdate, s === null ? p.firstBaseUpdate = l : s.next = l, p.lastBaseUpdate = l;
  }
  function Ac(s, l, p, y) {
    var _ = s.updateQueue;
    $r = !1;
    var T = _.firstBaseUpdate, O = _.lastBaseUpdate, j = _.shared.pending;
    if (j !== null) {
      _.shared.pending = null;
      var U = j, te = U.next;
      U.next = null, O === null ? T = te : O.next = te, O = U;
      var _e = s.alternate;
      _e !== null && (_e = _e.updateQueue, j = _e.lastBaseUpdate, j !== O && (j === null ? _e.firstBaseUpdate = te : j.next = te, _e.lastBaseUpdate = U));
    }
    if (T !== null) {
      var Ee = _.baseState;
      O = 0, _e = te = U = null, j = T;
      do {
        var xe = j.lane, We = j.eventTime;
        if ((y & xe) === xe) {
          _e !== null && (_e = _e.next = {
            eventTime: We,
            lane: 0,
            tag: j.tag,
            payload: j.payload,
            callback: j.callback,
            next: null
          });
          e: {
            var qe = s, et = j;
            switch (xe = l, We = p, et.tag) {
              case 1:
                if (qe = et.payload, typeof qe == "function") {
                  Ee = qe.call(We, Ee, xe);
                  break e;
                }
                Ee = qe;
                break e;
              case 3:
                qe.flags = qe.flags & -65537 | 128;
              case 0:
                if (qe = et.payload, xe = typeof qe == "function" ? qe.call(We, Ee, xe) : qe, xe == null) break e;
                Ee = me({}, Ee, xe);
                break e;
              case 2:
                $r = !0;
            }
          }
          j.callback !== null && j.lane !== 0 && (s.flags |= 64, xe = _.effects, xe === null ? _.effects = [j] : xe.push(j));
        } else We = { eventTime: We, lane: xe, tag: j.tag, payload: j.payload, callback: j.callback, next: null }, _e === null ? (te = _e = We, U = Ee) : _e = _e.next = We, O |= xe;
        if (j = j.next, j === null) {
          if (j = _.shared.pending, j === null) break;
          xe = j, j = xe.next, xe.next = null, _.lastBaseUpdate = xe, _.shared.pending = null;
        }
      } while (!0);
      if (_e === null && (U = Ee), _.baseState = U, _.firstBaseUpdate = te, _.lastBaseUpdate = _e, l = _.shared.interleaved, l !== null) {
        _ = l;
        do
          O |= _.lane, _ = _.next;
        while (_ !== l);
      } else T === null && (_.shared.lanes = 0);
      rs |= O, s.lanes = O, s.memoizedState = Ee;
    }
  }
  function lm(s, l, p) {
    if (s = l.effects, l.effects = null, s !== null) for (l = 0; l < s.length; l++) {
      var y = s[l], _ = y.callback;
      if (_ !== null) {
        if (y.callback = null, y = p, typeof _ != "function") throw Error(i(191, _));
        _.call(y);
      }
    }
  }
  var Oc = {}, es = Aa(Oc), Pc = Aa(Oc), Lc = Aa(Oc);
  function ll(s) {
    if (s === Oc) throw Error(i(174));
    return s;
  }
  function um(s, l) {
    switch (rt(Lc, l), rt(Pc, s), rt(es, Oc), s = l.nodeType, s) {
      case 9:
      case 11:
        l = (l = l.documentElement) ? l.namespaceURI : Ki(null, "");
        break;
      default:
        s = s === 8 ? l.parentNode : l, l = s.namespaceURI || null, s = s.tagName, l = Ki(l, s);
    }
    Cn(es), rt(es, l);
  }
  function ul() {
    Cn(es), Cn(Pc), Cn(Lc);
  }
  function Sy(s) {
    ll(Lc.current);
    var l = ll(es.current), p = Ki(l, s.type);
    l !== p && (rt(Pc, s), rt(es, p));
  }
  function Md(s) {
    Pc.current === s && (Cn(es), Cn(Pc));
  }
  var Vn = Aa(0);
  function Ad(s) {
    for (var l = s; l !== null; ) {
      if (l.tag === 13) {
        var p = l.memoizedState;
        if (p !== null && (p = p.dehydrated, p === null || p.data === "$?" || p.data === "$!")) return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if (l.flags & 128) return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === s) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === s) return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  var Nc = [];
  function st() {
    for (var s = 0; s < Nc.length; s++) Nc[s]._workInProgressVersionPrimary = null;
    Nc.length = 0;
  }
  var Nt = B.ReactCurrentDispatcher, en = B.ReactCurrentBatchConfig, mn = 0, tn = null, ci = null, Ti = null, Od = !1, zc = !1, cl = 0, be = 0;
  function Zt() {
    throw Error(i(321));
  }
  function mt(s, l) {
    if (l === null) return !1;
    for (var p = 0; p < l.length && p < s.length; p++) if (!ka(s[p], l[p])) return !1;
    return !0;
  }
  function co(s, l, p, y, _, T) {
    if (mn = T, tn = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, Nt.current = s === null || s.memoizedState === null ? Gd : Uc, s = p(y, _), zc) {
      T = 0;
      do {
        if (zc = !1, cl = 0, 25 <= T) throw Error(i(301));
        T += 1, Ti = ci = null, l.updateQueue = null, Nt.current = Kd, s = p(y, _);
      } while (zc);
    }
    if (Nt.current = ml, l = ci !== null && ci.next !== null, mn = 0, Ti = ci = tn = null, Od = !1, l) throw Error(i(300));
    return s;
  }
  function Oa() {
    var s = cl !== 0;
    return cl = 0, s;
  }
  function Xi() {
    var s = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Ti === null ? tn.memoizedState = Ti = s : Ti = Ti.next = s, Ti;
  }
  function Jn() {
    if (ci === null) {
      var s = tn.alternate;
      s = s !== null ? s.memoizedState : null;
    } else s = ci.next;
    var l = Ti === null ? tn.memoizedState : Ti.next;
    if (l !== null) Ti = l, ci = s;
    else {
      if (s === null) throw Error(i(310));
      ci = s, s = { memoizedState: ci.memoizedState, baseState: ci.baseState, baseQueue: ci.baseQueue, queue: ci.queue, next: null }, Ti === null ? tn.memoizedState = Ti = s : Ti = Ti.next = s;
    }
    return Ti;
  }
  function As(s, l) {
    return typeof l == "function" ? l(s) : l;
  }
  function fo(s) {
    var l = Jn(), p = l.queue;
    if (p === null) throw Error(i(311));
    p.lastRenderedReducer = s;
    var y = ci, _ = y.baseQueue, T = p.pending;
    if (T !== null) {
      if (_ !== null) {
        var O = _.next;
        _.next = T.next, T.next = O;
      }
      y.baseQueue = _ = T, p.pending = null;
    }
    if (_ !== null) {
      T = _.next, y = y.baseState;
      var j = O = null, U = null, te = T;
      do {
        var _e = te.lane;
        if ((mn & _e) === _e) U !== null && (U = U.next = { lane: 0, action: te.action, hasEagerState: te.hasEagerState, eagerState: te.eagerState, next: null }), y = te.hasEagerState ? te.eagerState : s(y, te.action);
        else {
          var Ee = {
            lane: _e,
            action: te.action,
            hasEagerState: te.hasEagerState,
            eagerState: te.eagerState,
            next: null
          };
          U === null ? (j = U = Ee, O = y) : U = U.next = Ee, tn.lanes |= _e, rs |= _e;
        }
        te = te.next;
      } while (te !== null && te !== T);
      U === null ? O = y : U.next = j, ka(y, l.memoizedState) || (fi = !0), l.memoizedState = y, l.baseState = O, l.baseQueue = U, p.lastRenderedState = y;
    }
    if (s = p.interleaved, s !== null) {
      _ = s;
      do
        T = _.lane, tn.lanes |= T, rs |= T, _ = _.next;
      while (_ !== s);
    } else _ === null && (p.lanes = 0);
    return [l.memoizedState, p.dispatch];
  }
  function fl(s) {
    var l = Jn(), p = l.queue;
    if (p === null) throw Error(i(311));
    p.lastRenderedReducer = s;
    var y = p.dispatch, _ = p.pending, T = l.memoizedState;
    if (_ !== null) {
      p.pending = null;
      var O = _ = _.next;
      do
        T = s(T, O.action), O = O.next;
      while (O !== _);
      ka(T, l.memoizedState) || (fi = !0), l.memoizedState = T, l.baseQueue === null && (l.baseState = T), p.lastRenderedState = T;
    }
    return [T, y];
  }
  function Pd() {
  }
  function Ld(s, l) {
    var p = tn, y = Jn(), _ = l(), T = !ka(y.memoizedState, _);
    if (T && (y.memoizedState = _, fi = !0), y = y.queue, Fc(Fd.bind(null, p, y, s), [s]), y.getSnapshot !== l || T || Ti !== null && Ti.memoizedState.tag & 1) {
      if (p.flags |= 2048, dl(9, zd.bind(null, p, y, _, l), void 0, null), xi === null) throw Error(i(349));
      mn & 30 || Nd(p, l, _);
    }
    return _;
  }
  function Nd(s, l, p) {
    s.flags |= 16384, s = { getSnapshot: l, value: p }, l = tn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, tn.updateQueue = l, l.stores = [s]) : (p = l.stores, p === null ? l.stores = [s] : p.push(s));
  }
  function zd(s, l, p, y) {
    l.value = p, l.getSnapshot = y, Vd(l) && jd(s);
  }
  function Fd(s, l, p) {
    return p(function() {
      Vd(l) && jd(s);
    });
  }
  function Vd(s) {
    var l = s.getSnapshot;
    s = s.value;
    try {
      var p = l();
      return !ka(s, p);
    } catch {
      return !0;
    }
  }
  function jd(s) {
    var l = Ir(s, 1);
    l !== null && ar(l, s, 1, -1);
  }
  function Bd(s) {
    var l = Xi();
    return typeof s == "function" && (s = s()), l.memoizedState = l.baseState = s, s = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: As, lastRenderedState: s }, l.queue = s, s = s.dispatch = pl.bind(null, tn, s), [l.memoizedState, s];
  }
  function dl(s, l, p, y) {
    return s = { tag: s, create: l, destroy: p, deps: y, next: null }, l = tn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, tn.updateQueue = l, l.lastEffect = s.next = s) : (p = l.lastEffect, p === null ? l.lastEffect = s.next = s : (y = p.next, p.next = s, s.next = y, l.lastEffect = s)), s;
  }
  function Hd() {
    return Jn().memoizedState;
  }
  function gu(s, l, p, y) {
    var _ = Xi();
    tn.flags |= s, _.memoizedState = dl(1 | l, p, void 0, y === void 0 ? null : y);
  }
  function vu(s, l, p, y) {
    var _ = Jn();
    y = y === void 0 ? null : y;
    var T = void 0;
    if (ci !== null) {
      var O = ci.memoizedState;
      if (T = O.destroy, y !== null && mt(y, O.deps)) {
        _.memoizedState = dl(l, p, T, y);
        return;
      }
    }
    tn.flags |= s, _.memoizedState = dl(1 | l, p, T, y);
  }
  function Ud(s, l) {
    return gu(8390656, 8, s, l);
  }
  function Fc(s, l) {
    return vu(2048, 8, s, l);
  }
  function Id(s, l) {
    return vu(4, 2, s, l);
  }
  function Vc(s, l) {
    return vu(4, 4, s, l);
  }
  function hl(s, l) {
    if (typeof l == "function") return s = s(), l(s), function() {
      l(null);
    };
    if (l != null) return s = s(), l.current = s, function() {
      l.current = null;
    };
  }
  function $d(s, l, p) {
    return p = p != null ? p.concat([s]) : null, vu(4, 4, hl.bind(null, l, s), p);
  }
  function jc() {
  }
  function Wd(s, l) {
    var p = Jn();
    l = l === void 0 ? null : l;
    var y = p.memoizedState;
    return y !== null && l !== null && mt(l, y[1]) ? y[0] : (p.memoizedState = [s, l], s);
  }
  function Yd(s, l) {
    var p = Jn();
    l = l === void 0 ? null : l;
    var y = p.memoizedState;
    return y !== null && l !== null && mt(l, y[1]) ? y[0] : (s = s(), p.memoizedState = [s, l], s);
  }
  function cm(s, l, p) {
    return mn & 21 ? (ka(p, l) || (p = qf(), tn.lanes |= p, rs |= p, s.baseState = !0), l) : (s.baseState && (s.baseState = !1, fi = !0), s.memoizedState = p);
  }
  function Bc(s, l) {
    var p = hn;
    hn = p !== 0 && 4 > p ? p : 4, s(!0);
    var y = en.transition;
    en.transition = {};
    try {
      s(!1), l();
    } finally {
      hn = p, en.transition = y;
    }
  }
  function fm() {
    return Jn().memoizedState;
  }
  function Hc(s, l, p) {
    var y = as(s);
    if (p = { lane: y, action: p, hasEagerState: !1, eagerState: null, next: null }, Wr(s)) _y(l, p);
    else if (p = sm(s, l, p, y), p !== null) {
      var _ = pi();
      ar(p, s, y, _), bn(p, l, y);
    }
  }
  function pl(s, l, p) {
    var y = as(s), _ = { lane: y, action: p, hasEagerState: !1, eagerState: null, next: null };
    if (Wr(s)) _y(l, _);
    else {
      var T = s.alternate;
      if (s.lanes === 0 && (T === null || T.lanes === 0) && (T = l.lastRenderedReducer, T !== null)) try {
        var O = l.lastRenderedState, j = T(O, p);
        if (_.hasEagerState = !0, _.eagerState = j, ka(j, O)) {
          var U = l.interleaved;
          U === null ? (_.next = _, am(l)) : (_.next = U.next, U.next = _), l.interleaved = _;
          return;
        }
      } catch {
      } finally {
      }
      p = sm(s, l, _, y), p !== null && (_ = pi(), ar(p, s, y, _), bn(p, l, y));
    }
  }
  function Wr(s) {
    var l = s.alternate;
    return s === tn || l !== null && l === tn;
  }
  function _y(s, l) {
    zc = Od = !0;
    var p = s.pending;
    p === null ? l.next = l : (l.next = p.next, p.next = l), s.pending = l;
  }
  function bn(s, l, p) {
    if (p & 4194240) {
      var y = l.lanes;
      y &= s.pendingLanes, p |= y, l.lanes = p, Zf(s, p);
    }
  }
  var ml = { readContext: oa, useCallback: Zt, useContext: Zt, useEffect: Zt, useImperativeHandle: Zt, useInsertionEffect: Zt, useLayoutEffect: Zt, useMemo: Zt, useReducer: Zt, useRef: Zt, useState: Zt, useDebugValue: Zt, useDeferredValue: Zt, useTransition: Zt, useMutableSource: Zt, useSyncExternalStore: Zt, useId: Zt, unstable_isNewReconciler: !1 }, Gd = { readContext: oa, useCallback: function(s, l) {
    return Xi().memoizedState = [s, l === void 0 ? null : l], s;
  }, useContext: oa, useEffect: Ud, useImperativeHandle: function(s, l, p) {
    return p = p != null ? p.concat([s]) : null, gu(
      4194308,
      4,
      hl.bind(null, l, s),
      p
    );
  }, useLayoutEffect: function(s, l) {
    return gu(4194308, 4, s, l);
  }, useInsertionEffect: function(s, l) {
    return gu(4, 2, s, l);
  }, useMemo: function(s, l) {
    var p = Xi();
    return l = l === void 0 ? null : l, s = s(), p.memoizedState = [s, l], s;
  }, useReducer: function(s, l, p) {
    var y = Xi();
    return l = p !== void 0 ? p(l) : l, y.memoizedState = y.baseState = l, s = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: s, lastRenderedState: l }, y.queue = s, s = s.dispatch = Hc.bind(null, tn, s), [y.memoizedState, s];
  }, useRef: function(s) {
    var l = Xi();
    return s = { current: s }, l.memoizedState = s;
  }, useState: Bd, useDebugValue: jc, useDeferredValue: function(s) {
    return Xi().memoizedState = s;
  }, useTransition: function() {
    var s = Bd(!1), l = s[0];
    return s = Bc.bind(null, s[1]), Xi().memoizedState = s, [l, s];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(s, l, p) {
    var y = tn, _ = Xi();
    if (Pn) {
      if (p === void 0) throw Error(i(407));
      p = p();
    } else {
      if (p = l(), xi === null) throw Error(i(349));
      mn & 30 || Nd(y, l, p);
    }
    _.memoizedState = p;
    var T = { value: p, getSnapshot: l };
    return _.queue = T, Ud(Fd.bind(
      null,
      y,
      T,
      s
    ), [s]), y.flags |= 2048, dl(9, zd.bind(null, y, T, p, l), void 0, null), p;
  }, useId: function() {
    var s = Xi(), l = xi.identifierPrefix;
    if (Pn) {
      var p = Ja, y = Za;
      p = (y & ~(1 << 32 - Jr(y) - 1)).toString(32) + p, l = ":" + l + "R" + p, p = cl++, 0 < p && (l += "H" + p.toString(32)), l += ":";
    } else p = be++, l = ":" + l + "r" + p.toString(32) + ":";
    return s.memoizedState = l;
  }, unstable_isNewReconciler: !1 }, Uc = {
    readContext: oa,
    useCallback: Wd,
    useContext: oa,
    useEffect: Fc,
    useImperativeHandle: $d,
    useInsertionEffect: Id,
    useLayoutEffect: Vc,
    useMemo: Yd,
    useReducer: fo,
    useRef: Hd,
    useState: function() {
      return fo(As);
    },
    useDebugValue: jc,
    useDeferredValue: function(s) {
      var l = Jn();
      return cm(l, ci.memoizedState, s);
    },
    useTransition: function() {
      var s = fo(As)[0], l = Jn().memoizedState;
      return [s, l];
    },
    useMutableSource: Pd,
    useSyncExternalStore: Ld,
    useId: fm,
    unstable_isNewReconciler: !1
  }, Kd = { readContext: oa, useCallback: Wd, useContext: oa, useEffect: Fc, useImperativeHandle: $d, useInsertionEffect: Id, useLayoutEffect: Vc, useMemo: Yd, useReducer: fl, useRef: Hd, useState: function() {
    return fl(As);
  }, useDebugValue: jc, useDeferredValue: function(s) {
    var l = Jn();
    return ci === null ? l.memoizedState = s : cm(l, ci.memoizedState, s);
  }, useTransition: function() {
    var s = fl(As)[0], l = Jn().memoizedState;
    return [s, l];
  }, useMutableSource: Pd, useSyncExternalStore: Ld, useId: fm, unstable_isNewReconciler: !1 };
  function Pa(s, l) {
    if (s && s.defaultProps) {
      l = me({}, l), s = s.defaultProps;
      for (var p in s) l[p] === void 0 && (l[p] = s[p]);
      return l;
    }
    return l;
  }
  function dm(s, l, p, y) {
    l = s.memoizedState, p = p(y, l), p = p == null ? l : me({}, l, p), s.memoizedState = p, s.lanes === 0 && (s.updateQueue.baseState = p);
  }
  var Xd = { isMounted: function(s) {
    return (s = s._reactInternals) ? lt(s) === s : !1;
  }, enqueueSetState: function(s, l, p) {
    s = s._reactInternals;
    var y = pi(), _ = as(s), T = Ms(y, _);
    T.payload = l, p != null && (T.callback = p), l = uo(s, T, _), l !== null && (ar(l, s, _, y), kd(l, s, _));
  }, enqueueReplaceState: function(s, l, p) {
    s = s._reactInternals;
    var y = pi(), _ = as(s), T = Ms(y, _);
    T.tag = 1, T.payload = l, p != null && (T.callback = p), l = uo(s, T, _), l !== null && (ar(l, s, _, y), kd(l, s, _));
  }, enqueueForceUpdate: function(s, l) {
    s = s._reactInternals;
    var p = pi(), y = as(s), _ = Ms(p, y);
    _.tag = 2, l != null && (_.callback = l), l = uo(s, _, y), l !== null && (ar(l, s, y, p), kd(l, s, y));
  } };
  function Cy(s, l, p, y, _, T, O) {
    return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(y, T, O) : l.prototype && l.prototype.isPureReactComponent ? !Sc(p, y) || !Sc(_, T) : !0;
  }
  function Qd(s, l, p) {
    var y = !1, _ = xr, T = l.contextType;
    return typeof T == "object" && T !== null ? T = oa(T) : (_ = li(l) ? Sr : Yn.current, y = l.contextTypes, T = (y = y != null) ? ra(s, _) : xr), l = new l(p, T), s.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = Xd, s.stateNode = l, l._reactInternals = s, y && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = _, s.__reactInternalMemoizedMaskedChildContext = T), l;
  }
  function wy(s, l, p, y) {
    s = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(p, y), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(p, y), l.state !== s && Xd.enqueueReplaceState(l, l.state, null);
  }
  function Ic(s, l, p, y) {
    var _ = s.stateNode;
    _.props = p, _.state = s.memoizedState, _.refs = {}, om(s);
    var T = l.contextType;
    typeof T == "object" && T !== null ? _.context = oa(T) : (T = li(l) ? Sr : Yn.current, _.context = ra(s, T)), _.state = s.memoizedState, T = l.getDerivedStateFromProps, typeof T == "function" && (dm(s, l, T, p), _.state = s.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof _.getSnapshotBeforeUpdate == "function" || typeof _.UNSAFE_componentWillMount != "function" && typeof _.componentWillMount != "function" || (l = _.state, typeof _.componentWillMount == "function" && _.componentWillMount(), typeof _.UNSAFE_componentWillMount == "function" && _.UNSAFE_componentWillMount(), l !== _.state && Xd.enqueueReplaceState(_, _.state, null), Ac(s, p, _, y), _.state = s.memoizedState), typeof _.componentDidMount == "function" && (s.flags |= 4194308);
  }
  function gl(s, l) {
    try {
      var p = "", y = l;
      do
        p += de(y), y = y.return;
      while (y);
      var _ = p;
    } catch (T) {
      _ = `
Error generating stack: ` + T.message + `
` + T.stack;
    }
    return { value: s, source: l, stack: _, digest: null };
  }
  function hm(s, l, p) {
    return { value: s, source: null, stack: p ?? null, digest: l ?? null };
  }
  function pm(s, l) {
    try {
      console.error(l.value);
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  var qd = typeof WeakMap == "function" ? WeakMap : Map;
  function Ty(s, l, p) {
    p = Ms(-1, p), p.tag = 3, p.payload = { element: null };
    var y = l.value;
    return p.callback = function() {
      Cu || (Cu = !0, bl = y), pm(s, l);
    }, p;
  }
  function mm(s, l, p) {
    p = Ms(-1, p), p.tag = 3;
    var y = s.type.getDerivedStateFromError;
    if (typeof y == "function") {
      var _ = l.value;
      p.payload = function() {
        return y(_);
      }, p.callback = function() {
        pm(s, l);
      };
    }
    var T = s.stateNode;
    return T !== null && typeof T.componentDidCatch == "function" && (p.callback = function() {
      pm(s, l), typeof y != "function" && (mo === null ? mo = /* @__PURE__ */ new Set([this]) : mo.add(this));
      var O = l.stack;
      this.componentDidCatch(l.value, { componentStack: O !== null ? O : "" });
    }), p;
  }
  function gm(s, l, p) {
    var y = s.pingCache;
    if (y === null) {
      y = s.pingCache = new qd();
      var _ = /* @__PURE__ */ new Set();
      y.set(l, _);
    } else _ = y.get(l), _ === void 0 && (_ = /* @__PURE__ */ new Set(), y.set(l, _));
    _.has(p) || (_.add(p), s = GS.bind(null, s, l, p), l.then(s, s));
  }
  function Ey(s) {
    do {
      var l;
      if ((l = s.tag === 13) && (l = s.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l) return s;
      s = s.return;
    } while (s !== null);
    return null;
  }
  function ho(s, l, p, y, _) {
    return s.mode & 1 ? (s.flags |= 65536, s.lanes = _, s) : (s === l ? s.flags |= 65536 : (s.flags |= 128, p.flags |= 131072, p.flags &= -52805, p.tag === 1 && (p.alternate === null ? p.tag = 17 : (l = Ms(-1, 1), l.tag = 2, uo(p, l, 1))), p.lanes |= 1), s);
  }
  var $c = B.ReactCurrentOwner, fi = !1;
  function Ni(s, l, p, y) {
    l.child = s === null ? Ue(l, null, p, y) : Zn(l, s.child, p, y);
  }
  function Er(s, l, p, y, _) {
    p = p.render;
    var T = l.ref;
    return Fn(l, _), y = co(s, l, p, y, T, _), p = Oa(), s !== null && !fi ? (l.updateQueue = s.updateQueue, l.flags &= -2053, s.lanes &= ~_, ua(s, l, _)) : (Pn && p && Td(l), l.flags |= 1, Ni(s, l, y, _), l.child);
  }
  function vl(s, l, p, y, _) {
    if (s === null) {
      var T = p.type;
      return typeof T == "function" && !Mm(T) && T.defaultProps === void 0 && p.compare === null && p.defaultProps === void 0 ? (l.tag = 15, l.type = T, Mt(s, l, T, y, _)) : (s = of(p.type, null, y, l, l.mode, _), s.ref = l.ref, s.return = l, l.child = s);
    }
    if (T = s.child, !(s.lanes & _)) {
      var O = T.memoizedProps;
      if (p = p.compare, p = p !== null ? p : Sc, p(O, y) && s.ref === l.ref) return ua(s, l, _);
    }
    return l.flags |= 1, s = vo(T, y), s.ref = l.ref, s.return = l, l.child = s;
  }
  function Mt(s, l, p, y, _) {
    if (s !== null) {
      var T = s.memoizedProps;
      if (Sc(T, y) && s.ref === l.ref) if (fi = !1, l.pendingProps = y = T, (s.lanes & _) !== 0) s.flags & 131072 && (fi = !0);
      else return l.lanes = s.lanes, ua(s, l, _);
    }
    return Ry(s, l, p, y, _);
  }
  function Wc(s, l, p) {
    var y = l.pendingProps, _ = y.children, T = s !== null ? s.memoizedState : null;
    if (y.mode === "hidden") if (!(l.mode & 1)) l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, rt(xu, Yr), Yr |= p;
    else {
      if (!(p & 1073741824)) return s = T !== null ? T.baseLanes | p : p, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: s, cachePool: null, transitions: null }, l.updateQueue = null, rt(xu, Yr), Yr |= s, null;
      l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, y = T !== null ? T.baseLanes : p, rt(xu, Yr), Yr |= y;
    }
    else T !== null ? (y = T.baseLanes | p, l.memoizedState = null) : y = p, rt(xu, Yr), Yr |= y;
    return Ni(s, l, _, p), l.child;
  }
  function vm(s, l) {
    var p = l.ref;
    (s === null && p !== null || s !== null && s.ref !== p) && (l.flags |= 512, l.flags |= 2097152);
  }
  function Ry(s, l, p, y, _) {
    var T = li(p) ? Sr : Yn.current;
    return T = ra(l, T), Fn(l, _), p = co(s, l, p, y, T, _), y = Oa(), s !== null && !fi ? (l.updateQueue = s.updateQueue, l.flags &= -2053, s.lanes &= ~_, ua(s, l, _)) : (Pn && y && Td(l), l.flags |= 1, Ni(s, l, p, _), l.child);
  }
  function Dy(s, l, p, y, _) {
    if (li(p)) {
      var T = !0;
      _r(l);
    } else T = !1;
    if (Fn(l, _), l.stateNode === null) la(s, l), Qd(l, p, y), Ic(l, p, y, _), y = !0;
    else if (s === null) {
      var O = l.stateNode, j = l.memoizedProps;
      O.props = j;
      var U = O.context, te = p.contextType;
      typeof te == "object" && te !== null ? te = oa(te) : (te = li(p) ? Sr : Yn.current, te = ra(l, te));
      var _e = p.getDerivedStateFromProps, Ee = typeof _e == "function" || typeof O.getSnapshotBeforeUpdate == "function";
      Ee || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (j !== y || U !== te) && wy(l, O, y, te), $r = !1;
      var xe = l.memoizedState;
      O.state = xe, Ac(l, y, O, _), U = l.memoizedState, j !== y || xe !== U || yi.current || $r ? (typeof _e == "function" && (dm(l, p, _e, y), U = l.memoizedState), (j = $r || Cy(l, p, j, y, xe, U, te)) ? (Ee || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (typeof O.componentWillMount == "function" && O.componentWillMount(), typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount()), typeof O.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof O.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = y, l.memoizedState = U), O.props = y, O.state = U, O.context = te, y = j) : (typeof O.componentDidMount == "function" && (l.flags |= 4194308), y = !1);
    } else {
      O = l.stateNode, by(s, l), j = l.memoizedProps, te = l.type === l.elementType ? j : Pa(l.type, j), O.props = te, Ee = l.pendingProps, xe = O.context, U = p.contextType, typeof U == "object" && U !== null ? U = oa(U) : (U = li(p) ? Sr : Yn.current, U = ra(l, U));
      var We = p.getDerivedStateFromProps;
      (_e = typeof We == "function" || typeof O.getSnapshotBeforeUpdate == "function") || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (j !== Ee || xe !== U) && wy(l, O, y, U), $r = !1, xe = l.memoizedState, O.state = xe, Ac(l, y, O, _);
      var qe = l.memoizedState;
      j !== Ee || xe !== qe || yi.current || $r ? (typeof We == "function" && (dm(l, p, We, y), qe = l.memoizedState), (te = $r || Cy(l, p, te, y, xe, qe, U) || !1) ? (_e || typeof O.UNSAFE_componentWillUpdate != "function" && typeof O.componentWillUpdate != "function" || (typeof O.componentWillUpdate == "function" && O.componentWillUpdate(y, qe, U), typeof O.UNSAFE_componentWillUpdate == "function" && O.UNSAFE_componentWillUpdate(y, qe, U)), typeof O.componentDidUpdate == "function" && (l.flags |= 4), typeof O.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof O.componentDidUpdate != "function" || j === s.memoizedProps && xe === s.memoizedState || (l.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || j === s.memoizedProps && xe === s.memoizedState || (l.flags |= 1024), l.memoizedProps = y, l.memoizedState = qe), O.props = y, O.state = qe, O.context = U, y = te) : (typeof O.componentDidUpdate != "function" || j === s.memoizedProps && xe === s.memoizedState || (l.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || j === s.memoizedProps && xe === s.memoizedState || (l.flags |= 1024), y = !1);
    }
    return Yc(s, l, p, y, T, _);
  }
  function Yc(s, l, p, y, _, T) {
    vm(s, l);
    var O = (l.flags & 128) !== 0;
    if (!y && !O) return _ && Cd(l, p, !1), ua(s, l, T);
    y = l.stateNode, $c.current = l;
    var j = O && typeof p.getDerivedStateFromError != "function" ? null : y.render();
    return l.flags |= 1, s !== null && O ? (l.child = Zn(l, s.child, null, T), l.child = Zn(l, null, j, T)) : Ni(s, l, j, T), l.memoizedState = y.state, _ && Cd(l, p, !0), l.child;
  }
  function yu(s) {
    var l = s.stateNode;
    l.pendingContext ? my(s, l.pendingContext, l.pendingContext !== l.context) : l.context && my(s, l.context, !1), um(s, l.containerInfo);
  }
  function ky(s, l, p, y, _) {
    return lo(), ks(_), l.flags |= 256, Ni(s, l, p, y), l.child;
  }
  var Zd = { dehydrated: null, treeContext: null, retryLane: 0 };
  function ym(s) {
    return { baseLanes: s, cachePool: null, transitions: null };
  }
  function Jd(s, l, p) {
    var y = l.pendingProps, _ = Vn.current, T = !1, O = (l.flags & 128) !== 0, j;
    if ((j = O) || (j = s !== null && s.memoizedState === null ? !1 : (_ & 2) !== 0), j ? (T = !0, l.flags &= -129) : (s === null || s.memoizedState !== null) && (_ |= 1), rt(Vn, _ & 1), s === null)
      return em(l), s = l.memoizedState, s !== null && (s = s.dehydrated, s !== null) ? (l.mode & 1 ? s.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (O = y.children, s = y.fallback, T ? (y = l.mode, T = l.child, O = { mode: "hidden", children: O }, !(y & 1) && T !== null ? (T.childLanes = 0, T.pendingProps = O) : T = yo(O, y, 0, null), s = Ns(s, y, p, null), T.return = l, s.return = l, T.sibling = s, l.child = T, l.child.memoizedState = ym(p), l.memoizedState = Zd, s) : bm(l, O));
    if (_ = s.memoizedState, _ !== null && (j = _.dehydrated, j !== null)) return My(s, l, O, y, j, _, p);
    if (T) {
      T = y.fallback, O = l.mode, _ = s.child, j = _.sibling;
      var U = { mode: "hidden", children: y.children };
      return !(O & 1) && l.child !== _ ? (y = l.child, y.childLanes = 0, y.pendingProps = U, l.deletions = null) : (y = vo(_, U), y.subtreeFlags = _.subtreeFlags & 14680064), j !== null ? T = vo(j, T) : (T = Ns(T, O, p, null), T.flags |= 2), T.return = l, y.return = l, y.sibling = T, l.child = y, y = T, T = l.child, O = s.child.memoizedState, O = O === null ? ym(p) : { baseLanes: O.baseLanes | p, cachePool: null, transitions: O.transitions }, T.memoizedState = O, T.childLanes = s.childLanes & ~p, l.memoizedState = Zd, y;
    }
    return T = s.child, s = T.sibling, y = vo(T, { mode: "visible", children: y.children }), !(l.mode & 1) && (y.lanes = p), y.return = l, y.sibling = null, s !== null && (p = l.deletions, p === null ? (l.deletions = [s], l.flags |= 16) : p.push(s)), l.child = y, l.memoizedState = null, y;
  }
  function bm(s, l) {
    return l = yo({ mode: "visible", children: l }, s.mode, 0, null), l.return = s, s.child = l;
  }
  function Gc(s, l, p, y) {
    return y !== null && ks(y), Zn(l, s.child, null, p), s = bm(l, l.pendingProps.children), s.flags |= 2, l.memoizedState = null, s;
  }
  function My(s, l, p, y, _, T, O) {
    if (p)
      return l.flags & 256 ? (l.flags &= -257, y = hm(Error(i(422))), Gc(s, l, O, y)) : l.memoizedState !== null ? (l.child = s.child, l.flags |= 128, null) : (T = y.fallback, _ = l.mode, y = yo({ mode: "visible", children: y.children }, _, 0, null), T = Ns(T, _, O, null), T.flags |= 2, y.return = l, T.return = l, y.sibling = T, l.child = y, l.mode & 1 && Zn(l, s.child, null, O), l.child.memoizedState = ym(O), l.memoizedState = Zd, T);
    if (!(l.mode & 1)) return Gc(s, l, O, null);
    if (_.data === "$!") {
      if (y = _.nextSibling && _.nextSibling.dataset, y) var j = y.dgst;
      return y = j, T = Error(i(419)), y = hm(T, y, void 0), Gc(s, l, O, y);
    }
    if (j = (O & s.childLanes) !== 0, fi || j) {
      if (y = xi, y !== null) {
        switch (O & -O) {
          case 4:
            _ = 2;
            break;
          case 16:
            _ = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            _ = 32;
            break;
          case 536870912:
            _ = 268435456;
            break;
          default:
            _ = 0;
        }
        _ = _ & (y.suspendedLanes | O) ? 0 : _, _ !== 0 && _ !== T.retryLane && (T.retryLane = _, Ir(s, _), ar(y, s, _, -1));
      }
      return km(), y = hm(Error(i(421))), Gc(s, l, O, y);
    }
    return _.data === "$?" ? (l.flags |= 128, l.child = s.child, l = KS.bind(null, s), _._reactRetry = l, null) : (s = T.treeContext, wr = Ka(_.nextSibling), Cr = l, Pn = !0, sa = null, s !== null && (ui[aa++] = Za, ui[aa++] = Ja, ui[aa++] = Hr, Za = s.id, Ja = s.overflow, Hr = l), l = bm(l, y.children), l.flags |= 4096, l);
  }
  function xm(s, l, p) {
    s.lanes |= l;
    var y = s.alternate;
    y !== null && (y.lanes |= l), rm(s.return, l, p);
  }
  function nr(s, l, p, y, _) {
    var T = s.memoizedState;
    T === null ? s.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: y, tail: p, tailMode: _ } : (T.isBackwards = l, T.rendering = null, T.renderingStartTime = 0, T.last = y, T.tail = p, T.tailMode = _);
  }
  function ts(s, l, p) {
    var y = l.pendingProps, _ = y.revealOrder, T = y.tail;
    if (Ni(s, l, y.children, p), y = Vn.current, y & 2) y = y & 1 | 2, l.flags |= 128;
    else {
      if (s !== null && s.flags & 128) e: for (s = l.child; s !== null; ) {
        if (s.tag === 13) s.memoizedState !== null && xm(s, p, l);
        else if (s.tag === 19) xm(s, p, l);
        else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === l) break e;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === l) break e;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      y &= 1;
    }
    if (rt(Vn, y), !(l.mode & 1)) l.memoizedState = null;
    else switch (_) {
      case "forwards":
        for (p = l.child, _ = null; p !== null; ) s = p.alternate, s !== null && Ad(s) === null && (_ = p), p = p.sibling;
        p = _, p === null ? (_ = l.child, l.child = null) : (_ = p.sibling, p.sibling = null), nr(l, !1, _, p, T);
        break;
      case "backwards":
        for (p = null, _ = l.child, l.child = null; _ !== null; ) {
          if (s = _.alternate, s !== null && Ad(s) === null) {
            l.child = _;
            break;
          }
          s = _.sibling, _.sibling = p, p = _, _ = s;
        }
        nr(l, !0, p, null, T);
        break;
      case "together":
        nr(l, !1, null, null, void 0);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function la(s, l) {
    !(l.mode & 1) && s !== null && (s.alternate = null, l.alternate = null, l.flags |= 2);
  }
  function ua(s, l, p) {
    if (s !== null && (l.dependencies = s.dependencies), rs |= l.lanes, !(p & l.childLanes)) return null;
    if (s !== null && l.child !== s.child) throw Error(i(153));
    if (l.child !== null) {
      for (s = l.child, p = vo(s, s.pendingProps), l.child = p, p.return = l; s.sibling !== null; ) s = s.sibling, p = p.sibling = vo(s, s.pendingProps), p.return = l;
      p.sibling = null;
    }
    return l.child;
  }
  function Kc(s, l, p) {
    switch (l.tag) {
      case 3:
        yu(l), lo();
        break;
      case 5:
        Sy(l);
        break;
      case 1:
        li(l.type) && _r(l);
        break;
      case 4:
        um(l, l.stateNode.containerInfo);
        break;
      case 10:
        var y = l.type._context, _ = l.memoizedProps.value;
        rt(Ur, y._currentValue), y._currentValue = _;
        break;
      case 13:
        if (y = l.memoizedState, y !== null)
          return y.dehydrated !== null ? (rt(Vn, Vn.current & 1), l.flags |= 128, null) : p & l.child.childLanes ? Jd(s, l, p) : (rt(Vn, Vn.current & 1), s = ua(s, l, p), s !== null ? s.sibling : null);
        rt(Vn, Vn.current & 1);
        break;
      case 19:
        if (y = (p & l.childLanes) !== 0, s.flags & 128) {
          if (y) return ts(s, l, p);
          l.flags |= 128;
        }
        if (_ = l.memoizedState, _ !== null && (_.rendering = null, _.tail = null, _.lastEffect = null), rt(Vn, Vn.current), y) break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, Wc(s, l, p);
    }
    return ua(s, l, p);
  }
  var ca, di, Ay, Oy;
  ca = function(s, l) {
    for (var p = l.child; p !== null; ) {
      if (p.tag === 5 || p.tag === 6) s.appendChild(p.stateNode);
      else if (p.tag !== 4 && p.child !== null) {
        p.child.return = p, p = p.child;
        continue;
      }
      if (p === l) break;
      for (; p.sibling === null; ) {
        if (p.return === null || p.return === l) return;
        p = p.return;
      }
      p.sibling.return = p.return, p = p.sibling;
    }
  }, di = function() {
  }, Ay = function(s, l, p, y) {
    var _ = s.memoizedProps;
    if (_ !== y) {
      s = l.stateNode, ll(es.current);
      var T = null;
      switch (p) {
        case "input":
          _ = tt(s, _), y = tt(s, y), T = [];
          break;
        case "select":
          _ = me({}, _, { value: void 0 }), y = me({}, y, { value: void 0 }), T = [];
          break;
        case "textarea":
          _ = Rt(s, _), y = Rt(s, y), T = [];
          break;
        default:
          typeof _.onClick != "function" && typeof y.onClick == "function" && (s.onclick = no);
      }
      dn(p, y);
      var O;
      p = null;
      for (te in _) if (!y.hasOwnProperty(te) && _.hasOwnProperty(te) && _[te] != null) if (te === "style") {
        var j = _[te];
        for (O in j) j.hasOwnProperty(O) && (p || (p = {}), p[O] = "");
      } else te !== "dangerouslySetInnerHTML" && te !== "children" && te !== "suppressContentEditableWarning" && te !== "suppressHydrationWarning" && te !== "autoFocus" && (o.hasOwnProperty(te) ? T || (T = []) : (T = T || []).push(te, null));
      for (te in y) {
        var U = y[te];
        if (j = _ != null ? _[te] : void 0, y.hasOwnProperty(te) && U !== j && (U != null || j != null)) if (te === "style") if (j) {
          for (O in j) !j.hasOwnProperty(O) || U && U.hasOwnProperty(O) || (p || (p = {}), p[O] = "");
          for (O in U) U.hasOwnProperty(O) && j[O] !== U[O] && (p || (p = {}), p[O] = U[O]);
        } else p || (T || (T = []), T.push(
          te,
          p
        )), p = U;
        else te === "dangerouslySetInnerHTML" ? (U = U ? U.__html : void 0, j = j ? j.__html : void 0, U != null && j !== U && (T = T || []).push(te, U)) : te === "children" ? typeof U != "string" && typeof U != "number" || (T = T || []).push(te, "" + U) : te !== "suppressContentEditableWarning" && te !== "suppressHydrationWarning" && (o.hasOwnProperty(te) ? (U != null && te === "onScroll" && un("scroll", s), T || j === U || (T = [])) : (T = T || []).push(te, U));
      }
      p && (T = T || []).push("style", p);
      var te = T;
      (l.updateQueue = te) && (l.flags |= 4);
    }
  }, Oy = function(s, l, p, y) {
    p !== y && (l.flags |= 4);
  };
  function Xc(s, l) {
    if (!Pn) switch (s.tailMode) {
      case "hidden":
        l = s.tail;
        for (var p = null; l !== null; ) l.alternate !== null && (p = l), l = l.sibling;
        p === null ? s.tail = null : p.sibling = null;
        break;
      case "collapsed":
        p = s.tail;
        for (var y = null; p !== null; ) p.alternate !== null && (y = p), p = p.sibling;
        y === null ? l || s.tail === null ? s.tail = null : s.tail.sibling = null : y.sibling = null;
    }
  }
  function Ei(s) {
    var l = s.alternate !== null && s.alternate.child === s.child, p = 0, y = 0;
    if (l) for (var _ = s.child; _ !== null; ) p |= _.lanes | _.childLanes, y |= _.subtreeFlags & 14680064, y |= _.flags & 14680064, _.return = s, _ = _.sibling;
    else for (_ = s.child; _ !== null; ) p |= _.lanes | _.childLanes, y |= _.subtreeFlags, y |= _.flags, _.return = s, _ = _.sibling;
    return s.subtreeFlags |= y, s.childLanes = p, l;
  }
  function Py(s, l, p) {
    var y = l.pendingProps;
    switch (Ed(l), l.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ei(l), null;
      case 1:
        return li(l.type) && hu(), Ei(l), null;
      case 3:
        return y = l.stateNode, ul(), Cn(yi), Cn(Yn), st(), y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), (s === null || s.child === null) && (Rd(l) ? l.flags |= 4 : s === null || s.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, sa !== null && (xl(sa), sa = null))), di(s, l), Ei(l), null;
      case 5:
        Md(l);
        var _ = ll(Lc.current);
        if (p = l.type, s !== null && l.stateNode != null) Ay(s, l, p, y, _), s.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
        else {
          if (!y) {
            if (l.stateNode === null) throw Error(i(166));
            return Ei(l), null;
          }
          if (s = ll(es.current), Rd(l)) {
            y = l.stateNode, p = l.type;
            var T = l.memoizedProps;
            switch (y[Xa] = l, y[Rc] = T, s = (l.mode & 1) !== 0, p) {
              case "dialog":
                un("cancel", y), un("close", y);
                break;
              case "iframe":
              case "object":
              case "embed":
                un("load", y);
                break;
              case "video":
              case "audio":
                for (_ = 0; _ < wc.length; _++) un(wc[_], y);
                break;
              case "source":
                un("error", y);
                break;
              case "img":
              case "image":
              case "link":
                un(
                  "error",
                  y
                ), un("load", y);
                break;
              case "details":
                un("toggle", y);
                break;
              case "input":
                Et(y, T), un("invalid", y);
                break;
              case "select":
                y._wrapperState = { wasMultiple: !!T.multiple }, un("invalid", y);
                break;
              case "textarea":
                Bt(y, T), un("invalid", y);
            }
            dn(p, T), _ = null;
            for (var O in T) if (T.hasOwnProperty(O)) {
              var j = T[O];
              O === "children" ? typeof j == "string" ? y.textContent !== j && (T.suppressHydrationWarning !== !0 && bd(y.textContent, j, s), _ = ["children", j]) : typeof j == "number" && y.textContent !== "" + j && (T.suppressHydrationWarning !== !0 && bd(
                y.textContent,
                j,
                s
              ), _ = ["children", "" + j]) : o.hasOwnProperty(O) && j != null && O === "onScroll" && un("scroll", y);
            }
            switch (p) {
              case "input":
                pt(y), ln(y, T, !0);
                break;
              case "textarea":
                pt(y), An(y);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof T.onClick == "function" && (y.onclick = no);
            }
            y = _, l.updateQueue = y, y !== null && (l.flags |= 4);
          } else {
            O = _.nodeType === 9 ? _ : _.ownerDocument, s === "http://www.w3.org/1999/xhtml" && (s = si(p)), s === "http://www.w3.org/1999/xhtml" ? p === "script" ? (s = O.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild)) : typeof y.is == "string" ? s = O.createElement(p, { is: y.is }) : (s = O.createElement(p), p === "select" && (O = s, y.multiple ? O.multiple = !0 : y.size && (O.size = y.size))) : s = O.createElementNS(s, p), s[Xa] = l, s[Rc] = y, ca(s, l, !1, !1), l.stateNode = s;
            e: {
              switch (O = _n(p, y), p) {
                case "dialog":
                  un("cancel", s), un("close", s), _ = y;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  un("load", s), _ = y;
                  break;
                case "video":
                case "audio":
                  for (_ = 0; _ < wc.length; _++) un(wc[_], s);
                  _ = y;
                  break;
                case "source":
                  un("error", s), _ = y;
                  break;
                case "img":
                case "image":
                case "link":
                  un(
                    "error",
                    s
                  ), un("load", s), _ = y;
                  break;
                case "details":
                  un("toggle", s), _ = y;
                  break;
                case "input":
                  Et(s, y), _ = tt(s, y), un("invalid", s);
                  break;
                case "option":
                  _ = y;
                  break;
                case "select":
                  s._wrapperState = { wasMultiple: !!y.multiple }, _ = me({}, y, { value: void 0 }), un("invalid", s);
                  break;
                case "textarea":
                  Bt(s, y), _ = Rt(s, y), un("invalid", s);
                  break;
                default:
                  _ = y;
              }
              dn(p, _), j = _;
              for (T in j) if (j.hasOwnProperty(T)) {
                var U = j[T];
                T === "style" ? Vt(s, U) : T === "dangerouslySetInnerHTML" ? (U = U ? U.__html : void 0, U != null && Ji(s, U)) : T === "children" ? typeof U == "string" ? (p !== "textarea" || U !== "") && Le(s, U) : typeof U == "number" && Le(s, "" + U) : T !== "suppressContentEditableWarning" && T !== "suppressHydrationWarning" && T !== "autoFocus" && (o.hasOwnProperty(T) ? U != null && T === "onScroll" && un("scroll", s) : U != null && F(s, T, U, O));
              }
              switch (p) {
                case "input":
                  pt(s), ln(s, y, !1);
                  break;
                case "textarea":
                  pt(s), An(s);
                  break;
                case "option":
                  y.value != null && s.setAttribute("value", "" + we(y.value));
                  break;
                case "select":
                  s.multiple = !!y.multiple, T = y.value, T != null ? Dt(s, !!y.multiple, T, !1) : y.defaultValue != null && Dt(
                    s,
                    !!y.multiple,
                    y.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof _.onClick == "function" && (s.onclick = no);
              }
              switch (p) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  y = !!y.autoFocus;
                  break e;
                case "img":
                  y = !0;
                  break e;
                default:
                  y = !1;
              }
            }
            y && (l.flags |= 4);
          }
          l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
        }
        return Ei(l), null;
      case 6:
        if (s && l.stateNode != null) Oy(s, l, s.memoizedProps, y);
        else {
          if (typeof y != "string" && l.stateNode === null) throw Error(i(166));
          if (p = ll(Lc.current), ll(es.current), Rd(l)) {
            if (y = l.stateNode, p = l.memoizedProps, y[Xa] = l, (T = y.nodeValue !== p) && (s = Cr, s !== null)) switch (s.tag) {
              case 3:
                bd(y.nodeValue, p, (s.mode & 1) !== 0);
                break;
              case 5:
                s.memoizedProps.suppressHydrationWarning !== !0 && bd(y.nodeValue, p, (s.mode & 1) !== 0);
            }
            T && (l.flags |= 4);
          } else y = (p.nodeType === 9 ? p : p.ownerDocument).createTextNode(y), y[Xa] = l, l.stateNode = y;
        }
        return Ei(l), null;
      case 13:
        if (Cn(Vn), y = l.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
          if (Pn && wr !== null && l.mode & 1 && !(l.flags & 128)) Mc(), lo(), l.flags |= 98560, T = !1;
          else if (T = Rd(l), y !== null && y.dehydrated !== null) {
            if (s === null) {
              if (!T) throw Error(i(318));
              if (T = l.memoizedState, T = T !== null ? T.dehydrated : null, !T) throw Error(i(317));
              T[Xa] = l;
            } else lo(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            Ei(l), T = !1;
          } else sa !== null && (xl(sa), sa = null), T = !0;
          if (!T) return l.flags & 65536 ? l : null;
        }
        return l.flags & 128 ? (l.lanes = p, l) : (y = y !== null, y !== (s !== null && s.memoizedState !== null) && y && (l.child.flags |= 8192, l.mode & 1 && (s === null || Vn.current & 1 ? ti === 0 && (ti = 3) : km())), l.updateQueue !== null && (l.flags |= 4), Ei(l), null);
      case 4:
        return ul(), di(s, l), s === null && lu(l.stateNode.containerInfo), Ei(l), null;
      case 10:
        return im(l.type._context), Ei(l), null;
      case 17:
        return li(l.type) && hu(), Ei(l), null;
      case 19:
        if (Cn(Vn), T = l.memoizedState, T === null) return Ei(l), null;
        if (y = (l.flags & 128) !== 0, O = T.rendering, O === null) if (y) Xc(T, !1);
        else {
          if (ti !== 0 || s !== null && s.flags & 128) for (s = l.child; s !== null; ) {
            if (O = Ad(s), O !== null) {
              for (l.flags |= 128, Xc(T, !1), y = O.updateQueue, y !== null && (l.updateQueue = y, l.flags |= 4), l.subtreeFlags = 0, y = p, p = l.child; p !== null; ) T = p, s = y, T.flags &= 14680066, O = T.alternate, O === null ? (T.childLanes = 0, T.lanes = s, T.child = null, T.subtreeFlags = 0, T.memoizedProps = null, T.memoizedState = null, T.updateQueue = null, T.dependencies = null, T.stateNode = null) : (T.childLanes = O.childLanes, T.lanes = O.lanes, T.child = O.child, T.subtreeFlags = 0, T.deletions = null, T.memoizedProps = O.memoizedProps, T.memoizedState = O.memoizedState, T.updateQueue = O.updateQueue, T.type = O.type, s = O.dependencies, T.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }), p = p.sibling;
              return rt(Vn, Vn.current & 1 | 2), l.child;
            }
            s = s.sibling;
          }
          T.tail !== null && Ot() > _u && (l.flags |= 128, y = !0, Xc(T, !1), l.lanes = 4194304);
        }
        else {
          if (!y) if (s = Ad(O), s !== null) {
            if (l.flags |= 128, y = !0, p = s.updateQueue, p !== null && (l.updateQueue = p, l.flags |= 4), Xc(T, !0), T.tail === null && T.tailMode === "hidden" && !O.alternate && !Pn) return Ei(l), null;
          } else 2 * Ot() - T.renderingStartTime > _u && p !== 1073741824 && (l.flags |= 128, y = !0, Xc(T, !1), l.lanes = 4194304);
          T.isBackwards ? (O.sibling = l.child, l.child = O) : (p = T.last, p !== null ? p.sibling = O : l.child = O, T.last = O);
        }
        return T.tail !== null ? (l = T.tail, T.rendering = l, T.tail = l.sibling, T.renderingStartTime = Ot(), l.sibling = null, p = Vn.current, rt(Vn, y ? p & 1 | 2 : p & 1), l) : (Ei(l), null);
      case 22:
      case 23:
        return Dm(), y = l.memoizedState !== null, s !== null && s.memoizedState !== null !== y && (l.flags |= 8192), y && l.mode & 1 ? Yr & 1073741824 && (Ei(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : Ei(l), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(i(156, l.tag));
  }
  function eh(s, l) {
    switch (Ed(l), l.tag) {
      case 1:
        return li(l.type) && hu(), s = l.flags, s & 65536 ? (l.flags = s & -65537 | 128, l) : null;
      case 3:
        return ul(), Cn(yi), Cn(Yn), st(), s = l.flags, s & 65536 && !(s & 128) ? (l.flags = s & -65537 | 128, l) : null;
      case 5:
        return Md(l), null;
      case 13:
        if (Cn(Vn), s = l.memoizedState, s !== null && s.dehydrated !== null) {
          if (l.alternate === null) throw Error(i(340));
          lo();
        }
        return s = l.flags, s & 65536 ? (l.flags = s & -65537 | 128, l) : null;
      case 19:
        return Cn(Vn), null;
      case 4:
        return ul(), null;
      case 10:
        return im(l.type._context), null;
      case 22:
      case 23:
        return Dm(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Qc = !1, Qi = !1, HS = typeof WeakSet == "function" ? WeakSet : Set, Xe = null;
  function bu(s, l) {
    var p = s.ref;
    if (p !== null) if (typeof p == "function") try {
      p(null);
    } catch (y) {
      Ln(s, l, y);
    }
    else p.current = null;
  }
  function th(s, l, p) {
    try {
      p();
    } catch (y) {
      Ln(s, l, y);
    }
  }
  var Ly = !1;
  function Ny(s, l) {
    if (Ec = Xo, s = _c(), fd(s)) {
      if ("selectionStart" in s) var p = { start: s.selectionStart, end: s.selectionEnd };
      else e: {
        p = (p = s.ownerDocument) && p.defaultView || window;
        var y = p.getSelection && p.getSelection();
        if (y && y.rangeCount !== 0) {
          p = y.anchorNode;
          var _ = y.anchorOffset, T = y.focusNode;
          y = y.focusOffset;
          try {
            p.nodeType, T.nodeType;
          } catch {
            p = null;
            break e;
          }
          var O = 0, j = -1, U = -1, te = 0, _e = 0, Ee = s, xe = null;
          t: for (; ; ) {
            for (var We; Ee !== p || _ !== 0 && Ee.nodeType !== 3 || (j = O + _), Ee !== T || y !== 0 && Ee.nodeType !== 3 || (U = O + y), Ee.nodeType === 3 && (O += Ee.nodeValue.length), (We = Ee.firstChild) !== null; )
              xe = Ee, Ee = We;
            for (; ; ) {
              if (Ee === s) break t;
              if (xe === p && ++te === _ && (j = O), xe === T && ++_e === y && (U = O), (We = Ee.nextSibling) !== null) break;
              Ee = xe, xe = Ee.parentNode;
            }
            Ee = We;
          }
          p = j === -1 || U === -1 ? null : { start: j, end: U };
        } else p = null;
      }
      p = p || { start: 0, end: 0 };
    } else p = null;
    for (nl = { focusedElem: s, selectionRange: p }, Xo = !1, Xe = l; Xe !== null; ) if (l = Xe, s = l.child, (l.subtreeFlags & 1028) !== 0 && s !== null) s.return = l, Xe = s;
    else for (; Xe !== null; ) {
      l = Xe;
      try {
        var qe = l.alternate;
        if (l.flags & 1024) switch (l.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (qe !== null) {
              var et = qe.memoizedProps, ni = qe.memoizedState, X = l.stateNode, $ = X.getSnapshotBeforeUpdate(l.elementType === l.type ? et : Pa(l.type, et), ni);
              X.__reactInternalSnapshotBeforeUpdate = $;
            }
            break;
          case 3:
            var Z = l.stateNode.containerInfo;
            Z.nodeType === 1 ? Z.textContent = "" : Z.nodeType === 9 && Z.documentElement && Z.removeChild(Z.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(i(163));
        }
      } catch (Ce) {
        Ln(l, l.return, Ce);
      }
      if (s = l.sibling, s !== null) {
        s.return = l.return, Xe = s;
        break;
      }
      Xe = l.return;
    }
    return qe = Ly, Ly = !1, qe;
  }
  function qc(s, l, p) {
    var y = l.updateQueue;
    if (y = y !== null ? y.lastEffect : null, y !== null) {
      var _ = y = y.next;
      do {
        if ((_.tag & s) === s) {
          var T = _.destroy;
          _.destroy = void 0, T !== void 0 && th(l, p, T);
        }
        _ = _.next;
      } while (_ !== y);
    }
  }
  function Zc(s, l) {
    if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
      var p = l = l.next;
      do {
        if ((p.tag & s) === s) {
          var y = p.create;
          p.destroy = y();
        }
        p = p.next;
      } while (p !== l);
    }
  }
  function Sm(s) {
    var l = s.ref;
    if (l !== null) {
      var p = s.stateNode;
      switch (s.tag) {
        case 5:
          s = p;
          break;
        default:
          s = p;
      }
      typeof l == "function" ? l(s) : l.current = s;
    }
  }
  function nh(s) {
    var l = s.alternate;
    l !== null && (s.alternate = null, nh(l)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (l = s.stateNode, l !== null && (delete l[Xa], delete l[Rc], delete l[Dc], delete l[du], delete l[jS])), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
  }
  function Jc(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4;
  }
  function Os(s) {
    e: for (; ; ) {
      for (; s.sibling === null; ) {
        if (s.return === null || Jc(s.return)) return null;
        s = s.return;
      }
      for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18; ) {
        if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
        s.child.return = s, s = s.child;
      }
      if (!(s.flags & 2)) return s.stateNode;
    }
  }
  function ns(s, l, p) {
    var y = s.tag;
    if (y === 5 || y === 6) s = s.stateNode, l ? p.nodeType === 8 ? p.parentNode.insertBefore(s, l) : p.insertBefore(s, l) : (p.nodeType === 8 ? (l = p.parentNode, l.insertBefore(s, p)) : (l = p, l.appendChild(s)), p = p._reactRootContainer, p != null || l.onclick !== null || (l.onclick = no));
    else if (y !== 4 && (s = s.child, s !== null)) for (ns(s, l, p), s = s.sibling; s !== null; ) ns(s, l, p), s = s.sibling;
  }
  function is(s, l, p) {
    var y = s.tag;
    if (y === 5 || y === 6) s = s.stateNode, l ? p.insertBefore(s, l) : p.appendChild(s);
    else if (y !== 4 && (s = s.child, s !== null)) for (is(s, l, p), s = s.sibling; s !== null; ) is(s, l, p), s = s.sibling;
  }
  var ei = null, ir = !1;
  function rr(s, l, p) {
    for (p = p.child; p !== null; ) zy(s, l, p), p = p.sibling;
  }
  function zy(s, l, p) {
    if (Ra && typeof Ra.onCommitFiberUnmount == "function") try {
      Ra.onCommitFiberUnmount(fc, p);
    } catch {
    }
    switch (p.tag) {
      case 5:
        Qi || bu(p, l);
      case 6:
        var y = ei, _ = ir;
        ei = null, rr(s, l, p), ei = y, ir = _, ei !== null && (ir ? (s = ei, p = p.stateNode, s.nodeType === 8 ? s.parentNode.removeChild(p) : s.removeChild(p)) : ei.removeChild(p.stateNode));
        break;
      case 18:
        ei !== null && (ir ? (s = ei, p = p.stateNode, s.nodeType === 8 ? fu(s.parentNode, p) : s.nodeType === 1 && fu(s, p), Js(s)) : fu(ei, p.stateNode));
        break;
      case 4:
        y = ei, _ = ir, ei = p.stateNode.containerInfo, ir = !0, rr(s, l, p), ei = y, ir = _;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Qi && (y = p.updateQueue, y !== null && (y = y.lastEffect, y !== null))) {
          _ = y = y.next;
          do {
            var T = _, O = T.destroy;
            T = T.tag, O !== void 0 && (T & 2 || T & 4) && th(p, l, O), _ = _.next;
          } while (_ !== y);
        }
        rr(s, l, p);
        break;
      case 1:
        if (!Qi && (bu(p, l), y = p.stateNode, typeof y.componentWillUnmount == "function")) try {
          y.props = p.memoizedProps, y.state = p.memoizedState, y.componentWillUnmount();
        } catch (j) {
          Ln(p, l, j);
        }
        rr(s, l, p);
        break;
      case 21:
        rr(s, l, p);
        break;
      case 22:
        p.mode & 1 ? (Qi = (y = Qi) || p.memoizedState !== null, rr(s, l, p), Qi = y) : rr(s, l, p);
        break;
      default:
        rr(s, l, p);
    }
  }
  function Fy(s) {
    var l = s.updateQueue;
    if (l !== null) {
      s.updateQueue = null;
      var p = s.stateNode;
      p === null && (p = s.stateNode = new HS()), l.forEach(function(y) {
        var _ = Yy.bind(null, s, y);
        p.has(y) || (p.add(y), y.then(_, _));
      });
    }
  }
  function La(s, l) {
    var p = l.deletions;
    if (p !== null) for (var y = 0; y < p.length; y++) {
      var _ = p[y];
      try {
        var T = s, O = l, j = O;
        e: for (; j !== null; ) {
          switch (j.tag) {
            case 5:
              ei = j.stateNode, ir = !1;
              break e;
            case 3:
              ei = j.stateNode.containerInfo, ir = !0;
              break e;
            case 4:
              ei = j.stateNode.containerInfo, ir = !0;
              break e;
          }
          j = j.return;
        }
        if (ei === null) throw Error(i(160));
        zy(T, O, _), ei = null, ir = !1;
        var U = _.alternate;
        U !== null && (U.return = null), _.return = null;
      } catch (te) {
        Ln(_, l, te);
      }
    }
    if (l.subtreeFlags & 12854) for (l = l.child; l !== null; ) _m(l, s), l = l.sibling;
  }
  function _m(s, l) {
    var p = s.alternate, y = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (La(l, s), Rr(s), y & 4) {
          try {
            qc(3, s, s.return), Zc(3, s);
          } catch (et) {
            Ln(s, s.return, et);
          }
          try {
            qc(5, s, s.return);
          } catch (et) {
            Ln(s, s.return, et);
          }
        }
        break;
      case 1:
        La(l, s), Rr(s), y & 512 && p !== null && bu(p, p.return);
        break;
      case 5:
        if (La(l, s), Rr(s), y & 512 && p !== null && bu(p, p.return), s.flags & 32) {
          var _ = s.stateNode;
          try {
            Le(_, "");
          } catch (et) {
            Ln(s, s.return, et);
          }
        }
        if (y & 4 && (_ = s.stateNode, _ != null)) {
          var T = s.memoizedProps, O = p !== null ? p.memoizedProps : T, j = s.type, U = s.updateQueue;
          if (s.updateQueue = null, U !== null) try {
            j === "input" && T.type === "radio" && T.name != null && Wt(_, T), _n(j, O);
            var te = _n(j, T);
            for (O = 0; O < U.length; O += 2) {
              var _e = U[O], Ee = U[O + 1];
              _e === "style" ? Vt(_, Ee) : _e === "dangerouslySetInnerHTML" ? Ji(_, Ee) : _e === "children" ? Le(_, Ee) : F(_, _e, Ee, te);
            }
            switch (j) {
              case "input":
                on(_, T);
                break;
              case "textarea":
                Dn(_, T);
                break;
              case "select":
                var xe = _._wrapperState.wasMultiple;
                _._wrapperState.wasMultiple = !!T.multiple;
                var We = T.value;
                We != null ? Dt(_, !!T.multiple, We, !1) : xe !== !!T.multiple && (T.defaultValue != null ? Dt(
                  _,
                  !!T.multiple,
                  T.defaultValue,
                  !0
                ) : Dt(_, !!T.multiple, T.multiple ? [] : "", !1));
            }
            _[Rc] = T;
          } catch (et) {
            Ln(s, s.return, et);
          }
        }
        break;
      case 6:
        if (La(l, s), Rr(s), y & 4) {
          if (s.stateNode === null) throw Error(i(162));
          _ = s.stateNode, T = s.memoizedProps;
          try {
            _.nodeValue = T;
          } catch (et) {
            Ln(s, s.return, et);
          }
        }
        break;
      case 3:
        if (La(l, s), Rr(s), y & 4 && p !== null && p.memoizedState.isDehydrated) try {
          Js(l.containerInfo);
        } catch (et) {
          Ln(s, s.return, et);
        }
        break;
      case 4:
        La(l, s), Rr(s);
        break;
      case 13:
        La(l, s), Rr(s), _ = s.child, _.flags & 8192 && (T = _.memoizedState !== null, _.stateNode.isHidden = T, !T || _.alternate !== null && _.alternate.memoizedState !== null || (Tm = Ot())), y & 4 && Fy(s);
        break;
      case 22:
        if (_e = p !== null && p.memoizedState !== null, s.mode & 1 ? (Qi = (te = Qi) || _e, La(l, s), Qi = te) : La(l, s), Rr(s), y & 8192) {
          if (te = s.memoizedState !== null, (s.stateNode.isHidden = te) && !_e && s.mode & 1) for (Xe = s, _e = s.child; _e !== null; ) {
            for (Ee = Xe = _e; Xe !== null; ) {
              switch (xe = Xe, We = xe.child, xe.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  qc(4, xe, xe.return);
                  break;
                case 1:
                  bu(xe, xe.return);
                  var qe = xe.stateNode;
                  if (typeof qe.componentWillUnmount == "function") {
                    y = xe, p = xe.return;
                    try {
                      l = y, qe.props = l.memoizedProps, qe.state = l.memoizedState, qe.componentWillUnmount();
                    } catch (et) {
                      Ln(y, p, et);
                    }
                  }
                  break;
                case 5:
                  bu(xe, xe.return);
                  break;
                case 22:
                  if (xe.memoizedState !== null) {
                    ef(Ee);
                    continue;
                  }
              }
              We !== null ? (We.return = xe, Xe = We) : ef(Ee);
            }
            _e = _e.sibling;
          }
          e: for (_e = null, Ee = s; ; ) {
            if (Ee.tag === 5) {
              if (_e === null) {
                _e = Ee;
                try {
                  _ = Ee.stateNode, te ? (T = _.style, typeof T.setProperty == "function" ? T.setProperty("display", "none", "important") : T.display = "none") : (j = Ee.stateNode, U = Ee.memoizedProps.style, O = U != null && U.hasOwnProperty("display") ? U.display : null, j.style.display = Qt("display", O));
                } catch (et) {
                  Ln(s, s.return, et);
                }
              }
            } else if (Ee.tag === 6) {
              if (_e === null) try {
                Ee.stateNode.nodeValue = te ? "" : Ee.memoizedProps;
              } catch (et) {
                Ln(s, s.return, et);
              }
            } else if ((Ee.tag !== 22 && Ee.tag !== 23 || Ee.memoizedState === null || Ee === s) && Ee.child !== null) {
              Ee.child.return = Ee, Ee = Ee.child;
              continue;
            }
            if (Ee === s) break e;
            for (; Ee.sibling === null; ) {
              if (Ee.return === null || Ee.return === s) break e;
              _e === Ee && (_e = null), Ee = Ee.return;
            }
            _e === Ee && (_e = null), Ee.sibling.return = Ee.return, Ee = Ee.sibling;
          }
        }
        break;
      case 19:
        La(l, s), Rr(s), y & 4 && Fy(s);
        break;
      case 21:
        break;
      default:
        La(
          l,
          s
        ), Rr(s);
    }
  }
  function Rr(s) {
    var l = s.flags;
    if (l & 2) {
      try {
        e: {
          for (var p = s.return; p !== null; ) {
            if (Jc(p)) {
              var y = p;
              break e;
            }
            p = p.return;
          }
          throw Error(i(160));
        }
        switch (y.tag) {
          case 5:
            var _ = y.stateNode;
            y.flags & 32 && (Le(_, ""), y.flags &= -33);
            var T = Os(s);
            is(s, T, _);
            break;
          case 3:
          case 4:
            var O = y.stateNode.containerInfo, j = Os(s);
            ns(s, j, O);
            break;
          default:
            throw Error(i(161));
        }
      } catch (U) {
        Ln(s, s.return, U);
      }
      s.flags &= -3;
    }
    l & 4096 && (s.flags &= -4097);
  }
  function US(s, l, p) {
    Xe = s, Cm(s);
  }
  function Cm(s, l, p) {
    for (var y = (s.mode & 1) !== 0; Xe !== null; ) {
      var _ = Xe, T = _.child;
      if (_.tag === 22 && y) {
        var O = _.memoizedState !== null || Qc;
        if (!O) {
          var j = _.alternate, U = j !== null && j.memoizedState !== null || Qi;
          j = Qc;
          var te = Qi;
          if (Qc = O, (Qi = U) && !te) for (Xe = _; Xe !== null; ) O = Xe, U = O.child, O.tag === 22 && O.memoizedState !== null ? wm(_) : U !== null ? (U.return = O, Xe = U) : wm(_);
          for (; T !== null; ) Xe = T, Cm(T), T = T.sibling;
          Xe = _, Qc = j, Qi = te;
        }
        Vy(s);
      } else _.subtreeFlags & 8772 && T !== null ? (T.return = _, Xe = T) : Vy(s);
    }
  }
  function Vy(s) {
    for (; Xe !== null; ) {
      var l = Xe;
      if (l.flags & 8772) {
        var p = l.alternate;
        try {
          if (l.flags & 8772) switch (l.tag) {
            case 0:
            case 11:
            case 15:
              Qi || Zc(5, l);
              break;
            case 1:
              var y = l.stateNode;
              if (l.flags & 4 && !Qi) if (p === null) y.componentDidMount();
              else {
                var _ = l.elementType === l.type ? p.memoizedProps : Pa(l.type, p.memoizedProps);
                y.componentDidUpdate(_, p.memoizedState, y.__reactInternalSnapshotBeforeUpdate);
              }
              var T = l.updateQueue;
              T !== null && lm(l, T, y);
              break;
            case 3:
              var O = l.updateQueue;
              if (O !== null) {
                if (p = null, l.child !== null) switch (l.child.tag) {
                  case 5:
                    p = l.child.stateNode;
                    break;
                  case 1:
                    p = l.child.stateNode;
                }
                lm(l, O, p);
              }
              break;
            case 5:
              var j = l.stateNode;
              if (p === null && l.flags & 4) {
                p = j;
                var U = l.memoizedProps;
                switch (l.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    U.autoFocus && p.focus();
                    break;
                  case "img":
                    U.src && (p.src = U.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (l.memoizedState === null) {
                var te = l.alternate;
                if (te !== null) {
                  var _e = te.memoizedState;
                  if (_e !== null) {
                    var Ee = _e.dehydrated;
                    Ee !== null && Js(Ee);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(i(163));
          }
          Qi || l.flags & 512 && Sm(l);
        } catch (xe) {
          Ln(l, l.return, xe);
        }
      }
      if (l === s) {
        Xe = null;
        break;
      }
      if (p = l.sibling, p !== null) {
        p.return = l.return, Xe = p;
        break;
      }
      Xe = l.return;
    }
  }
  function ef(s) {
    for (; Xe !== null; ) {
      var l = Xe;
      if (l === s) {
        Xe = null;
        break;
      }
      var p = l.sibling;
      if (p !== null) {
        p.return = l.return, Xe = p;
        break;
      }
      Xe = l.return;
    }
  }
  function wm(s) {
    for (; Xe !== null; ) {
      var l = Xe;
      try {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            var p = l.return;
            try {
              Zc(4, l);
            } catch (U) {
              Ln(l, p, U);
            }
            break;
          case 1:
            var y = l.stateNode;
            if (typeof y.componentDidMount == "function") {
              var _ = l.return;
              try {
                y.componentDidMount();
              } catch (U) {
                Ln(l, _, U);
              }
            }
            var T = l.return;
            try {
              Sm(l);
            } catch (U) {
              Ln(l, T, U);
            }
            break;
          case 5:
            var O = l.return;
            try {
              Sm(l);
            } catch (U) {
              Ln(l, O, U);
            }
        }
      } catch (U) {
        Ln(l, l.return, U);
      }
      if (l === s) {
        Xe = null;
        break;
      }
      var j = l.sibling;
      if (j !== null) {
        j.return = l.return, Xe = j;
        break;
      }
      Xe = l.return;
    }
  }
  var IS = Math.ceil, po = B.ReactCurrentDispatcher, yl = B.ReactCurrentOwner, zi = B.ReactCurrentBatchConfig, Ut = 0, xi = null, hi = null, Fi = 0, Yr = 0, xu = Aa(0), ti = 0, tf = null, rs = 0, Su = 0, ih = 0, nf = null, Dr = null, Tm = 0, _u = 1 / 0, Gr = null, Cu = !1, bl = null, mo = null, rh = !1, Ps = null, rf = 0, go = 0, wu = null, af = -1, qi = 0;
  function pi() {
    return Ut & 6 ? Ot() : af !== -1 ? af : af = Ot();
  }
  function as(s) {
    return s.mode & 1 ? Ut & 2 && Fi !== 0 ? Fi & -Fi : BS.transition !== null ? (qi === 0 && (qi = qf()), qi) : (s = hn, s !== 0 || (s = window.event, s = s === void 0 ? 16 : td(s.type)), s) : 1;
  }
  function ar(s, l, p, y) {
    if (50 < go) throw go = 0, wu = null, Error(i(185));
    Go(s, p, y), (!(Ut & 2) || s !== xi) && (s === xi && (!(Ut & 2) && (Su |= p), ti === 4 && Na(s, Fi)), kr(s, y), p === 1 && Ut === 0 && !(l.mode & 1) && (_u = Ot() + 500, pu && qa()));
  }
  function kr(s, l) {
    var p = s.callbackNode;
    Sp(s, l);
    var y = Yo(s, s === xi ? Fi : 0);
    if (y === 0) p !== null && er(p), s.callbackNode = null, s.callbackPriority = 0;
    else if (l = y & -y, s.callbackPriority !== l) {
      if (p != null && er(p), l === 1) s.tag === 0 ? ro(Em.bind(null, s)) : wd(Em.bind(null, s)), cu(function() {
        !(Ut & 6) && qa();
      }), p = null;
      else {
        switch (wp(y)) {
          case 1:
            p = xs;
            break;
          case 4:
            p = uc;
            break;
          case 16:
            p = cc;
            break;
          case 536870912:
            p = bp;
            break;
          default:
            p = cc;
        }
        p = Ky(p, ah.bind(null, s));
      }
      s.callbackPriority = l, s.callbackNode = p;
    }
  }
  function ah(s, l) {
    if (af = -1, qi = 0, Ut & 6) throw Error(i(327));
    var p = s.callbackNode;
    if (Tu() && s.callbackNode !== p) return null;
    var y = Yo(s, s === xi ? Fi : 0);
    if (y === 0) return null;
    if (y & 30 || y & s.expiredLanes || l) l = sh(s, y);
    else {
      l = y;
      var _ = Ut;
      Ut |= 2;
      var T = By();
      (xi !== s || Fi !== l) && (Gr = null, _u = Ot() + 500, Ls(s, l));
      do
        try {
          Hy();
          break;
        } catch (j) {
          jy(s, j);
        }
      while (!0);
      nm(), po.current = T, Ut = _, hi !== null ? l = 0 : (xi = null, Fi = 0, l = ti);
    }
    if (l !== 0) {
      if (l === 2 && (_ = _p(s), _ !== 0 && (y = _, l = sf(s, _))), l === 1) throw p = tf, Ls(s, 0), Na(s, y), kr(s, Ot()), p;
      if (l === 6) Na(s, y);
      else {
        if (_ = s.current.alternate, !(y & 30) && !$S(_) && (l = sh(s, y), l === 2 && (T = _p(s), T !== 0 && (y = T, l = sf(s, T))), l === 1)) throw p = tf, Ls(s, 0), Na(s, y), kr(s, Ot()), p;
        switch (s.finishedWork = _, s.finishedLanes = y, l) {
          case 0:
          case 1:
            throw Error(i(345));
          case 2:
            _l(s, Dr, Gr);
            break;
          case 3:
            if (Na(s, y), (y & 130023424) === y && (l = Tm + 500 - Ot(), 10 < l)) {
              if (Yo(s, 0) !== 0) break;
              if (_ = s.suspendedLanes, (_ & y) !== y) {
                pi(), s.pingedLanes |= s.suspendedLanes & _;
                break;
              }
              s.timeoutHandle = Sd(_l.bind(null, s, Dr, Gr), l);
              break;
            }
            _l(s, Dr, Gr);
            break;
          case 4:
            if (Na(s, y), (y & 4194240) === y) break;
            for (l = s.eventTimes, _ = -1; 0 < y; ) {
              var O = 31 - Jr(y);
              T = 1 << O, O = l[O], O > _ && (_ = O), y &= ~T;
            }
            if (y = _, y = Ot() - y, y = (120 > y ? 120 : 480 > y ? 480 : 1080 > y ? 1080 : 1920 > y ? 1920 : 3e3 > y ? 3e3 : 4320 > y ? 4320 : 1960 * IS(y / 1960)) - y, 10 < y) {
              s.timeoutHandle = Sd(_l.bind(null, s, Dr, Gr), y);
              break;
            }
            _l(s, Dr, Gr);
            break;
          case 5:
            _l(s, Dr, Gr);
            break;
          default:
            throw Error(i(329));
        }
      }
    }
    return kr(s, Ot()), s.callbackNode === p ? ah.bind(null, s) : null;
  }
  function sf(s, l) {
    var p = nf;
    return s.current.memoizedState.isDehydrated && (Ls(s, l).flags |= 256), s = sh(s, l), s !== 2 && (l = Dr, Dr = p, l !== null && xl(l)), s;
  }
  function xl(s) {
    Dr === null ? Dr = s : Dr.push.apply(Dr, s);
  }
  function $S(s) {
    for (var l = s; ; ) {
      if (l.flags & 16384) {
        var p = l.updateQueue;
        if (p !== null && (p = p.stores, p !== null)) for (var y = 0; y < p.length; y++) {
          var _ = p[y], T = _.getSnapshot;
          _ = _.value;
          try {
            if (!ka(T(), _)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (p = l.child, l.subtreeFlags & 16384 && p !== null) p.return = l, l = p;
      else {
        if (l === s) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === s) return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function Na(s, l) {
    for (l &= ~ih, l &= ~Su, s.suspendedLanes |= l, s.pingedLanes &= ~l, s = s.expirationTimes; 0 < l; ) {
      var p = 31 - Jr(l), y = 1 << p;
      s[p] = -1, l &= ~y;
    }
  }
  function Em(s) {
    if (Ut & 6) throw Error(i(327));
    Tu();
    var l = Yo(s, 0);
    if (!(l & 1)) return kr(s, Ot()), null;
    var p = sh(s, l);
    if (s.tag !== 0 && p === 2) {
      var y = _p(s);
      y !== 0 && (l = y, p = sf(s, y));
    }
    if (p === 1) throw p = tf, Ls(s, 0), Na(s, l), kr(s, Ot()), p;
    if (p === 6) throw Error(i(345));
    return s.finishedWork = s.current.alternate, s.finishedLanes = l, _l(s, Dr, Gr), kr(s, Ot()), null;
  }
  function Rm(s, l) {
    var p = Ut;
    Ut |= 1;
    try {
      return s(l);
    } finally {
      Ut = p, Ut === 0 && (_u = Ot() + 500, pu && qa());
    }
  }
  function Sl(s) {
    Ps !== null && Ps.tag === 0 && !(Ut & 6) && Tu();
    var l = Ut;
    Ut |= 1;
    var p = zi.transition, y = hn;
    try {
      if (zi.transition = null, hn = 1, s) return s();
    } finally {
      hn = y, zi.transition = p, Ut = l, !(Ut & 6) && qa();
    }
  }
  function Dm() {
    Yr = xu.current, Cn(xu);
  }
  function Ls(s, l) {
    s.finishedWork = null, s.finishedLanes = 0;
    var p = s.timeoutHandle;
    if (p !== -1 && (s.timeoutHandle = -1, qp(p)), hi !== null) for (p = hi.return; p !== null; ) {
      var y = p;
      switch (Ed(y), y.tag) {
        case 1:
          y = y.type.childContextTypes, y != null && hu();
          break;
        case 3:
          ul(), Cn(yi), Cn(Yn), st();
          break;
        case 5:
          Md(y);
          break;
        case 4:
          ul();
          break;
        case 13:
          Cn(Vn);
          break;
        case 19:
          Cn(Vn);
          break;
        case 10:
          im(y.type._context);
          break;
        case 22:
        case 23:
          Dm();
      }
      p = p.return;
    }
    if (xi = s, hi = s = vo(s.current, null), Fi = Yr = l, ti = 0, tf = null, ih = Su = rs = 0, Dr = nf = null, ol !== null) {
      for (l = 0; l < ol.length; l++) if (p = ol[l], y = p.interleaved, y !== null) {
        p.interleaved = null;
        var _ = y.next, T = p.pending;
        if (T !== null) {
          var O = T.next;
          T.next = _, y.next = O;
        }
        p.pending = y;
      }
      ol = null;
    }
    return s;
  }
  function jy(s, l) {
    do {
      var p = hi;
      try {
        if (nm(), Nt.current = ml, Od) {
          for (var y = tn.memoizedState; y !== null; ) {
            var _ = y.queue;
            _ !== null && (_.pending = null), y = y.next;
          }
          Od = !1;
        }
        if (mn = 0, Ti = ci = tn = null, zc = !1, cl = 0, yl.current = null, p === null || p.return === null) {
          ti = 1, tf = l, hi = null;
          break;
        }
        e: {
          var T = s, O = p.return, j = p, U = l;
          if (l = Fi, j.flags |= 32768, U !== null && typeof U == "object" && typeof U.then == "function") {
            var te = U, _e = j, Ee = _e.tag;
            if (!(_e.mode & 1) && (Ee === 0 || Ee === 11 || Ee === 15)) {
              var xe = _e.alternate;
              xe ? (_e.updateQueue = xe.updateQueue, _e.memoizedState = xe.memoizedState, _e.lanes = xe.lanes) : (_e.updateQueue = null, _e.memoizedState = null);
            }
            var We = Ey(O);
            if (We !== null) {
              We.flags &= -257, ho(We, O, j, T, l), We.mode & 1 && gm(T, te, l), l = We, U = te;
              var qe = l.updateQueue;
              if (qe === null) {
                var et = /* @__PURE__ */ new Set();
                et.add(U), l.updateQueue = et;
              } else qe.add(U);
              break e;
            } else {
              if (!(l & 1)) {
                gm(T, te, l), km();
                break e;
              }
              U = Error(i(426));
            }
          } else if (Pn && j.mode & 1) {
            var ni = Ey(O);
            if (ni !== null) {
              !(ni.flags & 65536) && (ni.flags |= 256), ho(ni, O, j, T, l), ks(gl(U, j));
              break e;
            }
          }
          T = U = gl(U, j), ti !== 4 && (ti = 2), nf === null ? nf = [T] : nf.push(T), T = O;
          do {
            switch (T.tag) {
              case 3:
                T.flags |= 65536, l &= -l, T.lanes |= l;
                var X = Ty(T, U, l);
                xy(T, X);
                break e;
              case 1:
                j = U;
                var $ = T.type, Z = T.stateNode;
                if (!(T.flags & 128) && (typeof $.getDerivedStateFromError == "function" || Z !== null && typeof Z.componentDidCatch == "function" && (mo === null || !mo.has(Z)))) {
                  T.flags |= 65536, l &= -l, T.lanes |= l;
                  var Ce = mm(T, j, l);
                  xy(T, Ce);
                  break e;
                }
            }
            T = T.return;
          } while (T !== null);
        }
        Iy(p);
      } catch (Ze) {
        l = Ze, hi === p && p !== null && (hi = p = p.return);
        continue;
      }
      break;
    } while (!0);
  }
  function By() {
    var s = po.current;
    return po.current = ml, s === null ? ml : s;
  }
  function km() {
    (ti === 0 || ti === 3 || ti === 2) && (ti = 4), xi === null || !(rs & 268435455) && !(Su & 268435455) || Na(xi, Fi);
  }
  function sh(s, l) {
    var p = Ut;
    Ut |= 2;
    var y = By();
    (xi !== s || Fi !== l) && (Gr = null, Ls(s, l));
    do
      try {
        WS();
        break;
      } catch (_) {
        jy(s, _);
      }
    while (!0);
    if (nm(), Ut = p, po.current = y, hi !== null) throw Error(i(261));
    return xi = null, Fi = 0, ti;
  }
  function WS() {
    for (; hi !== null; ) Uy(hi);
  }
  function Hy() {
    for (; hi !== null && !ys(); ) Uy(hi);
  }
  function Uy(s) {
    var l = Gy(s.alternate, s, Yr);
    s.memoizedProps = s.pendingProps, l === null ? Iy(s) : hi = l, yl.current = null;
  }
  function Iy(s) {
    var l = s;
    do {
      var p = l.alternate;
      if (s = l.return, l.flags & 32768) {
        if (p = eh(p, l), p !== null) {
          p.flags &= 32767, hi = p;
          return;
        }
        if (s !== null) s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null;
        else {
          ti = 6, hi = null;
          return;
        }
      } else if (p = Py(p, l, Yr), p !== null) {
        hi = p;
        return;
      }
      if (l = l.sibling, l !== null) {
        hi = l;
        return;
      }
      hi = l = s;
    } while (l !== null);
    ti === 0 && (ti = 5);
  }
  function _l(s, l, p) {
    var y = hn, _ = zi.transition;
    try {
      zi.transition = null, hn = 1, YS(s, l, p, y);
    } finally {
      zi.transition = _, hn = y;
    }
    return null;
  }
  function YS(s, l, p, y) {
    do
      Tu();
    while (Ps !== null);
    if (Ut & 6) throw Error(i(327));
    p = s.finishedWork;
    var _ = s.finishedLanes;
    if (p === null) return null;
    if (s.finishedWork = null, s.finishedLanes = 0, p === s.current) throw Error(i(177));
    s.callbackNode = null, s.callbackPriority = 0;
    var T = p.lanes | p.childLanes;
    if (SS(s, T), s === xi && (hi = xi = null, Fi = 0), !(p.subtreeFlags & 2064) && !(p.flags & 2064) || rh || (rh = !0, Ky(cc, function() {
      return Tu(), null;
    })), T = (p.flags & 15990) !== 0, p.subtreeFlags & 15990 || T) {
      T = zi.transition, zi.transition = null;
      var O = hn;
      hn = 1;
      var j = Ut;
      Ut |= 4, yl.current = null, Ny(s, p), _m(p, s), su(nl), Xo = !!Ec, nl = Ec = null, s.current = p, US(p), bs(), Ut = j, hn = O, zi.transition = T;
    } else s.current = p;
    if (rh && (rh = !1, Ps = s, rf = _), T = s.pendingLanes, T === 0 && (mo = null), zv(p.stateNode), kr(s, Ot()), l !== null) for (y = s.onRecoverableError, p = 0; p < l.length; p++) _ = l[p], y(_.value, { componentStack: _.stack, digest: _.digest });
    if (Cu) throw Cu = !1, s = bl, bl = null, s;
    return rf & 1 && s.tag !== 0 && Tu(), T = s.pendingLanes, T & 1 ? s === wu ? go++ : (go = 0, wu = s) : go = 0, qa(), null;
  }
  function Tu() {
    if (Ps !== null) {
      var s = wp(rf), l = zi.transition, p = hn;
      try {
        if (zi.transition = null, hn = 16 > s ? 16 : s, Ps === null) var y = !1;
        else {
          if (s = Ps, Ps = null, rf = 0, Ut & 6) throw Error(i(331));
          var _ = Ut;
          for (Ut |= 4, Xe = s.current; Xe !== null; ) {
            var T = Xe, O = T.child;
            if (Xe.flags & 16) {
              var j = T.deletions;
              if (j !== null) {
                for (var U = 0; U < j.length; U++) {
                  var te = j[U];
                  for (Xe = te; Xe !== null; ) {
                    var _e = Xe;
                    switch (_e.tag) {
                      case 0:
                      case 11:
                      case 15:
                        qc(8, _e, T);
                    }
                    var Ee = _e.child;
                    if (Ee !== null) Ee.return = _e, Xe = Ee;
                    else for (; Xe !== null; ) {
                      _e = Xe;
                      var xe = _e.sibling, We = _e.return;
                      if (nh(_e), _e === te) {
                        Xe = null;
                        break;
                      }
                      if (xe !== null) {
                        xe.return = We, Xe = xe;
                        break;
                      }
                      Xe = We;
                    }
                  }
                }
                var qe = T.alternate;
                if (qe !== null) {
                  var et = qe.child;
                  if (et !== null) {
                    qe.child = null;
                    do {
                      var ni = et.sibling;
                      et.sibling = null, et = ni;
                    } while (et !== null);
                  }
                }
                Xe = T;
              }
            }
            if (T.subtreeFlags & 2064 && O !== null) O.return = T, Xe = O;
            else e: for (; Xe !== null; ) {
              if (T = Xe, T.flags & 2048) switch (T.tag) {
                case 0:
                case 11:
                case 15:
                  qc(9, T, T.return);
              }
              var X = T.sibling;
              if (X !== null) {
                X.return = T.return, Xe = X;
                break e;
              }
              Xe = T.return;
            }
          }
          var $ = s.current;
          for (Xe = $; Xe !== null; ) {
            O = Xe;
            var Z = O.child;
            if (O.subtreeFlags & 2064 && Z !== null) Z.return = O, Xe = Z;
            else e: for (O = $; Xe !== null; ) {
              if (j = Xe, j.flags & 2048) try {
                switch (j.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Zc(9, j);
                }
              } catch (Ze) {
                Ln(j, j.return, Ze);
              }
              if (j === O) {
                Xe = null;
                break e;
              }
              var Ce = j.sibling;
              if (Ce !== null) {
                Ce.return = j.return, Xe = Ce;
                break e;
              }
              Xe = j.return;
            }
          }
          if (Ut = _, qa(), Ra && typeof Ra.onPostCommitFiberRoot == "function") try {
            Ra.onPostCommitFiberRoot(fc, s);
          } catch {
          }
          y = !0;
        }
        return y;
      } finally {
        hn = p, zi.transition = l;
      }
    }
    return !1;
  }
  function $y(s, l, p) {
    l = gl(p, l), l = Ty(s, l, 1), s = uo(s, l, 1), l = pi(), s !== null && (Go(s, 1, l), kr(s, l));
  }
  function Ln(s, l, p) {
    if (s.tag === 3) $y(s, s, p);
    else for (; l !== null; ) {
      if (l.tag === 3) {
        $y(l, s, p);
        break;
      } else if (l.tag === 1) {
        var y = l.stateNode;
        if (typeof l.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (mo === null || !mo.has(y))) {
          s = gl(p, s), s = mm(l, s, 1), l = uo(l, s, 1), s = pi(), l !== null && (Go(l, 1, s), kr(l, s));
          break;
        }
      }
      l = l.return;
    }
  }
  function GS(s, l, p) {
    var y = s.pingCache;
    y !== null && y.delete(l), l = pi(), s.pingedLanes |= s.suspendedLanes & p, xi === s && (Fi & p) === p && (ti === 4 || ti === 3 && (Fi & 130023424) === Fi && 500 > Ot() - Tm ? Ls(s, 0) : ih |= p), kr(s, l);
  }
  function Wy(s, l) {
    l === 0 && (s.mode & 1 ? (l = Da, Da <<= 1, !(Da & 130023424) && (Da = 4194304)) : l = 1);
    var p = pi();
    s = Ir(s, l), s !== null && (Go(s, l, p), kr(s, p));
  }
  function KS(s) {
    var l = s.memoizedState, p = 0;
    l !== null && (p = l.retryLane), Wy(s, p);
  }
  function Yy(s, l) {
    var p = 0;
    switch (s.tag) {
      case 13:
        var y = s.stateNode, _ = s.memoizedState;
        _ !== null && (p = _.retryLane);
        break;
      case 19:
        y = s.stateNode;
        break;
      default:
        throw Error(i(314));
    }
    y !== null && y.delete(l), Wy(s, p);
  }
  var Gy;
  Gy = function(s, l, p) {
    if (s !== null) if (s.memoizedProps !== l.pendingProps || yi.current) fi = !0;
    else {
      if (!(s.lanes & p) && !(l.flags & 128)) return fi = !1, Kc(s, l, p);
      fi = !!(s.flags & 131072);
    }
    else fi = !1, Pn && l.flags & 1048576 && gy(l, Ds, l.index);
    switch (l.lanes = 0, l.tag) {
      case 2:
        var y = l.type;
        la(s, l), s = l.pendingProps;
        var _ = ra(l, Yn.current);
        Fn(l, p), _ = co(null, l, y, s, _, p);
        var T = Oa();
        return l.flags |= 1, typeof _ == "object" && _ !== null && typeof _.render == "function" && _.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, li(y) ? (T = !0, _r(l)) : T = !1, l.memoizedState = _.state !== null && _.state !== void 0 ? _.state : null, om(l), _.updater = Xd, l.stateNode = _, _._reactInternals = l, Ic(l, y, s, p), l = Yc(null, l, y, !0, T, p)) : (l.tag = 0, Pn && T && Td(l), Ni(null, l, _, p), l = l.child), l;
      case 16:
        y = l.elementType;
        e: {
          switch (la(s, l), s = l.pendingProps, _ = y._init, y = _(y._payload), l.type = y, _ = l.tag = QS(y), s = Pa(y, s), _) {
            case 0:
              l = Ry(null, l, y, s, p);
              break e;
            case 1:
              l = Dy(null, l, y, s, p);
              break e;
            case 11:
              l = Er(null, l, y, s, p);
              break e;
            case 14:
              l = vl(null, l, y, Pa(y.type, s), p);
              break e;
          }
          throw Error(i(
            306,
            y,
            ""
          ));
        }
        return l;
      case 0:
        return y = l.type, _ = l.pendingProps, _ = l.elementType === y ? _ : Pa(y, _), Ry(s, l, y, _, p);
      case 1:
        return y = l.type, _ = l.pendingProps, _ = l.elementType === y ? _ : Pa(y, _), Dy(s, l, y, _, p);
      case 3:
        e: {
          if (yu(l), s === null) throw Error(i(387));
          y = l.pendingProps, T = l.memoizedState, _ = T.element, by(s, l), Ac(l, y, null, p);
          var O = l.memoizedState;
          if (y = O.element, T.isDehydrated) if (T = { element: y, isDehydrated: !1, cache: O.cache, pendingSuspenseBoundaries: O.pendingSuspenseBoundaries, transitions: O.transitions }, l.updateQueue.baseState = T, l.memoizedState = T, l.flags & 256) {
            _ = gl(Error(i(423)), l), l = ky(s, l, y, p, _);
            break e;
          } else if (y !== _) {
            _ = gl(Error(i(424)), l), l = ky(s, l, y, p, _);
            break e;
          } else for (wr = Ka(l.stateNode.containerInfo.firstChild), Cr = l, Pn = !0, sa = null, p = Ue(l, null, y, p), l.child = p; p; ) p.flags = p.flags & -3 | 4096, p = p.sibling;
          else {
            if (lo(), y === _) {
              l = ua(s, l, p);
              break e;
            }
            Ni(s, l, y, p);
          }
          l = l.child;
        }
        return l;
      case 5:
        return Sy(l), s === null && em(l), y = l.type, _ = l.pendingProps, T = s !== null ? s.memoizedProps : null, O = _.children, xd(y, _) ? O = null : T !== null && xd(y, T) && (l.flags |= 32), vm(s, l), Ni(s, l, O, p), l.child;
      case 6:
        return s === null && em(l), null;
      case 13:
        return Jd(s, l, p);
      case 4:
        return um(l, l.stateNode.containerInfo), y = l.pendingProps, s === null ? l.child = Zn(l, null, y, p) : Ni(s, l, y, p), l.child;
      case 11:
        return y = l.type, _ = l.pendingProps, _ = l.elementType === y ? _ : Pa(y, _), Er(s, l, y, _, p);
      case 7:
        return Ni(s, l, l.pendingProps, p), l.child;
      case 8:
        return Ni(s, l, l.pendingProps.children, p), l.child;
      case 12:
        return Ni(s, l, l.pendingProps.children, p), l.child;
      case 10:
        e: {
          if (y = l.type._context, _ = l.pendingProps, T = l.memoizedProps, O = _.value, rt(Ur, y._currentValue), y._currentValue = O, T !== null) if (ka(T.value, O)) {
            if (T.children === _.children && !yi.current) {
              l = ua(s, l, p);
              break e;
            }
          } else for (T = l.child, T !== null && (T.return = l); T !== null; ) {
            var j = T.dependencies;
            if (j !== null) {
              O = T.child;
              for (var U = j.firstContext; U !== null; ) {
                if (U.context === y) {
                  if (T.tag === 1) {
                    U = Ms(-1, p & -p), U.tag = 2;
                    var te = T.updateQueue;
                    if (te !== null) {
                      te = te.shared;
                      var _e = te.pending;
                      _e === null ? U.next = U : (U.next = _e.next, _e.next = U), te.pending = U;
                    }
                  }
                  T.lanes |= p, U = T.alternate, U !== null && (U.lanes |= p), rm(
                    T.return,
                    p,
                    l
                  ), j.lanes |= p;
                  break;
                }
                U = U.next;
              }
            } else if (T.tag === 10) O = T.type === l.type ? null : T.child;
            else if (T.tag === 18) {
              if (O = T.return, O === null) throw Error(i(341));
              O.lanes |= p, j = O.alternate, j !== null && (j.lanes |= p), rm(O, p, l), O = T.sibling;
            } else O = T.child;
            if (O !== null) O.return = T;
            else for (O = T; O !== null; ) {
              if (O === l) {
                O = null;
                break;
              }
              if (T = O.sibling, T !== null) {
                T.return = O.return, O = T;
                break;
              }
              O = O.return;
            }
            T = O;
          }
          Ni(s, l, _.children, p), l = l.child;
        }
        return l;
      case 9:
        return _ = l.type, y = l.pendingProps.children, Fn(l, p), _ = oa(_), y = y(_), l.flags |= 1, Ni(s, l, y, p), l.child;
      case 14:
        return y = l.type, _ = Pa(y, l.pendingProps), _ = Pa(y.type, _), vl(s, l, y, _, p);
      case 15:
        return Mt(s, l, l.type, l.pendingProps, p);
      case 17:
        return y = l.type, _ = l.pendingProps, _ = l.elementType === y ? _ : Pa(y, _), la(s, l), l.tag = 1, li(y) ? (s = !0, _r(l)) : s = !1, Fn(l, p), Qd(l, y, _), Ic(l, y, _, p), Yc(null, l, y, !0, s, p);
      case 19:
        return ts(s, l, p);
      case 22:
        return Wc(s, l, p);
    }
    throw Error(i(156, l.tag));
  };
  function Ky(s, l) {
    return zn(s, l);
  }
  function XS(s, l, p, y) {
    this.tag = s, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function fa(s, l, p, y) {
    return new XS(s, l, p, y);
  }
  function Mm(s) {
    return s = s.prototype, !(!s || !s.isReactComponent);
  }
  function QS(s) {
    if (typeof s == "function") return Mm(s) ? 1 : 0;
    if (s != null) {
      if (s = s.$$typeof, s === oe) return 11;
      if (s === Te) return 14;
    }
    return 2;
  }
  function vo(s, l) {
    var p = s.alternate;
    return p === null ? (p = fa(s.tag, l, s.key, s.mode), p.elementType = s.elementType, p.type = s.type, p.stateNode = s.stateNode, p.alternate = s, s.alternate = p) : (p.pendingProps = l, p.type = s.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = s.flags & 14680064, p.childLanes = s.childLanes, p.lanes = s.lanes, p.child = s.child, p.memoizedProps = s.memoizedProps, p.memoizedState = s.memoizedState, p.updateQueue = s.updateQueue, l = s.dependencies, p.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, p.sibling = s.sibling, p.index = s.index, p.ref = s.ref, p;
  }
  function of(s, l, p, y, _, T) {
    var O = 2;
    if (y = s, typeof s == "function") Mm(s) && (O = 1);
    else if (typeof s == "string") O = 5;
    else e: switch (s) {
      case Y:
        return Ns(p.children, _, T, l);
      case K:
        O = 8, _ |= 8;
        break;
      case ae:
        return s = fa(12, p, l, _ | 2), s.elementType = ae, s.lanes = T, s;
      case se:
        return s = fa(13, p, l, _), s.elementType = se, s.lanes = T, s;
      case Pe:
        return s = fa(19, p, l, _), s.elementType = Pe, s.lanes = T, s;
      case Oe:
        return yo(p, _, T, l);
      default:
        if (typeof s == "object" && s !== null) switch (s.$$typeof) {
          case ie:
            O = 10;
            break e;
          case ee:
            O = 9;
            break e;
          case oe:
            O = 11;
            break e;
          case Te:
            O = 14;
            break e;
          case Se:
            O = 16, y = null;
            break e;
        }
        throw Error(i(130, s == null ? s : typeof s, ""));
    }
    return l = fa(O, p, l, _), l.elementType = s, l.type = y, l.lanes = T, l;
  }
  function Ns(s, l, p, y) {
    return s = fa(7, s, y, l), s.lanes = p, s;
  }
  function yo(s, l, p, y) {
    return s = fa(22, s, y, l), s.elementType = Oe, s.lanes = p, s.stateNode = { isHidden: !1 }, s;
  }
  function Am(s, l, p) {
    return s = fa(6, s, null, l), s.lanes = p, s;
  }
  function oh(s, l, p) {
    return l = fa(4, s.children !== null ? s.children : [], s.key, l), l.lanes = p, l.stateNode = { containerInfo: s.containerInfo, pendingChildren: null, implementation: s.implementation }, l;
  }
  function Xy(s, l, p, y, _) {
    this.tag = l, this.containerInfo = s, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Cp(0), this.expirationTimes = Cp(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Cp(0), this.identifierPrefix = y, this.onRecoverableError = _, this.mutableSourceEagerHydrationData = null;
  }
  function lh(s, l, p, y, _, T, O, j, U) {
    return s = new Xy(s, l, p, j, U), l === 1 ? (l = 1, T === !0 && (l |= 8)) : l = 0, T = fa(3, null, null, l), s.current = T, T.stateNode = s, T.memoizedState = { element: y, isDehydrated: p, cache: null, transitions: null, pendingSuspenseBoundaries: null }, om(T), s;
  }
  function qS(s, l, p) {
    var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: G, key: y == null ? null : "" + y, children: s, containerInfo: l, implementation: p };
  }
  function Om(s) {
    if (!s) return xr;
    s = s._reactInternals;
    e: {
      if (lt(s) !== s || s.tag !== 1) throw Error(i(170));
      var l = s;
      do {
        switch (l.tag) {
          case 3:
            l = l.stateNode.context;
            break e;
          case 1:
            if (li(l.type)) {
              l = l.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        l = l.return;
      } while (l !== null);
      throw Error(i(171));
    }
    if (s.tag === 1) {
      var p = s.type;
      if (li(p)) return kc(s, p, l);
    }
    return l;
  }
  function Qy(s, l, p, y, _, T, O, j, U) {
    return s = lh(p, y, !0, s, _, T, O, j, U), s.context = Om(null), p = s.current, y = pi(), _ = as(p), T = Ms(y, _), T.callback = l ?? null, uo(p, T, _), s.current.lanes = _, Go(s, _, y), kr(s, y), s;
  }
  function uh(s, l, p, y) {
    var _ = l.current, T = pi(), O = as(_);
    return p = Om(p), l.context === null ? l.context = p : l.pendingContext = p, l = Ms(T, O), l.payload = { element: s }, y = y === void 0 ? null : y, y !== null && (l.callback = y), s = uo(_, l, O), s !== null && (ar(s, _, O, T), kd(s, _, O)), O;
  }
  function ch(s) {
    if (s = s.current, !s.child) return null;
    switch (s.child.tag) {
      case 5:
        return s.child.stateNode;
      default:
        return s.child.stateNode;
    }
  }
  function Pm(s, l) {
    if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
      var p = s.retryLane;
      s.retryLane = p !== 0 && p < l ? p : l;
    }
  }
  function fh(s, l) {
    Pm(s, l), (s = s.alternate) && Pm(s, l);
  }
  function qy() {
    return null;
  }
  var Cl = typeof reportError == "function" ? reportError : function(s) {
    console.error(s);
  };
  function Lm(s) {
    this._internalRoot = s;
  }
  dh.prototype.render = Lm.prototype.render = function(s) {
    var l = this._internalRoot;
    if (l === null) throw Error(i(409));
    uh(s, l, null, null);
  }, dh.prototype.unmount = Lm.prototype.unmount = function() {
    var s = this._internalRoot;
    if (s !== null) {
      this._internalRoot = null;
      var l = s.containerInfo;
      Sl(function() {
        uh(null, s, null, null);
      }), l[Es] = null;
    }
  };
  function dh(s) {
    this._internalRoot = s;
  }
  dh.prototype.unstable_scheduleHydration = function(s) {
    if (s) {
      var l = kt();
      s = { blockedOn: null, target: s, priority: l };
      for (var p = 0; p < Oi.length && l !== 0 && l < Oi[p].priority; p++) ;
      Oi.splice(p, 0, s), p === 0 && kp(s);
    }
  };
  function Nm(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11);
  }
  function hh(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11 && (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "));
  }
  function Zy() {
  }
  function ZS(s, l, p, y, _) {
    if (_) {
      if (typeof y == "function") {
        var T = y;
        y = function() {
          var te = ch(O);
          T.call(te);
        };
      }
      var O = Qy(l, y, s, 0, null, !1, !1, "", Zy);
      return s._reactRootContainer = O, s[Es] = O.current, lu(s.nodeType === 8 ? s.parentNode : s), Sl(), O;
    }
    for (; _ = s.lastChild; ) s.removeChild(_);
    if (typeof y == "function") {
      var j = y;
      y = function() {
        var te = ch(U);
        j.call(te);
      };
    }
    var U = lh(s, 0, !1, null, null, !1, !1, "", Zy);
    return s._reactRootContainer = U, s[Es] = U.current, lu(s.nodeType === 8 ? s.parentNode : s), Sl(function() {
      uh(l, U, p, y);
    }), U;
  }
  function lf(s, l, p, y, _) {
    var T = p._reactRootContainer;
    if (T) {
      var O = T;
      if (typeof _ == "function") {
        var j = _;
        _ = function() {
          var U = ch(O);
          j.call(U);
        };
      }
      uh(l, O, s, _);
    } else O = ZS(p, l, s, _, y);
    return ch(O);
  }
  pn = function(s) {
    switch (s.tag) {
      case 3:
        var l = s.stateNode;
        if (l.current.memoizedState.isDehydrated) {
          var p = Wo(l.pendingLanes);
          p !== 0 && (Zf(l, p | 1), kr(l, Ot()), !(Ut & 6) && (_u = Ot() + 500, qa()));
        }
        break;
      case 13:
        Sl(function() {
          var y = Ir(s, 1);
          if (y !== null) {
            var _ = pi();
            ar(y, s, 1, _);
          }
        }), fh(s, 1);
    }
  }, Tp = function(s) {
    if (s.tag === 13) {
      var l = Ir(s, 134217728);
      if (l !== null) {
        var p = pi();
        ar(l, s, 134217728, p);
      }
      fh(s, 134217728);
    }
  }, Ep = function(s) {
    if (s.tag === 13) {
      var l = as(s), p = Ir(s, l);
      if (p !== null) {
        var y = pi();
        ar(p, s, l, y);
      }
      fh(s, l);
    }
  }, kt = function() {
    return hn;
  }, Rp = function(s, l) {
    var p = hn;
    try {
      return hn = s, l();
    } finally {
      hn = p;
    }
  }, qt = function(s, l, p) {
    switch (l) {
      case "input":
        if (on(s, p), l = p.name, p.type === "radio" && l != null) {
          for (p = s; p.parentNode; ) p = p.parentNode;
          for (p = p.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < p.length; l++) {
            var y = p[l];
            if (y !== s && y.form === s.form) {
              var _ = qn(y);
              if (!_) throw Error(i(90));
              At(y), on(y, _);
            }
          }
        }
        break;
      case "textarea":
        Dn(s, p);
        break;
      case "select":
        l = p.value, l != null && Dt(s, !!p.multiple, l, !1);
    }
  }, ft = Rm, ce = Sl;
  var JS = { usingClientEntryPoint: !1, Events: [at, Ma, qn, Ve, Qe, Rm] }, uf = { findFiberByHostInstance: il, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Jy = { bundleType: uf.bundleType, version: uf.version, rendererPackageName: uf.rendererPackageName, rendererConfig: uf.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: B.ReactCurrentDispatcher, findHostInstanceByFiber: function(s) {
    return s = vi(s), s === null ? null : s.stateNode;
  }, findFiberByHostInstance: uf.findFiberByHostInstance || qy, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var bo = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!bo.isDisabled && bo.supportsFiber) try {
      fc = bo.inject(Jy), Ra = bo;
    } catch {
    }
  }
  return ya.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = JS, ya.createPortal = function(s, l) {
    var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Nm(l)) throw Error(i(200));
    return qS(s, l, null, p);
  }, ya.createRoot = function(s, l) {
    if (!Nm(s)) throw Error(i(299));
    var p = !1, y = "", _ = Cl;
    return l != null && (l.unstable_strictMode === !0 && (p = !0), l.identifierPrefix !== void 0 && (y = l.identifierPrefix), l.onRecoverableError !== void 0 && (_ = l.onRecoverableError)), l = lh(s, 1, !1, null, null, p, !1, y, _), s[Es] = l.current, lu(s.nodeType === 8 ? s.parentNode : s), new Lm(l);
  }, ya.findDOMNode = function(s) {
    if (s == null) return null;
    if (s.nodeType === 1) return s;
    var l = s._reactInternals;
    if (l === void 0)
      throw typeof s.render == "function" ? Error(i(188)) : (s = Object.keys(s).join(","), Error(i(268, s)));
    return s = vi(l), s = s === null ? null : s.stateNode, s;
  }, ya.flushSync = function(s) {
    return Sl(s);
  }, ya.hydrate = function(s, l, p) {
    if (!hh(l)) throw Error(i(200));
    return lf(null, s, l, !0, p);
  }, ya.hydrateRoot = function(s, l, p) {
    if (!Nm(s)) throw Error(i(405));
    var y = p != null && p.hydratedSources || null, _ = !1, T = "", O = Cl;
    if (p != null && (p.unstable_strictMode === !0 && (_ = !0), p.identifierPrefix !== void 0 && (T = p.identifierPrefix), p.onRecoverableError !== void 0 && (O = p.onRecoverableError)), l = Qy(l, null, s, 1, p ?? null, _, !1, T, O), s[Es] = l.current, lu(s), y) for (s = 0; s < y.length; s++) p = y[s], _ = p._getVersion, _ = _(p._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [p, _] : l.mutableSourceEagerHydrationData.push(
      p,
      _
    );
    return new dh(l);
  }, ya.render = function(s, l, p) {
    if (!hh(l)) throw Error(i(200));
    return lf(null, s, l, !1, p);
  }, ya.unmountComponentAtNode = function(s) {
    if (!hh(s)) throw Error(i(40));
    return s._reactRootContainer ? (Sl(function() {
      lf(null, null, s, !1, function() {
        s._reactRootContainer = null, s[Es] = null;
      });
    }), !0) : !1;
  }, ya.unstable_batchedUpdates = Rm, ya.unstable_renderSubtreeIntoContainer = function(s, l, p, y) {
    if (!hh(p)) throw Error(i(200));
    if (s == null || s._reactInternals === void 0) throw Error(i(38));
    return lf(s, l, p, !1, y);
  }, ya.version = "18.3.1-next-f1338f8080-20240426", ya;
}
var ba = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WA;
function I4() {
  return WA || (WA = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = ip, e = JL(), i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, a = !1;
    function o(n) {
      a = n;
    }
    function f(n) {
      if (!a) {
        for (var r = arguments.length, c = new Array(r > 1 ? r - 1 : 0), d = 1; d < r; d++)
          c[d - 1] = arguments[d];
        h("warn", n, c);
      }
    }
    function u(n) {
      if (!a) {
        for (var r = arguments.length, c = new Array(r > 1 ? r - 1 : 0), d = 1; d < r; d++)
          c[d - 1] = arguments[d];
        h("error", n, c);
      }
    }
    function h(n, r, c) {
      {
        var d = i.ReactDebugCurrentFrame, g = d.getStackAddendum();
        g !== "" && (r += "%s", c = c.concat([g]));
        var x = c.map(function(w) {
          return String(w);
        });
        x.unshift("Warning: " + r), Function.prototype.apply.call(console[n], console, x);
      }
    }
    var m = 0, v = 1, b = 2, S = 3, C = 4, E = 5, D = 6, M = 7, A = 8, P = 9, N = 10, F = 11, B = 12, V = 13, G = 14, Y = 15, K = 16, ae = 17, ie = 18, ee = 19, oe = 21, se = 22, Pe = 23, Te = 24, Se = 25, Oe = !0, re = !1, ge = !1, me = !1, fe = !1, pe = !0, Ae = !0, Ne = !0, de = !0, ze = /* @__PURE__ */ new Set(), De = {}, we = {};
    function ct(n, r) {
      gt(n, r), gt(n + "Capture", r);
    }
    function gt(n, r) {
      De[n] && u("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", n), De[n] = r;
      {
        var c = n.toLowerCase();
        we[c] = n, n === "onDoubleClick" && (we.ondblclick = n);
      }
      for (var d = 0; d < r.length; d++)
        ze.add(r[d]);
    }
    var pt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", At = Object.prototype.hasOwnProperty;
    function xt(n) {
      {
        var r = typeof Symbol == "function" && Symbol.toStringTag, c = r && n[Symbol.toStringTag] || n.constructor.name || "Object";
        return c;
      }
    }
    function tt(n) {
      try {
        return Et(n), !1;
      } catch {
        return !0;
      }
    }
    function Et(n) {
      return "" + n;
    }
    function Wt(n, r) {
      if (tt(n))
        return u("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", r, xt(n)), Et(n);
    }
    function on(n) {
      if (tt(n))
        return u("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", xt(n)), Et(n);
    }
    function ln(n, r) {
      if (tt(n))
        return u("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", r, xt(n)), Et(n);
    }
    function Yt(n, r) {
      if (tt(n))
        return u("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", r, xt(n)), Et(n);
    }
    function Xt(n) {
      if (tt(n))
        return u("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", xt(n)), Et(n);
    }
    function Dt(n) {
      if (tt(n))
        return u("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", xt(n)), Et(n);
    }
    var Rt = 0, Bt = 1, Dn = 2, An = 3, si = 4, Ki = 5, wi = 6, Ji = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Le = Ji + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", nt = new RegExp("^[" + Ji + "][" + Le + "]*$"), Ct = {}, Qt = {};
    function Vt(n) {
      return At.call(Qt, n) ? !0 : At.call(Ct, n) ? !1 : nt.test(n) ? (Qt[n] = !0, !0) : (Ct[n] = !0, u("Invalid attribute name: `%s`", n), !1);
    }
    function In(n, r, c) {
      return r !== null ? r.type === Rt : c ? !1 : n.length > 2 && (n[0] === "o" || n[0] === "O") && (n[1] === "n" || n[1] === "N");
    }
    function dn(n, r, c, d) {
      if (c !== null && c.type === Rt)
        return !1;
      switch (typeof r) {
        case "function":
        // $FlowIssue symbol is perfectly valid here
        case "symbol":
          return !0;
        case "boolean": {
          if (d)
            return !1;
          if (c !== null)
            return !c.acceptsBooleans;
          var g = n.toLowerCase().slice(0, 5);
          return g !== "data-" && g !== "aria-";
        }
        default:
          return !1;
      }
    }
    function _n(n, r, c, d) {
      if (r === null || typeof r > "u" || dn(n, r, c, d))
        return !0;
      if (d)
        return !1;
      if (c !== null)
        switch (c.type) {
          case An:
            return !r;
          case si:
            return r === !1;
          case Ki:
            return isNaN(r);
          case wi:
            return isNaN(r) || r < 1;
        }
      return !1;
    }
    function Jt(n) {
      return qt.hasOwnProperty(n) ? qt[n] : null;
    }
    function Gt(n, r, c, d, g, x, w) {
      this.acceptsBooleans = r === Dn || r === An || r === si, this.attributeName = d, this.attributeNamespace = g, this.mustUseProperty = c, this.propertyName = n, this.type = r, this.sanitizeURL = x, this.removeEmptyString = w;
    }
    var qt = {}, Mi = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Mi.forEach(function(n) {
      qt[n] = new Gt(
        n,
        Rt,
        !1,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
      var r = n[0], c = n[1];
      qt[r] = new Gt(
        r,
        Bt,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
      qt[n] = new Gt(
        n,
        Dn,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
      qt[n] = new Gt(
        n,
        Dn,
        !1,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(n) {
      qt[n] = new Gt(
        n,
        An,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      qt[n] = new Gt(
        n,
        An,
        !0,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      qt[n] = new Gt(
        n,
        si,
        !1,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      qt[n] = new Gt(
        n,
        wi,
        !1,
        // mustUseProperty
        n,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(n) {
      qt[n] = new Gt(
        n,
        Ki,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ai = /[\-\:]([a-z])/g, He = function(n) {
      return n[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      var r = n.replace(Ai, He);
      qt[r] = new Gt(
        r,
        Bt,
        !1,
        // mustUseProperty
        n,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      var r = n.replace(Ai, He);
      qt[r] = new Gt(
        r,
        Bt,
        !1,
        // mustUseProperty
        n,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(n) {
      var r = n.replace(Ai, He);
      qt[r] = new Gt(
        r,
        Bt,
        !1,
        // mustUseProperty
        n,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(n) {
      qt[n] = new Gt(
        n,
        Bt,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ve = "xlinkHref";
    qt[Ve] = new Gt(
      "xlinkHref",
      Bt,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(n) {
      qt[n] = new Gt(
        n,
        Bt,
        !1,
        // mustUseProperty
        n.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Qe = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, ft = !1;
    function ce(n) {
      !ft && Qe.test(n) && (ft = !0, u("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(n)));
    }
    function ye(n, r, c, d) {
      if (d.mustUseProperty) {
        var g = d.propertyName;
        return n[g];
      } else {
        Wt(c, r), d.sanitizeURL && ce("" + c);
        var x = d.attributeName, w = null;
        if (d.type === si) {
          if (n.hasAttribute(x)) {
            var R = n.getAttribute(x);
            return R === "" ? !0 : _n(r, c, d, !1) ? R : R === "" + c ? c : R;
          }
        } else if (n.hasAttribute(x)) {
          if (_n(r, c, d, !1))
            return n.getAttribute(x);
          if (d.type === An)
            return c;
          w = n.getAttribute(x);
        }
        return _n(r, c, d, !1) ? w === null ? c : w : w === "" + c ? c : w;
      }
    }
    function ke(n, r, c, d) {
      {
        if (!Vt(r))
          return;
        if (!n.hasAttribute(r))
          return c === void 0 ? void 0 : null;
        var g = n.getAttribute(r);
        return Wt(c, r), g === "" + c ? c : g;
      }
    }
    function Ge(n, r, c, d) {
      var g = Jt(r);
      if (!In(r, g, d)) {
        if (_n(r, c, g, d) && (c = null), d || g === null) {
          if (Vt(r)) {
            var x = r;
            c === null ? n.removeAttribute(x) : (Wt(c, r), n.setAttribute(x, "" + c));
          }
          return;
        }
        var w = g.mustUseProperty;
        if (w) {
          var R = g.propertyName;
          if (c === null) {
            var k = g.type;
            n[R] = k === An ? !1 : "";
          } else
            n[R] = c;
          return;
        }
        var L = g.attributeName, z = g.attributeNamespace;
        if (c === null)
          n.removeAttribute(L);
        else {
          var W = g.type, I;
          W === An || W === si && c === !0 ? I = "" : (Wt(c, L), I = "" + c, g.sanitizeURL && ce(I.toString())), z ? n.setAttributeNS(z, L, I) : n.setAttribute(L, I);
        }
      }
    }
    var yn = Symbol.for("react.element"), $n = Symbol.for("react.portal"), wa = Symbol.for("react.fragment"), Br = Symbol.for("react.strict_mode"), Ta = Symbol.for("react.profiler"), Ea = Symbol.for("react.provider"), H = Symbol.for("react.context"), ve = Symbol.for("react.forward_ref"), Be = Symbol.for("react.suspense"), ot = Symbol.for("react.suspense_list"), lt = Symbol.for("react.memo"), wt = Symbol.for("react.lazy"), Pt = Symbol.for("react.scope"), Ft = Symbol.for("react.debug_trace_mode"), vi = Symbol.for("react.offscreen"), On = Symbol.for("react.legacy_hidden"), zn = Symbol.for("react.cache"), er = Symbol.for("react.tracing_marker"), ys = Symbol.iterator, bs = "@@iterator";
    function Ot(n) {
      if (n === null || typeof n != "object")
        return null;
      var r = ys && n[ys] || n[bs];
      return typeof r == "function" ? r : null;
    }
    var Lt = Object.assign, xs = 0, uc, cc, Nv, bp, fc, Ra, zv;
    function Jr() {
    }
    Jr.__reactDisabledLog = !0;
    function yS() {
      {
        if (xs === 0) {
          uc = console.log, cc = console.info, Nv = console.warn, bp = console.error, fc = console.group, Ra = console.groupCollapsed, zv = console.groupEnd;
          var n = {
            configurable: !0,
            enumerable: !0,
            value: Jr,
            writable: !0
          };
          Object.defineProperties(console, {
            info: n,
            log: n,
            warn: n,
            error: n,
            group: n,
            groupCollapsed: n,
            groupEnd: n
          });
        }
        xs++;
      }
    }
    function bS() {
      {
        if (xs--, xs === 0) {
          var n = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Lt({}, n, {
              value: uc
            }),
            info: Lt({}, n, {
              value: cc
            }),
            warn: Lt({}, n, {
              value: Nv
            }),
            error: Lt({}, n, {
              value: bp
            }),
            group: Lt({}, n, {
              value: fc
            }),
            groupCollapsed: Lt({}, n, {
              value: Ra
            }),
            groupEnd: Lt({}, n, {
              value: zv
            })
          });
        }
        xs < 0 && u("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var xp = i.ReactCurrentDispatcher, eu;
    function Da(n, r, c) {
      {
        if (eu === void 0)
          try {
            throw Error();
          } catch (g) {
            var d = g.stack.trim().match(/\n( *(at )?)/);
            eu = d && d[1] || "";
          }
        return `
` + eu + n;
      }
    }
    var Wo = !1, Yo;
    {
      var xS = typeof WeakMap == "function" ? WeakMap : Map;
      Yo = new xS();
    }
    function Sp(n, r) {
      if (!n || Wo)
        return "";
      {
        var c = Yo.get(n);
        if (c !== void 0)
          return c;
      }
      var d;
      Wo = !0;
      var g = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var x;
      x = xp.current, xp.current = null, yS();
      try {
        if (r) {
          var w = function() {
            throw Error();
          };
          if (Object.defineProperty(w.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(w, []);
            } catch (ne) {
              d = ne;
            }
            Reflect.construct(n, [], w);
          } else {
            try {
              w.call();
            } catch (ne) {
              d = ne;
            }
            n.call(w.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ne) {
            d = ne;
          }
          n();
        }
      } catch (ne) {
        if (ne && d && typeof ne.stack == "string") {
          for (var R = ne.stack.split(`
`), k = d.stack.split(`
`), L = R.length - 1, z = k.length - 1; L >= 1 && z >= 0 && R[L] !== k[z]; )
            z--;
          for (; L >= 1 && z >= 0; L--, z--)
            if (R[L] !== k[z]) {
              if (L !== 1 || z !== 1)
                do
                  if (L--, z--, z < 0 || R[L] !== k[z]) {
                    var W = `
` + R[L].replace(" at new ", " at ");
                    return n.displayName && W.includes("<anonymous>") && (W = W.replace("<anonymous>", n.displayName)), typeof n == "function" && Yo.set(n, W), W;
                  }
                while (L >= 1 && z >= 0);
              break;
            }
        }
      } finally {
        Wo = !1, xp.current = x, bS(), Error.prepareStackTrace = g;
      }
      var I = n ? n.displayName || n.name : "", J = I ? Da(I) : "";
      return typeof n == "function" && Yo.set(n, J), J;
    }
    function _p(n, r, c) {
      return Sp(n, !0);
    }
    function qf(n, r, c) {
      return Sp(n, !1);
    }
    function Cp(n) {
      var r = n.prototype;
      return !!(r && r.isReactComponent);
    }
    function Go(n, r, c) {
      if (n == null)
        return "";
      if (typeof n == "function")
        return Sp(n, Cp(n));
      if (typeof n == "string")
        return Da(n);
      switch (n) {
        case Be:
          return Da("Suspense");
        case ot:
          return Da("SuspenseList");
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case ve:
            return qf(n.render);
          case lt:
            return Go(n.type, r, c);
          case wt: {
            var d = n, g = d._payload, x = d._init;
            try {
              return Go(x(g), r, c);
            } catch {
            }
          }
        }
      return "";
    }
    function SS(n) {
      switch (n._debugOwner && n._debugOwner.type, n._debugSource, n.tag) {
        case E:
          return Da(n.type);
        case K:
          return Da("Lazy");
        case V:
          return Da("Suspense");
        case ee:
          return Da("SuspenseList");
        case m:
        case b:
        case Y:
          return qf(n.type);
        case F:
          return qf(n.type.render);
        case v:
          return _p(n.type);
        default:
          return "";
      }
    }
    function Zf(n) {
      try {
        var r = "", c = n;
        do
          r += SS(c), c = c.return;
        while (c);
        return r;
      } catch (d) {
        return `
Error generating stack: ` + d.message + `
` + d.stack;
      }
    }
    function hn(n, r, c) {
      var d = n.displayName;
      if (d)
        return d;
      var g = r.displayName || r.name || "";
      return g !== "" ? c + "(" + g + ")" : c;
    }
    function wp(n) {
      return n.displayName || "Context";
    }
    function pn(n) {
      if (n == null)
        return null;
      if (typeof n.tag == "number" && u("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof n == "function")
        return n.displayName || n.name || null;
      if (typeof n == "string")
        return n;
      switch (n) {
        case wa:
          return "Fragment";
        case $n:
          return "Portal";
        case Ta:
          return "Profiler";
        case Br:
          return "StrictMode";
        case Be:
          return "Suspense";
        case ot:
          return "SuspenseList";
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case H:
            var r = n;
            return wp(r) + ".Consumer";
          case Ea:
            var c = n;
            return wp(c._context) + ".Provider";
          case ve:
            return hn(n, n.render, "ForwardRef");
          case lt:
            var d = n.displayName || null;
            return d !== null ? d : pn(n.type) || "Memo";
          case wt: {
            var g = n, x = g._payload, w = g._init;
            try {
              return pn(w(x));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Tp(n, r, c) {
      var d = r.displayName || r.name || "";
      return n.displayName || (d !== "" ? c + "(" + d + ")" : c);
    }
    function Ep(n) {
      return n.displayName || "Context";
    }
    function kt(n) {
      var r = n.tag, c = n.type;
      switch (r) {
        case Te:
          return "Cache";
        case P:
          var d = c;
          return Ep(d) + ".Consumer";
        case N:
          var g = c;
          return Ep(g._context) + ".Provider";
        case ie:
          return "DehydratedFragment";
        case F:
          return Tp(c, c.render, "ForwardRef");
        case M:
          return "Fragment";
        case E:
          return c;
        case C:
          return "Portal";
        case S:
          return "Root";
        case D:
          return "Text";
        case K:
          return pn(c);
        case A:
          return c === Br ? "StrictMode" : "Mode";
        case se:
          return "Offscreen";
        case B:
          return "Profiler";
        case oe:
          return "Scope";
        case V:
          return "Suspense";
        case ee:
          return "SuspenseList";
        case Se:
          return "TracingMarker";
        // The display name for this tags come from the user-provided type:
        case v:
        case m:
        case ae:
        case b:
        case G:
        case Y:
          if (typeof c == "function")
            return c.displayName || c.name || null;
          if (typeof c == "string")
            return c;
          break;
      }
      return null;
    }
    var Rp = i.ReactDebugCurrentFrame, tr = null, qs = !1;
    function ea() {
      {
        if (tr === null)
          return null;
        var n = tr._debugOwner;
        if (n !== null && typeof n < "u")
          return kt(n);
      }
      return null;
    }
    function Zs() {
      return tr === null ? "" : Zf(tr);
    }
    function Wn() {
      Rp.getCurrentStack = null, tr = null, qs = !1;
    }
    function kn(n) {
      Rp.getCurrentStack = n === null ? null : Zs, tr = n, qs = !1;
    }
    function dc() {
      return tr;
    }
    function Oi(n) {
      qs = n;
    }
    function ta(n) {
      return "" + n;
    }
    function Ss(n) {
      switch (typeof n) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return n;
        case "object":
          return Dt(n), n;
        default:
          return "";
      }
    }
    var hc = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Dp(n, r) {
      hc[r.type] || r.onChange || r.onInput || r.readOnly || r.disabled || r.value == null || u("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), r.onChange || r.readOnly || r.disabled || r.checked == null || u("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function kp(n) {
      var r = n.type, c = n.nodeName;
      return c && c.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
    }
    function pc(n) {
      return n._valueTracker;
    }
    function Fv(n) {
      n._valueTracker = null;
    }
    function _S(n) {
      var r = "";
      return n && (kp(n) ? r = n.checked ? "true" : "false" : r = n.value), r;
    }
    function mc(n) {
      var r = kp(n) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(n.constructor.prototype, r);
      Dt(n[r]);
      var d = "" + n[r];
      if (!(n.hasOwnProperty(r) || typeof c > "u" || typeof c.get != "function" || typeof c.set != "function")) {
        var g = c.get, x = c.set;
        Object.defineProperty(n, r, {
          configurable: !0,
          get: function() {
            return g.call(this);
          },
          set: function(R) {
            Dt(R), d = "" + R, x.call(this, R);
          }
        }), Object.defineProperty(n, r, {
          enumerable: c.enumerable
        });
        var w = {
          getValue: function() {
            return d;
          },
          setValue: function(R) {
            Dt(R), d = "" + R;
          },
          stopTracking: function() {
            Fv(n), delete n[r];
          }
        };
        return w;
      }
    }
    function Js(n) {
      pc(n) || (n._valueTracker = mc(n));
    }
    function Ko(n) {
      if (!n)
        return !1;
      var r = pc(n);
      if (!r)
        return !0;
      var c = r.getValue(), d = _S(n);
      return d !== c ? (r.setValue(d), !0) : !1;
    }
    function Xo(n) {
      if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u")
        return null;
      try {
        return n.activeElement || n.body;
      } catch {
        return n.body;
      }
    }
    var Vv = !1, jv = !1, Jf = !1, gc = !1;
    function ed(n) {
      var r = n.type === "checkbox" || n.type === "radio";
      return r ? n.checked != null : n.value != null;
    }
    function td(n, r) {
      var c = n, d = r.checked, g = Lt({}, r, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: d ?? c._wrapperState.initialChecked
      });
      return g;
    }
    function _s(n, r) {
      Dp("input", r), r.checked !== void 0 && r.defaultChecked !== void 0 && !jv && (u("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ea() || "A component", r.type), jv = !0), r.value !== void 0 && r.defaultValue !== void 0 && !Vv && (u("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ea() || "A component", r.type), Vv = !0);
      var c = n, d = r.defaultValue == null ? "" : r.defaultValue;
      c._wrapperState = {
        initialChecked: r.checked != null ? r.checked : r.defaultChecked,
        initialValue: Ss(r.value != null ? r.value : d),
        controlled: ed(r)
      };
    }
    function nd(n, r) {
      var c = n, d = r.checked;
      d != null && Ge(c, "checked", d, !1);
    }
    function tu(n, r) {
      var c = n;
      {
        var d = ed(r);
        !c._wrapperState.controlled && d && !gc && (u("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), gc = !0), c._wrapperState.controlled && !d && !Jf && (u("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Jf = !0);
      }
      nd(n, r);
      var g = Ss(r.value), x = r.type;
      if (g != null)
        x === "number" ? (g === 0 && c.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        c.value != g) && (c.value = ta(g)) : c.value !== ta(g) && (c.value = ta(g));
      else if (x === "submit" || x === "reset") {
        c.removeAttribute("value");
        return;
      }
      r.hasOwnProperty("value") ? ad(c, r.type, g) : r.hasOwnProperty("defaultValue") && ad(c, r.type, Ss(r.defaultValue)), r.checked == null && r.defaultChecked != null && (c.defaultChecked = !!r.defaultChecked);
    }
    function Mp(n, r, c) {
      var d = n;
      if (r.hasOwnProperty("value") || r.hasOwnProperty("defaultValue")) {
        var g = r.type, x = g === "submit" || g === "reset";
        if (x && (r.value === void 0 || r.value === null))
          return;
        var w = ta(d._wrapperState.initialValue);
        c || w !== d.value && (d.value = w), d.defaultValue = w;
      }
      var R = d.name;
      R !== "" && (d.name = ""), d.defaultChecked = !d.defaultChecked, d.defaultChecked = !!d._wrapperState.initialChecked, R !== "" && (d.name = R);
    }
    function id(n, r) {
      var c = n;
      tu(c, r), rd(c, r);
    }
    function rd(n, r) {
      var c = r.name;
      if (r.type === "radio" && c != null) {
        for (var d = n; d.parentNode; )
          d = d.parentNode;
        Wt(c, "name");
        for (var g = d.querySelectorAll("input[name=" + JSON.stringify("" + c) + '][type="radio"]'), x = 0; x < g.length; x++) {
          var w = g[x];
          if (!(w === n || w.form !== n.form)) {
            var R = v0(w);
            if (!R)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Ko(w), tu(w, R);
          }
        }
      }
    }
    function ad(n, r, c) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (r !== "number" || Xo(n.ownerDocument) !== n) && (c == null ? n.defaultValue = ta(n._wrapperState.initialValue) : n.defaultValue !== ta(c) && (n.defaultValue = ta(c)));
    }
    var yr = !1, Qo = !1, sd = !1;
    function nu(n, r) {
      r.value == null && (typeof r.children == "object" && r.children !== null ? t.Children.forEach(r.children, function(c) {
        c != null && (typeof c == "string" || typeof c == "number" || Qo || (Qo = !0, u("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : r.dangerouslySetInnerHTML != null && (sd || (sd = !0, u("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), r.selected != null && !yr && (u("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), yr = !0);
    }
    function CS(n, r) {
      r.value != null && n.setAttribute("value", ta(Ss(r.value)));
    }
    var Ap = Array.isArray;
    function Pi(n) {
      return Ap(n);
    }
    var qo;
    qo = !1;
    function vc() {
      var n = ea();
      return n ? `

Check the render method of \`` + n + "`." : "";
    }
    var Op = ["value", "defaultValue"];
    function wS(n) {
      {
        Dp("select", n);
        for (var r = 0; r < Op.length; r++) {
          var c = Op[r];
          if (n[c] != null) {
            var d = Pi(n[c]);
            n.multiple && !d ? u("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", c, vc()) : !n.multiple && d && u("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", c, vc());
          }
        }
      }
    }
    function iu(n, r, c, d) {
      var g = n.options;
      if (r) {
        for (var x = c, w = {}, R = 0; R < x.length; R++)
          w["$" + x[R]] = !0;
        for (var k = 0; k < g.length; k++) {
          var L = w.hasOwnProperty("$" + g[k].value);
          g[k].selected !== L && (g[k].selected = L), L && d && (g[k].defaultSelected = !0);
        }
      } else {
        for (var z = ta(Ss(c)), W = null, I = 0; I < g.length; I++) {
          if (g[I].value === z) {
            g[I].selected = !0, d && (g[I].defaultSelected = !0);
            return;
          }
          W === null && !g[I].disabled && (W = g[I]);
        }
        W !== null && (W.selected = !0);
      }
    }
    function Pp(n, r) {
      return Lt({}, r, {
        value: void 0
      });
    }
    function od(n, r) {
      var c = n;
      wS(r), c._wrapperState = {
        wasMultiple: !!r.multiple
      }, r.value !== void 0 && r.defaultValue !== void 0 && !qo && (u("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), qo = !0);
    }
    function TS(n, r) {
      var c = n;
      c.multiple = !!r.multiple;
      var d = r.value;
      d != null ? iu(c, !!r.multiple, d, !1) : r.defaultValue != null && iu(c, !!r.multiple, r.defaultValue, !0);
    }
    function ES(n, r) {
      var c = n, d = c._wrapperState.wasMultiple;
      c._wrapperState.wasMultiple = !!r.multiple;
      var g = r.value;
      g != null ? iu(c, !!r.multiple, g, !1) : d !== !!r.multiple && (r.defaultValue != null ? iu(c, !!r.multiple, r.defaultValue, !0) : iu(c, !!r.multiple, r.multiple ? [] : "", !1));
    }
    function RS(n, r) {
      var c = n, d = r.value;
      d != null && iu(c, !!r.multiple, d, !1);
    }
    var Bv = !1;
    function Lp(n, r) {
      var c = n;
      if (r.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var d = Lt({}, r, {
        value: void 0,
        defaultValue: void 0,
        children: ta(c._wrapperState.initialValue)
      });
      return d;
    }
    function Np(n, r) {
      var c = n;
      Dp("textarea", r), r.value !== void 0 && r.defaultValue !== void 0 && !Bv && (u("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", ea() || "A component"), Bv = !0);
      var d = r.value;
      if (d == null) {
        var g = r.children, x = r.defaultValue;
        if (g != null) {
          u("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (x != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Pi(g)) {
              if (g.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              g = g[0];
            }
            x = g;
          }
        }
        x == null && (x = ""), d = x;
      }
      c._wrapperState = {
        initialValue: Ss(d)
      };
    }
    function Hv(n, r) {
      var c = n, d = Ss(r.value), g = Ss(r.defaultValue);
      if (d != null) {
        var x = ta(d);
        x !== c.value && (c.value = x), r.defaultValue == null && c.defaultValue !== x && (c.defaultValue = x);
      }
      g != null && (c.defaultValue = ta(g));
    }
    function Uv(n, r) {
      var c = n, d = c.textContent;
      d === c._wrapperState.initialValue && d !== "" && d !== null && (c.value = d);
    }
    function DS(n, r) {
      Hv(n, r);
    }
    var Cs = "http://www.w3.org/1999/xhtml", zp = "http://www.w3.org/1998/Math/MathML", Fp = "http://www.w3.org/2000/svg";
    function Vp(n) {
      switch (n) {
        case "svg":
          return Fp;
        case "math":
          return zp;
        default:
          return Cs;
      }
    }
    function jp(n, r) {
      return n == null || n === Cs ? Vp(r) : n === Fp && r === "foreignObject" ? Cs : n;
    }
    var Iv = function(n) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(r, c, d, g) {
        MSApp.execUnsafeLocalFunction(function() {
          return n(r, c, d, g);
        });
      } : n;
    }, ld, $v = Iv(function(n, r) {
      if (n.namespaceURI === Fp && !("innerHTML" in n)) {
        ld = ld || document.createElement("div"), ld.innerHTML = "<svg>" + r.valueOf().toString() + "</svg>";
        for (var c = ld.firstChild; n.firstChild; )
          n.removeChild(n.firstChild);
        for (; c.firstChild; )
          n.appendChild(c.firstChild);
        return;
      }
      n.innerHTML = r;
    }), br = 1, ws = 3, oi = 8, Ts = 9, Bp = 11, ru = function(n, r) {
      if (r) {
        var c = n.firstChild;
        if (c && c === n.lastChild && c.nodeType === ws) {
          c.nodeValue = r;
          return;
        }
      }
      n.textContent = r;
    }, yc = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, bc = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Wv(n, r) {
      return n + r.charAt(0).toUpperCase() + r.substring(1);
    }
    var Yv = ["Webkit", "ms", "Moz", "O"];
    Object.keys(bc).forEach(function(n) {
      Yv.forEach(function(r) {
        bc[Wv(r, n)] = bc[n];
      });
    });
    function ud(n, r, c) {
      var d = r == null || typeof r == "boolean" || r === "";
      return d ? "" : !c && typeof r == "number" && r !== 0 && !(bc.hasOwnProperty(n) && bc[n]) ? r + "px" : (Yt(r, n), ("" + r).trim());
    }
    var Gv = /([A-Z])/g, Kv = /^ms-/;
    function au(n) {
      return n.replace(Gv, "-$1").toLowerCase().replace(Kv, "-ms-");
    }
    var Xv = function() {
    };
    {
      var kS = /^(?:webkit|moz|o)[A-Z]/, MS = /^-ms-/, Qv = /-(.)/g, Hp = /;\s*$/, Ga = {}, Zo = {}, qv = !1, xc = !1, AS = function(n) {
        return n.replace(Qv, function(r, c) {
          return c.toUpperCase();
        });
      }, Zv = function(n) {
        Ga.hasOwnProperty(n) && Ga[n] || (Ga[n] = !0, u(
          "Unsupported style property %s. Did you mean %s?",
          n,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          AS(n.replace(MS, "ms-"))
        ));
      }, Up = function(n) {
        Ga.hasOwnProperty(n) && Ga[n] || (Ga[n] = !0, u("Unsupported vendor-prefixed style property %s. Did you mean %s?", n, n.charAt(0).toUpperCase() + n.slice(1)));
      }, Ip = function(n, r) {
        Zo.hasOwnProperty(r) && Zo[r] || (Zo[r] = !0, u(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, n, r.replace(Hp, "")));
      }, Jv = function(n, r) {
        qv || (qv = !0, u("`NaN` is an invalid value for the `%s` css style property.", n));
      }, ey = function(n, r) {
        xc || (xc = !0, u("`Infinity` is an invalid value for the `%s` css style property.", n));
      };
      Xv = function(n, r) {
        n.indexOf("-") > -1 ? Zv(n) : kS.test(n) ? Up(n) : Hp.test(r) && Ip(n, r), typeof r == "number" && (isNaN(r) ? Jv(n, r) : isFinite(r) || ey(n, r));
      };
    }
    var ty = Xv;
    function OS(n) {
      {
        var r = "", c = "";
        for (var d in n)
          if (n.hasOwnProperty(d)) {
            var g = n[d];
            if (g != null) {
              var x = d.indexOf("--") === 0;
              r += c + (x ? d : au(d)) + ":", r += ud(d, g, x), c = ";";
            }
          }
        return r || null;
      }
    }
    function ny(n, r) {
      var c = n.style;
      for (var d in r)
        if (r.hasOwnProperty(d)) {
          var g = d.indexOf("--") === 0;
          g || ty(d, r[d]);
          var x = ud(d, r[d], g);
          d === "float" && (d = "cssFloat"), g ? c.setProperty(d, x) : c[d] = x;
        }
    }
    function PS(n) {
      return n == null || typeof n == "boolean" || n === "";
    }
    function iy(n) {
      var r = {};
      for (var c in n)
        for (var d = yc[c] || [c], g = 0; g < d.length; g++)
          r[d[g]] = c;
      return r;
    }
    function LS(n, r) {
      {
        if (!r)
          return;
        var c = iy(n), d = iy(r), g = {};
        for (var x in c) {
          var w = c[x], R = d[x];
          if (R && w !== R) {
            var k = w + "," + R;
            if (g[k])
              continue;
            g[k] = !0, u("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", PS(n[w]) ? "Removing" : "Updating", w, R);
          }
        }
      }
    }
    var ka = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Sc = Lt({
      menuitem: !0
    }, ka), ry = "__html";
    function cd(n, r) {
      if (r) {
        if (Sc[n] && (r.children != null || r.dangerouslySetInnerHTML != null))
          throw new Error(n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (r.dangerouslySetInnerHTML != null) {
          if (r.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof r.dangerouslySetInnerHTML != "object" || !(ry in r.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!r.suppressContentEditableWarning && r.contentEditable && r.children != null && u("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), r.style != null && typeof r.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function eo(n, r) {
      if (n.indexOf("-") === -1)
        return typeof r.is == "string";
      switch (n) {
        // These are reserved SVG and MathML elements.
        // We don't mind this list too much because we expect it to never grow.
        // The alternative is to track the namespace in a few places which is convoluted.
        // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var _c = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, fd = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, su = {}, NS = new RegExp("^(aria)-[" + Le + "]*$"), ou = new RegExp("^(aria)[A-Z][" + Le + "]*$");
    function $p(n, r) {
      {
        if (At.call(su, r) && su[r])
          return !0;
        if (ou.test(r)) {
          var c = "aria-" + r.slice(4).toLowerCase(), d = fd.hasOwnProperty(c) ? c : null;
          if (d == null)
            return u("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", r), su[r] = !0, !0;
          if (r !== d)
            return u("Invalid ARIA attribute `%s`. Did you mean `%s`?", r, d), su[r] = !0, !0;
        }
        if (NS.test(r)) {
          var g = r.toLowerCase(), x = fd.hasOwnProperty(g) ? g : null;
          if (x == null)
            return su[r] = !0, !1;
          if (r !== x)
            return u("Unknown ARIA attribute `%s`. Did you mean `%s`?", r, x), su[r] = !0, !0;
        }
      }
      return !0;
    }
    function Cc(n, r) {
      {
        var c = [];
        for (var d in r) {
          var g = $p(n, d);
          g || c.push(d);
        }
        var x = c.map(function(w) {
          return "`" + w + "`";
        }).join(", ");
        c.length === 1 ? u("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", x, n) : c.length > 1 && u("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", x, n);
      }
    }
    function Wp(n, r) {
      eo(n, r) || Cc(n, r);
    }
    var Yp = !1;
    function dd(n, r) {
      {
        if (n !== "input" && n !== "textarea" && n !== "select")
          return;
        r != null && r.value === null && !Yp && (Yp = !0, n === "select" && r.multiple ? u("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", n) : u("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", n));
      }
    }
    var Jo = function() {
    };
    {
      var Li = {}, Gp = /^on./, hd = /^on[^A-Z]/, ay = new RegExp("^(aria)-[" + Le + "]*$"), sy = new RegExp("^(aria)[A-Z][" + Le + "]*$");
      Jo = function(n, r, c, d) {
        if (At.call(Li, r) && Li[r])
          return !0;
        var g = r.toLowerCase();
        if (g === "onfocusin" || g === "onfocusout")
          return u("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Li[r] = !0, !0;
        if (d != null) {
          var x = d.registrationNameDependencies, w = d.possibleRegistrationNames;
          if (x.hasOwnProperty(r))
            return !0;
          var R = w.hasOwnProperty(g) ? w[g] : null;
          if (R != null)
            return u("Invalid event handler property `%s`. Did you mean `%s`?", r, R), Li[r] = !0, !0;
          if (Gp.test(r))
            return u("Unknown event handler property `%s`. It will be ignored.", r), Li[r] = !0, !0;
        } else if (Gp.test(r))
          return hd.test(r) && u("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", r), Li[r] = !0, !0;
        if (ay.test(r) || sy.test(r))
          return !0;
        if (g === "innerhtml")
          return u("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Li[r] = !0, !0;
        if (g === "aria")
          return u("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Li[r] = !0, !0;
        if (g === "is" && c !== null && c !== void 0 && typeof c != "string")
          return u("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof c), Li[r] = !0, !0;
        if (typeof c == "number" && isNaN(c))
          return u("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", r), Li[r] = !0, !0;
        var k = Jt(r), L = k !== null && k.type === Rt;
        if (_c.hasOwnProperty(g)) {
          var z = _c[g];
          if (z !== r)
            return u("Invalid DOM property `%s`. Did you mean `%s`?", r, z), Li[r] = !0, !0;
        } else if (!L && r !== g)
          return u("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", r, g), Li[r] = !0, !0;
        return typeof c == "boolean" && dn(r, c, k, !1) ? (c ? u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', c, r, r, c, r) : u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', c, r, r, c, r, r, r), Li[r] = !0, !0) : L ? !0 : dn(r, c, k, !1) ? (Li[r] = !0, !1) : ((c === "false" || c === "true") && k !== null && k.type === An && (u("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", c, r, c === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', r, c), Li[r] = !0), !0);
      };
    }
    var oy = function(n, r, c) {
      {
        var d = [];
        for (var g in r) {
          var x = Jo(n, g, r[g], c);
          x || d.push(g);
        }
        var w = d.map(function(R) {
          return "`" + R + "`";
        }).join(", ");
        d.length === 1 ? u("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", w, n) : d.length > 1 && u("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", w, n);
      }
    };
    function ly(n, r, c) {
      eo(n, r) || oy(n, r, c);
    }
    var Kp = 1, pd = 2, na = 4, Xp = Kp | pd | na, el = null;
    function zS(n) {
      el !== null && u("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), el = n;
    }
    function FS() {
      el === null && u("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), el = null;
    }
    function wc(n) {
      return n === el;
    }
    function Qp(n) {
      var r = n.target || n.srcElement || window;
      return r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === ws ? r.parentNode : r;
    }
    var md = null, tl = null, un = null;
    function gd(n) {
      var r = Du(n);
      if (r) {
        if (typeof md != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var c = r.stateNode;
        if (c) {
          var d = v0(c);
          md(r.stateNode, r.type, d);
        }
      }
    }
    function vd(n) {
      md = n;
    }
    function lu(n) {
      tl ? un ? un.push(n) : un = [n] : tl = n;
    }
    function uy() {
      return tl !== null || un !== null;
    }
    function yd() {
      if (tl) {
        var n = tl, r = un;
        if (tl = null, un = null, gd(n), r)
          for (var c = 0; c < r.length; c++)
            gd(r[c]);
      }
    }
    var uu = function(n, r) {
      return n(r);
    }, Tc = function() {
    }, to = !1;
    function cy() {
      var n = uy();
      n && (Tc(), yd());
    }
    function fy(n, r, c) {
      if (to)
        return n(r, c);
      to = !0;
      try {
        return uu(n, r, c);
      } finally {
        to = !1, cy();
      }
    }
    function VS(n, r, c) {
      uu = n, Tc = c;
    }
    function dy(n) {
      return n === "button" || n === "input" || n === "select" || n === "textarea";
    }
    function bd(n, r, c) {
      switch (n) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(c.disabled && dy(r));
        default:
          return !1;
      }
    }
    function no(n, r) {
      var c = n.stateNode;
      if (c === null)
        return null;
      var d = v0(c);
      if (d === null)
        return null;
      var g = d[r];
      if (bd(r, n.type, d))
        return null;
      if (g && typeof g != "function")
        throw new Error("Expected `" + r + "` listener to be a function, instead got a value of `" + typeof g + "` type.");
      return g;
    }
    var Ec = !1;
    if (pt)
      try {
        var nl = {};
        Object.defineProperty(nl, "passive", {
          get: function() {
            Ec = !0;
          }
        }), window.addEventListener("test", nl, nl), window.removeEventListener("test", nl, nl);
      } catch {
        Ec = !1;
      }
    function xd(n, r, c, d, g, x, w, R, k) {
      var L = Array.prototype.slice.call(arguments, 3);
      try {
        r.apply(c, L);
      } catch (z) {
        this.onError(z);
      }
    }
    var Sd = xd;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var qp = document.createElement("react");
      Sd = function(r, c, d, g, x, w, R, k, L) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var z = document.createEvent("Event"), W = !1, I = !0, J = window.event, ne = Object.getOwnPropertyDescriptor(window, "event");
        function le() {
          qp.removeEventListener(ue, ut, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = J);
        }
        var Ie = Array.prototype.slice.call(arguments, 3);
        function ut() {
          W = !0, le(), c.apply(d, Ie), I = !1;
        }
        var it, $t = !1, jt = !1;
        function Q(q) {
          if (it = q.error, $t = !0, it === null && q.colno === 0 && q.lineno === 0 && (jt = !0), q.defaultPrevented && it != null && typeof it == "object")
            try {
              it._suppressLogging = !0;
            } catch {
            }
        }
        var ue = "react-" + (r || "invokeguardedcallback");
        if (window.addEventListener("error", Q), qp.addEventListener(ue, ut, !1), z.initEvent(ue, !1, !1), qp.dispatchEvent(z), ne && Object.defineProperty(window, "event", ne), W && I && ($t ? jt && (it = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : it = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(it)), window.removeEventListener("error", Q), !W)
          return le(), xd.apply(this, arguments);
      };
    }
    var hy = Sd, cu = !1, _d = null, fu = !1, Ka = null, py = {
      onError: function(n) {
        cu = !0, _d = n;
      }
    };
    function io(n, r, c, d, g, x, w, R, k) {
      cu = !1, _d = null, hy.apply(py, arguments);
    }
    function Xa(n, r, c, d, g, x, w, R, k) {
      if (io.apply(this, arguments), cu) {
        var L = Dc();
        fu || (fu = !0, Ka = L);
      }
    }
    function Rc() {
      if (fu) {
        var n = Ka;
        throw fu = !1, Ka = null, n;
      }
    }
    function Es() {
      return cu;
    }
    function Dc() {
      if (cu) {
        var n = _d;
        return cu = !1, _d = null, n;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function du(n) {
      return n._reactInternals;
    }
    function jS(n) {
      return n._reactInternals !== void 0;
    }
    function il(n, r) {
      n._reactInternals = r;
    }
    var at = (
      /*                      */
      0
    ), Ma = (
      /*                */
      1
    ), qn = (
      /*                    */
      2
    ), Ht = (
      /*                       */
      4
    ), ia = (
      /*                */
      16
    ), Aa = (
      /*                 */
      32
    ), Cn = (
      /*                     */
      64
    ), rt = (
      /*                   */
      128
    ), xr = (
      /*            */
      256
    ), Yn = (
      /*                          */
      512
    ), yi = (
      /*                     */
      1024
    ), Sr = (
      /*                      */
      2048
    ), ra = (
      /*                    */
      4096
    ), li = (
      /*                   */
      8192
    ), hu = (
      /*             */
      16384
    ), my = (
      /*               */
      32767
    ), kc = (
      /*                   */
      32768
    ), _r = (
      /*                */
      65536
    ), Cd = (
      /* */
      131072
    ), Qa = (
      /*                       */
      1048576
    ), pu = (
      /*                    */
      2097152
    ), Rs = (
      /*                 */
      4194304
    ), wd = (
      /*                */
      8388608
    ), ro = (
      /*               */
      16777216
    ), qa = (
      /*              */
      33554432
    ), ao = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Ht | yi | 0
    ), so = qn | Ht | ia | Aa | Yn | ra | li, oo = Ht | Cn | Yn | li, Ds = Sr | ia, ui = Rs | wd | pu, aa = i.ReactCurrentOwner;
    function Hr(n) {
      var r = n, c = n;
      if (n.alternate)
        for (; r.return; )
          r = r.return;
      else {
        var d = r;
        do
          r = d, (r.flags & (qn | ra)) !== at && (c = r.return), d = r.return;
        while (d);
      }
      return r.tag === S ? c : null;
    }
    function Za(n) {
      if (n.tag === V) {
        var r = n.memoizedState;
        if (r === null) {
          var c = n.alternate;
          c !== null && (r = c.memoizedState);
        }
        if (r !== null)
          return r.dehydrated;
      }
      return null;
    }
    function Ja(n) {
      return n.tag === S ? n.stateNode.containerInfo : null;
    }
    function rl(n) {
      return Hr(n) === n;
    }
    function gy(n) {
      {
        var r = aa.current;
        if (r !== null && r.tag === v) {
          var c = r, d = c.stateNode;
          d._warnedAboutRefsInRender || u("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", kt(c) || "A component"), d._warnedAboutRefsInRender = !0;
        }
      }
      var g = du(n);
      return g ? Hr(g) === g : !1;
    }
    function Td(n) {
      if (Hr(n) !== n)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Ed(n) {
      var r = n.alternate;
      if (!r) {
        var c = Hr(n);
        if (c === null)
          throw new Error("Unable to find node on an unmounted component.");
        return c !== n ? null : n;
      }
      for (var d = n, g = r; ; ) {
        var x = d.return;
        if (x === null)
          break;
        var w = x.alternate;
        if (w === null) {
          var R = x.return;
          if (R !== null) {
            d = g = R;
            continue;
          }
          break;
        }
        if (x.child === w.child) {
          for (var k = x.child; k; ) {
            if (k === d)
              return Td(x), n;
            if (k === g)
              return Td(x), r;
            k = k.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (d.return !== g.return)
          d = x, g = w;
        else {
          for (var L = !1, z = x.child; z; ) {
            if (z === d) {
              L = !0, d = x, g = w;
              break;
            }
            if (z === g) {
              L = !0, g = x, d = w;
              break;
            }
            z = z.sibling;
          }
          if (!L) {
            for (z = w.child; z; ) {
              if (z === d) {
                L = !0, d = w, g = x;
                break;
              }
              if (z === g) {
                L = !0, g = w, d = x;
                break;
              }
              z = z.sibling;
            }
            if (!L)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (d.alternate !== g)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (d.tag !== S)
        throw new Error("Unable to find node on an unmounted component.");
      return d.stateNode.current === d ? n : r;
    }
    function Cr(n) {
      var r = Ed(n);
      return r !== null ? wr(r) : null;
    }
    function wr(n) {
      if (n.tag === E || n.tag === D)
        return n;
      for (var r = n.child; r !== null; ) {
        var c = wr(r);
        if (c !== null)
          return c;
        r = r.sibling;
      }
      return null;
    }
    function Pn(n) {
      var r = Ed(n);
      return r !== null ? sa(r) : null;
    }
    function sa(n) {
      if (n.tag === E || n.tag === D)
        return n;
      for (var r = n.child; r !== null; ) {
        if (r.tag !== C) {
          var c = sa(r);
          if (c !== null)
            return c;
        }
        r = r.sibling;
      }
      return null;
    }
    var Zp = e.unstable_scheduleCallback, vy = e.unstable_cancelCallback, Jp = e.unstable_shouldYield, em = e.unstable_requestPaint, bi = e.unstable_now, Rd = e.unstable_getCurrentPriorityLevel, Mc = e.unstable_ImmediatePriority, lo = e.unstable_UserBlockingPriority, ks = e.unstable_NormalPriority, BS = e.unstable_LowPriority, al = e.unstable_IdlePriority, Dd = e.unstable_yieldValue, yy = e.unstable_setDisableYieldValue, sl = null, Zn = null, Ue = null, Ur = !1, Tr = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function mu(n) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var r = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (r.isDisabled)
        return !0;
      if (!r.supportsFiber)
        return u("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Ae && (n = Lt({}, n, {
          getLaneLabelMap: ol,
          injectProfilingHooks: oa
        })), sl = r.inject(n), Zn = r;
      } catch (c) {
        u("React instrumentation encountered an error: %s.", c);
      }
      return !!r.checkDCE;
    }
    function tm(n, r) {
      if (Zn && typeof Zn.onScheduleFiberRoot == "function")
        try {
          Zn.onScheduleFiberRoot(sl, n, r);
        } catch (c) {
          Ur || (Ur = !0, u("React instrumentation encountered an error: %s", c));
        }
    }
    function nm(n, r) {
      if (Zn && typeof Zn.onCommitFiberRoot == "function")
        try {
          var c = (n.current.flags & rt) === rt;
          if (Ne) {
            var d;
            switch (r) {
              case nr:
                d = Mc;
                break;
              case ts:
                d = lo;
                break;
              case la:
                d = ks;
                break;
              case ua:
                d = al;
                break;
              default:
                d = ks;
                break;
            }
            Zn.onCommitFiberRoot(sl, n, d, c);
          }
        } catch (g) {
          Ur || (Ur = !0, u("React instrumentation encountered an error: %s", g));
        }
    }
    function im(n) {
      if (Zn && typeof Zn.onPostCommitFiberRoot == "function")
        try {
          Zn.onPostCommitFiberRoot(sl, n);
        } catch (r) {
          Ur || (Ur = !0, u("React instrumentation encountered an error: %s", r));
        }
    }
    function rm(n) {
      if (Zn && typeof Zn.onCommitFiberUnmount == "function")
        try {
          Zn.onCommitFiberUnmount(sl, n);
        } catch (r) {
          Ur || (Ur = !0, u("React instrumentation encountered an error: %s", r));
        }
    }
    function Fn(n) {
      if (typeof Dd == "function" && (yy(n), o(n)), Zn && typeof Zn.setStrictMode == "function")
        try {
          Zn.setStrictMode(sl, n);
        } catch (r) {
          Ur || (Ur = !0, u("React instrumentation encountered an error: %s", r));
        }
    }
    function oa(n) {
      Ue = n;
    }
    function ol() {
      {
        for (var n = /* @__PURE__ */ new Map(), r = 1, c = 0; c < cl; c++) {
          var d = _y(r);
          n.set(r, d), r *= 2;
        }
        return n;
      }
    }
    function am(n) {
      Ue !== null && typeof Ue.markCommitStarted == "function" && Ue.markCommitStarted(n);
    }
    function sm() {
      Ue !== null && typeof Ue.markCommitStopped == "function" && Ue.markCommitStopped();
    }
    function Ir(n) {
      Ue !== null && typeof Ue.markComponentRenderStarted == "function" && Ue.markComponentRenderStarted(n);
    }
    function $r() {
      Ue !== null && typeof Ue.markComponentRenderStopped == "function" && Ue.markComponentRenderStopped();
    }
    function om(n) {
      Ue !== null && typeof Ue.markComponentPassiveEffectMountStarted == "function" && Ue.markComponentPassiveEffectMountStarted(n);
    }
    function by() {
      Ue !== null && typeof Ue.markComponentPassiveEffectMountStopped == "function" && Ue.markComponentPassiveEffectMountStopped();
    }
    function Ms(n) {
      Ue !== null && typeof Ue.markComponentPassiveEffectUnmountStarted == "function" && Ue.markComponentPassiveEffectUnmountStarted(n);
    }
    function uo() {
      Ue !== null && typeof Ue.markComponentPassiveEffectUnmountStopped == "function" && Ue.markComponentPassiveEffectUnmountStopped();
    }
    function kd(n) {
      Ue !== null && typeof Ue.markComponentLayoutEffectMountStarted == "function" && Ue.markComponentLayoutEffectMountStarted(n);
    }
    function xy() {
      Ue !== null && typeof Ue.markComponentLayoutEffectMountStopped == "function" && Ue.markComponentLayoutEffectMountStopped();
    }
    function Ac(n) {
      Ue !== null && typeof Ue.markComponentLayoutEffectUnmountStarted == "function" && Ue.markComponentLayoutEffectUnmountStarted(n);
    }
    function lm() {
      Ue !== null && typeof Ue.markComponentLayoutEffectUnmountStopped == "function" && Ue.markComponentLayoutEffectUnmountStopped();
    }
    function Oc(n, r, c) {
      Ue !== null && typeof Ue.markComponentErrored == "function" && Ue.markComponentErrored(n, r, c);
    }
    function es(n, r, c) {
      Ue !== null && typeof Ue.markComponentSuspended == "function" && Ue.markComponentSuspended(n, r, c);
    }
    function Pc(n) {
      Ue !== null && typeof Ue.markLayoutEffectsStarted == "function" && Ue.markLayoutEffectsStarted(n);
    }
    function Lc() {
      Ue !== null && typeof Ue.markLayoutEffectsStopped == "function" && Ue.markLayoutEffectsStopped();
    }
    function ll(n) {
      Ue !== null && typeof Ue.markPassiveEffectsStarted == "function" && Ue.markPassiveEffectsStarted(n);
    }
    function um() {
      Ue !== null && typeof Ue.markPassiveEffectsStopped == "function" && Ue.markPassiveEffectsStopped();
    }
    function ul(n) {
      Ue !== null && typeof Ue.markRenderStarted == "function" && Ue.markRenderStarted(n);
    }
    function Sy() {
      Ue !== null && typeof Ue.markRenderYielded == "function" && Ue.markRenderYielded();
    }
    function Md() {
      Ue !== null && typeof Ue.markRenderStopped == "function" && Ue.markRenderStopped();
    }
    function Vn(n) {
      Ue !== null && typeof Ue.markRenderScheduled == "function" && Ue.markRenderScheduled(n);
    }
    function Ad(n, r) {
      Ue !== null && typeof Ue.markForceUpdateScheduled == "function" && Ue.markForceUpdateScheduled(n, r);
    }
    function Nc(n, r) {
      Ue !== null && typeof Ue.markStateUpdateScheduled == "function" && Ue.markStateUpdateScheduled(n, r);
    }
    var st = (
      /*                         */
      0
    ), Nt = (
      /*                 */
      1
    ), en = (
      /*                    */
      2
    ), mn = (
      /*               */
      8
    ), tn = (
      /*              */
      16
    ), ci = Math.clz32 ? Math.clz32 : zc, Ti = Math.log, Od = Math.LN2;
    function zc(n) {
      var r = n >>> 0;
      return r === 0 ? 32 : 31 - (Ti(r) / Od | 0) | 0;
    }
    var cl = 31, be = (
      /*                        */
      0
    ), Zt = (
      /*                          */
      0
    ), mt = (
      /*                        */
      1
    ), co = (
      /*    */
      2
    ), Oa = (
      /*             */
      4
    ), Xi = (
      /*            */
      8
    ), Jn = (
      /*                     */
      16
    ), As = (
      /*                */
      32
    ), fo = (
      /*                       */
      4194240
    ), fl = (
      /*                        */
      64
    ), Pd = (
      /*                        */
      128
    ), Ld = (
      /*                        */
      256
    ), Nd = (
      /*                        */
      512
    ), zd = (
      /*                        */
      1024
    ), Fd = (
      /*                        */
      2048
    ), Vd = (
      /*                        */
      4096
    ), jd = (
      /*                        */
      8192
    ), Bd = (
      /*                        */
      16384
    ), dl = (
      /*                       */
      32768
    ), Hd = (
      /*                       */
      65536
    ), gu = (
      /*                       */
      131072
    ), vu = (
      /*                       */
      262144
    ), Ud = (
      /*                       */
      524288
    ), Fc = (
      /*                       */
      1048576
    ), Id = (
      /*                       */
      2097152
    ), Vc = (
      /*                            */
      130023424
    ), hl = (
      /*                             */
      4194304
    ), $d = (
      /*                             */
      8388608
    ), jc = (
      /*                             */
      16777216
    ), Wd = (
      /*                             */
      33554432
    ), Yd = (
      /*                             */
      67108864
    ), cm = hl, Bc = (
      /*          */
      134217728
    ), fm = (
      /*                          */
      268435455
    ), Hc = (
      /*               */
      268435456
    ), pl = (
      /*                        */
      536870912
    ), Wr = (
      /*                   */
      1073741824
    );
    function _y(n) {
      {
        if (n & mt)
          return "Sync";
        if (n & co)
          return "InputContinuousHydration";
        if (n & Oa)
          return "InputContinuous";
        if (n & Xi)
          return "DefaultHydration";
        if (n & Jn)
          return "Default";
        if (n & As)
          return "TransitionHydration";
        if (n & fo)
          return "Transition";
        if (n & Vc)
          return "Retry";
        if (n & Bc)
          return "SelectiveHydration";
        if (n & Hc)
          return "IdleHydration";
        if (n & pl)
          return "Idle";
        if (n & Wr)
          return "Offscreen";
      }
    }
    var bn = -1, ml = fl, Gd = hl;
    function Uc(n) {
      switch (ho(n)) {
        case mt:
          return mt;
        case co:
          return co;
        case Oa:
          return Oa;
        case Xi:
          return Xi;
        case Jn:
          return Jn;
        case As:
          return As;
        case fl:
        case Pd:
        case Ld:
        case Nd:
        case zd:
        case Fd:
        case Vd:
        case jd:
        case Bd:
        case dl:
        case Hd:
        case gu:
        case vu:
        case Ud:
        case Fc:
        case Id:
          return n & fo;
        case hl:
        case $d:
        case jc:
        case Wd:
        case Yd:
          return n & Vc;
        case Bc:
          return Bc;
        case Hc:
          return Hc;
        case pl:
          return pl;
        case Wr:
          return Wr;
        default:
          return u("Should have found matching lanes. This is a bug in React."), n;
      }
    }
    function Kd(n, r) {
      var c = n.pendingLanes;
      if (c === be)
        return be;
      var d = be, g = n.suspendedLanes, x = n.pingedLanes, w = c & fm;
      if (w !== be) {
        var R = w & ~g;
        if (R !== be)
          d = Uc(R);
        else {
          var k = w & x;
          k !== be && (d = Uc(k));
        }
      } else {
        var L = c & ~g;
        L !== be ? d = Uc(L) : x !== be && (d = Uc(x));
      }
      if (d === be)
        return be;
      if (r !== be && r !== d && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (r & g) === be) {
        var z = ho(d), W = ho(r);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          z >= W || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          z === Jn && (W & fo) !== be
        )
          return r;
      }
      (d & Oa) !== be && (d |= c & Jn);
      var I = n.entangledLanes;
      if (I !== be)
        for (var J = n.entanglements, ne = d & I; ne > 0; ) {
          var le = fi(ne), Ie = 1 << le;
          d |= J[le], ne &= ~Ie;
        }
      return d;
    }
    function Pa(n, r) {
      for (var c = n.eventTimes, d = bn; r > 0; ) {
        var g = fi(r), x = 1 << g, w = c[g];
        w > d && (d = w), r &= ~x;
      }
      return d;
    }
    function dm(n, r) {
      switch (n) {
        case mt:
        case co:
        case Oa:
          return r + 250;
        case Xi:
        case Jn:
        case As:
        case fl:
        case Pd:
        case Ld:
        case Nd:
        case zd:
        case Fd:
        case Vd:
        case jd:
        case Bd:
        case dl:
        case Hd:
        case gu:
        case vu:
        case Ud:
        case Fc:
        case Id:
          return r + 5e3;
        case hl:
        case $d:
        case jc:
        case Wd:
        case Yd:
          return bn;
        case Bc:
        case Hc:
        case pl:
        case Wr:
          return bn;
        default:
          return u("Should have found matching lanes. This is a bug in React."), bn;
      }
    }
    function Xd(n, r) {
      for (var c = n.pendingLanes, d = n.suspendedLanes, g = n.pingedLanes, x = n.expirationTimes, w = c; w > 0; ) {
        var R = fi(w), k = 1 << R, L = x[R];
        L === bn ? ((k & d) === be || (k & g) !== be) && (x[R] = dm(k, r)) : L <= r && (n.expiredLanes |= k), w &= ~k;
      }
    }
    function Cy(n) {
      return Uc(n.pendingLanes);
    }
    function Qd(n) {
      var r = n.pendingLanes & -1073741825;
      return r !== be ? r : r & Wr ? Wr : be;
    }
    function wy(n) {
      return (n & mt) !== be;
    }
    function Ic(n) {
      return (n & fm) !== be;
    }
    function gl(n) {
      return (n & Vc) === n;
    }
    function hm(n) {
      var r = mt | Oa | Jn;
      return (n & r) === be;
    }
    function pm(n) {
      return (n & fo) === n;
    }
    function qd(n, r) {
      var c = co | Oa | Xi | Jn;
      return (r & c) !== be;
    }
    function Ty(n, r) {
      return (r & n.expiredLanes) !== be;
    }
    function mm(n) {
      return (n & fo) !== be;
    }
    function gm() {
      var n = ml;
      return ml <<= 1, (ml & fo) === be && (ml = fl), n;
    }
    function Ey() {
      var n = Gd;
      return Gd <<= 1, (Gd & Vc) === be && (Gd = hl), n;
    }
    function ho(n) {
      return n & -n;
    }
    function $c(n) {
      return ho(n);
    }
    function fi(n) {
      return 31 - ci(n);
    }
    function Ni(n) {
      return fi(n);
    }
    function Er(n, r) {
      return (n & r) !== be;
    }
    function vl(n, r) {
      return (n & r) === r;
    }
    function Mt(n, r) {
      return n | r;
    }
    function Wc(n, r) {
      return n & ~r;
    }
    function vm(n, r) {
      return n & r;
    }
    function Ry(n) {
      return n;
    }
    function Dy(n, r) {
      return n !== Zt && n < r ? n : r;
    }
    function Yc(n) {
      for (var r = [], c = 0; c < cl; c++)
        r.push(n);
      return r;
    }
    function yu(n, r, c) {
      n.pendingLanes |= r, r !== pl && (n.suspendedLanes = be, n.pingedLanes = be);
      var d = n.eventTimes, g = Ni(r);
      d[g] = c;
    }
    function ky(n, r) {
      n.suspendedLanes |= r, n.pingedLanes &= ~r;
      for (var c = n.expirationTimes, d = r; d > 0; ) {
        var g = fi(d), x = 1 << g;
        c[g] = bn, d &= ~x;
      }
    }
    function Zd(n, r, c) {
      n.pingedLanes |= n.suspendedLanes & r;
    }
    function ym(n, r) {
      var c = n.pendingLanes & ~r;
      n.pendingLanes = r, n.suspendedLanes = be, n.pingedLanes = be, n.expiredLanes &= r, n.mutableReadLanes &= r, n.entangledLanes &= r;
      for (var d = n.entanglements, g = n.eventTimes, x = n.expirationTimes, w = c; w > 0; ) {
        var R = fi(w), k = 1 << R;
        d[R] = be, g[R] = bn, x[R] = bn, w &= ~k;
      }
    }
    function Jd(n, r) {
      for (var c = n.entangledLanes |= r, d = n.entanglements, g = c; g; ) {
        var x = fi(g), w = 1 << x;
        // Is this one of the newly entangled lanes?
        w & r | // Is this lane transitively entangled with the newly entangled lanes?
        d[x] & r && (d[x] |= r), g &= ~w;
      }
    }
    function bm(n, r) {
      var c = ho(r), d;
      switch (c) {
        case Oa:
          d = co;
          break;
        case Jn:
          d = Xi;
          break;
        case fl:
        case Pd:
        case Ld:
        case Nd:
        case zd:
        case Fd:
        case Vd:
        case jd:
        case Bd:
        case dl:
        case Hd:
        case gu:
        case vu:
        case Ud:
        case Fc:
        case Id:
        case hl:
        case $d:
        case jc:
        case Wd:
        case Yd:
          d = As;
          break;
        case pl:
          d = Hc;
          break;
        default:
          d = Zt;
          break;
      }
      return (d & (n.suspendedLanes | r)) !== Zt ? Zt : d;
    }
    function Gc(n, r, c) {
      if (Tr)
        for (var d = n.pendingUpdatersLaneMap; c > 0; ) {
          var g = Ni(c), x = 1 << g, w = d[g];
          w.add(r), c &= ~x;
        }
    }
    function My(n, r) {
      if (Tr)
        for (var c = n.pendingUpdatersLaneMap, d = n.memoizedUpdaters; r > 0; ) {
          var g = Ni(r), x = 1 << g, w = c[g];
          w.size > 0 && (w.forEach(function(R) {
            var k = R.alternate;
            (k === null || !d.has(k)) && d.add(R);
          }), w.clear()), r &= ~x;
        }
    }
    function xm(n, r) {
      return null;
    }
    var nr = mt, ts = Oa, la = Jn, ua = pl, Kc = Zt;
    function ca() {
      return Kc;
    }
    function di(n) {
      Kc = n;
    }
    function Ay(n, r) {
      var c = Kc;
      try {
        return Kc = n, r();
      } finally {
        Kc = c;
      }
    }
    function Oy(n, r) {
      return n !== 0 && n < r ? n : r;
    }
    function Xc(n, r) {
      return n > r ? n : r;
    }
    function Ei(n, r) {
      return n !== 0 && n < r;
    }
    function Py(n) {
      var r = ho(n);
      return Ei(nr, r) ? Ei(ts, r) ? Ic(r) ? la : ua : ts : nr;
    }
    function eh(n) {
      var r = n.current.memoizedState;
      return r.isDehydrated;
    }
    var Qc;
    function Qi(n) {
      Qc = n;
    }
    function HS(n) {
      Qc(n);
    }
    var Xe;
    function bu(n) {
      Xe = n;
    }
    var th;
    function Ly(n) {
      th = n;
    }
    var Ny;
    function qc(n) {
      Ny = n;
    }
    var Zc;
    function Sm(n) {
      Zc = n;
    }
    var nh = !1, Jc = [], Os = null, ns = null, is = null, ei = /* @__PURE__ */ new Map(), ir = /* @__PURE__ */ new Map(), rr = [], zy = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Fy(n) {
      return zy.indexOf(n) > -1;
    }
    function La(n, r, c, d, g) {
      return {
        blockedOn: n,
        domEventName: r,
        eventSystemFlags: c,
        nativeEvent: g,
        targetContainers: [d]
      };
    }
    function _m(n, r) {
      switch (n) {
        case "focusin":
        case "focusout":
          Os = null;
          break;
        case "dragenter":
        case "dragleave":
          ns = null;
          break;
        case "mouseover":
        case "mouseout":
          is = null;
          break;
        case "pointerover":
        case "pointerout": {
          var c = r.pointerId;
          ei.delete(c);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var d = r.pointerId;
          ir.delete(d);
          break;
        }
      }
    }
    function Rr(n, r, c, d, g, x) {
      if (n === null || n.nativeEvent !== x) {
        var w = La(r, c, d, g, x);
        if (r !== null) {
          var R = Du(r);
          R !== null && Xe(R);
        }
        return w;
      }
      n.eventSystemFlags |= d;
      var k = n.targetContainers;
      return g !== null && k.indexOf(g) === -1 && k.push(g), n;
    }
    function US(n, r, c, d, g) {
      switch (r) {
        case "focusin": {
          var x = g;
          return Os = Rr(Os, n, r, c, d, x), !0;
        }
        case "dragenter": {
          var w = g;
          return ns = Rr(ns, n, r, c, d, w), !0;
        }
        case "mouseover": {
          var R = g;
          return is = Rr(is, n, r, c, d, R), !0;
        }
        case "pointerover": {
          var k = g, L = k.pointerId;
          return ei.set(L, Rr(ei.get(L) || null, n, r, c, d, k)), !0;
        }
        case "gotpointercapture": {
          var z = g, W = z.pointerId;
          return ir.set(W, Rr(ir.get(W) || null, n, r, c, d, z)), !0;
        }
      }
      return !1;
    }
    function Cm(n) {
      var r = df(n.target);
      if (r !== null) {
        var c = Hr(r);
        if (c !== null) {
          var d = c.tag;
          if (d === V) {
            var g = Za(c);
            if (g !== null) {
              n.blockedOn = g, Zc(n.priority, function() {
                th(c);
              });
              return;
            }
          } else if (d === S) {
            var x = c.stateNode;
            if (eh(x)) {
              n.blockedOn = Ja(c);
              return;
            }
          }
        }
      }
      n.blockedOn = null;
    }
    function Vy(n) {
      for (var r = Ny(), c = {
        blockedOn: null,
        target: n,
        priority: r
      }, d = 0; d < rr.length && Ei(r, rr[d].priority); d++)
        ;
      rr.splice(d, 0, c), d === 0 && Cm(c);
    }
    function ef(n) {
      if (n.blockedOn !== null)
        return !1;
      for (var r = n.targetContainers; r.length > 0; ) {
        var c = r[0], d = Su(n.domEventName, n.eventSystemFlags, c, n.nativeEvent);
        if (d === null) {
          var g = n.nativeEvent, x = new g.constructor(g.type, g);
          zS(x), g.target.dispatchEvent(x), FS();
        } else {
          var w = Du(d);
          return w !== null && Xe(w), n.blockedOn = d, !1;
        }
        r.shift();
      }
      return !0;
    }
    function wm(n, r, c) {
      ef(n) && c.delete(r);
    }
    function IS() {
      nh = !1, Os !== null && ef(Os) && (Os = null), ns !== null && ef(ns) && (ns = null), is !== null && ef(is) && (is = null), ei.forEach(wm), ir.forEach(wm);
    }
    function po(n, r) {
      n.blockedOn === r && (n.blockedOn = null, nh || (nh = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, IS)));
    }
    function yl(n) {
      if (Jc.length > 0) {
        po(Jc[0], n);
        for (var r = 1; r < Jc.length; r++) {
          var c = Jc[r];
          c.blockedOn === n && (c.blockedOn = null);
        }
      }
      Os !== null && po(Os, n), ns !== null && po(ns, n), is !== null && po(is, n);
      var d = function(R) {
        return po(R, n);
      };
      ei.forEach(d), ir.forEach(d);
      for (var g = 0; g < rr.length; g++) {
        var x = rr[g];
        x.blockedOn === n && (x.blockedOn = null);
      }
      for (; rr.length > 0; ) {
        var w = rr[0];
        if (w.blockedOn !== null)
          break;
        Cm(w), w.blockedOn === null && rr.shift();
      }
    }
    var zi = i.ReactCurrentBatchConfig, Ut = !0;
    function xi(n) {
      Ut = !!n;
    }
    function hi() {
      return Ut;
    }
    function Fi(n, r, c) {
      var d = ih(r), g;
      switch (d) {
        case nr:
          g = Yr;
          break;
        case ts:
          g = xu;
          break;
        case la:
        default:
          g = ti;
          break;
      }
      return g.bind(null, r, c, n);
    }
    function Yr(n, r, c, d) {
      var g = ca(), x = zi.transition;
      zi.transition = null;
      try {
        di(nr), ti(n, r, c, d);
      } finally {
        di(g), zi.transition = x;
      }
    }
    function xu(n, r, c, d) {
      var g = ca(), x = zi.transition;
      zi.transition = null;
      try {
        di(ts), ti(n, r, c, d);
      } finally {
        di(g), zi.transition = x;
      }
    }
    function ti(n, r, c, d) {
      Ut && tf(n, r, c, d);
    }
    function tf(n, r, c, d) {
      var g = Su(n, r, c, d);
      if (g === null) {
        s_(n, r, d, rs, c), _m(n, d);
        return;
      }
      if (US(g, n, r, c, d)) {
        d.stopPropagation();
        return;
      }
      if (_m(n, d), r & na && Fy(n)) {
        for (; g !== null; ) {
          var x = Du(g);
          x !== null && HS(x);
          var w = Su(n, r, c, d);
          if (w === null && s_(n, r, d, rs, c), w === g)
            break;
          g = w;
        }
        g !== null && d.stopPropagation();
        return;
      }
      s_(n, r, d, null, c);
    }
    var rs = null;
    function Su(n, r, c, d) {
      rs = null;
      var g = Qp(d), x = df(g);
      if (x !== null) {
        var w = Hr(x);
        if (w === null)
          x = null;
        else {
          var R = w.tag;
          if (R === V) {
            var k = Za(w);
            if (k !== null)
              return k;
            x = null;
          } else if (R === S) {
            var L = w.stateNode;
            if (eh(L))
              return Ja(w);
            x = null;
          } else w !== x && (x = null);
        }
      }
      return rs = x, null;
    }
    function ih(n) {
      switch (n) {
        // Used by SimpleEventPlugin:
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        // Used by polyfills:
        // eslint-disable-next-line no-fallthrough
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        // Only enableCreateEventHandleAPI:
        // eslint-disable-next-line no-fallthrough
        case "beforeblur":
        case "afterblur":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return nr;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ts;
        case "message": {
          var r = Rd();
          switch (r) {
            case Mc:
              return nr;
            case lo:
              return ts;
            case ks:
            case BS:
              return la;
            case al:
              return ua;
            default:
              return la;
          }
        }
        default:
          return la;
      }
    }
    function nf(n, r, c) {
      return n.addEventListener(r, c, !1), c;
    }
    function Dr(n, r, c) {
      return n.addEventListener(r, c, !0), c;
    }
    function Tm(n, r, c, d) {
      return n.addEventListener(r, c, {
        capture: !0,
        passive: d
      }), c;
    }
    function _u(n, r, c, d) {
      return n.addEventListener(r, c, {
        passive: d
      }), c;
    }
    var Gr = null, Cu = null, bl = null;
    function mo(n) {
      return Gr = n, Cu = rf(), !0;
    }
    function rh() {
      Gr = null, Cu = null, bl = null;
    }
    function Ps() {
      if (bl)
        return bl;
      var n, r = Cu, c = r.length, d, g = rf(), x = g.length;
      for (n = 0; n < c && r[n] === g[n]; n++)
        ;
      var w = c - n;
      for (d = 1; d <= w && r[c - d] === g[x - d]; d++)
        ;
      var R = d > 1 ? 1 - d : void 0;
      return bl = g.slice(n, R), bl;
    }
    function rf() {
      return "value" in Gr ? Gr.value : Gr.textContent;
    }
    function go(n) {
      var r, c = n.keyCode;
      return "charCode" in n ? (r = n.charCode, r === 0 && c === 13 && (r = 13)) : r = c, r === 10 && (r = 13), r >= 32 || r === 13 ? r : 0;
    }
    function wu() {
      return !0;
    }
    function af() {
      return !1;
    }
    function qi(n) {
      function r(c, d, g, x, w) {
        this._reactName = c, this._targetInst = g, this.type = d, this.nativeEvent = x, this.target = w, this.currentTarget = null;
        for (var R in n)
          if (n.hasOwnProperty(R)) {
            var k = n[R];
            k ? this[R] = k(x) : this[R] = x[R];
          }
        var L = x.defaultPrevented != null ? x.defaultPrevented : x.returnValue === !1;
        return L ? this.isDefaultPrevented = wu : this.isDefaultPrevented = af, this.isPropagationStopped = af, this;
      }
      return Lt(r.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var c = this.nativeEvent;
          c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = wu);
        },
        stopPropagation: function() {
          var c = this.nativeEvent;
          c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = wu);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: wu
      }), r;
    }
    var pi = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(n) {
        return n.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, as = qi(pi), ar = Lt({}, pi, {
      view: 0,
      detail: 0
    }), kr = qi(ar), ah, sf, xl;
    function $S(n) {
      n !== xl && (xl && n.type === "mousemove" ? (ah = n.screenX - xl.screenX, sf = n.screenY - xl.screenY) : (ah = 0, sf = 0), xl = n);
    }
    var Na = Lt({}, ar, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Ln,
      button: 0,
      buttons: 0,
      relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
      },
      movementX: function(n) {
        return "movementX" in n ? n.movementX : ($S(n), ah);
      },
      movementY: function(n) {
        return "movementY" in n ? n.movementY : sf;
      }
    }), Em = qi(Na), Rm = Lt({}, Na, {
      dataTransfer: 0
    }), Sl = qi(Rm), Dm = Lt({}, ar, {
      relatedTarget: 0
    }), Ls = qi(Dm), jy = Lt({}, pi, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), By = qi(jy), km = Lt({}, pi, {
      clipboardData: function(n) {
        return "clipboardData" in n ? n.clipboardData : window.clipboardData;
      }
    }), sh = qi(km), WS = Lt({}, pi, {
      data: 0
    }), Hy = qi(WS), Uy = Hy, Iy = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, _l = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function YS(n) {
      if (n.key) {
        var r = Iy[n.key] || n.key;
        if (r !== "Unidentified")
          return r;
      }
      if (n.type === "keypress") {
        var c = go(n);
        return c === 13 ? "Enter" : String.fromCharCode(c);
      }
      return n.type === "keydown" || n.type === "keyup" ? _l[n.keyCode] || "Unidentified" : "";
    }
    var Tu = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function $y(n) {
      var r = this, c = r.nativeEvent;
      if (c.getModifierState)
        return c.getModifierState(n);
      var d = Tu[n];
      return d ? !!c[d] : !1;
    }
    function Ln(n) {
      return $y;
    }
    var GS = Lt({}, ar, {
      key: YS,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Ln,
      // Legacy Interface
      charCode: function(n) {
        return n.type === "keypress" ? go(n) : 0;
      },
      keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      },
      which: function(n) {
        return n.type === "keypress" ? go(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      }
    }), Wy = qi(GS), KS = Lt({}, Na, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Yy = qi(KS), Gy = Lt({}, ar, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Ln
    }), Ky = qi(Gy), XS = Lt({}, pi, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), fa = qi(XS), Mm = Lt({}, Na, {
      deltaX: function(n) {
        return "deltaX" in n ? n.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in n ? -n.wheelDeltaX : 0
        );
      },
      deltaY: function(n) {
        return "deltaY" in n ? n.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in n ? -n.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in n ? -n.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), QS = qi(Mm), vo = [9, 13, 27, 32], of = 229, Ns = pt && "CompositionEvent" in window, yo = null;
    pt && "documentMode" in document && (yo = document.documentMode);
    var Am = pt && "TextEvent" in window && !yo, oh = pt && (!Ns || yo && yo > 8 && yo <= 11), Xy = 32, lh = String.fromCharCode(Xy);
    function qS() {
      ct("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ct("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ct("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ct("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Om = !1;
    function Qy(n) {
      return (n.ctrlKey || n.altKey || n.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(n.ctrlKey && n.altKey);
    }
    function uh(n) {
      switch (n) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function ch(n, r) {
      return n === "keydown" && r.keyCode === of;
    }
    function Pm(n, r) {
      switch (n) {
        case "keyup":
          return vo.indexOf(r.keyCode) !== -1;
        case "keydown":
          return r.keyCode !== of;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function fh(n) {
      var r = n.detail;
      return typeof r == "object" && "data" in r ? r.data : null;
    }
    function qy(n) {
      return n.locale === "ko";
    }
    var Cl = !1;
    function Lm(n, r, c, d, g) {
      var x, w;
      if (Ns ? x = uh(r) : Cl ? Pm(r, d) && (x = "onCompositionEnd") : ch(r, d) && (x = "onCompositionStart"), !x)
        return null;
      oh && !qy(d) && (!Cl && x === "onCompositionStart" ? Cl = mo(g) : x === "onCompositionEnd" && Cl && (w = Ps()));
      var R = r0(c, x);
      if (R.length > 0) {
        var k = new Hy(x, r, null, d, g);
        if (n.push({
          event: k,
          listeners: R
        }), w)
          k.data = w;
        else {
          var L = fh(d);
          L !== null && (k.data = L);
        }
      }
    }
    function dh(n, r) {
      switch (n) {
        case "compositionend":
          return fh(r);
        case "keypress":
          var c = r.which;
          return c !== Xy ? null : (Om = !0, lh);
        case "textInput":
          var d = r.data;
          return d === lh && Om ? null : d;
        default:
          return null;
      }
    }
    function Nm(n, r) {
      if (Cl) {
        if (n === "compositionend" || !Ns && Pm(n, r)) {
          var c = Ps();
          return rh(), Cl = !1, c;
        }
        return null;
      }
      switch (n) {
        case "paste":
          return null;
        case "keypress":
          if (!Qy(r)) {
            if (r.char && r.char.length > 1)
              return r.char;
            if (r.which)
              return String.fromCharCode(r.which);
          }
          return null;
        case "compositionend":
          return oh && !qy(r) ? null : r.data;
        default:
          return null;
      }
    }
    function hh(n, r, c, d, g) {
      var x;
      if (Am ? x = dh(r, d) : x = Nm(r, d), !x)
        return null;
      var w = r0(c, "onBeforeInput");
      if (w.length > 0) {
        var R = new Uy("onBeforeInput", "beforeinput", null, d, g);
        n.push({
          event: R,
          listeners: w
        }), R.data = x;
      }
    }
    function Zy(n, r, c, d, g, x, w) {
      Lm(n, r, c, d, g), hh(n, r, c, d, g);
    }
    var ZS = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function lf(n) {
      var r = n && n.nodeName && n.nodeName.toLowerCase();
      return r === "input" ? !!ZS[n.type] : r === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function JS(n) {
      if (!pt)
        return !1;
      var r = "on" + n, c = r in document;
      if (!c) {
        var d = document.createElement("div");
        d.setAttribute(r, "return;"), c = typeof d[r] == "function";
      }
      return c;
    }
    function uf() {
      ct("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function Jy(n, r, c, d) {
      lu(d);
      var g = r0(r, "onChange");
      if (g.length > 0) {
        var x = new as("onChange", "change", null, c, d);
        n.push({
          event: x,
          listeners: g
        });
      }
    }
    var bo = null, s = null;
    function l(n) {
      var r = n.nodeName && n.nodeName.toLowerCase();
      return r === "select" || r === "input" && n.type === "file";
    }
    function p(n) {
      var r = [];
      Jy(r, s, n, Qp(n)), fy(y, r);
    }
    function y(n) {
      G1(n, 0);
    }
    function _(n) {
      var r = bh(n);
      if (Ko(r))
        return n;
    }
    function T(n, r) {
      if (n === "change")
        return r;
    }
    var O = !1;
    pt && (O = JS("input") && (!document.documentMode || document.documentMode > 9));
    function j(n, r) {
      bo = n, s = r, bo.attachEvent("onpropertychange", te);
    }
    function U() {
      bo && (bo.detachEvent("onpropertychange", te), bo = null, s = null);
    }
    function te(n) {
      n.propertyName === "value" && _(s) && p(n);
    }
    function _e(n, r, c) {
      n === "focusin" ? (U(), j(r, c)) : n === "focusout" && U();
    }
    function Ee(n, r) {
      if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return _(s);
    }
    function xe(n) {
      var r = n.nodeName;
      return r && r.toLowerCase() === "input" && (n.type === "checkbox" || n.type === "radio");
    }
    function We(n, r) {
      if (n === "click")
        return _(r);
    }
    function qe(n, r) {
      if (n === "input" || n === "change")
        return _(r);
    }
    function et(n) {
      var r = n._wrapperState;
      !r || !r.controlled || n.type !== "number" || ad(n, "number", n.value);
    }
    function ni(n, r, c, d, g, x, w) {
      var R = c ? bh(c) : window, k, L;
      if (l(R) ? k = T : lf(R) ? O ? k = qe : (k = Ee, L = _e) : xe(R) && (k = We), k) {
        var z = k(r, c);
        if (z) {
          Jy(n, z, d, g);
          return;
        }
      }
      L && L(r, R, c), r === "focusout" && et(R);
    }
    function X() {
      gt("onMouseEnter", ["mouseout", "mouseover"]), gt("onMouseLeave", ["mouseout", "mouseover"]), gt("onPointerEnter", ["pointerout", "pointerover"]), gt("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function $(n, r, c, d, g, x, w) {
      var R = r === "mouseover" || r === "pointerover", k = r === "mouseout" || r === "pointerout";
      if (R && !wc(d)) {
        var L = d.relatedTarget || d.fromElement;
        if (L && (df(L) || Xm(L)))
          return;
      }
      if (!(!k && !R)) {
        var z;
        if (g.window === g)
          z = g;
        else {
          var W = g.ownerDocument;
          W ? z = W.defaultView || W.parentWindow : z = window;
        }
        var I, J;
        if (k) {
          var ne = d.relatedTarget || d.toElement;
          if (I = c, J = ne ? df(ne) : null, J !== null) {
            var le = Hr(J);
            (J !== le || J.tag !== E && J.tag !== D) && (J = null);
          }
        } else
          I = null, J = c;
        if (I !== J) {
          var Ie = Em, ut = "onMouseLeave", it = "onMouseEnter", $t = "mouse";
          (r === "pointerout" || r === "pointerover") && (Ie = Yy, ut = "onPointerLeave", it = "onPointerEnter", $t = "pointer");
          var jt = I == null ? z : bh(I), Q = J == null ? z : bh(J), ue = new Ie(ut, $t + "leave", I, d, g);
          ue.target = jt, ue.relatedTarget = Q;
          var q = null, Re = df(g);
          if (Re === c) {
            var Ke = new Ie(it, $t + "enter", J, d, g);
            Ke.target = Q, Ke.relatedTarget = jt, q = Ke;
          }
          tF(n, ue, q, I, J);
        }
      }
    }
    function Z(n, r) {
      return n === r && (n !== 0 || 1 / n === 1 / r) || n !== n && r !== r;
    }
    var Ce = typeof Object.is == "function" ? Object.is : Z;
    function Ze(n, r) {
      if (Ce(n, r))
        return !0;
      if (typeof n != "object" || n === null || typeof r != "object" || r === null)
        return !1;
      var c = Object.keys(n), d = Object.keys(r);
      if (c.length !== d.length)
        return !1;
      for (var g = 0; g < c.length; g++) {
        var x = c[g];
        if (!At.call(r, x) || !Ce(n[x], r[x]))
          return !1;
      }
      return !0;
    }
    function dt(n) {
      for (; n && n.firstChild; )
        n = n.firstChild;
      return n;
    }
    function ht(n) {
      for (; n; ) {
        if (n.nextSibling)
          return n.nextSibling;
        n = n.parentNode;
      }
    }
    function yt(n, r) {
      for (var c = dt(n), d = 0, g = 0; c; ) {
        if (c.nodeType === ws) {
          if (g = d + c.textContent.length, d <= r && g >= r)
            return {
              node: c,
              offset: r - d
            };
          d = g;
        }
        c = dt(ht(c));
      }
    }
    function Ri(n) {
      var r = n.ownerDocument, c = r && r.defaultView || window, d = c.getSelection && c.getSelection();
      if (!d || d.rangeCount === 0)
        return null;
      var g = d.anchorNode, x = d.anchorOffset, w = d.focusNode, R = d.focusOffset;
      try {
        g.nodeType, w.nodeType;
      } catch {
        return null;
      }
      return nn(n, g, x, w, R);
    }
    function nn(n, r, c, d, g) {
      var x = 0, w = -1, R = -1, k = 0, L = 0, z = n, W = null;
      e: for (; ; ) {
        for (var I = null; z === r && (c === 0 || z.nodeType === ws) && (w = x + c), z === d && (g === 0 || z.nodeType === ws) && (R = x + g), z.nodeType === ws && (x += z.nodeValue.length), (I = z.firstChild) !== null; )
          W = z, z = I;
        for (; ; ) {
          if (z === n)
            break e;
          if (W === r && ++k === c && (w = x), W === d && ++L === g && (R = x), (I = z.nextSibling) !== null)
            break;
          z = W, W = z.parentNode;
        }
        z = I;
      }
      return w === -1 || R === -1 ? null : {
        start: w,
        end: R
      };
    }
    function xo(n, r) {
      var c = n.ownerDocument || document, d = c && c.defaultView || window;
      if (d.getSelection) {
        var g = d.getSelection(), x = n.textContent.length, w = Math.min(r.start, x), R = r.end === void 0 ? w : Math.min(r.end, x);
        if (!g.extend && w > R) {
          var k = R;
          R = w, w = k;
        }
        var L = yt(n, w), z = yt(n, R);
        if (L && z) {
          if (g.rangeCount === 1 && g.anchorNode === L.node && g.anchorOffset === L.offset && g.focusNode === z.node && g.focusOffset === z.offset)
            return;
          var W = c.createRange();
          W.setStart(L.node, L.offset), g.removeAllRanges(), w > R ? (g.addRange(W), g.extend(z.node, z.offset)) : (W.setEnd(z.node, z.offset), g.addRange(W));
        }
      }
    }
    function e0(n) {
      return n && n.nodeType === ws;
    }
    function z1(n, r) {
      return !n || !r ? !1 : n === r ? !0 : e0(n) ? !1 : e0(r) ? z1(n, r.parentNode) : "contains" in n ? n.contains(r) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(r) & 16) : !1;
    }
    function Fz(n) {
      return n && n.ownerDocument && z1(n.ownerDocument.documentElement, n);
    }
    function Vz(n) {
      try {
        return typeof n.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function F1() {
      for (var n = window, r = Xo(); r instanceof n.HTMLIFrameElement; ) {
        if (Vz(r))
          n = r.contentWindow;
        else
          return r;
        r = Xo(n.document);
      }
      return r;
    }
    function e_(n) {
      var r = n && n.nodeName && n.nodeName.toLowerCase();
      return r && (r === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || r === "textarea" || n.contentEditable === "true");
    }
    function jz() {
      var n = F1();
      return {
        focusedElem: n,
        selectionRange: e_(n) ? Hz(n) : null
      };
    }
    function Bz(n) {
      var r = F1(), c = n.focusedElem, d = n.selectionRange;
      if (r !== c && Fz(c)) {
        d !== null && e_(c) && Uz(c, d);
        for (var g = [], x = c; x = x.parentNode; )
          x.nodeType === br && g.push({
            element: x,
            left: x.scrollLeft,
            top: x.scrollTop
          });
        typeof c.focus == "function" && c.focus();
        for (var w = 0; w < g.length; w++) {
          var R = g[w];
          R.element.scrollLeft = R.left, R.element.scrollTop = R.top;
        }
      }
    }
    function Hz(n) {
      var r;
      return "selectionStart" in n ? r = {
        start: n.selectionStart,
        end: n.selectionEnd
      } : r = Ri(n), r || {
        start: 0,
        end: 0
      };
    }
    function Uz(n, r) {
      var c = r.start, d = r.end;
      d === void 0 && (d = c), "selectionStart" in n ? (n.selectionStart = c, n.selectionEnd = Math.min(d, n.value.length)) : xo(n, r);
    }
    var Iz = pt && "documentMode" in document && document.documentMode <= 11;
    function $z() {
      ct("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var ph = null, t_ = null, zm = null, n_ = !1;
    function Wz(n) {
      if ("selectionStart" in n && e_(n))
        return {
          start: n.selectionStart,
          end: n.selectionEnd
        };
      var r = n.ownerDocument && n.ownerDocument.defaultView || window, c = r.getSelection();
      return {
        anchorNode: c.anchorNode,
        anchorOffset: c.anchorOffset,
        focusNode: c.focusNode,
        focusOffset: c.focusOffset
      };
    }
    function Yz(n) {
      return n.window === n ? n.document : n.nodeType === Ts ? n : n.ownerDocument;
    }
    function V1(n, r, c) {
      var d = Yz(c);
      if (!(n_ || ph == null || ph !== Xo(d))) {
        var g = Wz(ph);
        if (!zm || !Ze(zm, g)) {
          zm = g;
          var x = r0(t_, "onSelect");
          if (x.length > 0) {
            var w = new as("onSelect", "select", null, r, c);
            n.push({
              event: w,
              listeners: x
            }), w.target = ph;
          }
        }
      }
    }
    function Gz(n, r, c, d, g, x, w) {
      var R = c ? bh(c) : window;
      switch (r) {
        // Track the input node that has focus.
        case "focusin":
          (lf(R) || R.contentEditable === "true") && (ph = R, t_ = c, zm = null);
          break;
        case "focusout":
          ph = null, t_ = null, zm = null;
          break;
        // Don't fire the event while the user is dragging. This matches the
        // semantics of the native select event.
        case "mousedown":
          n_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          n_ = !1, V1(n, d, g);
          break;
        // Chrome and IE fire non-standard event when selection is changed (and
        // sometimes when it hasn't). IE's event fires out of order with respect
        // to key and input events on deletion, so we discard it.
        //
        // Firefox doesn't support selectionchange, so check selection status
        // after each key entry. The selection changes after keydown and before
        // keyup, but we check on keydown as well in the case of holding down a
        // key, when multiple keydown events are fired but only one keyup is.
        // This is also our approach for IE handling, for the reason above.
        case "selectionchange":
          if (Iz)
            break;
        // falls through
        case "keydown":
        case "keyup":
          V1(n, d, g);
      }
    }
    function t0(n, r) {
      var c = {};
      return c[n.toLowerCase()] = r.toLowerCase(), c["Webkit" + n] = "webkit" + r, c["Moz" + n] = "moz" + r, c;
    }
    var mh = {
      animationend: t0("Animation", "AnimationEnd"),
      animationiteration: t0("Animation", "AnimationIteration"),
      animationstart: t0("Animation", "AnimationStart"),
      transitionend: t0("Transition", "TransitionEnd")
    }, i_ = {}, j1 = {};
    pt && (j1 = document.createElement("div").style, "AnimationEvent" in window || (delete mh.animationend.animation, delete mh.animationiteration.animation, delete mh.animationstart.animation), "TransitionEvent" in window || delete mh.transitionend.transition);
    function n0(n) {
      if (i_[n])
        return i_[n];
      if (!mh[n])
        return n;
      var r = mh[n];
      for (var c in r)
        if (r.hasOwnProperty(c) && c in j1)
          return i_[n] = r[c];
      return n;
    }
    var B1 = n0("animationend"), H1 = n0("animationiteration"), U1 = n0("animationstart"), I1 = n0("transitionend"), $1 = /* @__PURE__ */ new Map(), W1 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Eu(n, r) {
      $1.set(n, r), ct(r, [n]);
    }
    function Kz() {
      for (var n = 0; n < W1.length; n++) {
        var r = W1[n], c = r.toLowerCase(), d = r[0].toUpperCase() + r.slice(1);
        Eu(c, "on" + d);
      }
      Eu(B1, "onAnimationEnd"), Eu(H1, "onAnimationIteration"), Eu(U1, "onAnimationStart"), Eu("dblclick", "onDoubleClick"), Eu("focusin", "onFocus"), Eu("focusout", "onBlur"), Eu(I1, "onTransitionEnd");
    }
    function Xz(n, r, c, d, g, x, w) {
      var R = $1.get(r);
      if (R !== void 0) {
        var k = as, L = r;
        switch (r) {
          case "keypress":
            if (go(d) === 0)
              return;
          /* falls through */
          case "keydown":
          case "keyup":
            k = Wy;
            break;
          case "focusin":
            L = "focus", k = Ls;
            break;
          case "focusout":
            L = "blur", k = Ls;
            break;
          case "beforeblur":
          case "afterblur":
            k = Ls;
            break;
          case "click":
            if (d.button === 2)
              return;
          /* falls through */
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          // TODO: Disabled elements should not respond to mouse events
          /* falls through */
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k = Em;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k = Sl;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k = Ky;
            break;
          case B1:
          case H1:
          case U1:
            k = By;
            break;
          case I1:
            k = fa;
            break;
          case "scroll":
            k = kr;
            break;
          case "wheel":
            k = QS;
            break;
          case "copy":
          case "cut":
          case "paste":
            k = sh;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k = Yy;
            break;
        }
        var z = (x & na) !== 0;
        {
          var W = !z && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          r === "scroll", I = Jz(c, R, d.type, z, W);
          if (I.length > 0) {
            var J = new k(R, L, null, d, g);
            n.push({
              event: J,
              listeners: I
            });
          }
        }
      }
    }
    Kz(), X(), uf(), $z(), qS();
    function Qz(n, r, c, d, g, x, w) {
      Xz(n, r, c, d, g, x);
      var R = (x & Xp) === 0;
      R && ($(n, r, c, d, g), ni(n, r, c, d, g), Gz(n, r, c, d, g), Zy(n, r, c, d, g));
    }
    var Fm = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], r_ = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Fm));
    function Y1(n, r, c) {
      var d = n.type || "unknown-event";
      n.currentTarget = c, Xa(d, r, void 0, n), n.currentTarget = null;
    }
    function qz(n, r, c) {
      var d;
      if (c)
        for (var g = r.length - 1; g >= 0; g--) {
          var x = r[g], w = x.instance, R = x.currentTarget, k = x.listener;
          if (w !== d && n.isPropagationStopped())
            return;
          Y1(n, k, R), d = w;
        }
      else
        for (var L = 0; L < r.length; L++) {
          var z = r[L], W = z.instance, I = z.currentTarget, J = z.listener;
          if (W !== d && n.isPropagationStopped())
            return;
          Y1(n, J, I), d = W;
        }
    }
    function G1(n, r) {
      for (var c = (r & na) !== 0, d = 0; d < n.length; d++) {
        var g = n[d], x = g.event, w = g.listeners;
        qz(x, w, c);
      }
      Rc();
    }
    function Zz(n, r, c, d, g) {
      var x = Qp(c), w = [];
      Qz(w, n, d, c, x, r), G1(w, r);
    }
    function jn(n, r) {
      r_.has(n) || u('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', n);
      var c = !1, d = DV(r), g = nF(n);
      d.has(g) || (K1(r, n, pd, c), d.add(g));
    }
    function a_(n, r, c) {
      r_.has(n) && !r && u('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', n);
      var d = 0;
      r && (d |= na), K1(c, n, d, r);
    }
    var i0 = "_reactListening" + Math.random().toString(36).slice(2);
    function Vm(n) {
      if (!n[i0]) {
        n[i0] = !0, ze.forEach(function(c) {
          c !== "selectionchange" && (r_.has(c) || a_(c, !1, n), a_(c, !0, n));
        });
        var r = n.nodeType === Ts ? n : n.ownerDocument;
        r !== null && (r[i0] || (r[i0] = !0, a_("selectionchange", !1, r)));
      }
    }
    function K1(n, r, c, d, g) {
      var x = Fi(n, r, c), w = void 0;
      Ec && (r === "touchstart" || r === "touchmove" || r === "wheel") && (w = !0), n = n, d ? w !== void 0 ? Tm(n, r, x, w) : Dr(n, r, x) : w !== void 0 ? _u(n, r, x, w) : nf(n, r, x);
    }
    function X1(n, r) {
      return n === r || n.nodeType === oi && n.parentNode === r;
    }
    function s_(n, r, c, d, g) {
      var x = d;
      if (!(r & Kp) && !(r & pd)) {
        var w = g;
        if (d !== null) {
          var R = d;
          e: for (; ; ) {
            if (R === null)
              return;
            var k = R.tag;
            if (k === S || k === C) {
              var L = R.stateNode.containerInfo;
              if (X1(L, w))
                break;
              if (k === C)
                for (var z = R.return; z !== null; ) {
                  var W = z.tag;
                  if (W === S || W === C) {
                    var I = z.stateNode.containerInfo;
                    if (X1(I, w))
                      return;
                  }
                  z = z.return;
                }
              for (; L !== null; ) {
                var J = df(L);
                if (J === null)
                  return;
                var ne = J.tag;
                if (ne === E || ne === D) {
                  R = x = J;
                  continue e;
                }
                L = L.parentNode;
              }
            }
            R = R.return;
          }
        }
      }
      fy(function() {
        return Zz(n, r, c, x);
      });
    }
    function jm(n, r, c) {
      return {
        instance: n,
        listener: r,
        currentTarget: c
      };
    }
    function Jz(n, r, c, d, g, x) {
      for (var w = r !== null ? r + "Capture" : null, R = d ? w : r, k = [], L = n, z = null; L !== null; ) {
        var W = L, I = W.stateNode, J = W.tag;
        if (J === E && I !== null && (z = I, R !== null)) {
          var ne = no(L, R);
          ne != null && k.push(jm(L, ne, z));
        }
        if (g)
          break;
        L = L.return;
      }
      return k;
    }
    function r0(n, r) {
      for (var c = r + "Capture", d = [], g = n; g !== null; ) {
        var x = g, w = x.stateNode, R = x.tag;
        if (R === E && w !== null) {
          var k = w, L = no(g, c);
          L != null && d.unshift(jm(g, L, k));
          var z = no(g, r);
          z != null && d.push(jm(g, z, k));
        }
        g = g.return;
      }
      return d;
    }
    function gh(n) {
      if (n === null)
        return null;
      do
        n = n.return;
      while (n && n.tag !== E);
      return n || null;
    }
    function eF(n, r) {
      for (var c = n, d = r, g = 0, x = c; x; x = gh(x))
        g++;
      for (var w = 0, R = d; R; R = gh(R))
        w++;
      for (; g - w > 0; )
        c = gh(c), g--;
      for (; w - g > 0; )
        d = gh(d), w--;
      for (var k = g; k--; ) {
        if (c === d || d !== null && c === d.alternate)
          return c;
        c = gh(c), d = gh(d);
      }
      return null;
    }
    function Q1(n, r, c, d, g) {
      for (var x = r._reactName, w = [], R = c; R !== null && R !== d; ) {
        var k = R, L = k.alternate, z = k.stateNode, W = k.tag;
        if (L !== null && L === d)
          break;
        if (W === E && z !== null) {
          var I = z;
          if (g) {
            var J = no(R, x);
            J != null && w.unshift(jm(R, J, I));
          } else if (!g) {
            var ne = no(R, x);
            ne != null && w.push(jm(R, ne, I));
          }
        }
        R = R.return;
      }
      w.length !== 0 && n.push({
        event: r,
        listeners: w
      });
    }
    function tF(n, r, c, d, g) {
      var x = d && g ? eF(d, g) : null;
      d !== null && Q1(n, r, d, x, !1), g !== null && c !== null && Q1(n, c, g, x, !0);
    }
    function nF(n, r) {
      return n + "__bubble";
    }
    var da = !1, Bm = "dangerouslySetInnerHTML", a0 = "suppressContentEditableWarning", Ru = "suppressHydrationWarning", q1 = "autoFocus", cf = "children", ff = "style", s0 = "__html", o_, o0, Hm, Z1, l0, J1, eR;
    o_ = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, o0 = function(n, r) {
      Wp(n, r), dd(n, r), ly(n, r, {
        registrationNameDependencies: De,
        possibleRegistrationNames: we
      });
    }, J1 = pt && !document.documentMode, Hm = function(n, r, c) {
      if (!da) {
        var d = u0(c), g = u0(r);
        g !== d && (da = !0, u("Prop `%s` did not match. Server: %s Client: %s", n, JSON.stringify(g), JSON.stringify(d)));
      }
    }, Z1 = function(n) {
      if (!da) {
        da = !0;
        var r = [];
        n.forEach(function(c) {
          r.push(c);
        }), u("Extra attributes from the server: %s", r);
      }
    }, l0 = function(n, r) {
      r === !1 ? u("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", n, n, n) : u("Expected `%s` listener to be a function, instead got a value of `%s` type.", n, typeof r);
    }, eR = function(n, r) {
      var c = n.namespaceURI === Cs ? n.ownerDocument.createElement(n.tagName) : n.ownerDocument.createElementNS(n.namespaceURI, n.tagName);
      return c.innerHTML = r, c.innerHTML;
    };
    var iF = /\r\n?/g, rF = /\u0000|\uFFFD/g;
    function u0(n) {
      Xt(n);
      var r = typeof n == "string" ? n : "" + n;
      return r.replace(iF, `
`).replace(rF, "");
    }
    function c0(n, r, c, d) {
      var g = u0(r), x = u0(n);
      if (x !== g && (d && (da || (da = !0, u('Text content did not match. Server: "%s" Client: "%s"', x, g))), c && Oe))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function tR(n) {
      return n.nodeType === Ts ? n : n.ownerDocument;
    }
    function aF() {
    }
    function f0(n) {
      n.onclick = aF;
    }
    function sF(n, r, c, d, g) {
      for (var x in d)
        if (d.hasOwnProperty(x)) {
          var w = d[x];
          if (x === ff)
            w && Object.freeze(w), ny(r, w);
          else if (x === Bm) {
            var R = w ? w[s0] : void 0;
            R != null && $v(r, R);
          } else if (x === cf)
            if (typeof w == "string") {
              var k = n !== "textarea" || w !== "";
              k && ru(r, w);
            } else typeof w == "number" && ru(r, "" + w);
          else x === a0 || x === Ru || x === q1 || (De.hasOwnProperty(x) ? w != null && (typeof w != "function" && l0(x, w), x === "onScroll" && jn("scroll", r)) : w != null && Ge(r, x, w, g));
        }
    }
    function oF(n, r, c, d) {
      for (var g = 0; g < r.length; g += 2) {
        var x = r[g], w = r[g + 1];
        x === ff ? ny(n, w) : x === Bm ? $v(n, w) : x === cf ? ru(n, w) : Ge(n, x, w, d);
      }
    }
    function lF(n, r, c, d) {
      var g, x = tR(c), w, R = d;
      if (R === Cs && (R = Vp(n)), R === Cs) {
        if (g = eo(n, r), !g && n !== n.toLowerCase() && u("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", n), n === "script") {
          var k = x.createElement("div");
          k.innerHTML = "<script><\/script>";
          var L = k.firstChild;
          w = k.removeChild(L);
        } else if (typeof r.is == "string")
          w = x.createElement(n, {
            is: r.is
          });
        else if (w = x.createElement(n), n === "select") {
          var z = w;
          r.multiple ? z.multiple = !0 : r.size && (z.size = r.size);
        }
      } else
        w = x.createElementNS(R, n);
      return R === Cs && !g && Object.prototype.toString.call(w) === "[object HTMLUnknownElement]" && !At.call(o_, n) && (o_[n] = !0, u("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", n)), w;
    }
    function uF(n, r) {
      return tR(r).createTextNode(n);
    }
    function cF(n, r, c, d) {
      var g = eo(r, c);
      o0(r, c);
      var x;
      switch (r) {
        case "dialog":
          jn("cancel", n), jn("close", n), x = c;
          break;
        case "iframe":
        case "object":
        case "embed":
          jn("load", n), x = c;
          break;
        case "video":
        case "audio":
          for (var w = 0; w < Fm.length; w++)
            jn(Fm[w], n);
          x = c;
          break;
        case "source":
          jn("error", n), x = c;
          break;
        case "img":
        case "image":
        case "link":
          jn("error", n), jn("load", n), x = c;
          break;
        case "details":
          jn("toggle", n), x = c;
          break;
        case "input":
          _s(n, c), x = td(n, c), jn("invalid", n);
          break;
        case "option":
          nu(n, c), x = c;
          break;
        case "select":
          od(n, c), x = Pp(n, c), jn("invalid", n);
          break;
        case "textarea":
          Np(n, c), x = Lp(n, c), jn("invalid", n);
          break;
        default:
          x = c;
      }
      switch (cd(r, x), sF(r, n, d, x, g), r) {
        case "input":
          Js(n), Mp(n, c, !1);
          break;
        case "textarea":
          Js(n), Uv(n);
          break;
        case "option":
          CS(n, c);
          break;
        case "select":
          TS(n, c);
          break;
        default:
          typeof x.onClick == "function" && f0(n);
          break;
      }
    }
    function fF(n, r, c, d, g) {
      o0(r, d);
      var x = null, w, R;
      switch (r) {
        case "input":
          w = td(n, c), R = td(n, d), x = [];
          break;
        case "select":
          w = Pp(n, c), R = Pp(n, d), x = [];
          break;
        case "textarea":
          w = Lp(n, c), R = Lp(n, d), x = [];
          break;
        default:
          w = c, R = d, typeof w.onClick != "function" && typeof R.onClick == "function" && f0(n);
          break;
      }
      cd(r, R);
      var k, L, z = null;
      for (k in w)
        if (!(R.hasOwnProperty(k) || !w.hasOwnProperty(k) || w[k] == null))
          if (k === ff) {
            var W = w[k];
            for (L in W)
              W.hasOwnProperty(L) && (z || (z = {}), z[L] = "");
          } else k === Bm || k === cf || k === a0 || k === Ru || k === q1 || (De.hasOwnProperty(k) ? x || (x = []) : (x = x || []).push(k, null));
      for (k in R) {
        var I = R[k], J = w != null ? w[k] : void 0;
        if (!(!R.hasOwnProperty(k) || I === J || I == null && J == null))
          if (k === ff)
            if (I && Object.freeze(I), J) {
              for (L in J)
                J.hasOwnProperty(L) && (!I || !I.hasOwnProperty(L)) && (z || (z = {}), z[L] = "");
              for (L in I)
                I.hasOwnProperty(L) && J[L] !== I[L] && (z || (z = {}), z[L] = I[L]);
            } else
              z || (x || (x = []), x.push(k, z)), z = I;
          else if (k === Bm) {
            var ne = I ? I[s0] : void 0, le = J ? J[s0] : void 0;
            ne != null && le !== ne && (x = x || []).push(k, ne);
          } else k === cf ? (typeof I == "string" || typeof I == "number") && (x = x || []).push(k, "" + I) : k === a0 || k === Ru || (De.hasOwnProperty(k) ? (I != null && (typeof I != "function" && l0(k, I), k === "onScroll" && jn("scroll", n)), !x && J !== I && (x = [])) : (x = x || []).push(k, I));
      }
      return z && (LS(z, R[ff]), (x = x || []).push(ff, z)), x;
    }
    function dF(n, r, c, d, g) {
      c === "input" && g.type === "radio" && g.name != null && nd(n, g);
      var x = eo(c, d), w = eo(c, g);
      switch (oF(n, r, x, w), c) {
        case "input":
          tu(n, g);
          break;
        case "textarea":
          Hv(n, g);
          break;
        case "select":
          ES(n, g);
          break;
      }
    }
    function hF(n) {
      {
        var r = n.toLowerCase();
        return _c.hasOwnProperty(r) && _c[r] || null;
      }
    }
    function pF(n, r, c, d, g, x, w) {
      var R, k;
      switch (R = eo(r, c), o0(r, c), r) {
        case "dialog":
          jn("cancel", n), jn("close", n);
          break;
        case "iframe":
        case "object":
        case "embed":
          jn("load", n);
          break;
        case "video":
        case "audio":
          for (var L = 0; L < Fm.length; L++)
            jn(Fm[L], n);
          break;
        case "source":
          jn("error", n);
          break;
        case "img":
        case "image":
        case "link":
          jn("error", n), jn("load", n);
          break;
        case "details":
          jn("toggle", n);
          break;
        case "input":
          _s(n, c), jn("invalid", n);
          break;
        case "option":
          nu(n, c);
          break;
        case "select":
          od(n, c), jn("invalid", n);
          break;
        case "textarea":
          Np(n, c), jn("invalid", n);
          break;
      }
      cd(r, c);
      {
        k = /* @__PURE__ */ new Set();
        for (var z = n.attributes, W = 0; W < z.length; W++) {
          var I = z[W].name.toLowerCase();
          switch (I) {
            // Controlled attributes are not validated
            // TODO: Only ignore them on controlled tags.
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              k.add(z[W].name);
          }
        }
      }
      var J = null;
      for (var ne in c)
        if (c.hasOwnProperty(ne)) {
          var le = c[ne];
          if (ne === cf)
            typeof le == "string" ? n.textContent !== le && (c[Ru] !== !0 && c0(n.textContent, le, x, w), J = [cf, le]) : typeof le == "number" && n.textContent !== "" + le && (c[Ru] !== !0 && c0(n.textContent, le, x, w), J = [cf, "" + le]);
          else if (De.hasOwnProperty(ne))
            le != null && (typeof le != "function" && l0(ne, le), ne === "onScroll" && jn("scroll", n));
          else if (w && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof R == "boolean") {
            var Ie = void 0, ut = Jt(ne);
            if (c[Ru] !== !0) {
              if (!(ne === a0 || ne === Ru || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              ne === "value" || ne === "checked" || ne === "selected")) {
                if (ne === Bm) {
                  var it = n.innerHTML, $t = le ? le[s0] : void 0;
                  if ($t != null) {
                    var jt = eR(n, $t);
                    jt !== it && Hm(ne, it, jt);
                  }
                } else if (ne === ff) {
                  if (k.delete(ne), J1) {
                    var Q = OS(le);
                    Ie = n.getAttribute("style"), Q !== Ie && Hm(ne, Ie, Q);
                  }
                } else if (R)
                  k.delete(ne.toLowerCase()), Ie = ke(n, ne, le), le !== Ie && Hm(ne, Ie, le);
                else if (!In(ne, ut, R) && !_n(ne, le, ut, R)) {
                  var ue = !1;
                  if (ut !== null)
                    k.delete(ut.attributeName), Ie = ye(n, ne, le, ut);
                  else {
                    var q = d;
                    if (q === Cs && (q = Vp(r)), q === Cs)
                      k.delete(ne.toLowerCase());
                    else {
                      var Re = hF(ne);
                      Re !== null && Re !== ne && (ue = !0, k.delete(Re)), k.delete(ne);
                    }
                    Ie = ke(n, ne, le);
                  }
                  var Ke = fe;
                  !Ke && le !== Ie && !ue && Hm(ne, Ie, le);
                }
              }
            }
          }
        }
      switch (w && // $FlowFixMe - Should be inferred as not undefined.
      k.size > 0 && c[Ru] !== !0 && Z1(k), r) {
        case "input":
          Js(n), Mp(n, c, !0);
          break;
        case "textarea":
          Js(n), Uv(n);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof c.onClick == "function" && f0(n);
          break;
      }
      return J;
    }
    function mF(n, r, c) {
      var d = n.nodeValue !== r;
      return d;
    }
    function l_(n, r) {
      {
        if (da)
          return;
        da = !0, u("Did not expect server HTML to contain a <%s> in <%s>.", r.nodeName.toLowerCase(), n.nodeName.toLowerCase());
      }
    }
    function u_(n, r) {
      {
        if (da)
          return;
        da = !0, u('Did not expect server HTML to contain the text node "%s" in <%s>.', r.nodeValue, n.nodeName.toLowerCase());
      }
    }
    function c_(n, r, c) {
      {
        if (da)
          return;
        da = !0, u("Expected server HTML to contain a matching <%s> in <%s>.", r, n.nodeName.toLowerCase());
      }
    }
    function f_(n, r) {
      {
        if (r === "" || da)
          return;
        da = !0, u('Expected server HTML to contain a matching text node for "%s" in <%s>.', r, n.nodeName.toLowerCase());
      }
    }
    function gF(n, r, c) {
      switch (r) {
        case "input":
          id(n, c);
          return;
        case "textarea":
          DS(n, c);
          return;
        case "select":
          RS(n, c);
          return;
      }
    }
    var Um = function() {
    }, Im = function() {
    };
    {
      var vF = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], nR = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], yF = nR.concat(["button"]), bF = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], iR = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Im = function(n, r) {
        var c = Lt({}, n || iR), d = {
          tag: r
        };
        return nR.indexOf(r) !== -1 && (c.aTagInScope = null, c.buttonTagInScope = null, c.nobrTagInScope = null), yF.indexOf(r) !== -1 && (c.pTagInButtonScope = null), vF.indexOf(r) !== -1 && r !== "address" && r !== "div" && r !== "p" && (c.listItemTagAutoclosing = null, c.dlItemTagAutoclosing = null), c.current = d, r === "form" && (c.formTag = d), r === "a" && (c.aTagInScope = d), r === "button" && (c.buttonTagInScope = d), r === "nobr" && (c.nobrTagInScope = d), r === "p" && (c.pTagInButtonScope = d), r === "li" && (c.listItemTagAutoclosing = d), (r === "dd" || r === "dt") && (c.dlItemTagAutoclosing = d), c;
      };
      var xF = function(n, r) {
        switch (r) {
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
          case "select":
            return n === "option" || n === "optgroup" || n === "#text";
          case "optgroup":
            return n === "option" || n === "#text";
          // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
          // but
          case "option":
            return n === "#text";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
          // No special behavior since these rules fall back to "in body" mode for
          // all except special table nodes which cause bad parsing behavior anyway.
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
          case "tr":
            return n === "th" || n === "td" || n === "style" || n === "script" || n === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
          case "tbody":
          case "thead":
          case "tfoot":
            return n === "tr" || n === "style" || n === "script" || n === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
          case "colgroup":
            return n === "col" || n === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
          case "table":
            return n === "caption" || n === "colgroup" || n === "tbody" || n === "tfoot" || n === "thead" || n === "style" || n === "script" || n === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
          case "head":
            return n === "base" || n === "basefont" || n === "bgsound" || n === "link" || n === "meta" || n === "title" || n === "noscript" || n === "noframes" || n === "style" || n === "script" || n === "template";
          // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
          case "html":
            return n === "head" || n === "body" || n === "frameset";
          case "frameset":
            return n === "frame";
          case "#document":
            return n === "html";
        }
        switch (n) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r !== "h1" && r !== "h2" && r !== "h3" && r !== "h4" && r !== "h5" && r !== "h6";
          case "rp":
          case "rt":
            return bF.indexOf(r) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return r == null;
        }
        return !0;
      }, SF = function(n, r) {
        switch (n) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r.pTagInButtonScope;
          case "form":
            return r.formTag || r.pTagInButtonScope;
          case "li":
            return r.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return r.dlItemTagAutoclosing;
          case "button":
            return r.buttonTagInScope;
          case "a":
            return r.aTagInScope;
          case "nobr":
            return r.nobrTagInScope;
        }
        return null;
      }, rR = {};
      Um = function(n, r, c) {
        c = c || iR;
        var d = c.current, g = d && d.tag;
        r != null && (n != null && u("validateDOMNesting: when childText is passed, childTag should be null"), n = "#text");
        var x = xF(n, g) ? null : d, w = x ? null : SF(n, c), R = x || w;
        if (R) {
          var k = R.tag, L = !!x + "|" + n + "|" + k;
          if (!rR[L]) {
            rR[L] = !0;
            var z = n, W = "";
            if (n === "#text" ? /\S/.test(r) ? z = "Text nodes" : (z = "Whitespace text nodes", W = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : z = "<" + n + ">", x) {
              var I = "";
              k === "table" && n === "tr" && (I += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), u("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", z, k, W, I);
            } else
              u("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", z, k);
          }
        }
      };
    }
    var d0 = "suppressHydrationWarning", h0 = "$", p0 = "/$", $m = "$?", Wm = "$!", _F = "style", d_ = null, h_ = null;
    function CF(n) {
      var r, c, d = n.nodeType;
      switch (d) {
        case Ts:
        case Bp: {
          r = d === Ts ? "#document" : "#fragment";
          var g = n.documentElement;
          c = g ? g.namespaceURI : jp(null, "");
          break;
        }
        default: {
          var x = d === oi ? n.parentNode : n, w = x.namespaceURI || null;
          r = x.tagName, c = jp(w, r);
          break;
        }
      }
      {
        var R = r.toLowerCase(), k = Im(null, R);
        return {
          namespace: c,
          ancestorInfo: k
        };
      }
    }
    function wF(n, r, c) {
      {
        var d = n, g = jp(d.namespace, r), x = Im(d.ancestorInfo, r);
        return {
          namespace: g,
          ancestorInfo: x
        };
      }
    }
    function JX(n) {
      return n;
    }
    function TF(n) {
      d_ = hi(), h_ = jz();
      var r = null;
      return xi(!1), r;
    }
    function EF(n) {
      Bz(h_), xi(d_), d_ = null, h_ = null;
    }
    function RF(n, r, c, d, g) {
      var x;
      {
        var w = d;
        if (Um(n, null, w.ancestorInfo), typeof r.children == "string" || typeof r.children == "number") {
          var R = "" + r.children, k = Im(w.ancestorInfo, n);
          Um(null, R, k);
        }
        x = w.namespace;
      }
      var L = lF(n, r, c, x);
      return Km(g, L), S_(L, r), L;
    }
    function DF(n, r) {
      n.appendChild(r);
    }
    function kF(n, r, c, d, g) {
      switch (cF(n, r, c, d), r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!c.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function MF(n, r, c, d, g, x) {
      {
        var w = x;
        if (typeof d.children != typeof c.children && (typeof d.children == "string" || typeof d.children == "number")) {
          var R = "" + d.children, k = Im(w.ancestorInfo, r);
          Um(null, R, k);
        }
      }
      return fF(n, r, c, d);
    }
    function p_(n, r) {
      return n === "textarea" || n === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
    }
    function AF(n, r, c, d) {
      {
        var g = c;
        Um(null, n, g.ancestorInfo);
      }
      var x = uF(n, r);
      return Km(d, x), x;
    }
    function OF() {
      var n = window.event;
      return n === void 0 ? la : ih(n.type);
    }
    var m_ = typeof setTimeout == "function" ? setTimeout : void 0, PF = typeof clearTimeout == "function" ? clearTimeout : void 0, g_ = -1, aR = typeof Promise == "function" ? Promise : void 0, LF = typeof queueMicrotask == "function" ? queueMicrotask : typeof aR < "u" ? function(n) {
      return aR.resolve(null).then(n).catch(NF);
    } : m_;
    function NF(n) {
      setTimeout(function() {
        throw n;
      });
    }
    function zF(n, r, c, d) {
      switch (r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && n.focus();
          return;
        case "img": {
          c.src && (n.src = c.src);
          return;
        }
      }
    }
    function FF(n, r, c, d, g, x) {
      dF(n, r, c, d, g), S_(n, g);
    }
    function sR(n) {
      ru(n, "");
    }
    function VF(n, r, c) {
      n.nodeValue = c;
    }
    function jF(n, r) {
      n.appendChild(r);
    }
    function BF(n, r) {
      var c;
      n.nodeType === oi ? (c = n.parentNode, c.insertBefore(r, n)) : (c = n, c.appendChild(r));
      var d = n._reactRootContainer;
      d == null && c.onclick === null && f0(c);
    }
    function HF(n, r, c) {
      n.insertBefore(r, c);
    }
    function UF(n, r, c) {
      n.nodeType === oi ? n.parentNode.insertBefore(r, c) : n.insertBefore(r, c);
    }
    function IF(n, r) {
      n.removeChild(r);
    }
    function $F(n, r) {
      n.nodeType === oi ? n.parentNode.removeChild(r) : n.removeChild(r);
    }
    function v_(n, r) {
      var c = r, d = 0;
      do {
        var g = c.nextSibling;
        if (n.removeChild(c), g && g.nodeType === oi) {
          var x = g.data;
          if (x === p0)
            if (d === 0) {
              n.removeChild(g), yl(r);
              return;
            } else
              d--;
          else (x === h0 || x === $m || x === Wm) && d++;
        }
        c = g;
      } while (c);
      yl(r);
    }
    function WF(n, r) {
      n.nodeType === oi ? v_(n.parentNode, r) : n.nodeType === br && v_(n, r), yl(n);
    }
    function YF(n) {
      n = n;
      var r = n.style;
      typeof r.setProperty == "function" ? r.setProperty("display", "none", "important") : r.display = "none";
    }
    function GF(n) {
      n.nodeValue = "";
    }
    function KF(n, r) {
      n = n;
      var c = r[_F], d = c != null && c.hasOwnProperty("display") ? c.display : null;
      n.style.display = ud("display", d);
    }
    function XF(n, r) {
      n.nodeValue = r;
    }
    function QF(n) {
      n.nodeType === br ? n.textContent = "" : n.nodeType === Ts && n.documentElement && n.removeChild(n.documentElement);
    }
    function qF(n, r, c) {
      return n.nodeType !== br || r.toLowerCase() !== n.nodeName.toLowerCase() ? null : n;
    }
    function ZF(n, r) {
      return r === "" || n.nodeType !== ws ? null : n;
    }
    function JF(n) {
      return n.nodeType !== oi ? null : n;
    }
    function oR(n) {
      return n.data === $m;
    }
    function y_(n) {
      return n.data === Wm;
    }
    function eV(n) {
      var r = n.nextSibling && n.nextSibling.dataset, c, d, g;
      return r && (c = r.dgst, d = r.msg, g = r.stck), {
        message: d,
        digest: c,
        stack: g
      };
    }
    function tV(n, r) {
      n._reactRetry = r;
    }
    function m0(n) {
      for (; n != null; n = n.nextSibling) {
        var r = n.nodeType;
        if (r === br || r === ws)
          break;
        if (r === oi) {
          var c = n.data;
          if (c === h0 || c === Wm || c === $m)
            break;
          if (c === p0)
            return null;
        }
      }
      return n;
    }
    function Ym(n) {
      return m0(n.nextSibling);
    }
    function nV(n) {
      return m0(n.firstChild);
    }
    function iV(n) {
      return m0(n.firstChild);
    }
    function rV(n) {
      return m0(n.nextSibling);
    }
    function aV(n, r, c, d, g, x, w) {
      Km(x, n), S_(n, c);
      var R;
      {
        var k = g;
        R = k.namespace;
      }
      var L = (x.mode & Nt) !== st;
      return pF(n, r, c, R, d, L, w);
    }
    function sV(n, r, c, d) {
      return Km(c, n), c.mode & Nt, mF(n, r);
    }
    function oV(n, r) {
      Km(r, n);
    }
    function lV(n) {
      for (var r = n.nextSibling, c = 0; r; ) {
        if (r.nodeType === oi) {
          var d = r.data;
          if (d === p0) {
            if (c === 0)
              return Ym(r);
            c--;
          } else (d === h0 || d === Wm || d === $m) && c++;
        }
        r = r.nextSibling;
      }
      return null;
    }
    function lR(n) {
      for (var r = n.previousSibling, c = 0; r; ) {
        if (r.nodeType === oi) {
          var d = r.data;
          if (d === h0 || d === Wm || d === $m) {
            if (c === 0)
              return r;
            c--;
          } else d === p0 && c++;
        }
        r = r.previousSibling;
      }
      return null;
    }
    function uV(n) {
      yl(n);
    }
    function cV(n) {
      yl(n);
    }
    function fV(n) {
      return n !== "head" && n !== "body";
    }
    function dV(n, r, c, d) {
      var g = !0;
      c0(r.nodeValue, c, d, g);
    }
    function hV(n, r, c, d, g, x) {
      if (r[d0] !== !0) {
        var w = !0;
        c0(d.nodeValue, g, x, w);
      }
    }
    function pV(n, r) {
      r.nodeType === br ? l_(n, r) : r.nodeType === oi || u_(n, r);
    }
    function mV(n, r) {
      {
        var c = n.parentNode;
        c !== null && (r.nodeType === br ? l_(c, r) : r.nodeType === oi || u_(c, r));
      }
    }
    function gV(n, r, c, d, g) {
      (g || r[d0] !== !0) && (d.nodeType === br ? l_(c, d) : d.nodeType === oi || u_(c, d));
    }
    function vV(n, r, c) {
      c_(n, r);
    }
    function yV(n, r) {
      f_(n, r);
    }
    function bV(n, r, c) {
      {
        var d = n.parentNode;
        d !== null && c_(d, r);
      }
    }
    function xV(n, r) {
      {
        var c = n.parentNode;
        c !== null && f_(c, r);
      }
    }
    function SV(n, r, c, d, g, x) {
      (x || r[d0] !== !0) && c_(c, d);
    }
    function _V(n, r, c, d, g) {
      (g || r[d0] !== !0) && f_(c, d);
    }
    function CV(n) {
      u("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", n.nodeName.toLowerCase());
    }
    function wV(n) {
      Vm(n);
    }
    var vh = Math.random().toString(36).slice(2), yh = "__reactFiber$" + vh, b_ = "__reactProps$" + vh, Gm = "__reactContainer$" + vh, x_ = "__reactEvents$" + vh, TV = "__reactListeners$" + vh, EV = "__reactHandles$" + vh;
    function RV(n) {
      delete n[yh], delete n[b_], delete n[x_], delete n[TV], delete n[EV];
    }
    function Km(n, r) {
      r[yh] = n;
    }
    function g0(n, r) {
      r[Gm] = n;
    }
    function uR(n) {
      n[Gm] = null;
    }
    function Xm(n) {
      return !!n[Gm];
    }
    function df(n) {
      var r = n[yh];
      if (r)
        return r;
      for (var c = n.parentNode; c; ) {
        if (r = c[Gm] || c[yh], r) {
          var d = r.alternate;
          if (r.child !== null || d !== null && d.child !== null)
            for (var g = lR(n); g !== null; ) {
              var x = g[yh];
              if (x)
                return x;
              g = lR(g);
            }
          return r;
        }
        n = c, c = n.parentNode;
      }
      return null;
    }
    function Du(n) {
      var r = n[yh] || n[Gm];
      return r && (r.tag === E || r.tag === D || r.tag === V || r.tag === S) ? r : null;
    }
    function bh(n) {
      if (n.tag === E || n.tag === D)
        return n.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function v0(n) {
      return n[b_] || null;
    }
    function S_(n, r) {
      n[b_] = r;
    }
    function DV(n) {
      var r = n[x_];
      return r === void 0 && (r = n[x_] = /* @__PURE__ */ new Set()), r;
    }
    var cR = {}, fR = i.ReactDebugCurrentFrame;
    function y0(n) {
      if (n) {
        var r = n._owner, c = Go(n.type, n._source, r ? r.type : null);
        fR.setExtraStackFrame(c);
      } else
        fR.setExtraStackFrame(null);
    }
    function zs(n, r, c, d, g) {
      {
        var x = Function.call.bind(At);
        for (var w in n)
          if (x(n, w)) {
            var R = void 0;
            try {
              if (typeof n[w] != "function") {
                var k = Error((d || "React class") + ": " + c + " type `" + w + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof n[w] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw k.name = "Invariant Violation", k;
              }
              R = n[w](r, w, d, c, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (L) {
              R = L;
            }
            R && !(R instanceof Error) && (y0(g), u("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", d || "React class", c, w, typeof R), y0(null)), R instanceof Error && !(R.message in cR) && (cR[R.message] = !0, y0(g), u("Failed %s type: %s", c, R.message), y0(null));
          }
      }
    }
    var __ = [], b0;
    b0 = [];
    var wl = -1;
    function ku(n) {
      return {
        current: n
      };
    }
    function Mr(n, r) {
      if (wl < 0) {
        u("Unexpected pop.");
        return;
      }
      r !== b0[wl] && u("Unexpected Fiber popped."), n.current = __[wl], __[wl] = null, b0[wl] = null, wl--;
    }
    function Ar(n, r, c) {
      wl++, __[wl] = n.current, b0[wl] = c, n.current = r;
    }
    var C_;
    C_ = {};
    var za = {};
    Object.freeze(za);
    var Tl = ku(za), So = ku(!1), w_ = za;
    function xh(n, r, c) {
      return c && _o(r) ? w_ : Tl.current;
    }
    function dR(n, r, c) {
      {
        var d = n.stateNode;
        d.__reactInternalMemoizedUnmaskedChildContext = r, d.__reactInternalMemoizedMaskedChildContext = c;
      }
    }
    function Sh(n, r) {
      {
        var c = n.type, d = c.contextTypes;
        if (!d)
          return za;
        var g = n.stateNode;
        if (g && g.__reactInternalMemoizedUnmaskedChildContext === r)
          return g.__reactInternalMemoizedMaskedChildContext;
        var x = {};
        for (var w in d)
          x[w] = r[w];
        {
          var R = kt(n) || "Unknown";
          zs(d, x, "context", R);
        }
        return g && dR(n, r, x), x;
      }
    }
    function x0() {
      return So.current;
    }
    function _o(n) {
      {
        var r = n.childContextTypes;
        return r != null;
      }
    }
    function S0(n) {
      Mr(So, n), Mr(Tl, n);
    }
    function T_(n) {
      Mr(So, n), Mr(Tl, n);
    }
    function hR(n, r, c) {
      {
        if (Tl.current !== za)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Ar(Tl, r, n), Ar(So, c, n);
      }
    }
    function pR(n, r, c) {
      {
        var d = n.stateNode, g = r.childContextTypes;
        if (typeof d.getChildContext != "function") {
          {
            var x = kt(n) || "Unknown";
            C_[x] || (C_[x] = !0, u("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", x, x));
          }
          return c;
        }
        var w = d.getChildContext();
        for (var R in w)
          if (!(R in g))
            throw new Error((kt(n) || "Unknown") + '.getChildContext(): key "' + R + '" is not defined in childContextTypes.');
        {
          var k = kt(n) || "Unknown";
          zs(g, w, "child context", k);
        }
        return Lt({}, c, w);
      }
    }
    function _0(n) {
      {
        var r = n.stateNode, c = r && r.__reactInternalMemoizedMergedChildContext || za;
        return w_ = Tl.current, Ar(Tl, c, n), Ar(So, So.current, n), !0;
      }
    }
    function mR(n, r, c) {
      {
        var d = n.stateNode;
        if (!d)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (c) {
          var g = pR(n, r, w_);
          d.__reactInternalMemoizedMergedChildContext = g, Mr(So, n), Mr(Tl, n), Ar(Tl, g, n), Ar(So, c, n);
        } else
          Mr(So, n), Ar(So, c, n);
      }
    }
    function kV(n) {
      {
        if (!rl(n) || n.tag !== v)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var r = n;
        do {
          switch (r.tag) {
            case S:
              return r.stateNode.context;
            case v: {
              var c = r.type;
              if (_o(c))
                return r.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          r = r.return;
        } while (r !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Mu = 0, C0 = 1, El = null, E_ = !1, R_ = !1;
    function gR(n) {
      El === null ? El = [n] : El.push(n);
    }
    function MV(n) {
      E_ = !0, gR(n);
    }
    function vR() {
      E_ && Au();
    }
    function Au() {
      if (!R_ && El !== null) {
        R_ = !0;
        var n = 0, r = ca();
        try {
          var c = !0, d = El;
          for (di(nr); n < d.length; n++) {
            var g = d[n];
            do
              g = g(c);
            while (g !== null);
          }
          El = null, E_ = !1;
        } catch (x) {
          throw El !== null && (El = El.slice(n + 1)), Zp(Mc, Au), x;
        } finally {
          di(r), R_ = !1;
        }
      }
      return null;
    }
    var _h = [], Ch = 0, w0 = null, T0 = 0, ss = [], os = 0, hf = null, Rl = 1, Dl = "";
    function AV(n) {
      return mf(), (n.flags & Qa) !== at;
    }
    function OV(n) {
      return mf(), T0;
    }
    function PV() {
      var n = Dl, r = Rl, c = r & ~LV(r);
      return c.toString(32) + n;
    }
    function pf(n, r) {
      mf(), _h[Ch++] = T0, _h[Ch++] = w0, w0 = n, T0 = r;
    }
    function yR(n, r, c) {
      mf(), ss[os++] = Rl, ss[os++] = Dl, ss[os++] = hf, hf = n;
      var d = Rl, g = Dl, x = E0(d) - 1, w = d & ~(1 << x), R = c + 1, k = E0(r) + x;
      if (k > 30) {
        var L = x - x % 5, z = (1 << L) - 1, W = (w & z).toString(32), I = w >> L, J = x - L, ne = E0(r) + J, le = R << J, Ie = le | I, ut = W + g;
        Rl = 1 << ne | Ie, Dl = ut;
      } else {
        var it = R << x, $t = it | w, jt = g;
        Rl = 1 << k | $t, Dl = jt;
      }
    }
    function D_(n) {
      mf();
      var r = n.return;
      if (r !== null) {
        var c = 1, d = 0;
        pf(n, c), yR(n, c, d);
      }
    }
    function E0(n) {
      return 32 - ci(n);
    }
    function LV(n) {
      return 1 << E0(n) - 1;
    }
    function k_(n) {
      for (; n === w0; )
        w0 = _h[--Ch], _h[Ch] = null, T0 = _h[--Ch], _h[Ch] = null;
      for (; n === hf; )
        hf = ss[--os], ss[os] = null, Dl = ss[--os], ss[os] = null, Rl = ss[--os], ss[os] = null;
    }
    function NV() {
      return mf(), hf !== null ? {
        id: Rl,
        overflow: Dl
      } : null;
    }
    function zV(n, r) {
      mf(), ss[os++] = Rl, ss[os++] = Dl, ss[os++] = hf, Rl = r.id, Dl = r.overflow, hf = n;
    }
    function mf() {
      or() || u("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var sr = null, ls = null, Fs = !1, gf = !1, Ou = null;
    function FV() {
      Fs && u("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function bR() {
      gf = !0;
    }
    function VV() {
      return gf;
    }
    function jV(n) {
      var r = n.stateNode.containerInfo;
      return ls = iV(r), sr = n, Fs = !0, Ou = null, gf = !1, !0;
    }
    function BV(n, r, c) {
      return ls = rV(r), sr = n, Fs = !0, Ou = null, gf = !1, c !== null && zV(n, c), !0;
    }
    function xR(n, r) {
      switch (n.tag) {
        case S: {
          pV(n.stateNode.containerInfo, r);
          break;
        }
        case E: {
          var c = (n.mode & Nt) !== st;
          gV(
            n.type,
            n.memoizedProps,
            n.stateNode,
            r,
            // TODO: Delete this argument when we remove the legacy root API.
            c
          );
          break;
        }
        case V: {
          var d = n.memoizedState;
          d.dehydrated !== null && mV(d.dehydrated, r);
          break;
        }
      }
    }
    function SR(n, r) {
      xR(n, r);
      var c = $H();
      c.stateNode = r, c.return = n;
      var d = n.deletions;
      d === null ? (n.deletions = [c], n.flags |= ia) : d.push(c);
    }
    function M_(n, r) {
      {
        if (gf)
          return;
        switch (n.tag) {
          case S: {
            var c = n.stateNode.containerInfo;
            switch (r.tag) {
              case E:
                var d = r.type;
                r.pendingProps, vV(c, d);
                break;
              case D:
                var g = r.pendingProps;
                yV(c, g);
                break;
            }
            break;
          }
          case E: {
            var x = n.type, w = n.memoizedProps, R = n.stateNode;
            switch (r.tag) {
              case E: {
                var k = r.type, L = r.pendingProps, z = (n.mode & Nt) !== st;
                SV(
                  x,
                  w,
                  R,
                  k,
                  L,
                  // TODO: Delete this argument when we remove the legacy root API.
                  z
                );
                break;
              }
              case D: {
                var W = r.pendingProps, I = (n.mode & Nt) !== st;
                _V(
                  x,
                  w,
                  R,
                  W,
                  // TODO: Delete this argument when we remove the legacy root API.
                  I
                );
                break;
              }
            }
            break;
          }
          case V: {
            var J = n.memoizedState, ne = J.dehydrated;
            if (ne !== null) switch (r.tag) {
              case E:
                var le = r.type;
                r.pendingProps, bV(ne, le);
                break;
              case D:
                var Ie = r.pendingProps;
                xV(ne, Ie);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function _R(n, r) {
      r.flags = r.flags & -4097 | qn, M_(n, r);
    }
    function CR(n, r) {
      switch (n.tag) {
        case E: {
          var c = n.type;
          n.pendingProps;
          var d = qF(r, c);
          return d !== null ? (n.stateNode = d, sr = n, ls = nV(d), !0) : !1;
        }
        case D: {
          var g = n.pendingProps, x = ZF(r, g);
          return x !== null ? (n.stateNode = x, sr = n, ls = null, !0) : !1;
        }
        case V: {
          var w = JF(r);
          if (w !== null) {
            var R = {
              dehydrated: w,
              treeContext: NV(),
              retryLane: Wr
            };
            n.memoizedState = R;
            var k = WH(w);
            return k.return = n, n.child = k, sr = n, ls = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function A_(n) {
      return (n.mode & Nt) !== st && (n.flags & rt) === at;
    }
    function O_(n) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function P_(n) {
      if (Fs) {
        var r = ls;
        if (!r) {
          A_(n) && (M_(sr, n), O_()), _R(sr, n), Fs = !1, sr = n;
          return;
        }
        var c = r;
        if (!CR(n, r)) {
          A_(n) && (M_(sr, n), O_()), r = Ym(c);
          var d = sr;
          if (!r || !CR(n, r)) {
            _R(sr, n), Fs = !1, sr = n;
            return;
          }
          SR(d, c);
        }
      }
    }
    function HV(n, r, c) {
      var d = n.stateNode, g = !gf, x = aV(d, n.type, n.memoizedProps, r, c, n, g);
      return n.updateQueue = x, x !== null;
    }
    function UV(n) {
      var r = n.stateNode, c = n.memoizedProps, d = sV(r, c, n);
      if (d) {
        var g = sr;
        if (g !== null)
          switch (g.tag) {
            case S: {
              var x = g.stateNode.containerInfo, w = (g.mode & Nt) !== st;
              dV(
                x,
                r,
                c,
                // TODO: Delete this argument when we remove the legacy root API.
                w
              );
              break;
            }
            case E: {
              var R = g.type, k = g.memoizedProps, L = g.stateNode, z = (g.mode & Nt) !== st;
              hV(
                R,
                k,
                L,
                r,
                c,
                // TODO: Delete this argument when we remove the legacy root API.
                z
              );
              break;
            }
          }
      }
      return d;
    }
    function IV(n) {
      var r = n.memoizedState, c = r !== null ? r.dehydrated : null;
      if (!c)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      oV(c, n);
    }
    function $V(n) {
      var r = n.memoizedState, c = r !== null ? r.dehydrated : null;
      if (!c)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return lV(c);
    }
    function wR(n) {
      for (var r = n.return; r !== null && r.tag !== E && r.tag !== S && r.tag !== V; )
        r = r.return;
      sr = r;
    }
    function R0(n) {
      if (n !== sr)
        return !1;
      if (!Fs)
        return wR(n), Fs = !0, !1;
      if (n.tag !== S && (n.tag !== E || fV(n.type) && !p_(n.type, n.memoizedProps))) {
        var r = ls;
        if (r)
          if (A_(n))
            TR(n), O_();
          else
            for (; r; )
              SR(n, r), r = Ym(r);
      }
      return wR(n), n.tag === V ? ls = $V(n) : ls = sr ? Ym(n.stateNode) : null, !0;
    }
    function WV() {
      return Fs && ls !== null;
    }
    function TR(n) {
      for (var r = ls; r; )
        xR(n, r), r = Ym(r);
    }
    function wh() {
      sr = null, ls = null, Fs = !1, gf = !1;
    }
    function ER() {
      Ou !== null && (bk(Ou), Ou = null);
    }
    function or() {
      return Fs;
    }
    function L_(n) {
      Ou === null ? Ou = [n] : Ou.push(n);
    }
    var YV = i.ReactCurrentBatchConfig, GV = null;
    function KV() {
      return YV.transition;
    }
    var Vs = {
      recordUnsafeLifecycleWarnings: function(n, r) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(n, r) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var XV = function(n) {
        for (var r = null, c = n; c !== null; )
          c.mode & mn && (r = c), c = c.return;
        return r;
      }, vf = function(n) {
        var r = [];
        return n.forEach(function(c) {
          r.push(c);
        }), r.sort().join(", ");
      }, Qm = [], qm = [], Zm = [], Jm = [], eg = [], tg = [], yf = /* @__PURE__ */ new Set();
      Vs.recordUnsafeLifecycleWarnings = function(n, r) {
        yf.has(n.type) || (typeof r.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        r.componentWillMount.__suppressDeprecationWarning !== !0 && Qm.push(n), n.mode & mn && typeof r.UNSAFE_componentWillMount == "function" && qm.push(n), typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Zm.push(n), n.mode & mn && typeof r.UNSAFE_componentWillReceiveProps == "function" && Jm.push(n), typeof r.componentWillUpdate == "function" && r.componentWillUpdate.__suppressDeprecationWarning !== !0 && eg.push(n), n.mode & mn && typeof r.UNSAFE_componentWillUpdate == "function" && tg.push(n));
      }, Vs.flushPendingUnsafeLifecycleWarnings = function() {
        var n = /* @__PURE__ */ new Set();
        Qm.length > 0 && (Qm.forEach(function(I) {
          n.add(kt(I) || "Component"), yf.add(I.type);
        }), Qm = []);
        var r = /* @__PURE__ */ new Set();
        qm.length > 0 && (qm.forEach(function(I) {
          r.add(kt(I) || "Component"), yf.add(I.type);
        }), qm = []);
        var c = /* @__PURE__ */ new Set();
        Zm.length > 0 && (Zm.forEach(function(I) {
          c.add(kt(I) || "Component"), yf.add(I.type);
        }), Zm = []);
        var d = /* @__PURE__ */ new Set();
        Jm.length > 0 && (Jm.forEach(function(I) {
          d.add(kt(I) || "Component"), yf.add(I.type);
        }), Jm = []);
        var g = /* @__PURE__ */ new Set();
        eg.length > 0 && (eg.forEach(function(I) {
          g.add(kt(I) || "Component"), yf.add(I.type);
        }), eg = []);
        var x = /* @__PURE__ */ new Set();
        if (tg.length > 0 && (tg.forEach(function(I) {
          x.add(kt(I) || "Component"), yf.add(I.type);
        }), tg = []), r.size > 0) {
          var w = vf(r);
          u(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, w);
        }
        if (d.size > 0) {
          var R = vf(d);
          u(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, R);
        }
        if (x.size > 0) {
          var k = vf(x);
          u(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, k);
        }
        if (n.size > 0) {
          var L = vf(n);
          f(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, L);
        }
        if (c.size > 0) {
          var z = vf(c);
          f(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, z);
        }
        if (g.size > 0) {
          var W = vf(g);
          f(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, W);
        }
      };
      var D0 = /* @__PURE__ */ new Map(), RR = /* @__PURE__ */ new Set();
      Vs.recordLegacyContextWarning = function(n, r) {
        var c = XV(n);
        if (c === null) {
          u("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!RR.has(n.type)) {
          var d = D0.get(c);
          (n.type.contextTypes != null || n.type.childContextTypes != null || r !== null && typeof r.getChildContext == "function") && (d === void 0 && (d = [], D0.set(c, d)), d.push(n));
        }
      }, Vs.flushLegacyContextWarning = function() {
        D0.forEach(function(n, r) {
          if (n.length !== 0) {
            var c = n[0], d = /* @__PURE__ */ new Set();
            n.forEach(function(x) {
              d.add(kt(x) || "Component"), RR.add(x.type);
            });
            var g = vf(d);
            try {
              kn(c), u(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, g);
            } finally {
              Wn();
            }
          }
        });
      }, Vs.discardPendingWarnings = function() {
        Qm = [], qm = [], Zm = [], Jm = [], eg = [], tg = [], D0 = /* @__PURE__ */ new Map();
      };
    }
    var N_, z_, F_, V_, j_, DR = function(n, r) {
    };
    N_ = !1, z_ = !1, F_ = {}, V_ = {}, j_ = {}, DR = function(n, r) {
      if (!(n === null || typeof n != "object") && !(!n._store || n._store.validated || n.key != null)) {
        if (typeof n._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        n._store.validated = !0;
        var c = kt(r) || "Component";
        V_[c] || (V_[c] = !0, u('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function QV(n) {
      return n.prototype && n.prototype.isReactComponent;
    }
    function ng(n, r, c) {
      var d = c.ref;
      if (d !== null && typeof d != "function" && typeof d != "object") {
        if ((n.mode & mn || pe) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(c._owner && c._self && c._owner.stateNode !== c._self) && // Will already throw with "Function components cannot have string refs"
        !(c._owner && c._owner.tag !== v) && // Will already warn with "Function components cannot be given refs"
        !(typeof c.type == "function" && !QV(c.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        c._owner) {
          var g = kt(n) || "Component";
          F_[g] || (u('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', g, d), F_[g] = !0);
        }
        if (c._owner) {
          var x = c._owner, w;
          if (x) {
            var R = x;
            if (R.tag !== v)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            w = R.stateNode;
          }
          if (!w)
            throw new Error("Missing owner for string ref " + d + ". This error is likely caused by a bug in React. Please file an issue.");
          var k = w;
          ln(d, "ref");
          var L = "" + d;
          if (r !== null && r.ref !== null && typeof r.ref == "function" && r.ref._stringRef === L)
            return r.ref;
          var z = function(W) {
            var I = k.refs;
            W === null ? delete I[L] : I[L] = W;
          };
          return z._stringRef = L, z;
        } else {
          if (typeof d != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!c._owner)
            throw new Error("Element ref was specified as a string (" + d + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return d;
    }
    function k0(n, r) {
      var c = Object.prototype.toString.call(r);
      throw new Error("Objects are not valid as a React child (found: " + (c === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : c) + "). If you meant to render a collection of children, use an array instead.");
    }
    function M0(n) {
      {
        var r = kt(n) || "Component";
        if (j_[r])
          return;
        j_[r] = !0, u("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function kR(n) {
      var r = n._payload, c = n._init;
      return c(r);
    }
    function MR(n) {
      function r(Q, ue) {
        if (n) {
          var q = Q.deletions;
          q === null ? (Q.deletions = [ue], Q.flags |= ia) : q.push(ue);
        }
      }
      function c(Q, ue) {
        if (!n)
          return null;
        for (var q = ue; q !== null; )
          r(Q, q), q = q.sibling;
        return null;
      }
      function d(Q, ue) {
        for (var q = /* @__PURE__ */ new Map(), Re = ue; Re !== null; )
          Re.key !== null ? q.set(Re.key, Re) : q.set(Re.index, Re), Re = Re.sibling;
        return q;
      }
      function g(Q, ue) {
        var q = Rf(Q, ue);
        return q.index = 0, q.sibling = null, q;
      }
      function x(Q, ue, q) {
        if (Q.index = q, !n)
          return Q.flags |= Qa, ue;
        var Re = Q.alternate;
        if (Re !== null) {
          var Ke = Re.index;
          return Ke < ue ? (Q.flags |= qn, ue) : Ke;
        } else
          return Q.flags |= qn, ue;
      }
      function w(Q) {
        return n && Q.alternate === null && (Q.flags |= qn), Q;
      }
      function R(Q, ue, q, Re) {
        if (ue === null || ue.tag !== D) {
          var Ke = Lw(q, Q.mode, Re);
          return Ke.return = Q, Ke;
        } else {
          var $e = g(ue, q);
          return $e.return = Q, $e;
        }
      }
      function k(Q, ue, q, Re) {
        var Ke = q.type;
        if (Ke === wa)
          return z(Q, ue, q.props.children, Re, q.key);
        if (ue !== null && (ue.elementType === Ke || // Keep this check inline so it only runs on the false path:
        Nk(ue, q) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Ke == "object" && Ke !== null && Ke.$$typeof === wt && kR(Ke) === ue.type)) {
          var $e = g(ue, q.props);
          return $e.ref = ng(Q, ue, q), $e.return = Q, $e._debugSource = q._source, $e._debugOwner = q._owner, $e;
        }
        var vt = Pw(q, Q.mode, Re);
        return vt.ref = ng(Q, ue, q), vt.return = Q, vt;
      }
      function L(Q, ue, q, Re) {
        if (ue === null || ue.tag !== C || ue.stateNode.containerInfo !== q.containerInfo || ue.stateNode.implementation !== q.implementation) {
          var Ke = Nw(q, Q.mode, Re);
          return Ke.return = Q, Ke;
        } else {
          var $e = g(ue, q.children || []);
          return $e.return = Q, $e;
        }
      }
      function z(Q, ue, q, Re, Ke) {
        if (ue === null || ue.tag !== M) {
          var $e = Iu(q, Q.mode, Re, Ke);
          return $e.return = Q, $e;
        } else {
          var vt = g(ue, q);
          return vt.return = Q, vt;
        }
      }
      function W(Q, ue, q) {
        if (typeof ue == "string" && ue !== "" || typeof ue == "number") {
          var Re = Lw("" + ue, Q.mode, q);
          return Re.return = Q, Re;
        }
        if (typeof ue == "object" && ue !== null) {
          switch (ue.$$typeof) {
            case yn: {
              var Ke = Pw(ue, Q.mode, q);
              return Ke.ref = ng(Q, null, ue), Ke.return = Q, Ke;
            }
            case $n: {
              var $e = Nw(ue, Q.mode, q);
              return $e.return = Q, $e;
            }
            case wt: {
              var vt = ue._payload, Tt = ue._init;
              return W(Q, Tt(vt), q);
            }
          }
          if (Pi(ue) || Ot(ue)) {
            var vn = Iu(ue, Q.mode, q, null);
            return vn.return = Q, vn;
          }
          k0(Q, ue);
        }
        return typeof ue == "function" && M0(Q), null;
      }
      function I(Q, ue, q, Re) {
        var Ke = ue !== null ? ue.key : null;
        if (typeof q == "string" && q !== "" || typeof q == "number")
          return Ke !== null ? null : R(Q, ue, "" + q, Re);
        if (typeof q == "object" && q !== null) {
          switch (q.$$typeof) {
            case yn:
              return q.key === Ke ? k(Q, ue, q, Re) : null;
            case $n:
              return q.key === Ke ? L(Q, ue, q, Re) : null;
            case wt: {
              var $e = q._payload, vt = q._init;
              return I(Q, ue, vt($e), Re);
            }
          }
          if (Pi(q) || Ot(q))
            return Ke !== null ? null : z(Q, ue, q, Re, null);
          k0(Q, q);
        }
        return typeof q == "function" && M0(Q), null;
      }
      function J(Q, ue, q, Re, Ke) {
        if (typeof Re == "string" && Re !== "" || typeof Re == "number") {
          var $e = Q.get(q) || null;
          return R(ue, $e, "" + Re, Ke);
        }
        if (typeof Re == "object" && Re !== null) {
          switch (Re.$$typeof) {
            case yn: {
              var vt = Q.get(Re.key === null ? q : Re.key) || null;
              return k(ue, vt, Re, Ke);
            }
            case $n: {
              var Tt = Q.get(Re.key === null ? q : Re.key) || null;
              return L(ue, Tt, Re, Ke);
            }
            case wt:
              var vn = Re._payload, rn = Re._init;
              return J(Q, ue, q, rn(vn), Ke);
          }
          if (Pi(Re) || Ot(Re)) {
            var Si = Q.get(q) || null;
            return z(ue, Si, Re, Ke, null);
          }
          k0(ue, Re);
        }
        return typeof Re == "function" && M0(ue), null;
      }
      function ne(Q, ue, q) {
        {
          if (typeof Q != "object" || Q === null)
            return ue;
          switch (Q.$$typeof) {
            case yn:
            case $n:
              DR(Q, q);
              var Re = Q.key;
              if (typeof Re != "string")
                break;
              if (ue === null) {
                ue = /* @__PURE__ */ new Set(), ue.add(Re);
                break;
              }
              if (!ue.has(Re)) {
                ue.add(Re);
                break;
              }
              u("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Re);
              break;
            case wt:
              var Ke = Q._payload, $e = Q._init;
              ne($e(Ke), ue, q);
              break;
          }
        }
        return ue;
      }
      function le(Q, ue, q, Re) {
        for (var Ke = null, $e = 0; $e < q.length; $e++) {
          var vt = q[$e];
          Ke = ne(vt, Ke, Q);
        }
        for (var Tt = null, vn = null, rn = ue, Si = 0, an = 0, mi = null; rn !== null && an < q.length; an++) {
          rn.index > an ? (mi = rn, rn = null) : mi = rn.sibling;
          var Pr = I(Q, rn, q[an], Re);
          if (Pr === null) {
            rn === null && (rn = mi);
            break;
          }
          n && rn && Pr.alternate === null && r(Q, rn), Si = x(Pr, Si, an), vn === null ? Tt = Pr : vn.sibling = Pr, vn = Pr, rn = mi;
        }
        if (an === q.length) {
          if (c(Q, rn), or()) {
            var pr = an;
            pf(Q, pr);
          }
          return Tt;
        }
        if (rn === null) {
          for (; an < q.length; an++) {
            var Va = W(Q, q[an], Re);
            Va !== null && (Si = x(Va, Si, an), vn === null ? Tt = Va : vn.sibling = Va, vn = Va);
          }
          if (or()) {
            var qr = an;
            pf(Q, qr);
          }
          return Tt;
        }
        for (var Zr = d(Q, rn); an < q.length; an++) {
          var Lr = J(Zr, Q, an, q[an], Re);
          Lr !== null && (n && Lr.alternate !== null && Zr.delete(Lr.key === null ? an : Lr.key), Si = x(Lr, Si, an), vn === null ? Tt = Lr : vn.sibling = Lr, vn = Lr);
        }
        if (n && Zr.forEach(function(Ih) {
          return r(Q, Ih);
        }), or()) {
          var Nl = an;
          pf(Q, Nl);
        }
        return Tt;
      }
      function Ie(Q, ue, q, Re) {
        var Ke = Ot(q);
        if (typeof Ke != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          q[Symbol.toStringTag] === "Generator" && (z_ || u("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), z_ = !0), q.entries === Ke && (N_ || u("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), N_ = !0);
          var $e = Ke.call(q);
          if ($e)
            for (var vt = null, Tt = $e.next(); !Tt.done; Tt = $e.next()) {
              var vn = Tt.value;
              vt = ne(vn, vt, Q);
            }
        }
        var rn = Ke.call(q);
        if (rn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Si = null, an = null, mi = ue, Pr = 0, pr = 0, Va = null, qr = rn.next(); mi !== null && !qr.done; pr++, qr = rn.next()) {
          mi.index > pr ? (Va = mi, mi = null) : Va = mi.sibling;
          var Zr = I(Q, mi, qr.value, Re);
          if (Zr === null) {
            mi === null && (mi = Va);
            break;
          }
          n && mi && Zr.alternate === null && r(Q, mi), Pr = x(Zr, Pr, pr), an === null ? Si = Zr : an.sibling = Zr, an = Zr, mi = Va;
        }
        if (qr.done) {
          if (c(Q, mi), or()) {
            var Lr = pr;
            pf(Q, Lr);
          }
          return Si;
        }
        if (mi === null) {
          for (; !qr.done; pr++, qr = rn.next()) {
            var Nl = W(Q, qr.value, Re);
            Nl !== null && (Pr = x(Nl, Pr, pr), an === null ? Si = Nl : an.sibling = Nl, an = Nl);
          }
          if (or()) {
            var Ih = pr;
            pf(Q, Ih);
          }
          return Si;
        }
        for (var Lg = d(Q, mi); !qr.done; pr++, qr = rn.next()) {
          var Mo = J(Lg, Q, pr, qr.value, Re);
          Mo !== null && (n && Mo.alternate !== null && Lg.delete(Mo.key === null ? pr : Mo.key), Pr = x(Mo, Pr, pr), an === null ? Si = Mo : an.sibling = Mo, an = Mo);
        }
        if (n && Lg.forEach(function(_U) {
          return r(Q, _U);
        }), or()) {
          var SU = pr;
          pf(Q, SU);
        }
        return Si;
      }
      function ut(Q, ue, q, Re) {
        if (ue !== null && ue.tag === D) {
          c(Q, ue.sibling);
          var Ke = g(ue, q);
          return Ke.return = Q, Ke;
        }
        c(Q, ue);
        var $e = Lw(q, Q.mode, Re);
        return $e.return = Q, $e;
      }
      function it(Q, ue, q, Re) {
        for (var Ke = q.key, $e = ue; $e !== null; ) {
          if ($e.key === Ke) {
            var vt = q.type;
            if (vt === wa) {
              if ($e.tag === M) {
                c(Q, $e.sibling);
                var Tt = g($e, q.props.children);
                return Tt.return = Q, Tt._debugSource = q._source, Tt._debugOwner = q._owner, Tt;
              }
            } else if ($e.elementType === vt || // Keep this check inline so it only runs on the false path:
            Nk($e, q) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof vt == "object" && vt !== null && vt.$$typeof === wt && kR(vt) === $e.type) {
              c(Q, $e.sibling);
              var vn = g($e, q.props);
              return vn.ref = ng(Q, $e, q), vn.return = Q, vn._debugSource = q._source, vn._debugOwner = q._owner, vn;
            }
            c(Q, $e);
            break;
          } else
            r(Q, $e);
          $e = $e.sibling;
        }
        if (q.type === wa) {
          var rn = Iu(q.props.children, Q.mode, Re, q.key);
          return rn.return = Q, rn;
        } else {
          var Si = Pw(q, Q.mode, Re);
          return Si.ref = ng(Q, ue, q), Si.return = Q, Si;
        }
      }
      function $t(Q, ue, q, Re) {
        for (var Ke = q.key, $e = ue; $e !== null; ) {
          if ($e.key === Ke)
            if ($e.tag === C && $e.stateNode.containerInfo === q.containerInfo && $e.stateNode.implementation === q.implementation) {
              c(Q, $e.sibling);
              var vt = g($e, q.children || []);
              return vt.return = Q, vt;
            } else {
              c(Q, $e);
              break;
            }
          else
            r(Q, $e);
          $e = $e.sibling;
        }
        var Tt = Nw(q, Q.mode, Re);
        return Tt.return = Q, Tt;
      }
      function jt(Q, ue, q, Re) {
        var Ke = typeof q == "object" && q !== null && q.type === wa && q.key === null;
        if (Ke && (q = q.props.children), typeof q == "object" && q !== null) {
          switch (q.$$typeof) {
            case yn:
              return w(it(Q, ue, q, Re));
            case $n:
              return w($t(Q, ue, q, Re));
            case wt:
              var $e = q._payload, vt = q._init;
              return jt(Q, ue, vt($e), Re);
          }
          if (Pi(q))
            return le(Q, ue, q, Re);
          if (Ot(q))
            return Ie(Q, ue, q, Re);
          k0(Q, q);
        }
        return typeof q == "string" && q !== "" || typeof q == "number" ? w(ut(Q, ue, "" + q, Re)) : (typeof q == "function" && M0(Q), c(Q, ue));
      }
      return jt;
    }
    var Th = MR(!0), AR = MR(!1);
    function qV(n, r) {
      if (n !== null && r.child !== n.child)
        throw new Error("Resuming work not yet implemented.");
      if (r.child !== null) {
        var c = r.child, d = Rf(c, c.pendingProps);
        for (r.child = d, d.return = r; c.sibling !== null; )
          c = c.sibling, d = d.sibling = Rf(c, c.pendingProps), d.return = r;
        d.sibling = null;
      }
    }
    function ZV(n, r) {
      for (var c = n.child; c !== null; )
        jH(c, r), c = c.sibling;
    }
    var B_ = ku(null), H_;
    H_ = {};
    var A0 = null, Eh = null, U_ = null, O0 = !1;
    function P0() {
      A0 = null, Eh = null, U_ = null, O0 = !1;
    }
    function OR() {
      O0 = !0;
    }
    function PR() {
      O0 = !1;
    }
    function LR(n, r, c) {
      Ar(B_, r._currentValue, n), r._currentValue = c, r._currentRenderer !== void 0 && r._currentRenderer !== null && r._currentRenderer !== H_ && u("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), r._currentRenderer = H_;
    }
    function I_(n, r) {
      var c = B_.current;
      Mr(B_, r), n._currentValue = c;
    }
    function $_(n, r, c) {
      for (var d = n; d !== null; ) {
        var g = d.alternate;
        if (vl(d.childLanes, r) ? g !== null && !vl(g.childLanes, r) && (g.childLanes = Mt(g.childLanes, r)) : (d.childLanes = Mt(d.childLanes, r), g !== null && (g.childLanes = Mt(g.childLanes, r))), d === c)
          break;
        d = d.return;
      }
      d !== c && u("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function JV(n, r, c) {
      ej(n, r, c);
    }
    function ej(n, r, c) {
      var d = n.child;
      for (d !== null && (d.return = n); d !== null; ) {
        var g = void 0, x = d.dependencies;
        if (x !== null) {
          g = d.child;
          for (var w = x.firstContext; w !== null; ) {
            if (w.context === r) {
              if (d.tag === v) {
                var R = $c(c), k = kl(bn, R);
                k.tag = N0;
                var L = d.updateQueue;
                if (L !== null) {
                  var z = L.shared, W = z.pending;
                  W === null ? k.next = k : (k.next = W.next, W.next = k), z.pending = k;
                }
              }
              d.lanes = Mt(d.lanes, c);
              var I = d.alternate;
              I !== null && (I.lanes = Mt(I.lanes, c)), $_(d.return, c, n), x.lanes = Mt(x.lanes, c);
              break;
            }
            w = w.next;
          }
        } else if (d.tag === N)
          g = d.type === n.type ? null : d.child;
        else if (d.tag === ie) {
          var J = d.return;
          if (J === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          J.lanes = Mt(J.lanes, c);
          var ne = J.alternate;
          ne !== null && (ne.lanes = Mt(ne.lanes, c)), $_(J, c, n), g = d.sibling;
        } else
          g = d.child;
        if (g !== null)
          g.return = d;
        else
          for (g = d; g !== null; ) {
            if (g === n) {
              g = null;
              break;
            }
            var le = g.sibling;
            if (le !== null) {
              le.return = g.return, g = le;
              break;
            }
            g = g.return;
          }
        d = g;
      }
    }
    function Rh(n, r) {
      A0 = n, Eh = null, U_ = null;
      var c = n.dependencies;
      if (c !== null) {
        var d = c.firstContext;
        d !== null && (Er(c.lanes, r) && vg(), c.firstContext = null);
      }
    }
    function Di(n) {
      O0 && u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var r = n._currentValue;
      if (U_ !== n) {
        var c = {
          context: n,
          memoizedValue: r,
          next: null
        };
        if (Eh === null) {
          if (A0 === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Eh = c, A0.dependencies = {
            lanes: be,
            firstContext: c
          };
        } else
          Eh = Eh.next = c;
      }
      return r;
    }
    var bf = null;
    function W_(n) {
      bf === null ? bf = [n] : bf.push(n);
    }
    function tj() {
      if (bf !== null) {
        for (var n = 0; n < bf.length; n++) {
          var r = bf[n], c = r.interleaved;
          if (c !== null) {
            r.interleaved = null;
            var d = c.next, g = r.pending;
            if (g !== null) {
              var x = g.next;
              g.next = d, c.next = x;
            }
            r.pending = c;
          }
        }
        bf = null;
      }
    }
    function NR(n, r, c, d) {
      var g = r.interleaved;
      return g === null ? (c.next = c, W_(r)) : (c.next = g.next, g.next = c), r.interleaved = c, L0(n, d);
    }
    function nj(n, r, c, d) {
      var g = r.interleaved;
      g === null ? (c.next = c, W_(r)) : (c.next = g.next, g.next = c), r.interleaved = c;
    }
    function ij(n, r, c, d) {
      var g = r.interleaved;
      return g === null ? (c.next = c, W_(r)) : (c.next = g.next, g.next = c), r.interleaved = c, L0(n, d);
    }
    function ha(n, r) {
      return L0(n, r);
    }
    var rj = L0;
    function L0(n, r) {
      n.lanes = Mt(n.lanes, r);
      var c = n.alternate;
      c !== null && (c.lanes = Mt(c.lanes, r)), c === null && (n.flags & (qn | ra)) !== at && Ak(n);
      for (var d = n, g = n.return; g !== null; )
        g.childLanes = Mt(g.childLanes, r), c = g.alternate, c !== null ? c.childLanes = Mt(c.childLanes, r) : (g.flags & (qn | ra)) !== at && Ak(n), d = g, g = g.return;
      if (d.tag === S) {
        var x = d.stateNode;
        return x;
      } else
        return null;
    }
    var zR = 0, FR = 1, N0 = 2, Y_ = 3, z0 = !1, G_, F0;
    G_ = !1, F0 = null;
    function K_(n) {
      var r = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: be
        },
        effects: null
      };
      n.updateQueue = r;
    }
    function VR(n, r) {
      var c = r.updateQueue, d = n.updateQueue;
      if (c === d) {
        var g = {
          baseState: d.baseState,
          firstBaseUpdate: d.firstBaseUpdate,
          lastBaseUpdate: d.lastBaseUpdate,
          shared: d.shared,
          effects: d.effects
        };
        r.updateQueue = g;
      }
    }
    function kl(n, r) {
      var c = {
        eventTime: n,
        lane: r,
        tag: zR,
        payload: null,
        callback: null,
        next: null
      };
      return c;
    }
    function Pu(n, r, c) {
      var d = n.updateQueue;
      if (d === null)
        return null;
      var g = d.shared;
      if (F0 === g && !G_ && (u("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), G_ = !0), nH()) {
        var x = g.pending;
        return x === null ? r.next = r : (r.next = x.next, x.next = r), g.pending = r, rj(n, c);
      } else
        return ij(n, g, r, c);
    }
    function V0(n, r, c) {
      var d = r.updateQueue;
      if (d !== null) {
        var g = d.shared;
        if (mm(c)) {
          var x = g.lanes;
          x = vm(x, n.pendingLanes);
          var w = Mt(x, c);
          g.lanes = w, Jd(n, w);
        }
      }
    }
    function X_(n, r) {
      var c = n.updateQueue, d = n.alternate;
      if (d !== null) {
        var g = d.updateQueue;
        if (c === g) {
          var x = null, w = null, R = c.firstBaseUpdate;
          if (R !== null) {
            var k = R;
            do {
              var L = {
                eventTime: k.eventTime,
                lane: k.lane,
                tag: k.tag,
                payload: k.payload,
                callback: k.callback,
                next: null
              };
              w === null ? x = w = L : (w.next = L, w = L), k = k.next;
            } while (k !== null);
            w === null ? x = w = r : (w.next = r, w = r);
          } else
            x = w = r;
          c = {
            baseState: g.baseState,
            firstBaseUpdate: x,
            lastBaseUpdate: w,
            shared: g.shared,
            effects: g.effects
          }, n.updateQueue = c;
          return;
        }
      }
      var z = c.lastBaseUpdate;
      z === null ? c.firstBaseUpdate = r : z.next = r, c.lastBaseUpdate = r;
    }
    function aj(n, r, c, d, g, x) {
      switch (c.tag) {
        case FR: {
          var w = c.payload;
          if (typeof w == "function") {
            OR();
            var R = w.call(x, d, g);
            {
              if (n.mode & mn) {
                Fn(!0);
                try {
                  w.call(x, d, g);
                } finally {
                  Fn(!1);
                }
              }
              PR();
            }
            return R;
          }
          return w;
        }
        case Y_:
          n.flags = n.flags & -65537 | rt;
        // Intentional fallthrough
        case zR: {
          var k = c.payload, L;
          if (typeof k == "function") {
            OR(), L = k.call(x, d, g);
            {
              if (n.mode & mn) {
                Fn(!0);
                try {
                  k.call(x, d, g);
                } finally {
                  Fn(!1);
                }
              }
              PR();
            }
          } else
            L = k;
          return L == null ? d : Lt({}, d, L);
        }
        case N0:
          return z0 = !0, d;
      }
      return d;
    }
    function j0(n, r, c, d) {
      var g = n.updateQueue;
      z0 = !1, F0 = g.shared;
      var x = g.firstBaseUpdate, w = g.lastBaseUpdate, R = g.shared.pending;
      if (R !== null) {
        g.shared.pending = null;
        var k = R, L = k.next;
        k.next = null, w === null ? x = L : w.next = L, w = k;
        var z = n.alternate;
        if (z !== null) {
          var W = z.updateQueue, I = W.lastBaseUpdate;
          I !== w && (I === null ? W.firstBaseUpdate = L : I.next = L, W.lastBaseUpdate = k);
        }
      }
      if (x !== null) {
        var J = g.baseState, ne = be, le = null, Ie = null, ut = null, it = x;
        do {
          var $t = it.lane, jt = it.eventTime;
          if (vl(d, $t)) {
            if (ut !== null) {
              var ue = {
                eventTime: jt,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Zt,
                tag: it.tag,
                payload: it.payload,
                callback: it.callback,
                next: null
              };
              ut = ut.next = ue;
            }
            J = aj(n, g, it, J, r, c);
            var q = it.callback;
            if (q !== null && // If the update was already committed, we should not queue its
            // callback again.
            it.lane !== Zt) {
              n.flags |= Cn;
              var Re = g.effects;
              Re === null ? g.effects = [it] : Re.push(it);
            }
          } else {
            var Q = {
              eventTime: jt,
              lane: $t,
              tag: it.tag,
              payload: it.payload,
              callback: it.callback,
              next: null
            };
            ut === null ? (Ie = ut = Q, le = J) : ut = ut.next = Q, ne = Mt(ne, $t);
          }
          if (it = it.next, it === null) {
            if (R = g.shared.pending, R === null)
              break;
            var Ke = R, $e = Ke.next;
            Ke.next = null, it = $e, g.lastBaseUpdate = Ke, g.shared.pending = null;
          }
        } while (!0);
        ut === null && (le = J), g.baseState = le, g.firstBaseUpdate = Ie, g.lastBaseUpdate = ut;
        var vt = g.shared.interleaved;
        if (vt !== null) {
          var Tt = vt;
          do
            ne = Mt(ne, Tt.lane), Tt = Tt.next;
          while (Tt !== vt);
        } else x === null && (g.shared.lanes = be);
        kg(ne), n.lanes = ne, n.memoizedState = J;
      }
      F0 = null;
    }
    function sj(n, r) {
      if (typeof n != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + n));
      n.call(r);
    }
    function jR() {
      z0 = !1;
    }
    function B0() {
      return z0;
    }
    function BR(n, r, c) {
      var d = r.effects;
      if (r.effects = null, d !== null)
        for (var g = 0; g < d.length; g++) {
          var x = d[g], w = x.callback;
          w !== null && (x.callback = null, sj(w, c));
        }
    }
    var ig = {}, Lu = ku(ig), rg = ku(ig), H0 = ku(ig);
    function U0(n) {
      if (n === ig)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return n;
    }
    function HR() {
      var n = U0(H0.current);
      return n;
    }
    function Q_(n, r) {
      Ar(H0, r, n), Ar(rg, n, n), Ar(Lu, ig, n);
      var c = CF(r);
      Mr(Lu, n), Ar(Lu, c, n);
    }
    function Dh(n) {
      Mr(Lu, n), Mr(rg, n), Mr(H0, n);
    }
    function q_() {
      var n = U0(Lu.current);
      return n;
    }
    function UR(n) {
      U0(H0.current);
      var r = U0(Lu.current), c = wF(r, n.type);
      r !== c && (Ar(rg, n, n), Ar(Lu, c, n));
    }
    function Z_(n) {
      rg.current === n && (Mr(Lu, n), Mr(rg, n));
    }
    var oj = 0, IR = 1, $R = 1, ag = 2, js = ku(oj);
    function J_(n, r) {
      return (n & r) !== 0;
    }
    function kh(n) {
      return n & IR;
    }
    function eC(n, r) {
      return n & IR | r;
    }
    function lj(n, r) {
      return n | r;
    }
    function Nu(n, r) {
      Ar(js, r, n);
    }
    function Mh(n) {
      Mr(js, n);
    }
    function uj(n, r) {
      var c = n.memoizedState;
      return c !== null ? c.dehydrated !== null : (n.memoizedProps, !0);
    }
    function I0(n) {
      for (var r = n; r !== null; ) {
        if (r.tag === V) {
          var c = r.memoizedState;
          if (c !== null) {
            var d = c.dehydrated;
            if (d === null || oR(d) || y_(d))
              return r;
          }
        } else if (r.tag === ee && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        r.memoizedProps.revealOrder !== void 0) {
          var g = (r.flags & rt) !== at;
          if (g)
            return r;
        } else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === n)
          return null;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === n)
            return null;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return null;
    }
    var pa = (
      /*   */
      0
    ), Vi = (
      /* */
      1
    ), Co = (
      /*  */
      2
    ), ji = (
      /*    */
      4
    ), lr = (
      /*   */
      8
    ), tC = [];
    function nC() {
      for (var n = 0; n < tC.length; n++) {
        var r = tC[n];
        r._workInProgressVersionPrimary = null;
      }
      tC.length = 0;
    }
    function cj(n, r) {
      var c = r._getVersion, d = c(r._source);
      n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [r, d] : n.mutableSourceEagerHydrationData.push(r, d);
    }
    var Ye = i.ReactCurrentDispatcher, sg = i.ReactCurrentBatchConfig, iC, Ah;
    iC = /* @__PURE__ */ new Set();
    var xf = be, gn = null, Bi = null, Hi = null, $0 = !1, og = !1, lg = 0, fj = 0, dj = 25, he = null, us = null, zu = -1, rC = !1;
    function cn() {
      {
        var n = he;
        us === null ? us = [n] : us.push(n);
      }
    }
    function je() {
      {
        var n = he;
        us !== null && (zu++, us[zu] !== n && hj(n));
      }
    }
    function Oh(n) {
      n != null && !Pi(n) && u("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", he, typeof n);
    }
    function hj(n) {
      {
        var r = kt(gn);
        if (!iC.has(r) && (iC.add(r), us !== null)) {
          for (var c = "", d = 30, g = 0; g <= zu; g++) {
            for (var x = us[g], w = g === zu ? n : x, R = g + 1 + ". " + x; R.length < d; )
              R += " ";
            R += w + `
`, c += R;
          }
          u(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, r, c);
        }
      }
    }
    function Or() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function aC(n, r) {
      if (rC)
        return !1;
      if (r === null)
        return u("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", he), !1;
      n.length !== r.length && u(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, he, "[" + r.join(", ") + "]", "[" + n.join(", ") + "]");
      for (var c = 0; c < r.length && c < n.length; c++)
        if (!Ce(n[c], r[c]))
          return !1;
      return !0;
    }
    function Ph(n, r, c, d, g, x) {
      xf = x, gn = r, us = n !== null ? n._debugHookTypes : null, zu = -1, rC = n !== null && n.type !== r.type, r.memoizedState = null, r.updateQueue = null, r.lanes = be, n !== null && n.memoizedState !== null ? Ye.current = dD : us !== null ? Ye.current = fD : Ye.current = cD;
      var w = c(d, g);
      if (og) {
        var R = 0;
        do {
          if (og = !1, lg = 0, R >= dj)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          R += 1, rC = !1, Bi = null, Hi = null, r.updateQueue = null, zu = -1, Ye.current = hD, w = c(d, g);
        } while (og);
      }
      Ye.current = ib, r._debugHookTypes = us;
      var k = Bi !== null && Bi.next !== null;
      if (xf = be, gn = null, Bi = null, Hi = null, he = null, us = null, zu = -1, n !== null && (n.flags & ui) !== (r.flags & ui) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (n.mode & Nt) !== st && u("Internal React error: Expected static flag was missing. Please notify the React team."), $0 = !1, k)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return w;
    }
    function Lh() {
      var n = lg !== 0;
      return lg = 0, n;
    }
    function WR(n, r, c) {
      r.updateQueue = n.updateQueue, (r.mode & tn) !== st ? r.flags &= -50333701 : r.flags &= -2053, n.lanes = Wc(n.lanes, c);
    }
    function YR() {
      if (Ye.current = ib, $0) {
        for (var n = gn.memoizedState; n !== null; ) {
          var r = n.queue;
          r !== null && (r.pending = null), n = n.next;
        }
        $0 = !1;
      }
      xf = be, gn = null, Bi = null, Hi = null, us = null, zu = -1, he = null, aD = !1, og = !1, lg = 0;
    }
    function wo() {
      var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Hi === null ? gn.memoizedState = Hi = n : Hi = Hi.next = n, Hi;
    }
    function cs() {
      var n;
      if (Bi === null) {
        var r = gn.alternate;
        r !== null ? n = r.memoizedState : n = null;
      } else
        n = Bi.next;
      var c;
      if (Hi === null ? c = gn.memoizedState : c = Hi.next, c !== null)
        Hi = c, c = Hi.next, Bi = n;
      else {
        if (n === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Bi = n;
        var d = {
          memoizedState: Bi.memoizedState,
          baseState: Bi.baseState,
          baseQueue: Bi.baseQueue,
          queue: Bi.queue,
          next: null
        };
        Hi === null ? gn.memoizedState = Hi = d : Hi = Hi.next = d;
      }
      return Hi;
    }
    function GR() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function sC(n, r) {
      return typeof r == "function" ? r(n) : r;
    }
    function oC(n, r, c) {
      var d = wo(), g;
      c !== void 0 ? g = c(r) : g = r, d.memoizedState = d.baseState = g;
      var x = {
        pending: null,
        interleaved: null,
        lanes: be,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: g
      };
      d.queue = x;
      var w = x.dispatch = vj.bind(null, gn, x);
      return [d.memoizedState, w];
    }
    function lC(n, r, c) {
      var d = cs(), g = d.queue;
      if (g === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      g.lastRenderedReducer = n;
      var x = Bi, w = x.baseQueue, R = g.pending;
      if (R !== null) {
        if (w !== null) {
          var k = w.next, L = R.next;
          w.next = L, R.next = k;
        }
        x.baseQueue !== w && u("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), x.baseQueue = w = R, g.pending = null;
      }
      if (w !== null) {
        var z = w.next, W = x.baseState, I = null, J = null, ne = null, le = z;
        do {
          var Ie = le.lane;
          if (vl(xf, Ie)) {
            if (ne !== null) {
              var it = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Zt,
                action: le.action,
                hasEagerState: le.hasEagerState,
                eagerState: le.eagerState,
                next: null
              };
              ne = ne.next = it;
            }
            if (le.hasEagerState)
              W = le.eagerState;
            else {
              var $t = le.action;
              W = n(W, $t);
            }
          } else {
            var ut = {
              lane: Ie,
              action: le.action,
              hasEagerState: le.hasEagerState,
              eagerState: le.eagerState,
              next: null
            };
            ne === null ? (J = ne = ut, I = W) : ne = ne.next = ut, gn.lanes = Mt(gn.lanes, Ie), kg(Ie);
          }
          le = le.next;
        } while (le !== null && le !== z);
        ne === null ? I = W : ne.next = J, Ce(W, d.memoizedState) || vg(), d.memoizedState = W, d.baseState = I, d.baseQueue = ne, g.lastRenderedState = W;
      }
      var jt = g.interleaved;
      if (jt !== null) {
        var Q = jt;
        do {
          var ue = Q.lane;
          gn.lanes = Mt(gn.lanes, ue), kg(ue), Q = Q.next;
        } while (Q !== jt);
      } else w === null && (g.lanes = be);
      var q = g.dispatch;
      return [d.memoizedState, q];
    }
    function uC(n, r, c) {
      var d = cs(), g = d.queue;
      if (g === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      g.lastRenderedReducer = n;
      var x = g.dispatch, w = g.pending, R = d.memoizedState;
      if (w !== null) {
        g.pending = null;
        var k = w.next, L = k;
        do {
          var z = L.action;
          R = n(R, z), L = L.next;
        } while (L !== k);
        Ce(R, d.memoizedState) || vg(), d.memoizedState = R, d.baseQueue === null && (d.baseState = R), g.lastRenderedState = R;
      }
      return [R, x];
    }
    function eQ(n, r, c) {
    }
    function tQ(n, r, c) {
    }
    function cC(n, r, c) {
      var d = gn, g = wo(), x, w = or();
      if (w) {
        if (c === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        x = c(), Ah || x !== c() && (u("The result of getServerSnapshot should be cached to avoid an infinite loop"), Ah = !0);
      } else {
        if (x = r(), !Ah) {
          var R = r();
          Ce(x, R) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), Ah = !0);
        }
        var k = _b();
        if (k === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        qd(k, xf) || KR(d, r, x);
      }
      g.memoizedState = x;
      var L = {
        value: x,
        getSnapshot: r
      };
      return g.queue = L, X0(QR.bind(null, d, L, n), [n]), d.flags |= Sr, ug(Vi | lr, XR.bind(null, d, L, x, r), void 0, null), x;
    }
    function W0(n, r, c) {
      var d = gn, g = cs(), x = r();
      if (!Ah) {
        var w = r();
        Ce(x, w) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), Ah = !0);
      }
      var R = g.memoizedState, k = !Ce(R, x);
      k && (g.memoizedState = x, vg());
      var L = g.queue;
      if (fg(QR.bind(null, d, L, n), [n]), L.getSnapshot !== r || k || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Hi !== null && Hi.memoizedState.tag & Vi) {
        d.flags |= Sr, ug(Vi | lr, XR.bind(null, d, L, x, r), void 0, null);
        var z = _b();
        if (z === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        qd(z, xf) || KR(d, r, x);
      }
      return x;
    }
    function KR(n, r, c) {
      n.flags |= hu;
      var d = {
        getSnapshot: r,
        value: c
      }, g = gn.updateQueue;
      if (g === null)
        g = GR(), gn.updateQueue = g, g.stores = [d];
      else {
        var x = g.stores;
        x === null ? g.stores = [d] : x.push(d);
      }
    }
    function XR(n, r, c, d) {
      r.value = c, r.getSnapshot = d, qR(r) && ZR(n);
    }
    function QR(n, r, c) {
      var d = function() {
        qR(r) && ZR(n);
      };
      return c(d);
    }
    function qR(n) {
      var r = n.getSnapshot, c = n.value;
      try {
        var d = r();
        return !Ce(c, d);
      } catch {
        return !0;
      }
    }
    function ZR(n) {
      var r = ha(n, mt);
      r !== null && Wi(r, n, mt, bn);
    }
    function Y0(n) {
      var r = wo();
      typeof n == "function" && (n = n()), r.memoizedState = r.baseState = n;
      var c = {
        pending: null,
        interleaved: null,
        lanes: be,
        dispatch: null,
        lastRenderedReducer: sC,
        lastRenderedState: n
      };
      r.queue = c;
      var d = c.dispatch = yj.bind(null, gn, c);
      return [r.memoizedState, d];
    }
    function fC(n) {
      return lC(sC);
    }
    function dC(n) {
      return uC(sC);
    }
    function ug(n, r, c, d) {
      var g = {
        tag: n,
        create: r,
        destroy: c,
        deps: d,
        // Circular
        next: null
      }, x = gn.updateQueue;
      if (x === null)
        x = GR(), gn.updateQueue = x, x.lastEffect = g.next = g;
      else {
        var w = x.lastEffect;
        if (w === null)
          x.lastEffect = g.next = g;
        else {
          var R = w.next;
          w.next = g, g.next = R, x.lastEffect = g;
        }
      }
      return g;
    }
    function hC(n) {
      var r = wo();
      {
        var c = {
          current: n
        };
        return r.memoizedState = c, c;
      }
    }
    function G0(n) {
      var r = cs();
      return r.memoizedState;
    }
    function cg(n, r, c, d) {
      var g = wo(), x = d === void 0 ? null : d;
      gn.flags |= n, g.memoizedState = ug(Vi | r, c, void 0, x);
    }
    function K0(n, r, c, d) {
      var g = cs(), x = d === void 0 ? null : d, w = void 0;
      if (Bi !== null) {
        var R = Bi.memoizedState;
        if (w = R.destroy, x !== null) {
          var k = R.deps;
          if (aC(x, k)) {
            g.memoizedState = ug(r, c, w, x);
            return;
          }
        }
      }
      gn.flags |= n, g.memoizedState = ug(Vi | r, c, w, x);
    }
    function X0(n, r) {
      return (gn.mode & tn) !== st ? cg(qa | Sr | wd, lr, n, r) : cg(Sr | wd, lr, n, r);
    }
    function fg(n, r) {
      return K0(Sr, lr, n, r);
    }
    function pC(n, r) {
      return cg(Ht, Co, n, r);
    }
    function Q0(n, r) {
      return K0(Ht, Co, n, r);
    }
    function mC(n, r) {
      var c = Ht;
      return c |= Rs, (gn.mode & tn) !== st && (c |= ro), cg(c, ji, n, r);
    }
    function q0(n, r) {
      return K0(Ht, ji, n, r);
    }
    function JR(n, r) {
      if (typeof r == "function") {
        var c = r, d = n();
        return c(d), function() {
          c(null);
        };
      } else if (r != null) {
        var g = r;
        g.hasOwnProperty("current") || u("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(g).join(", ") + "}");
        var x = n();
        return g.current = x, function() {
          g.current = null;
        };
      }
    }
    function gC(n, r, c) {
      typeof r != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var d = c != null ? c.concat([n]) : null, g = Ht;
      return g |= Rs, (gn.mode & tn) !== st && (g |= ro), cg(g, ji, JR.bind(null, r, n), d);
    }
    function Z0(n, r, c) {
      typeof r != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var d = c != null ? c.concat([n]) : null;
      return K0(Ht, ji, JR.bind(null, r, n), d);
    }
    function pj(n, r) {
    }
    var J0 = pj;
    function vC(n, r) {
      var c = wo(), d = r === void 0 ? null : r;
      return c.memoizedState = [n, d], n;
    }
    function eb(n, r) {
      var c = cs(), d = r === void 0 ? null : r, g = c.memoizedState;
      if (g !== null && d !== null) {
        var x = g[1];
        if (aC(d, x))
          return g[0];
      }
      return c.memoizedState = [n, d], n;
    }
    function yC(n, r) {
      var c = wo(), d = r === void 0 ? null : r, g = n();
      return c.memoizedState = [g, d], g;
    }
    function tb(n, r) {
      var c = cs(), d = r === void 0 ? null : r, g = c.memoizedState;
      if (g !== null && d !== null) {
        var x = g[1];
        if (aC(d, x))
          return g[0];
      }
      var w = n();
      return c.memoizedState = [w, d], w;
    }
    function bC(n) {
      var r = wo();
      return r.memoizedState = n, n;
    }
    function eD(n) {
      var r = cs(), c = Bi, d = c.memoizedState;
      return nD(r, d, n);
    }
    function tD(n) {
      var r = cs();
      if (Bi === null)
        return r.memoizedState = n, n;
      var c = Bi.memoizedState;
      return nD(r, c, n);
    }
    function nD(n, r, c) {
      var d = !hm(xf);
      if (d) {
        if (!Ce(c, r)) {
          var g = gm();
          gn.lanes = Mt(gn.lanes, g), kg(g), n.baseState = !0;
        }
        return r;
      } else
        return n.baseState && (n.baseState = !1, vg()), n.memoizedState = c, c;
    }
    function mj(n, r, c) {
      var d = ca();
      di(Oy(d, ts)), n(!0);
      var g = sg.transition;
      sg.transition = {};
      var x = sg.transition;
      sg.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        n(!1), r();
      } finally {
        if (di(d), sg.transition = g, g === null && x._updatedFibers) {
          var w = x._updatedFibers.size;
          w > 10 && f("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), x._updatedFibers.clear();
        }
      }
    }
    function xC() {
      var n = Y0(!1), r = n[0], c = n[1], d = mj.bind(null, c), g = wo();
      return g.memoizedState = d, [r, d];
    }
    function iD() {
      var n = fC(), r = n[0], c = cs(), d = c.memoizedState;
      return [r, d];
    }
    function rD() {
      var n = dC(), r = n[0], c = cs(), d = c.memoizedState;
      return [r, d];
    }
    var aD = !1;
    function gj() {
      return aD;
    }
    function SC() {
      var n = wo(), r = _b(), c = r.identifierPrefix, d;
      if (or()) {
        var g = PV();
        d = ":" + c + "R" + g;
        var x = lg++;
        x > 0 && (d += "H" + x.toString(32)), d += ":";
      } else {
        var w = fj++;
        d = ":" + c + "r" + w.toString(32) + ":";
      }
      return n.memoizedState = d, d;
    }
    function nb() {
      var n = cs(), r = n.memoizedState;
      return r;
    }
    function vj(n, r, c) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var d = Hu(n), g = {
        lane: d,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (sD(n))
        oD(r, g);
      else {
        var x = NR(n, r, g, d);
        if (x !== null) {
          var w = Qr();
          Wi(x, n, d, w), lD(x, r, d);
        }
      }
      uD(n, d);
    }
    function yj(n, r, c) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var d = Hu(n), g = {
        lane: d,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (sD(n))
        oD(r, g);
      else {
        var x = n.alternate;
        if (n.lanes === be && (x === null || x.lanes === be)) {
          var w = r.lastRenderedReducer;
          if (w !== null) {
            var R;
            R = Ye.current, Ye.current = Bs;
            try {
              var k = r.lastRenderedState, L = w(k, c);
              if (g.hasEagerState = !0, g.eagerState = L, Ce(L, k)) {
                nj(n, r, g, d);
                return;
              }
            } catch {
            } finally {
              Ye.current = R;
            }
          }
        }
        var z = NR(n, r, g, d);
        if (z !== null) {
          var W = Qr();
          Wi(z, n, d, W), lD(z, r, d);
        }
      }
      uD(n, d);
    }
    function sD(n) {
      var r = n.alternate;
      return n === gn || r !== null && r === gn;
    }
    function oD(n, r) {
      og = $0 = !0;
      var c = n.pending;
      c === null ? r.next = r : (r.next = c.next, c.next = r), n.pending = r;
    }
    function lD(n, r, c) {
      if (mm(c)) {
        var d = r.lanes;
        d = vm(d, n.pendingLanes);
        var g = Mt(d, c);
        r.lanes = g, Jd(n, g);
      }
    }
    function uD(n, r, c) {
      Nc(n, r);
    }
    var ib = {
      readContext: Di,
      useCallback: Or,
      useContext: Or,
      useEffect: Or,
      useImperativeHandle: Or,
      useInsertionEffect: Or,
      useLayoutEffect: Or,
      useMemo: Or,
      useReducer: Or,
      useRef: Or,
      useState: Or,
      useDebugValue: Or,
      useDeferredValue: Or,
      useTransition: Or,
      useMutableSource: Or,
      useSyncExternalStore: Or,
      useId: Or,
      unstable_isNewReconciler: re
    }, cD = null, fD = null, dD = null, hD = null, To = null, Bs = null, rb = null;
    {
      var _C = function() {
        u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, St = function() {
        u("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      cD = {
        readContext: function(n) {
          return Di(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", cn(), Oh(r), vC(n, r);
        },
        useContext: function(n) {
          return he = "useContext", cn(), Di(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", cn(), Oh(r), X0(n, r);
        },
        useImperativeHandle: function(n, r, c) {
          return he = "useImperativeHandle", cn(), Oh(c), gC(n, r, c);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", cn(), Oh(r), pC(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", cn(), Oh(r), mC(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", cn(), Oh(r);
          var c = Ye.current;
          Ye.current = To;
          try {
            return yC(n, r);
          } finally {
            Ye.current = c;
          }
        },
        useReducer: function(n, r, c) {
          he = "useReducer", cn();
          var d = Ye.current;
          Ye.current = To;
          try {
            return oC(n, r, c);
          } finally {
            Ye.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", cn(), hC(n);
        },
        useState: function(n) {
          he = "useState", cn();
          var r = Ye.current;
          Ye.current = To;
          try {
            return Y0(n);
          } finally {
            Ye.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", cn(), void 0;
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", cn(), bC(n);
        },
        useTransition: function() {
          return he = "useTransition", cn(), xC();
        },
        useMutableSource: function(n, r, c) {
          return he = "useMutableSource", cn(), void 0;
        },
        useSyncExternalStore: function(n, r, c) {
          return he = "useSyncExternalStore", cn(), cC(n, r, c);
        },
        useId: function() {
          return he = "useId", cn(), SC();
        },
        unstable_isNewReconciler: re
      }, fD = {
        readContext: function(n) {
          return Di(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", je(), vC(n, r);
        },
        useContext: function(n) {
          return he = "useContext", je(), Di(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", je(), X0(n, r);
        },
        useImperativeHandle: function(n, r, c) {
          return he = "useImperativeHandle", je(), gC(n, r, c);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", je(), pC(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", je(), mC(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", je();
          var c = Ye.current;
          Ye.current = To;
          try {
            return yC(n, r);
          } finally {
            Ye.current = c;
          }
        },
        useReducer: function(n, r, c) {
          he = "useReducer", je();
          var d = Ye.current;
          Ye.current = To;
          try {
            return oC(n, r, c);
          } finally {
            Ye.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", je(), hC(n);
        },
        useState: function(n) {
          he = "useState", je();
          var r = Ye.current;
          Ye.current = To;
          try {
            return Y0(n);
          } finally {
            Ye.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", je(), void 0;
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", je(), bC(n);
        },
        useTransition: function() {
          return he = "useTransition", je(), xC();
        },
        useMutableSource: function(n, r, c) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(n, r, c) {
          return he = "useSyncExternalStore", je(), cC(n, r, c);
        },
        useId: function() {
          return he = "useId", je(), SC();
        },
        unstable_isNewReconciler: re
      }, dD = {
        readContext: function(n) {
          return Di(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", je(), eb(n, r);
        },
        useContext: function(n) {
          return he = "useContext", je(), Di(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", je(), fg(n, r);
        },
        useImperativeHandle: function(n, r, c) {
          return he = "useImperativeHandle", je(), Z0(n, r, c);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", je(), Q0(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", je(), q0(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", je();
          var c = Ye.current;
          Ye.current = Bs;
          try {
            return tb(n, r);
          } finally {
            Ye.current = c;
          }
        },
        useReducer: function(n, r, c) {
          he = "useReducer", je();
          var d = Ye.current;
          Ye.current = Bs;
          try {
            return lC(n, r, c);
          } finally {
            Ye.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", je(), G0();
        },
        useState: function(n) {
          he = "useState", je();
          var r = Ye.current;
          Ye.current = Bs;
          try {
            return fC(n);
          } finally {
            Ye.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", je(), J0();
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", je(), eD(n);
        },
        useTransition: function() {
          return he = "useTransition", je(), iD();
        },
        useMutableSource: function(n, r, c) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(n, r, c) {
          return he = "useSyncExternalStore", je(), W0(n, r);
        },
        useId: function() {
          return he = "useId", je(), nb();
        },
        unstable_isNewReconciler: re
      }, hD = {
        readContext: function(n) {
          return Di(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", je(), eb(n, r);
        },
        useContext: function(n) {
          return he = "useContext", je(), Di(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", je(), fg(n, r);
        },
        useImperativeHandle: function(n, r, c) {
          return he = "useImperativeHandle", je(), Z0(n, r, c);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", je(), Q0(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", je(), q0(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", je();
          var c = Ye.current;
          Ye.current = rb;
          try {
            return tb(n, r);
          } finally {
            Ye.current = c;
          }
        },
        useReducer: function(n, r, c) {
          he = "useReducer", je();
          var d = Ye.current;
          Ye.current = rb;
          try {
            return uC(n, r, c);
          } finally {
            Ye.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", je(), G0();
        },
        useState: function(n) {
          he = "useState", je();
          var r = Ye.current;
          Ye.current = rb;
          try {
            return dC(n);
          } finally {
            Ye.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", je(), J0();
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", je(), tD(n);
        },
        useTransition: function() {
          return he = "useTransition", je(), rD();
        },
        useMutableSource: function(n, r, c) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(n, r, c) {
          return he = "useSyncExternalStore", je(), W0(n, r);
        },
        useId: function() {
          return he = "useId", je(), nb();
        },
        unstable_isNewReconciler: re
      }, To = {
        readContext: function(n) {
          return _C(), Di(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", St(), cn(), vC(n, r);
        },
        useContext: function(n) {
          return he = "useContext", St(), cn(), Di(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", St(), cn(), X0(n, r);
        },
        useImperativeHandle: function(n, r, c) {
          return he = "useImperativeHandle", St(), cn(), gC(n, r, c);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", St(), cn(), pC(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", St(), cn(), mC(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", St(), cn();
          var c = Ye.current;
          Ye.current = To;
          try {
            return yC(n, r);
          } finally {
            Ye.current = c;
          }
        },
        useReducer: function(n, r, c) {
          he = "useReducer", St(), cn();
          var d = Ye.current;
          Ye.current = To;
          try {
            return oC(n, r, c);
          } finally {
            Ye.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", St(), cn(), hC(n);
        },
        useState: function(n) {
          he = "useState", St(), cn();
          var r = Ye.current;
          Ye.current = To;
          try {
            return Y0(n);
          } finally {
            Ye.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", St(), cn(), void 0;
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", St(), cn(), bC(n);
        },
        useTransition: function() {
          return he = "useTransition", St(), cn(), xC();
        },
        useMutableSource: function(n, r, c) {
          return he = "useMutableSource", St(), cn(), void 0;
        },
        useSyncExternalStore: function(n, r, c) {
          return he = "useSyncExternalStore", St(), cn(), cC(n, r, c);
        },
        useId: function() {
          return he = "useId", St(), cn(), SC();
        },
        unstable_isNewReconciler: re
      }, Bs = {
        readContext: function(n) {
          return _C(), Di(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", St(), je(), eb(n, r);
        },
        useContext: function(n) {
          return he = "useContext", St(), je(), Di(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", St(), je(), fg(n, r);
        },
        useImperativeHandle: function(n, r, c) {
          return he = "useImperativeHandle", St(), je(), Z0(n, r, c);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", St(), je(), Q0(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", St(), je(), q0(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", St(), je();
          var c = Ye.current;
          Ye.current = Bs;
          try {
            return tb(n, r);
          } finally {
            Ye.current = c;
          }
        },
        useReducer: function(n, r, c) {
          he = "useReducer", St(), je();
          var d = Ye.current;
          Ye.current = Bs;
          try {
            return lC(n, r, c);
          } finally {
            Ye.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", St(), je(), G0();
        },
        useState: function(n) {
          he = "useState", St(), je();
          var r = Ye.current;
          Ye.current = Bs;
          try {
            return fC(n);
          } finally {
            Ye.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", St(), je(), J0();
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", St(), je(), eD(n);
        },
        useTransition: function() {
          return he = "useTransition", St(), je(), iD();
        },
        useMutableSource: function(n, r, c) {
          return he = "useMutableSource", St(), je(), void 0;
        },
        useSyncExternalStore: function(n, r, c) {
          return he = "useSyncExternalStore", St(), je(), W0(n, r);
        },
        useId: function() {
          return he = "useId", St(), je(), nb();
        },
        unstable_isNewReconciler: re
      }, rb = {
        readContext: function(n) {
          return _C(), Di(n);
        },
        useCallback: function(n, r) {
          return he = "useCallback", St(), je(), eb(n, r);
        },
        useContext: function(n) {
          return he = "useContext", St(), je(), Di(n);
        },
        useEffect: function(n, r) {
          return he = "useEffect", St(), je(), fg(n, r);
        },
        useImperativeHandle: function(n, r, c) {
          return he = "useImperativeHandle", St(), je(), Z0(n, r, c);
        },
        useInsertionEffect: function(n, r) {
          return he = "useInsertionEffect", St(), je(), Q0(n, r);
        },
        useLayoutEffect: function(n, r) {
          return he = "useLayoutEffect", St(), je(), q0(n, r);
        },
        useMemo: function(n, r) {
          he = "useMemo", St(), je();
          var c = Ye.current;
          Ye.current = Bs;
          try {
            return tb(n, r);
          } finally {
            Ye.current = c;
          }
        },
        useReducer: function(n, r, c) {
          he = "useReducer", St(), je();
          var d = Ye.current;
          Ye.current = Bs;
          try {
            return uC(n, r, c);
          } finally {
            Ye.current = d;
          }
        },
        useRef: function(n) {
          return he = "useRef", St(), je(), G0();
        },
        useState: function(n) {
          he = "useState", St(), je();
          var r = Ye.current;
          Ye.current = Bs;
          try {
            return dC(n);
          } finally {
            Ye.current = r;
          }
        },
        useDebugValue: function(n, r) {
          return he = "useDebugValue", St(), je(), J0();
        },
        useDeferredValue: function(n) {
          return he = "useDeferredValue", St(), je(), tD(n);
        },
        useTransition: function() {
          return he = "useTransition", St(), je(), rD();
        },
        useMutableSource: function(n, r, c) {
          return he = "useMutableSource", St(), je(), void 0;
        },
        useSyncExternalStore: function(n, r, c) {
          return he = "useSyncExternalStore", St(), je(), W0(n, r);
        },
        useId: function() {
          return he = "useId", St(), je(), nb();
        },
        unstable_isNewReconciler: re
      };
    }
    var Fu = e.unstable_now, pD = 0, ab = -1, dg = -1, sb = -1, CC = !1, ob = !1;
    function mD() {
      return CC;
    }
    function bj() {
      ob = !0;
    }
    function xj() {
      CC = !1, ob = !1;
    }
    function Sj() {
      CC = ob, ob = !1;
    }
    function gD() {
      return pD;
    }
    function vD() {
      pD = Fu();
    }
    function wC(n) {
      dg = Fu(), n.actualStartTime < 0 && (n.actualStartTime = Fu());
    }
    function yD(n) {
      dg = -1;
    }
    function lb(n, r) {
      if (dg >= 0) {
        var c = Fu() - dg;
        n.actualDuration += c, r && (n.selfBaseDuration = c), dg = -1;
      }
    }
    function Eo(n) {
      if (ab >= 0) {
        var r = Fu() - ab;
        ab = -1;
        for (var c = n.return; c !== null; ) {
          switch (c.tag) {
            case S:
              var d = c.stateNode;
              d.effectDuration += r;
              return;
            case B:
              var g = c.stateNode;
              g.effectDuration += r;
              return;
          }
          c = c.return;
        }
      }
    }
    function TC(n) {
      if (sb >= 0) {
        var r = Fu() - sb;
        sb = -1;
        for (var c = n.return; c !== null; ) {
          switch (c.tag) {
            case S:
              var d = c.stateNode;
              d !== null && (d.passiveEffectDuration += r);
              return;
            case B:
              var g = c.stateNode;
              g !== null && (g.passiveEffectDuration += r);
              return;
          }
          c = c.return;
        }
      }
    }
    function Ro() {
      ab = Fu();
    }
    function EC() {
      sb = Fu();
    }
    function RC(n) {
      for (var r = n.child; r; )
        n.actualDuration += r.actualDuration, r = r.sibling;
    }
    function Hs(n, r) {
      if (n && n.defaultProps) {
        var c = Lt({}, r), d = n.defaultProps;
        for (var g in d)
          c[g] === void 0 && (c[g] = d[g]);
        return c;
      }
      return r;
    }
    var DC = {}, kC, MC, AC, OC, PC, bD, ub, LC, NC, zC, hg;
    {
      kC = /* @__PURE__ */ new Set(), MC = /* @__PURE__ */ new Set(), AC = /* @__PURE__ */ new Set(), OC = /* @__PURE__ */ new Set(), LC = /* @__PURE__ */ new Set(), PC = /* @__PURE__ */ new Set(), NC = /* @__PURE__ */ new Set(), zC = /* @__PURE__ */ new Set(), hg = /* @__PURE__ */ new Set();
      var xD = /* @__PURE__ */ new Set();
      ub = function(n, r) {
        if (!(n === null || typeof n == "function")) {
          var c = r + "_" + n;
          xD.has(c) || (xD.add(c), u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, n));
        }
      }, bD = function(n, r) {
        if (r === void 0) {
          var c = pn(n) || "Component";
          PC.has(c) || (PC.add(c), u("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", c));
        }
      }, Object.defineProperty(DC, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(DC);
    }
    function FC(n, r, c, d) {
      var g = n.memoizedState, x = c(d, g);
      {
        if (n.mode & mn) {
          Fn(!0);
          try {
            x = c(d, g);
          } finally {
            Fn(!1);
          }
        }
        bD(r, x);
      }
      var w = x == null ? g : Lt({}, g, x);
      if (n.memoizedState = w, n.lanes === be) {
        var R = n.updateQueue;
        R.baseState = w;
      }
    }
    var VC = {
      isMounted: gy,
      enqueueSetState: function(n, r, c) {
        var d = du(n), g = Qr(), x = Hu(d), w = kl(g, x);
        w.payload = r, c != null && (ub(c, "setState"), w.callback = c);
        var R = Pu(d, w, x);
        R !== null && (Wi(R, d, x, g), V0(R, d, x)), Nc(d, x);
      },
      enqueueReplaceState: function(n, r, c) {
        var d = du(n), g = Qr(), x = Hu(d), w = kl(g, x);
        w.tag = FR, w.payload = r, c != null && (ub(c, "replaceState"), w.callback = c);
        var R = Pu(d, w, x);
        R !== null && (Wi(R, d, x, g), V0(R, d, x)), Nc(d, x);
      },
      enqueueForceUpdate: function(n, r) {
        var c = du(n), d = Qr(), g = Hu(c), x = kl(d, g);
        x.tag = N0, r != null && (ub(r, "forceUpdate"), x.callback = r);
        var w = Pu(c, x, g);
        w !== null && (Wi(w, c, g, d), V0(w, c, g)), Ad(c, g);
      }
    };
    function SD(n, r, c, d, g, x, w) {
      var R = n.stateNode;
      if (typeof R.shouldComponentUpdate == "function") {
        var k = R.shouldComponentUpdate(d, x, w);
        {
          if (n.mode & mn) {
            Fn(!0);
            try {
              k = R.shouldComponentUpdate(d, x, w);
            } finally {
              Fn(!1);
            }
          }
          k === void 0 && u("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", pn(r) || "Component");
        }
        return k;
      }
      return r.prototype && r.prototype.isPureReactComponent ? !Ze(c, d) || !Ze(g, x) : !0;
    }
    function _j(n, r, c) {
      var d = n.stateNode;
      {
        var g = pn(r) || "Component", x = d.render;
        x || (r.prototype && typeof r.prototype.render == "function" ? u("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", g) : u("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", g)), d.getInitialState && !d.getInitialState.isReactClassApproved && !d.state && u("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", g), d.getDefaultProps && !d.getDefaultProps.isReactClassApproved && u("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", g), d.propTypes && u("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", g), d.contextType && u("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", g), r.childContextTypes && !hg.has(r) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (n.mode & mn) === st && (hg.add(r), u(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, g)), r.contextTypes && !hg.has(r) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (n.mode & mn) === st && (hg.add(r), u(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, g)), d.contextTypes && u("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", g), r.contextType && r.contextTypes && !NC.has(r) && (NC.add(r), u("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", g)), typeof d.componentShouldUpdate == "function" && u("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", g), r.prototype && r.prototype.isPureReactComponent && typeof d.shouldComponentUpdate < "u" && u("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", pn(r) || "A pure component"), typeof d.componentDidUnmount == "function" && u("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", g), typeof d.componentDidReceiveProps == "function" && u("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", g), typeof d.componentWillRecieveProps == "function" && u("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", g), typeof d.UNSAFE_componentWillRecieveProps == "function" && u("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", g);
        var w = d.props !== c;
        d.props !== void 0 && w && u("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", g, g), d.defaultProps && u("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", g, g), typeof d.getSnapshotBeforeUpdate == "function" && typeof d.componentDidUpdate != "function" && !AC.has(r) && (AC.add(r), u("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", pn(r))), typeof d.getDerivedStateFromProps == "function" && u("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", g), typeof d.getDerivedStateFromError == "function" && u("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", g), typeof r.getSnapshotBeforeUpdate == "function" && u("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", g);
        var R = d.state;
        R && (typeof R != "object" || Pi(R)) && u("%s.state: must be set to an object or null", g), typeof d.getChildContext == "function" && typeof r.childContextTypes != "object" && u("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", g);
      }
    }
    function _D(n, r) {
      r.updater = VC, n.stateNode = r, il(r, n), r._reactInternalInstance = DC;
    }
    function CD(n, r, c) {
      var d = !1, g = za, x = za, w = r.contextType;
      if ("contextType" in r) {
        var R = (
          // Allow null for conditional declaration
          w === null || w !== void 0 && w.$$typeof === H && w._context === void 0
        );
        if (!R && !zC.has(r)) {
          zC.add(r);
          var k = "";
          w === void 0 ? k = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof w != "object" ? k = " However, it is set to a " + typeof w + "." : w.$$typeof === Ea ? k = " Did you accidentally pass the Context.Provider instead?" : w._context !== void 0 ? k = " Did you accidentally pass the Context.Consumer instead?" : k = " However, it is set to an object with keys {" + Object.keys(w).join(", ") + "}.", u("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", pn(r) || "Component", k);
        }
      }
      if (typeof w == "object" && w !== null)
        x = Di(w);
      else {
        g = xh(n, r, !0);
        var L = r.contextTypes;
        d = L != null, x = d ? Sh(n, g) : za;
      }
      var z = new r(c, x);
      if (n.mode & mn) {
        Fn(!0);
        try {
          z = new r(c, x);
        } finally {
          Fn(!1);
        }
      }
      var W = n.memoizedState = z.state !== null && z.state !== void 0 ? z.state : null;
      _D(n, z);
      {
        if (typeof r.getDerivedStateFromProps == "function" && W === null) {
          var I = pn(r) || "Component";
          MC.has(I) || (MC.add(I), u("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", I, z.state === null ? "null" : "undefined", I));
        }
        if (typeof r.getDerivedStateFromProps == "function" || typeof z.getSnapshotBeforeUpdate == "function") {
          var J = null, ne = null, le = null;
          if (typeof z.componentWillMount == "function" && z.componentWillMount.__suppressDeprecationWarning !== !0 ? J = "componentWillMount" : typeof z.UNSAFE_componentWillMount == "function" && (J = "UNSAFE_componentWillMount"), typeof z.componentWillReceiveProps == "function" && z.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ne = "componentWillReceiveProps" : typeof z.UNSAFE_componentWillReceiveProps == "function" && (ne = "UNSAFE_componentWillReceiveProps"), typeof z.componentWillUpdate == "function" && z.componentWillUpdate.__suppressDeprecationWarning !== !0 ? le = "componentWillUpdate" : typeof z.UNSAFE_componentWillUpdate == "function" && (le = "UNSAFE_componentWillUpdate"), J !== null || ne !== null || le !== null) {
            var Ie = pn(r) || "Component", ut = typeof r.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            OC.has(Ie) || (OC.add(Ie), u(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ie, ut, J !== null ? `
  ` + J : "", ne !== null ? `
  ` + ne : "", le !== null ? `
  ` + le : ""));
          }
        }
      }
      return d && dR(n, g, x), z;
    }
    function Cj(n, r) {
      var c = r.state;
      typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), c !== r.state && (u("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", kt(n) || "Component"), VC.enqueueReplaceState(r, r.state, null));
    }
    function wD(n, r, c, d) {
      var g = r.state;
      if (typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(c, d), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(c, d), r.state !== g) {
        {
          var x = kt(n) || "Component";
          kC.has(x) || (kC.add(x), u("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", x));
        }
        VC.enqueueReplaceState(r, r.state, null);
      }
    }
    function jC(n, r, c, d) {
      _j(n, r, c);
      var g = n.stateNode;
      g.props = c, g.state = n.memoizedState, g.refs = {}, K_(n);
      var x = r.contextType;
      if (typeof x == "object" && x !== null)
        g.context = Di(x);
      else {
        var w = xh(n, r, !0);
        g.context = Sh(n, w);
      }
      {
        if (g.state === c) {
          var R = pn(r) || "Component";
          LC.has(R) || (LC.add(R), u("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", R));
        }
        n.mode & mn && Vs.recordLegacyContextWarning(n, g), Vs.recordUnsafeLifecycleWarnings(n, g);
      }
      g.state = n.memoizedState;
      var k = r.getDerivedStateFromProps;
      if (typeof k == "function" && (FC(n, r, k, c), g.state = n.memoizedState), typeof r.getDerivedStateFromProps != "function" && typeof g.getSnapshotBeforeUpdate != "function" && (typeof g.UNSAFE_componentWillMount == "function" || typeof g.componentWillMount == "function") && (Cj(n, g), j0(n, c, g, d), g.state = n.memoizedState), typeof g.componentDidMount == "function") {
        var L = Ht;
        L |= Rs, (n.mode & tn) !== st && (L |= ro), n.flags |= L;
      }
    }
    function wj(n, r, c, d) {
      var g = n.stateNode, x = n.memoizedProps;
      g.props = x;
      var w = g.context, R = r.contextType, k = za;
      if (typeof R == "object" && R !== null)
        k = Di(R);
      else {
        var L = xh(n, r, !0);
        k = Sh(n, L);
      }
      var z = r.getDerivedStateFromProps, W = typeof z == "function" || typeof g.getSnapshotBeforeUpdate == "function";
      !W && (typeof g.UNSAFE_componentWillReceiveProps == "function" || typeof g.componentWillReceiveProps == "function") && (x !== c || w !== k) && wD(n, g, c, k), jR();
      var I = n.memoizedState, J = g.state = I;
      if (j0(n, c, g, d), J = n.memoizedState, x === c && I === J && !x0() && !B0()) {
        if (typeof g.componentDidMount == "function") {
          var ne = Ht;
          ne |= Rs, (n.mode & tn) !== st && (ne |= ro), n.flags |= ne;
        }
        return !1;
      }
      typeof z == "function" && (FC(n, r, z, c), J = n.memoizedState);
      var le = B0() || SD(n, r, x, c, I, J, k);
      if (le) {
        if (!W && (typeof g.UNSAFE_componentWillMount == "function" || typeof g.componentWillMount == "function") && (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function") {
          var Ie = Ht;
          Ie |= Rs, (n.mode & tn) !== st && (Ie |= ro), n.flags |= Ie;
        }
      } else {
        if (typeof g.componentDidMount == "function") {
          var ut = Ht;
          ut |= Rs, (n.mode & tn) !== st && (ut |= ro), n.flags |= ut;
        }
        n.memoizedProps = c, n.memoizedState = J;
      }
      return g.props = c, g.state = J, g.context = k, le;
    }
    function Tj(n, r, c, d, g) {
      var x = r.stateNode;
      VR(n, r);
      var w = r.memoizedProps, R = r.type === r.elementType ? w : Hs(r.type, w);
      x.props = R;
      var k = r.pendingProps, L = x.context, z = c.contextType, W = za;
      if (typeof z == "object" && z !== null)
        W = Di(z);
      else {
        var I = xh(r, c, !0);
        W = Sh(r, I);
      }
      var J = c.getDerivedStateFromProps, ne = typeof J == "function" || typeof x.getSnapshotBeforeUpdate == "function";
      !ne && (typeof x.UNSAFE_componentWillReceiveProps == "function" || typeof x.componentWillReceiveProps == "function") && (w !== k || L !== W) && wD(r, x, d, W), jR();
      var le = r.memoizedState, Ie = x.state = le;
      if (j0(r, d, x, g), Ie = r.memoizedState, w === k && le === Ie && !x0() && !B0())
        return typeof x.componentDidUpdate == "function" && (w !== n.memoizedProps || le !== n.memoizedState) && (r.flags |= Ht), typeof x.getSnapshotBeforeUpdate == "function" && (w !== n.memoizedProps || le !== n.memoizedState) && (r.flags |= yi), !1;
      typeof J == "function" && (FC(r, c, J, d), Ie = r.memoizedState);
      var ut = B0() || SD(r, c, R, d, le, Ie, W) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      ge;
      return ut ? (!ne && (typeof x.UNSAFE_componentWillUpdate == "function" || typeof x.componentWillUpdate == "function") && (typeof x.componentWillUpdate == "function" && x.componentWillUpdate(d, Ie, W), typeof x.UNSAFE_componentWillUpdate == "function" && x.UNSAFE_componentWillUpdate(d, Ie, W)), typeof x.componentDidUpdate == "function" && (r.flags |= Ht), typeof x.getSnapshotBeforeUpdate == "function" && (r.flags |= yi)) : (typeof x.componentDidUpdate == "function" && (w !== n.memoizedProps || le !== n.memoizedState) && (r.flags |= Ht), typeof x.getSnapshotBeforeUpdate == "function" && (w !== n.memoizedProps || le !== n.memoizedState) && (r.flags |= yi), r.memoizedProps = d, r.memoizedState = Ie), x.props = d, x.state = Ie, x.context = W, ut;
    }
    function Sf(n, r) {
      return {
        value: n,
        source: r,
        stack: Zf(r),
        digest: null
      };
    }
    function BC(n, r, c) {
      return {
        value: n,
        source: null,
        stack: c ?? null,
        digest: r ?? null
      };
    }
    function Ej(n, r) {
      return !0;
    }
    function HC(n, r) {
      try {
        var c = Ej(n, r);
        if (c === !1)
          return;
        var d = r.value, g = r.source, x = r.stack, w = x !== null ? x : "";
        if (d != null && d._suppressLogging) {
          if (n.tag === v)
            return;
          console.error(d);
        }
        var R = g ? kt(g) : null, k = R ? "The above error occurred in the <" + R + "> component:" : "The above error occurred in one of your React components:", L;
        if (n.tag === S)
          L = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var z = kt(n) || "Anonymous";
          L = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + z + ".");
        }
        var W = k + `
` + w + `

` + ("" + L);
        console.error(W);
      } catch (I) {
        setTimeout(function() {
          throw I;
        });
      }
    }
    var Rj = typeof WeakMap == "function" ? WeakMap : Map;
    function TD(n, r, c) {
      var d = kl(bn, c);
      d.tag = Y_, d.payload = {
        element: null
      };
      var g = r.value;
      return d.callback = function() {
        bH(g), HC(n, r);
      }, d;
    }
    function UC(n, r, c) {
      var d = kl(bn, c);
      d.tag = Y_;
      var g = n.type.getDerivedStateFromError;
      if (typeof g == "function") {
        var x = r.value;
        d.payload = function() {
          return g(x);
        }, d.callback = function() {
          zk(n), HC(n, r);
        };
      }
      var w = n.stateNode;
      return w !== null && typeof w.componentDidCatch == "function" && (d.callback = function() {
        zk(n), HC(n, r), typeof g != "function" && vH(this);
        var k = r.value, L = r.stack;
        this.componentDidCatch(k, {
          componentStack: L !== null ? L : ""
        }), typeof g != "function" && (Er(n.lanes, mt) || u("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", kt(n) || "Unknown"));
      }), d;
    }
    function ED(n, r, c) {
      var d = n.pingCache, g;
      if (d === null ? (d = n.pingCache = new Rj(), g = /* @__PURE__ */ new Set(), d.set(r, g)) : (g = d.get(r), g === void 0 && (g = /* @__PURE__ */ new Set(), d.set(r, g))), !g.has(c)) {
        g.add(c);
        var x = xH.bind(null, n, r, c);
        Tr && Mg(n, c), r.then(x, x);
      }
    }
    function Dj(n, r, c, d) {
      var g = n.updateQueue;
      if (g === null) {
        var x = /* @__PURE__ */ new Set();
        x.add(c), n.updateQueue = x;
      } else
        g.add(c);
    }
    function kj(n, r) {
      var c = n.tag;
      if ((n.mode & Nt) === st && (c === m || c === F || c === Y)) {
        var d = n.alternate;
        d ? (n.updateQueue = d.updateQueue, n.memoizedState = d.memoizedState, n.lanes = d.lanes) : (n.updateQueue = null, n.memoizedState = null);
      }
    }
    function RD(n) {
      var r = n;
      do {
        if (r.tag === V && uj(r))
          return r;
        r = r.return;
      } while (r !== null);
      return null;
    }
    function DD(n, r, c, d, g) {
      if ((n.mode & Nt) === st) {
        if (n === r)
          n.flags |= _r;
        else {
          if (n.flags |= rt, c.flags |= Cd, c.flags &= -52805, c.tag === v) {
            var x = c.alternate;
            if (x === null)
              c.tag = ae;
            else {
              var w = kl(bn, mt);
              w.tag = N0, Pu(c, w, mt);
            }
          }
          c.lanes = Mt(c.lanes, mt);
        }
        return n;
      }
      return n.flags |= _r, n.lanes = g, n;
    }
    function Mj(n, r, c, d, g) {
      if (c.flags |= kc, Tr && Mg(n, g), d !== null && typeof d == "object" && typeof d.then == "function") {
        var x = d;
        kj(c), or() && c.mode & Nt && bR();
        var w = RD(r);
        if (w !== null) {
          w.flags &= -257, DD(w, r, c, n, g), w.mode & Nt && ED(n, x, g), Dj(w, n, x);
          return;
        } else {
          if (!wy(g)) {
            ED(n, x, g), Sw();
            return;
          }
          var R = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          d = R;
        }
      } else if (or() && c.mode & Nt) {
        bR();
        var k = RD(r);
        if (k !== null) {
          (k.flags & _r) === at && (k.flags |= xr), DD(k, r, c, n, g), L_(Sf(d, c));
          return;
        }
      }
      d = Sf(d, c), uH(d);
      var L = r;
      do {
        switch (L.tag) {
          case S: {
            var z = d;
            L.flags |= _r;
            var W = $c(g);
            L.lanes = Mt(L.lanes, W);
            var I = TD(L, z, W);
            X_(L, I);
            return;
          }
          case v:
            var J = d, ne = L.type, le = L.stateNode;
            if ((L.flags & rt) === at && (typeof ne.getDerivedStateFromError == "function" || le !== null && typeof le.componentDidCatch == "function" && !Rk(le))) {
              L.flags |= _r;
              var Ie = $c(g);
              L.lanes = Mt(L.lanes, Ie);
              var ut = UC(L, J, Ie);
              X_(L, ut);
              return;
            }
            break;
        }
        L = L.return;
      } while (L !== null);
    }
    function Aj() {
      return null;
    }
    var pg = i.ReactCurrentOwner, Us = !1, IC, mg, $C, WC, YC, _f, GC, cb, gg;
    IC = {}, mg = {}, $C = {}, WC = {}, YC = {}, _f = !1, GC = {}, cb = {}, gg = {};
    function Kr(n, r, c, d) {
      n === null ? r.child = AR(r, null, c, d) : r.child = Th(r, n.child, c, d);
    }
    function Oj(n, r, c, d) {
      r.child = Th(r, n.child, null, d), r.child = Th(r, null, c, d);
    }
    function kD(n, r, c, d, g) {
      if (r.type !== r.elementType) {
        var x = c.propTypes;
        x && zs(
          x,
          d,
          // Resolved props
          "prop",
          pn(c)
        );
      }
      var w = c.render, R = r.ref, k, L;
      Rh(r, g), Ir(r);
      {
        if (pg.current = r, Oi(!0), k = Ph(n, r, w, d, R, g), L = Lh(), r.mode & mn) {
          Fn(!0);
          try {
            k = Ph(n, r, w, d, R, g), L = Lh();
          } finally {
            Fn(!1);
          }
        }
        Oi(!1);
      }
      return $r(), n !== null && !Us ? (WR(n, r, g), Ml(n, r, g)) : (or() && L && D_(r), r.flags |= Ma, Kr(n, r, k, g), r.child);
    }
    function MD(n, r, c, d, g) {
      if (n === null) {
        var x = c.type;
        if (FH(x) && c.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        c.defaultProps === void 0) {
          var w = x;
          return w = Uh(x), r.tag = Y, r.type = w, QC(r, x), AD(n, r, w, d, g);
        }
        {
          var R = x.propTypes;
          if (R && zs(
            R,
            d,
            // Resolved props
            "prop",
            pn(x)
          ), c.defaultProps !== void 0) {
            var k = pn(x) || "Unknown";
            gg[k] || (u("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", k), gg[k] = !0);
          }
        }
        var L = Ow(c.type, null, d, r, r.mode, g);
        return L.ref = r.ref, L.return = r, r.child = L, L;
      }
      {
        var z = c.type, W = z.propTypes;
        W && zs(
          W,
          d,
          // Resolved props
          "prop",
          pn(z)
        );
      }
      var I = n.child, J = nw(n, g);
      if (!J) {
        var ne = I.memoizedProps, le = c.compare;
        if (le = le !== null ? le : Ze, le(ne, d) && n.ref === r.ref)
          return Ml(n, r, g);
      }
      r.flags |= Ma;
      var Ie = Rf(I, d);
      return Ie.ref = r.ref, Ie.return = r, r.child = Ie, Ie;
    }
    function AD(n, r, c, d, g) {
      if (r.type !== r.elementType) {
        var x = r.elementType;
        if (x.$$typeof === wt) {
          var w = x, R = w._payload, k = w._init;
          try {
            x = k(R);
          } catch {
            x = null;
          }
          var L = x && x.propTypes;
          L && zs(
            L,
            d,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            pn(x)
          );
        }
      }
      if (n !== null) {
        var z = n.memoizedProps;
        if (Ze(z, d) && n.ref === r.ref && // Prevent bailout if the implementation changed due to hot reload.
        r.type === n.type)
          if (Us = !1, r.pendingProps = d = z, nw(n, g))
            (n.flags & Cd) !== at && (Us = !0);
          else return r.lanes = n.lanes, Ml(n, r, g);
      }
      return KC(n, r, c, d, g);
    }
    function OD(n, r, c) {
      var d = r.pendingProps, g = d.children, x = n !== null ? n.memoizedState : null;
      if (d.mode === "hidden" || me)
        if ((r.mode & Nt) === st) {
          var w = {
            baseLanes: be,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = w, Cb(r, c);
        } else if (Er(c, Wr)) {
          var W = {
            baseLanes: be,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = W;
          var I = x !== null ? x.baseLanes : c;
          Cb(r, I);
        } else {
          var R = null, k;
          if (x !== null) {
            var L = x.baseLanes;
            k = Mt(L, c);
          } else
            k = c;
          r.lanes = r.childLanes = Wr;
          var z = {
            baseLanes: k,
            cachePool: R,
            transitions: null
          };
          return r.memoizedState = z, r.updateQueue = null, Cb(r, k), null;
        }
      else {
        var J;
        x !== null ? (J = Mt(x.baseLanes, c), r.memoizedState = null) : J = c, Cb(r, J);
      }
      return Kr(n, r, g, c), r.child;
    }
    function Pj(n, r, c) {
      var d = r.pendingProps;
      return Kr(n, r, d, c), r.child;
    }
    function Lj(n, r, c) {
      var d = r.pendingProps.children;
      return Kr(n, r, d, c), r.child;
    }
    function Nj(n, r, c) {
      {
        r.flags |= Ht;
        {
          var d = r.stateNode;
          d.effectDuration = 0, d.passiveEffectDuration = 0;
        }
      }
      var g = r.pendingProps, x = g.children;
      return Kr(n, r, x, c), r.child;
    }
    function PD(n, r) {
      var c = r.ref;
      (n === null && c !== null || n !== null && n.ref !== c) && (r.flags |= Yn, r.flags |= pu);
    }
    function KC(n, r, c, d, g) {
      if (r.type !== r.elementType) {
        var x = c.propTypes;
        x && zs(
          x,
          d,
          // Resolved props
          "prop",
          pn(c)
        );
      }
      var w;
      {
        var R = xh(r, c, !0);
        w = Sh(r, R);
      }
      var k, L;
      Rh(r, g), Ir(r);
      {
        if (pg.current = r, Oi(!0), k = Ph(n, r, c, d, w, g), L = Lh(), r.mode & mn) {
          Fn(!0);
          try {
            k = Ph(n, r, c, d, w, g), L = Lh();
          } finally {
            Fn(!1);
          }
        }
        Oi(!1);
      }
      return $r(), n !== null && !Us ? (WR(n, r, g), Ml(n, r, g)) : (or() && L && D_(r), r.flags |= Ma, Kr(n, r, k, g), r.child);
    }
    function LD(n, r, c, d, g) {
      {
        switch (ZH(r)) {
          case !1: {
            var x = r.stateNode, w = r.type, R = new w(r.memoizedProps, x.context), k = R.state;
            x.updater.enqueueSetState(x, k, null);
            break;
          }
          case !0: {
            r.flags |= rt, r.flags |= _r;
            var L = new Error("Simulated error coming from DevTools"), z = $c(g);
            r.lanes = Mt(r.lanes, z);
            var W = UC(r, Sf(L, r), z);
            X_(r, W);
            break;
          }
        }
        if (r.type !== r.elementType) {
          var I = c.propTypes;
          I && zs(
            I,
            d,
            // Resolved props
            "prop",
            pn(c)
          );
        }
      }
      var J;
      _o(c) ? (J = !0, _0(r)) : J = !1, Rh(r, g);
      var ne = r.stateNode, le;
      ne === null ? (db(n, r), CD(r, c, d), jC(r, c, d, g), le = !0) : n === null ? le = wj(r, c, d, g) : le = Tj(n, r, c, d, g);
      var Ie = XC(n, r, c, le, J, g);
      {
        var ut = r.stateNode;
        le && ut.props !== d && (_f || u("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", kt(r) || "a component"), _f = !0);
      }
      return Ie;
    }
    function XC(n, r, c, d, g, x) {
      PD(n, r);
      var w = (r.flags & rt) !== at;
      if (!d && !w)
        return g && mR(r, c, !1), Ml(n, r, x);
      var R = r.stateNode;
      pg.current = r;
      var k;
      if (w && typeof c.getDerivedStateFromError != "function")
        k = null, yD();
      else {
        Ir(r);
        {
          if (Oi(!0), k = R.render(), r.mode & mn) {
            Fn(!0);
            try {
              R.render();
            } finally {
              Fn(!1);
            }
          }
          Oi(!1);
        }
        $r();
      }
      return r.flags |= Ma, n !== null && w ? Oj(n, r, k, x) : Kr(n, r, k, x), r.memoizedState = R.state, g && mR(r, c, !0), r.child;
    }
    function ND(n) {
      var r = n.stateNode;
      r.pendingContext ? hR(n, r.pendingContext, r.pendingContext !== r.context) : r.context && hR(n, r.context, !1), Q_(n, r.containerInfo);
    }
    function zj(n, r, c) {
      if (ND(r), n === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var d = r.pendingProps, g = r.memoizedState, x = g.element;
      VR(n, r), j0(r, d, null, c);
      var w = r.memoizedState;
      r.stateNode;
      var R = w.element;
      if (g.isDehydrated) {
        var k = {
          element: R,
          isDehydrated: !1,
          cache: w.cache,
          pendingSuspenseBoundaries: w.pendingSuspenseBoundaries,
          transitions: w.transitions
        }, L = r.updateQueue;
        if (L.baseState = k, r.memoizedState = k, r.flags & xr) {
          var z = Sf(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), r);
          return zD(n, r, R, c, z);
        } else if (R !== x) {
          var W = Sf(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), r);
          return zD(n, r, R, c, W);
        } else {
          jV(r);
          var I = AR(r, null, R, c);
          r.child = I;
          for (var J = I; J; )
            J.flags = J.flags & -3 | ra, J = J.sibling;
        }
      } else {
        if (wh(), R === x)
          return Ml(n, r, c);
        Kr(n, r, R, c);
      }
      return r.child;
    }
    function zD(n, r, c, d, g) {
      return wh(), L_(g), r.flags |= xr, Kr(n, r, c, d), r.child;
    }
    function Fj(n, r, c) {
      UR(r), n === null && P_(r);
      var d = r.type, g = r.pendingProps, x = n !== null ? n.memoizedProps : null, w = g.children, R = p_(d, g);
      return R ? w = null : x !== null && p_(d, x) && (r.flags |= Aa), PD(n, r), Kr(n, r, w, c), r.child;
    }
    function Vj(n, r) {
      return n === null && P_(r), null;
    }
    function jj(n, r, c, d) {
      db(n, r);
      var g = r.pendingProps, x = c, w = x._payload, R = x._init, k = R(w);
      r.type = k;
      var L = r.tag = VH(k), z = Hs(k, g), W;
      switch (L) {
        case m:
          return QC(r, k), r.type = k = Uh(k), W = KC(null, r, k, z, d), W;
        case v:
          return r.type = k = Ew(k), W = LD(null, r, k, z, d), W;
        case F:
          return r.type = k = Rw(k), W = kD(null, r, k, z, d), W;
        case G: {
          if (r.type !== r.elementType) {
            var I = k.propTypes;
            I && zs(
              I,
              z,
              // Resolved for outer only
              "prop",
              pn(k)
            );
          }
          return W = MD(
            null,
            r,
            k,
            Hs(k.type, z),
            // The inner type can have defaults too
            d
          ), W;
        }
      }
      var J = "";
      throw k !== null && typeof k == "object" && k.$$typeof === wt && (J = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + k + ". " + ("Lazy element type must resolve to a class or function." + J));
    }
    function Bj(n, r, c, d, g) {
      db(n, r), r.tag = v;
      var x;
      return _o(c) ? (x = !0, _0(r)) : x = !1, Rh(r, g), CD(r, c, d), jC(r, c, d, g), XC(null, r, c, !0, x, g);
    }
    function Hj(n, r, c, d) {
      db(n, r);
      var g = r.pendingProps, x;
      {
        var w = xh(r, c, !1);
        x = Sh(r, w);
      }
      Rh(r, d);
      var R, k;
      Ir(r);
      {
        if (c.prototype && typeof c.prototype.render == "function") {
          var L = pn(c) || "Unknown";
          IC[L] || (u("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", L, L), IC[L] = !0);
        }
        r.mode & mn && Vs.recordLegacyContextWarning(r, null), Oi(!0), pg.current = r, R = Ph(null, r, c, g, x, d), k = Lh(), Oi(!1);
      }
      if ($r(), r.flags |= Ma, typeof R == "object" && R !== null && typeof R.render == "function" && R.$$typeof === void 0) {
        var z = pn(c) || "Unknown";
        mg[z] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", z, z, z), mg[z] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof R == "object" && R !== null && typeof R.render == "function" && R.$$typeof === void 0
      ) {
        {
          var W = pn(c) || "Unknown";
          mg[W] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", W, W, W), mg[W] = !0);
        }
        r.tag = v, r.memoizedState = null, r.updateQueue = null;
        var I = !1;
        return _o(c) ? (I = !0, _0(r)) : I = !1, r.memoizedState = R.state !== null && R.state !== void 0 ? R.state : null, K_(r), _D(r, R), jC(r, c, g, d), XC(null, r, c, !0, I, d);
      } else {
        if (r.tag = m, r.mode & mn) {
          Fn(!0);
          try {
            R = Ph(null, r, c, g, x, d), k = Lh();
          } finally {
            Fn(!1);
          }
        }
        return or() && k && D_(r), Kr(null, r, R, d), QC(r, c), r.child;
      }
    }
    function QC(n, r) {
      {
        if (r && r.childContextTypes && u("%s(...): childContextTypes cannot be defined on a function component.", r.displayName || r.name || "Component"), n.ref !== null) {
          var c = "", d = ea();
          d && (c += `

Check the render method of \`` + d + "`.");
          var g = d || "", x = n._debugSource;
          x && (g = x.fileName + ":" + x.lineNumber), YC[g] || (YC[g] = !0, u("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", c));
        }
        if (r.defaultProps !== void 0) {
          var w = pn(r) || "Unknown";
          gg[w] || (u("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", w), gg[w] = !0);
        }
        if (typeof r.getDerivedStateFromProps == "function") {
          var R = pn(r) || "Unknown";
          WC[R] || (u("%s: Function components do not support getDerivedStateFromProps.", R), WC[R] = !0);
        }
        if (typeof r.contextType == "object" && r.contextType !== null) {
          var k = pn(r) || "Unknown";
          $C[k] || (u("%s: Function components do not support contextType.", k), $C[k] = !0);
        }
      }
    }
    var qC = {
      dehydrated: null,
      treeContext: null,
      retryLane: Zt
    };
    function ZC(n) {
      return {
        baseLanes: n,
        cachePool: Aj(),
        transitions: null
      };
    }
    function Uj(n, r) {
      var c = null;
      return {
        baseLanes: Mt(n.baseLanes, r),
        cachePool: c,
        transitions: n.transitions
      };
    }
    function Ij(n, r, c, d) {
      if (r !== null) {
        var g = r.memoizedState;
        if (g === null)
          return !1;
      }
      return J_(n, ag);
    }
    function $j(n, r) {
      return Wc(n.childLanes, r);
    }
    function FD(n, r, c) {
      var d = r.pendingProps;
      JH(r) && (r.flags |= rt);
      var g = js.current, x = !1, w = (r.flags & rt) !== at;
      if (w || Ij(g, n) ? (x = !0, r.flags &= -129) : (n === null || n.memoizedState !== null) && (g = lj(g, $R)), g = kh(g), Nu(r, g), n === null) {
        P_(r);
        var R = r.memoizedState;
        if (R !== null) {
          var k = R.dehydrated;
          if (k !== null)
            return Xj(r, k);
        }
        var L = d.children, z = d.fallback;
        if (x) {
          var W = Wj(r, L, z, c), I = r.child;
          return I.memoizedState = ZC(c), r.memoizedState = qC, W;
        } else
          return JC(r, L);
      } else {
        var J = n.memoizedState;
        if (J !== null) {
          var ne = J.dehydrated;
          if (ne !== null)
            return Qj(n, r, w, d, ne, J, c);
        }
        if (x) {
          var le = d.fallback, Ie = d.children, ut = Gj(n, r, Ie, le, c), it = r.child, $t = n.child.memoizedState;
          return it.memoizedState = $t === null ? ZC(c) : Uj($t, c), it.childLanes = $j(n, c), r.memoizedState = qC, ut;
        } else {
          var jt = d.children, Q = Yj(n, r, jt, c);
          return r.memoizedState = null, Q;
        }
      }
    }
    function JC(n, r, c) {
      var d = n.mode, g = {
        mode: "visible",
        children: r
      }, x = ew(g, d);
      return x.return = n, n.child = x, x;
    }
    function Wj(n, r, c, d) {
      var g = n.mode, x = n.child, w = {
        mode: "hidden",
        children: r
      }, R, k;
      return (g & Nt) === st && x !== null ? (R = x, R.childLanes = be, R.pendingProps = w, n.mode & en && (R.actualDuration = 0, R.actualStartTime = -1, R.selfBaseDuration = 0, R.treeBaseDuration = 0), k = Iu(c, g, d, null)) : (R = ew(w, g), k = Iu(c, g, d, null)), R.return = n, k.return = n, R.sibling = k, n.child = R, k;
    }
    function ew(n, r, c) {
      return Vk(n, r, be, null);
    }
    function VD(n, r) {
      return Rf(n, r);
    }
    function Yj(n, r, c, d) {
      var g = n.child, x = g.sibling, w = VD(g, {
        mode: "visible",
        children: c
      });
      if ((r.mode & Nt) === st && (w.lanes = d), w.return = r, w.sibling = null, x !== null) {
        var R = r.deletions;
        R === null ? (r.deletions = [x], r.flags |= ia) : R.push(x);
      }
      return r.child = w, w;
    }
    function Gj(n, r, c, d, g) {
      var x = r.mode, w = n.child, R = w.sibling, k = {
        mode: "hidden",
        children: c
      }, L;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (x & Nt) === st && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        r.child !== w
      ) {
        var z = r.child;
        L = z, L.childLanes = be, L.pendingProps = k, r.mode & en && (L.actualDuration = 0, L.actualStartTime = -1, L.selfBaseDuration = w.selfBaseDuration, L.treeBaseDuration = w.treeBaseDuration), r.deletions = null;
      } else
        L = VD(w, k), L.subtreeFlags = w.subtreeFlags & ui;
      var W;
      return R !== null ? W = Rf(R, d) : (W = Iu(d, x, g, null), W.flags |= qn), W.return = r, L.return = r, L.sibling = W, r.child = L, W;
    }
    function fb(n, r, c, d) {
      d !== null && L_(d), Th(r, n.child, null, c);
      var g = r.pendingProps, x = g.children, w = JC(r, x);
      return w.flags |= qn, r.memoizedState = null, w;
    }
    function Kj(n, r, c, d, g) {
      var x = r.mode, w = {
        mode: "visible",
        children: c
      }, R = ew(w, x), k = Iu(d, x, g, null);
      return k.flags |= qn, R.return = r, k.return = r, R.sibling = k, r.child = R, (r.mode & Nt) !== st && Th(r, n.child, null, g), k;
    }
    function Xj(n, r, c) {
      return (n.mode & Nt) === st ? (u("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), n.lanes = mt) : y_(r) ? n.lanes = Xi : n.lanes = Wr, null;
    }
    function Qj(n, r, c, d, g, x, w) {
      if (c)
        if (r.flags & xr) {
          r.flags &= -257;
          var Q = BC(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return fb(n, r, w, Q);
        } else {
          if (r.memoizedState !== null)
            return r.child = n.child, r.flags |= rt, null;
          var ue = d.children, q = d.fallback, Re = Kj(n, r, ue, q, w), Ke = r.child;
          return Ke.memoizedState = ZC(w), r.memoizedState = qC, Re;
        }
      else {
        if (FV(), (r.mode & Nt) === st)
          return fb(
            n,
            r,
            w,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (y_(g)) {
          var R, k, L;
          {
            var z = eV(g);
            R = z.digest, k = z.message, L = z.stack;
          }
          var W;
          k ? W = new Error(k) : W = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var I = BC(W, R, L);
          return fb(n, r, w, I);
        }
        var J = Er(w, n.childLanes);
        if (Us || J) {
          var ne = _b();
          if (ne !== null) {
            var le = bm(ne, w);
            if (le !== Zt && le !== x.retryLane) {
              x.retryLane = le;
              var Ie = bn;
              ha(n, le), Wi(ne, n, le, Ie);
            }
          }
          Sw();
          var ut = BC(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return fb(n, r, w, ut);
        } else if (oR(g)) {
          r.flags |= rt, r.child = n.child;
          var it = SH.bind(null, n);
          return tV(g, it), null;
        } else {
          BV(r, g, x.treeContext);
          var $t = d.children, jt = JC(r, $t);
          return jt.flags |= ra, jt;
        }
      }
    }
    function jD(n, r, c) {
      n.lanes = Mt(n.lanes, r);
      var d = n.alternate;
      d !== null && (d.lanes = Mt(d.lanes, r)), $_(n.return, r, c);
    }
    function qj(n, r, c) {
      for (var d = r; d !== null; ) {
        if (d.tag === V) {
          var g = d.memoizedState;
          g !== null && jD(d, c, n);
        } else if (d.tag === ee)
          jD(d, c, n);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === n)
          return;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === n)
            return;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
    }
    function Zj(n) {
      for (var r = n, c = null; r !== null; ) {
        var d = r.alternate;
        d !== null && I0(d) === null && (c = r), r = r.sibling;
      }
      return c;
    }
    function Jj(n) {
      if (n !== void 0 && n !== "forwards" && n !== "backwards" && n !== "together" && !GC[n])
        if (GC[n] = !0, typeof n == "string")
          switch (n.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', n, n.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', n, n.toLowerCase());
              break;
            }
            default:
              u('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', n);
              break;
          }
        else
          u('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', n);
    }
    function eB(n, r) {
      n !== void 0 && !cb[n] && (n !== "collapsed" && n !== "hidden" ? (cb[n] = !0, u('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', n)) : r !== "forwards" && r !== "backwards" && (cb[n] = !0, u('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', n)));
    }
    function BD(n, r) {
      {
        var c = Pi(n), d = !c && typeof Ot(n) == "function";
        if (c || d) {
          var g = c ? "array" : "iterable";
          return u("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", g, r, g), !1;
        }
      }
      return !0;
    }
    function tB(n, r) {
      if ((r === "forwards" || r === "backwards") && n !== void 0 && n !== null && n !== !1)
        if (Pi(n)) {
          for (var c = 0; c < n.length; c++)
            if (!BD(n[c], c))
              return;
        } else {
          var d = Ot(n);
          if (typeof d == "function") {
            var g = d.call(n);
            if (g)
              for (var x = g.next(), w = 0; !x.done; x = g.next()) {
                if (!BD(x.value, w))
                  return;
                w++;
              }
          } else
            u('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', r);
        }
    }
    function tw(n, r, c, d, g) {
      var x = n.memoizedState;
      x === null ? n.memoizedState = {
        isBackwards: r,
        rendering: null,
        renderingStartTime: 0,
        last: d,
        tail: c,
        tailMode: g
      } : (x.isBackwards = r, x.rendering = null, x.renderingStartTime = 0, x.last = d, x.tail = c, x.tailMode = g);
    }
    function HD(n, r, c) {
      var d = r.pendingProps, g = d.revealOrder, x = d.tail, w = d.children;
      Jj(g), eB(x, g), tB(w, g), Kr(n, r, w, c);
      var R = js.current, k = J_(R, ag);
      if (k)
        R = eC(R, ag), r.flags |= rt;
      else {
        var L = n !== null && (n.flags & rt) !== at;
        L && qj(r, r.child, c), R = kh(R);
      }
      if (Nu(r, R), (r.mode & Nt) === st)
        r.memoizedState = null;
      else
        switch (g) {
          case "forwards": {
            var z = Zj(r.child), W;
            z === null ? (W = r.child, r.child = null) : (W = z.sibling, z.sibling = null), tw(
              r,
              !1,
              // isBackwards
              W,
              z,
              x
            );
            break;
          }
          case "backwards": {
            var I = null, J = r.child;
            for (r.child = null; J !== null; ) {
              var ne = J.alternate;
              if (ne !== null && I0(ne) === null) {
                r.child = J;
                break;
              }
              var le = J.sibling;
              J.sibling = I, I = J, J = le;
            }
            tw(
              r,
              !0,
              // isBackwards
              I,
              null,
              // last
              x
            );
            break;
          }
          case "together": {
            tw(
              r,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            r.memoizedState = null;
        }
      return r.child;
    }
    function nB(n, r, c) {
      Q_(r, r.stateNode.containerInfo);
      var d = r.pendingProps;
      return n === null ? r.child = Th(r, null, d, c) : Kr(n, r, d, c), r.child;
    }
    var UD = !1;
    function iB(n, r, c) {
      var d = r.type, g = d._context, x = r.pendingProps, w = r.memoizedProps, R = x.value;
      {
        "value" in x || UD || (UD = !0, u("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var k = r.type.propTypes;
        k && zs(k, x, "prop", "Context.Provider");
      }
      if (LR(r, g, R), w !== null) {
        var L = w.value;
        if (Ce(L, R)) {
          if (w.children === x.children && !x0())
            return Ml(n, r, c);
        } else
          JV(r, g, c);
      }
      var z = x.children;
      return Kr(n, r, z, c), r.child;
    }
    var ID = !1;
    function rB(n, r, c) {
      var d = r.type;
      d._context === void 0 ? d !== d.Consumer && (ID || (ID = !0, u("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : d = d._context;
      var g = r.pendingProps, x = g.children;
      typeof x != "function" && u("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Rh(r, c);
      var w = Di(d);
      Ir(r);
      var R;
      return pg.current = r, Oi(!0), R = x(w), Oi(!1), $r(), r.flags |= Ma, Kr(n, r, R, c), r.child;
    }
    function vg() {
      Us = !0;
    }
    function db(n, r) {
      (r.mode & Nt) === st && n !== null && (n.alternate = null, r.alternate = null, r.flags |= qn);
    }
    function Ml(n, r, c) {
      return n !== null && (r.dependencies = n.dependencies), yD(), kg(r.lanes), Er(c, r.childLanes) ? (qV(n, r), r.child) : null;
    }
    function aB(n, r, c) {
      {
        var d = r.return;
        if (d === null)
          throw new Error("Cannot swap the root fiber.");
        if (n.alternate = null, r.alternate = null, c.index = r.index, c.sibling = r.sibling, c.return = r.return, c.ref = r.ref, r === d.child)
          d.child = c;
        else {
          var g = d.child;
          if (g === null)
            throw new Error("Expected parent to have a child.");
          for (; g.sibling !== r; )
            if (g = g.sibling, g === null)
              throw new Error("Expected to find the previous sibling.");
          g.sibling = c;
        }
        var x = d.deletions;
        return x === null ? (d.deletions = [n], d.flags |= ia) : x.push(n), c.flags |= qn, c;
      }
    }
    function nw(n, r) {
      var c = n.lanes;
      return !!Er(c, r);
    }
    function sB(n, r, c) {
      switch (r.tag) {
        case S:
          ND(r), r.stateNode, wh();
          break;
        case E:
          UR(r);
          break;
        case v: {
          var d = r.type;
          _o(d) && _0(r);
          break;
        }
        case C:
          Q_(r, r.stateNode.containerInfo);
          break;
        case N: {
          var g = r.memoizedProps.value, x = r.type._context;
          LR(r, x, g);
          break;
        }
        case B:
          {
            var w = Er(c, r.childLanes);
            w && (r.flags |= Ht);
            {
              var R = r.stateNode;
              R.effectDuration = 0, R.passiveEffectDuration = 0;
            }
          }
          break;
        case V: {
          var k = r.memoizedState;
          if (k !== null) {
            if (k.dehydrated !== null)
              return Nu(r, kh(js.current)), r.flags |= rt, null;
            var L = r.child, z = L.childLanes;
            if (Er(c, z))
              return FD(n, r, c);
            Nu(r, kh(js.current));
            var W = Ml(n, r, c);
            return W !== null ? W.sibling : null;
          } else
            Nu(r, kh(js.current));
          break;
        }
        case ee: {
          var I = (n.flags & rt) !== at, J = Er(c, r.childLanes);
          if (I) {
            if (J)
              return HD(n, r, c);
            r.flags |= rt;
          }
          var ne = r.memoizedState;
          if (ne !== null && (ne.rendering = null, ne.tail = null, ne.lastEffect = null), Nu(r, js.current), J)
            break;
          return null;
        }
        case se:
        case Pe:
          return r.lanes = be, OD(n, r, c);
      }
      return Ml(n, r, c);
    }
    function $D(n, r, c) {
      if (r._debugNeedsRemount && n !== null)
        return aB(n, r, Ow(r.type, r.key, r.pendingProps, r._debugOwner || null, r.mode, r.lanes));
      if (n !== null) {
        var d = n.memoizedProps, g = r.pendingProps;
        if (d !== g || x0() || // Force a re-render if the implementation changed due to hot reload:
        r.type !== n.type)
          Us = !0;
        else {
          var x = nw(n, c);
          if (!x && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (r.flags & rt) === at)
            return Us = !1, sB(n, r, c);
          (n.flags & Cd) !== at ? Us = !0 : Us = !1;
        }
      } else if (Us = !1, or() && AV(r)) {
        var w = r.index, R = OV();
        yR(r, R, w);
      }
      switch (r.lanes = be, r.tag) {
        case b:
          return Hj(n, r, r.type, c);
        case K: {
          var k = r.elementType;
          return jj(n, r, k, c);
        }
        case m: {
          var L = r.type, z = r.pendingProps, W = r.elementType === L ? z : Hs(L, z);
          return KC(n, r, L, W, c);
        }
        case v: {
          var I = r.type, J = r.pendingProps, ne = r.elementType === I ? J : Hs(I, J);
          return LD(n, r, I, ne, c);
        }
        case S:
          return zj(n, r, c);
        case E:
          return Fj(n, r, c);
        case D:
          return Vj(n, r);
        case V:
          return FD(n, r, c);
        case C:
          return nB(n, r, c);
        case F: {
          var le = r.type, Ie = r.pendingProps, ut = r.elementType === le ? Ie : Hs(le, Ie);
          return kD(n, r, le, ut, c);
        }
        case M:
          return Pj(n, r, c);
        case A:
          return Lj(n, r, c);
        case B:
          return Nj(n, r, c);
        case N:
          return iB(n, r, c);
        case P:
          return rB(n, r, c);
        case G: {
          var it = r.type, $t = r.pendingProps, jt = Hs(it, $t);
          if (r.type !== r.elementType) {
            var Q = it.propTypes;
            Q && zs(
              Q,
              jt,
              // Resolved for outer only
              "prop",
              pn(it)
            );
          }
          return jt = Hs(it.type, jt), MD(n, r, it, jt, c);
        }
        case Y:
          return AD(n, r, r.type, r.pendingProps, c);
        case ae: {
          var ue = r.type, q = r.pendingProps, Re = r.elementType === ue ? q : Hs(ue, q);
          return Bj(n, r, ue, Re, c);
        }
        case ee:
          return HD(n, r, c);
        case oe:
          break;
        case se:
          return OD(n, r, c);
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Nh(n) {
      n.flags |= Ht;
    }
    function WD(n) {
      n.flags |= Yn, n.flags |= pu;
    }
    var YD, iw, GD, KD;
    YD = function(n, r, c, d) {
      for (var g = r.child; g !== null; ) {
        if (g.tag === E || g.tag === D)
          DF(n, g.stateNode);
        else if (g.tag !== C) {
          if (g.child !== null) {
            g.child.return = g, g = g.child;
            continue;
          }
        }
        if (g === r)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === r)
            return;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
    }, iw = function(n, r) {
    }, GD = function(n, r, c, d, g) {
      var x = n.memoizedProps;
      if (x !== d) {
        var w = r.stateNode, R = q_(), k = MF(w, c, x, d, g, R);
        r.updateQueue = k, k && Nh(r);
      }
    }, KD = function(n, r, c, d) {
      c !== d && Nh(r);
    };
    function yg(n, r) {
      if (!or())
        switch (n.tailMode) {
          case "hidden": {
            for (var c = n.tail, d = null; c !== null; )
              c.alternate !== null && (d = c), c = c.sibling;
            d === null ? n.tail = null : d.sibling = null;
            break;
          }
          case "collapsed": {
            for (var g = n.tail, x = null; g !== null; )
              g.alternate !== null && (x = g), g = g.sibling;
            x === null ? !r && n.tail !== null ? n.tail.sibling = null : n.tail = null : x.sibling = null;
            break;
          }
        }
    }
    function ur(n) {
      var r = n.alternate !== null && n.alternate.child === n.child, c = be, d = at;
      if (r) {
        if ((n.mode & en) !== st) {
          for (var k = n.selfBaseDuration, L = n.child; L !== null; )
            c = Mt(c, Mt(L.lanes, L.childLanes)), d |= L.subtreeFlags & ui, d |= L.flags & ui, k += L.treeBaseDuration, L = L.sibling;
          n.treeBaseDuration = k;
        } else
          for (var z = n.child; z !== null; )
            c = Mt(c, Mt(z.lanes, z.childLanes)), d |= z.subtreeFlags & ui, d |= z.flags & ui, z.return = n, z = z.sibling;
        n.subtreeFlags |= d;
      } else {
        if ((n.mode & en) !== st) {
          for (var g = n.actualDuration, x = n.selfBaseDuration, w = n.child; w !== null; )
            c = Mt(c, Mt(w.lanes, w.childLanes)), d |= w.subtreeFlags, d |= w.flags, g += w.actualDuration, x += w.treeBaseDuration, w = w.sibling;
          n.actualDuration = g, n.treeBaseDuration = x;
        } else
          for (var R = n.child; R !== null; )
            c = Mt(c, Mt(R.lanes, R.childLanes)), d |= R.subtreeFlags, d |= R.flags, R.return = n, R = R.sibling;
        n.subtreeFlags |= d;
      }
      return n.childLanes = c, r;
    }
    function oB(n, r, c) {
      if (WV() && (r.mode & Nt) !== st && (r.flags & rt) === at)
        return TR(r), wh(), r.flags |= xr | kc | _r, !1;
      var d = R0(r);
      if (c !== null && c.dehydrated !== null)
        if (n === null) {
          if (!d)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (IV(r), ur(r), (r.mode & en) !== st) {
            var g = c !== null;
            if (g) {
              var x = r.child;
              x !== null && (r.treeBaseDuration -= x.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (wh(), (r.flags & rt) === at && (r.memoizedState = null), r.flags |= Ht, ur(r), (r.mode & en) !== st) {
            var w = c !== null;
            if (w) {
              var R = r.child;
              R !== null && (r.treeBaseDuration -= R.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return ER(), !0;
    }
    function XD(n, r, c) {
      var d = r.pendingProps;
      switch (k_(r), r.tag) {
        case b:
        case K:
        case Y:
        case m:
        case F:
        case M:
        case A:
        case B:
        case P:
        case G:
          return ur(r), null;
        case v: {
          var g = r.type;
          return _o(g) && S0(r), ur(r), null;
        }
        case S: {
          var x = r.stateNode;
          if (Dh(r), T_(r), nC(), x.pendingContext && (x.context = x.pendingContext, x.pendingContext = null), n === null || n.child === null) {
            var w = R0(r);
            if (w)
              Nh(r);
            else if (n !== null) {
              var R = n.memoizedState;
              // Check if this is a client root
              (!R.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (r.flags & xr) !== at) && (r.flags |= yi, ER());
            }
          }
          return iw(n, r), ur(r), null;
        }
        case E: {
          Z_(r);
          var k = HR(), L = r.type;
          if (n !== null && r.stateNode != null)
            GD(n, r, L, d, k), n.ref !== r.ref && WD(r);
          else {
            if (!d) {
              if (r.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return ur(r), null;
            }
            var z = q_(), W = R0(r);
            if (W)
              HV(r, k, z) && Nh(r);
            else {
              var I = RF(L, d, k, z, r);
              YD(I, r, !1, !1), r.stateNode = I, kF(I, L, d, k) && Nh(r);
            }
            r.ref !== null && WD(r);
          }
          return ur(r), null;
        }
        case D: {
          var J = d;
          if (n && r.stateNode != null) {
            var ne = n.memoizedProps;
            KD(n, r, ne, J);
          } else {
            if (typeof J != "string" && r.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var le = HR(), Ie = q_(), ut = R0(r);
            ut ? UV(r) && Nh(r) : r.stateNode = AF(J, le, Ie, r);
          }
          return ur(r), null;
        }
        case V: {
          Mh(r);
          var it = r.memoizedState;
          if (n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            var $t = oB(n, r, it);
            if (!$t)
              return r.flags & _r ? r : null;
          }
          if ((r.flags & rt) !== at)
            return r.lanes = c, (r.mode & en) !== st && RC(r), r;
          var jt = it !== null, Q = n !== null && n.memoizedState !== null;
          if (jt !== Q && jt) {
            var ue = r.child;
            if (ue.flags |= li, (r.mode & Nt) !== st) {
              var q = n === null && (r.memoizedProps.unstable_avoidThisFallback !== !0 || !0);
              q || J_(js.current, $R) ? lH() : Sw();
            }
          }
          var Re = r.updateQueue;
          if (Re !== null && (r.flags |= Ht), ur(r), (r.mode & en) !== st && jt) {
            var Ke = r.child;
            Ke !== null && (r.treeBaseDuration -= Ke.treeBaseDuration);
          }
          return null;
        }
        case C:
          return Dh(r), iw(n, r), n === null && wV(r.stateNode.containerInfo), ur(r), null;
        case N:
          var $e = r.type._context;
          return I_($e, r), ur(r), null;
        case ae: {
          var vt = r.type;
          return _o(vt) && S0(r), ur(r), null;
        }
        case ee: {
          Mh(r);
          var Tt = r.memoizedState;
          if (Tt === null)
            return ur(r), null;
          var vn = (r.flags & rt) !== at, rn = Tt.rendering;
          if (rn === null)
            if (vn)
              yg(Tt, !1);
            else {
              var Si = cH() && (n === null || (n.flags & rt) === at);
              if (!Si)
                for (var an = r.child; an !== null; ) {
                  var mi = I0(an);
                  if (mi !== null) {
                    vn = !0, r.flags |= rt, yg(Tt, !1);
                    var Pr = mi.updateQueue;
                    return Pr !== null && (r.updateQueue = Pr, r.flags |= Ht), r.subtreeFlags = at, ZV(r, c), Nu(r, eC(js.current, ag)), r.child;
                  }
                  an = an.sibling;
                }
              Tt.tail !== null && bi() > gk() && (r.flags |= rt, vn = !0, yg(Tt, !1), r.lanes = cm);
            }
          else {
            if (!vn) {
              var pr = I0(rn);
              if (pr !== null) {
                r.flags |= rt, vn = !0;
                var Va = pr.updateQueue;
                if (Va !== null && (r.updateQueue = Va, r.flags |= Ht), yg(Tt, !0), Tt.tail === null && Tt.tailMode === "hidden" && !rn.alternate && !or())
                  return ur(r), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              bi() * 2 - Tt.renderingStartTime > gk() && c !== Wr && (r.flags |= rt, vn = !0, yg(Tt, !1), r.lanes = cm);
            }
            if (Tt.isBackwards)
              rn.sibling = r.child, r.child = rn;
            else {
              var qr = Tt.last;
              qr !== null ? qr.sibling = rn : r.child = rn, Tt.last = rn;
            }
          }
          if (Tt.tail !== null) {
            var Zr = Tt.tail;
            Tt.rendering = Zr, Tt.tail = Zr.sibling, Tt.renderingStartTime = bi(), Zr.sibling = null;
            var Lr = js.current;
            return vn ? Lr = eC(Lr, ag) : Lr = kh(Lr), Nu(r, Lr), Zr;
          }
          return ur(r), null;
        }
        case oe:
          break;
        case se:
        case Pe: {
          xw(r);
          var Nl = r.memoizedState, Ih = Nl !== null;
          if (n !== null) {
            var Lg = n.memoizedState, Mo = Lg !== null;
            Mo !== Ih && (r.flags |= li);
          }
          return !Ih || (r.mode & Nt) === st ? ur(r) : Er(ko, Wr) && (ur(r), r.subtreeFlags & (qn | Ht) && (r.flags |= li)), null;
        }
        case Te:
          return null;
        case Se:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function lB(n, r, c) {
      switch (k_(r), r.tag) {
        case v: {
          var d = r.type;
          _o(d) && S0(r);
          var g = r.flags;
          return g & _r ? (r.flags = g & -65537 | rt, (r.mode & en) !== st && RC(r), r) : null;
        }
        case S: {
          r.stateNode, Dh(r), T_(r), nC();
          var x = r.flags;
          return (x & _r) !== at && (x & rt) === at ? (r.flags = x & -65537 | rt, r) : null;
        }
        case E:
          return Z_(r), null;
        case V: {
          Mh(r);
          var w = r.memoizedState;
          if (w !== null && w.dehydrated !== null) {
            if (r.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            wh();
          }
          var R = r.flags;
          return R & _r ? (r.flags = R & -65537 | rt, (r.mode & en) !== st && RC(r), r) : null;
        }
        case ee:
          return Mh(r), null;
        case C:
          return Dh(r), null;
        case N:
          var k = r.type._context;
          return I_(k, r), null;
        case se:
        case Pe:
          return xw(r), null;
        case Te:
          return null;
        default:
          return null;
      }
    }
    function QD(n, r, c) {
      switch (k_(r), r.tag) {
        case v: {
          var d = r.type.childContextTypes;
          d != null && S0(r);
          break;
        }
        case S: {
          r.stateNode, Dh(r), T_(r), nC();
          break;
        }
        case E: {
          Z_(r);
          break;
        }
        case C:
          Dh(r);
          break;
        case V:
          Mh(r);
          break;
        case ee:
          Mh(r);
          break;
        case N:
          var g = r.type._context;
          I_(g, r);
          break;
        case se:
        case Pe:
          xw(r);
          break;
      }
    }
    var qD = null;
    qD = /* @__PURE__ */ new Set();
    var hb = !1, cr = !1, uB = typeof WeakSet == "function" ? WeakSet : Set, Je = null, zh = null, Fh = null;
    function cB(n) {
      io(null, function() {
        throw n;
      }), Dc();
    }
    var fB = function(n, r) {
      if (r.props = n.memoizedProps, r.state = n.memoizedState, n.mode & en)
        try {
          Ro(), r.componentWillUnmount();
        } finally {
          Eo(n);
        }
      else
        r.componentWillUnmount();
    };
    function ZD(n, r) {
      try {
        Vu(ji, n);
      } catch (c) {
        Mn(n, r, c);
      }
    }
    function rw(n, r, c) {
      try {
        fB(n, c);
      } catch (d) {
        Mn(n, r, d);
      }
    }
    function dB(n, r, c) {
      try {
        c.componentDidMount();
      } catch (d) {
        Mn(n, r, d);
      }
    }
    function JD(n, r) {
      try {
        tk(n);
      } catch (c) {
        Mn(n, r, c);
      }
    }
    function Vh(n, r) {
      var c = n.ref;
      if (c !== null)
        if (typeof c == "function") {
          var d;
          try {
            if (Ne && de && n.mode & en)
              try {
                Ro(), d = c(null);
              } finally {
                Eo(n);
              }
            else
              d = c(null);
          } catch (g) {
            Mn(n, r, g);
          }
          typeof d == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", kt(n));
        } else
          c.current = null;
    }
    function pb(n, r, c) {
      try {
        c();
      } catch (d) {
        Mn(n, r, d);
      }
    }
    var ek = !1;
    function hB(n, r) {
      TF(n.containerInfo), Je = r, pB();
      var c = ek;
      return ek = !1, c;
    }
    function pB() {
      for (; Je !== null; ) {
        var n = Je, r = n.child;
        (n.subtreeFlags & ao) !== at && r !== null ? (r.return = n, Je = r) : mB();
      }
    }
    function mB() {
      for (; Je !== null; ) {
        var n = Je;
        kn(n);
        try {
          gB(n);
        } catch (c) {
          Mn(n, n.return, c);
        }
        Wn();
        var r = n.sibling;
        if (r !== null) {
          r.return = n.return, Je = r;
          return;
        }
        Je = n.return;
      }
    }
    function gB(n) {
      var r = n.alternate, c = n.flags;
      if ((c & yi) !== at) {
        switch (kn(n), n.tag) {
          case m:
          case F:
          case Y:
            break;
          case v: {
            if (r !== null) {
              var d = r.memoizedProps, g = r.memoizedState, x = n.stateNode;
              n.type === n.elementType && !_f && (x.props !== n.memoizedProps && u("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(n) || "instance"), x.state !== n.memoizedState && u("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(n) || "instance"));
              var w = x.getSnapshotBeforeUpdate(n.elementType === n.type ? d : Hs(n.type, d), g);
              {
                var R = qD;
                w === void 0 && !R.has(n.type) && (R.add(n.type), u("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", kt(n)));
              }
              x.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          }
          case S: {
            {
              var k = n.stateNode;
              QF(k.containerInfo);
            }
            break;
          }
          case E:
          case D:
          case C:
          case ae:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Wn();
      }
    }
    function Is(n, r, c) {
      var d = r.updateQueue, g = d !== null ? d.lastEffect : null;
      if (g !== null) {
        var x = g.next, w = x;
        do {
          if ((w.tag & n) === n) {
            var R = w.destroy;
            w.destroy = void 0, R !== void 0 && ((n & lr) !== pa ? Ms(r) : (n & ji) !== pa && Ac(r), (n & Co) !== pa && Ag(!0), pb(r, c, R), (n & Co) !== pa && Ag(!1), (n & lr) !== pa ? uo() : (n & ji) !== pa && lm());
          }
          w = w.next;
        } while (w !== x);
      }
    }
    function Vu(n, r) {
      var c = r.updateQueue, d = c !== null ? c.lastEffect : null;
      if (d !== null) {
        var g = d.next, x = g;
        do {
          if ((x.tag & n) === n) {
            (n & lr) !== pa ? om(r) : (n & ji) !== pa && kd(r);
            var w = x.create;
            (n & Co) !== pa && Ag(!0), x.destroy = w(), (n & Co) !== pa && Ag(!1), (n & lr) !== pa ? by() : (n & ji) !== pa && xy();
            {
              var R = x.destroy;
              if (R !== void 0 && typeof R != "function") {
                var k = void 0;
                (x.tag & ji) !== at ? k = "useLayoutEffect" : (x.tag & Co) !== at ? k = "useInsertionEffect" : k = "useEffect";
                var L = void 0;
                R === null ? L = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof R.then == "function" ? L = `

It looks like you wrote ` + k + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + k + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : L = " You returned: " + R, u("%s must not return anything besides a function, which is used for clean-up.%s", k, L);
              }
            }
          }
          x = x.next;
        } while (x !== g);
      }
    }
    function vB(n, r) {
      if ((r.flags & Ht) !== at)
        switch (r.tag) {
          case B: {
            var c = r.stateNode.passiveEffectDuration, d = r.memoizedProps, g = d.id, x = d.onPostCommit, w = gD(), R = r.alternate === null ? "mount" : "update";
            mD() && (R = "nested-update"), typeof x == "function" && x(g, R, c, w);
            var k = r.return;
            e: for (; k !== null; ) {
              switch (k.tag) {
                case S:
                  var L = k.stateNode;
                  L.passiveEffectDuration += c;
                  break e;
                case B:
                  var z = k.stateNode;
                  z.passiveEffectDuration += c;
                  break e;
              }
              k = k.return;
            }
            break;
          }
        }
    }
    function yB(n, r, c, d) {
      if ((c.flags & oo) !== at)
        switch (c.tag) {
          case m:
          case F:
          case Y: {
            if (!cr)
              if (c.mode & en)
                try {
                  Ro(), Vu(ji | Vi, c);
                } finally {
                  Eo(c);
                }
              else
                Vu(ji | Vi, c);
            break;
          }
          case v: {
            var g = c.stateNode;
            if (c.flags & Ht && !cr)
              if (r === null)
                if (c.type === c.elementType && !_f && (g.props !== c.memoizedProps && u("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(c) || "instance"), g.state !== c.memoizedState && u("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(c) || "instance")), c.mode & en)
                  try {
                    Ro(), g.componentDidMount();
                  } finally {
                    Eo(c);
                  }
                else
                  g.componentDidMount();
              else {
                var x = c.elementType === c.type ? r.memoizedProps : Hs(c.type, r.memoizedProps), w = r.memoizedState;
                if (c.type === c.elementType && !_f && (g.props !== c.memoizedProps && u("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(c) || "instance"), g.state !== c.memoizedState && u("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(c) || "instance")), c.mode & en)
                  try {
                    Ro(), g.componentDidUpdate(x, w, g.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Eo(c);
                  }
                else
                  g.componentDidUpdate(x, w, g.__reactInternalSnapshotBeforeUpdate);
              }
            var R = c.updateQueue;
            R !== null && (c.type === c.elementType && !_f && (g.props !== c.memoizedProps && u("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(c) || "instance"), g.state !== c.memoizedState && u("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(c) || "instance")), BR(c, R, g));
            break;
          }
          case S: {
            var k = c.updateQueue;
            if (k !== null) {
              var L = null;
              if (c.child !== null)
                switch (c.child.tag) {
                  case E:
                    L = c.child.stateNode;
                    break;
                  case v:
                    L = c.child.stateNode;
                    break;
                }
              BR(c, k, L);
            }
            break;
          }
          case E: {
            var z = c.stateNode;
            if (r === null && c.flags & Ht) {
              var W = c.type, I = c.memoizedProps;
              zF(z, W, I);
            }
            break;
          }
          case D:
            break;
          case C:
            break;
          case B: {
            {
              var J = c.memoizedProps, ne = J.onCommit, le = J.onRender, Ie = c.stateNode.effectDuration, ut = gD(), it = r === null ? "mount" : "update";
              mD() && (it = "nested-update"), typeof le == "function" && le(c.memoizedProps.id, it, c.actualDuration, c.treeBaseDuration, c.actualStartTime, ut);
              {
                typeof ne == "function" && ne(c.memoizedProps.id, it, Ie, ut), mH(c);
                var $t = c.return;
                e: for (; $t !== null; ) {
                  switch ($t.tag) {
                    case S:
                      var jt = $t.stateNode;
                      jt.effectDuration += Ie;
                      break e;
                    case B:
                      var Q = $t.stateNode;
                      Q.effectDuration += Ie;
                      break e;
                  }
                  $t = $t.return;
                }
              }
            }
            break;
          }
          case V: {
            EB(n, c);
            break;
          }
          case ee:
          case ae:
          case oe:
          case se:
          case Pe:
          case Se:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      cr || c.flags & Yn && tk(c);
    }
    function bB(n) {
      switch (n.tag) {
        case m:
        case F:
        case Y: {
          if (n.mode & en)
            try {
              Ro(), ZD(n, n.return);
            } finally {
              Eo(n);
            }
          else
            ZD(n, n.return);
          break;
        }
        case v: {
          var r = n.stateNode;
          typeof r.componentDidMount == "function" && dB(n, n.return, r), JD(n, n.return);
          break;
        }
        case E: {
          JD(n, n.return);
          break;
        }
      }
    }
    function xB(n, r) {
      for (var c = null, d = n; ; ) {
        if (d.tag === E) {
          if (c === null) {
            c = d;
            try {
              var g = d.stateNode;
              r ? YF(g) : KF(d.stateNode, d.memoizedProps);
            } catch (w) {
              Mn(n, n.return, w);
            }
          }
        } else if (d.tag === D) {
          if (c === null)
            try {
              var x = d.stateNode;
              r ? GF(x) : XF(x, d.memoizedProps);
            } catch (w) {
              Mn(n, n.return, w);
            }
        } else if (!((d.tag === se || d.tag === Pe) && d.memoizedState !== null && d !== n)) {
          if (d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
        }
        if (d === n)
          return;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === n)
            return;
          c === d && (c = null), d = d.return;
        }
        c === d && (c = null), d.sibling.return = d.return, d = d.sibling;
      }
    }
    function tk(n) {
      var r = n.ref;
      if (r !== null) {
        var c = n.stateNode, d;
        switch (n.tag) {
          case E:
            d = c;
            break;
          default:
            d = c;
        }
        if (typeof r == "function") {
          var g;
          if (n.mode & en)
            try {
              Ro(), g = r(d);
            } finally {
              Eo(n);
            }
          else
            g = r(d);
          typeof g == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", kt(n));
        } else
          r.hasOwnProperty("current") || u("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", kt(n)), r.current = d;
      }
    }
    function SB(n) {
      var r = n.alternate;
      r !== null && (r.return = null), n.return = null;
    }
    function nk(n) {
      var r = n.alternate;
      r !== null && (n.alternate = null, nk(r));
      {
        if (n.child = null, n.deletions = null, n.sibling = null, n.tag === E) {
          var c = n.stateNode;
          c !== null && RV(c);
        }
        n.stateNode = null, n._debugOwner = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
      }
    }
    function _B(n) {
      for (var r = n.return; r !== null; ) {
        if (ik(r))
          return r;
        r = r.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ik(n) {
      return n.tag === E || n.tag === S || n.tag === C;
    }
    function rk(n) {
      var r = n;
      e: for (; ; ) {
        for (; r.sibling === null; ) {
          if (r.return === null || ik(r.return))
            return null;
          r = r.return;
        }
        for (r.sibling.return = r.return, r = r.sibling; r.tag !== E && r.tag !== D && r.tag !== ie; ) {
          if (r.flags & qn || r.child === null || r.tag === C)
            continue e;
          r.child.return = r, r = r.child;
        }
        if (!(r.flags & qn))
          return r.stateNode;
      }
    }
    function CB(n) {
      var r = _B(n);
      switch (r.tag) {
        case E: {
          var c = r.stateNode;
          r.flags & Aa && (sR(c), r.flags &= -33);
          var d = rk(n);
          sw(n, d, c);
          break;
        }
        case S:
        case C: {
          var g = r.stateNode.containerInfo, x = rk(n);
          aw(n, x, g);
          break;
        }
        // eslint-disable-next-line-no-fallthrough
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function aw(n, r, c) {
      var d = n.tag, g = d === E || d === D;
      if (g) {
        var x = n.stateNode;
        r ? UF(c, x, r) : BF(c, x);
      } else if (d !== C) {
        var w = n.child;
        if (w !== null) {
          aw(w, r, c);
          for (var R = w.sibling; R !== null; )
            aw(R, r, c), R = R.sibling;
        }
      }
    }
    function sw(n, r, c) {
      var d = n.tag, g = d === E || d === D;
      if (g) {
        var x = n.stateNode;
        r ? HF(c, x, r) : jF(c, x);
      } else if (d !== C) {
        var w = n.child;
        if (w !== null) {
          sw(w, r, c);
          for (var R = w.sibling; R !== null; )
            sw(R, r, c), R = R.sibling;
        }
      }
    }
    var fr = null, $s = !1;
    function wB(n, r, c) {
      {
        var d = r;
        e: for (; d !== null; ) {
          switch (d.tag) {
            case E: {
              fr = d.stateNode, $s = !1;
              break e;
            }
            case S: {
              fr = d.stateNode.containerInfo, $s = !0;
              break e;
            }
            case C: {
              fr = d.stateNode.containerInfo, $s = !0;
              break e;
            }
          }
          d = d.return;
        }
        if (fr === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        ak(n, r, c), fr = null, $s = !1;
      }
      SB(c);
    }
    function ju(n, r, c) {
      for (var d = c.child; d !== null; )
        ak(n, r, d), d = d.sibling;
    }
    function ak(n, r, c) {
      switch (rm(c), c.tag) {
        case E:
          cr || Vh(c, r);
        // eslint-disable-next-line-no-fallthrough
        case D: {
          {
            var d = fr, g = $s;
            fr = null, ju(n, r, c), fr = d, $s = g, fr !== null && ($s ? $F(fr, c.stateNode) : IF(fr, c.stateNode));
          }
          return;
        }
        case ie: {
          fr !== null && ($s ? WF(fr, c.stateNode) : v_(fr, c.stateNode));
          return;
        }
        case C: {
          {
            var x = fr, w = $s;
            fr = c.stateNode.containerInfo, $s = !0, ju(n, r, c), fr = x, $s = w;
          }
          return;
        }
        case m:
        case F:
        case G:
        case Y: {
          if (!cr) {
            var R = c.updateQueue;
            if (R !== null) {
              var k = R.lastEffect;
              if (k !== null) {
                var L = k.next, z = L;
                do {
                  var W = z, I = W.destroy, J = W.tag;
                  I !== void 0 && ((J & Co) !== pa ? pb(c, r, I) : (J & ji) !== pa && (Ac(c), c.mode & en ? (Ro(), pb(c, r, I), Eo(c)) : pb(c, r, I), lm())), z = z.next;
                } while (z !== L);
              }
            }
          }
          ju(n, r, c);
          return;
        }
        case v: {
          if (!cr) {
            Vh(c, r);
            var ne = c.stateNode;
            typeof ne.componentWillUnmount == "function" && rw(c, r, ne);
          }
          ju(n, r, c);
          return;
        }
        case oe: {
          ju(n, r, c);
          return;
        }
        case se: {
          if (
            // TODO: Remove this dead flag
            c.mode & Nt
          ) {
            var le = cr;
            cr = le || c.memoizedState !== null, ju(n, r, c), cr = le;
          } else
            ju(n, r, c);
          break;
        }
        default: {
          ju(n, r, c);
          return;
        }
      }
    }
    function TB(n) {
      n.memoizedState;
    }
    function EB(n, r) {
      var c = r.memoizedState;
      if (c === null) {
        var d = r.alternate;
        if (d !== null) {
          var g = d.memoizedState;
          if (g !== null) {
            var x = g.dehydrated;
            x !== null && cV(x);
          }
        }
      }
    }
    function sk(n) {
      var r = n.updateQueue;
      if (r !== null) {
        n.updateQueue = null;
        var c = n.stateNode;
        c === null && (c = n.stateNode = new uB()), r.forEach(function(d) {
          var g = _H.bind(null, n, d);
          if (!c.has(d)) {
            if (c.add(d), Tr)
              if (zh !== null && Fh !== null)
                Mg(Fh, zh);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            d.then(g, g);
          }
        });
      }
    }
    function RB(n, r, c) {
      zh = c, Fh = n, kn(r), ok(r, n), kn(r), zh = null, Fh = null;
    }
    function Ws(n, r, c) {
      var d = r.deletions;
      if (d !== null)
        for (var g = 0; g < d.length; g++) {
          var x = d[g];
          try {
            wB(n, r, x);
          } catch (k) {
            Mn(x, r, k);
          }
        }
      var w = dc();
      if (r.subtreeFlags & so)
        for (var R = r.child; R !== null; )
          kn(R), ok(R, n), R = R.sibling;
      kn(w);
    }
    function ok(n, r, c) {
      var d = n.alternate, g = n.flags;
      switch (n.tag) {
        case m:
        case F:
        case G:
        case Y: {
          if (Ws(r, n), Do(n), g & Ht) {
            try {
              Is(Co | Vi, n, n.return), Vu(Co | Vi, n);
            } catch (vt) {
              Mn(n, n.return, vt);
            }
            if (n.mode & en) {
              try {
                Ro(), Is(ji | Vi, n, n.return);
              } catch (vt) {
                Mn(n, n.return, vt);
              }
              Eo(n);
            } else
              try {
                Is(ji | Vi, n, n.return);
              } catch (vt) {
                Mn(n, n.return, vt);
              }
          }
          return;
        }
        case v: {
          Ws(r, n), Do(n), g & Yn && d !== null && Vh(d, d.return);
          return;
        }
        case E: {
          Ws(r, n), Do(n), g & Yn && d !== null && Vh(d, d.return);
          {
            if (n.flags & Aa) {
              var x = n.stateNode;
              try {
                sR(x);
              } catch (vt) {
                Mn(n, n.return, vt);
              }
            }
            if (g & Ht) {
              var w = n.stateNode;
              if (w != null) {
                var R = n.memoizedProps, k = d !== null ? d.memoizedProps : R, L = n.type, z = n.updateQueue;
                if (n.updateQueue = null, z !== null)
                  try {
                    FF(w, z, L, k, R, n);
                  } catch (vt) {
                    Mn(n, n.return, vt);
                  }
              }
            }
          }
          return;
        }
        case D: {
          if (Ws(r, n), Do(n), g & Ht) {
            if (n.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var W = n.stateNode, I = n.memoizedProps, J = d !== null ? d.memoizedProps : I;
            try {
              VF(W, J, I);
            } catch (vt) {
              Mn(n, n.return, vt);
            }
          }
          return;
        }
        case S: {
          if (Ws(r, n), Do(n), g & Ht && d !== null) {
            var ne = d.memoizedState;
            if (ne.isDehydrated)
              try {
                uV(r.containerInfo);
              } catch (vt) {
                Mn(n, n.return, vt);
              }
          }
          return;
        }
        case C: {
          Ws(r, n), Do(n);
          return;
        }
        case V: {
          Ws(r, n), Do(n);
          var le = n.child;
          if (le.flags & li) {
            var Ie = le.stateNode, ut = le.memoizedState, it = ut !== null;
            if (Ie.isHidden = it, it) {
              var $t = le.alternate !== null && le.alternate.memoizedState !== null;
              $t || oH();
            }
          }
          if (g & Ht) {
            try {
              TB(n);
            } catch (vt) {
              Mn(n, n.return, vt);
            }
            sk(n);
          }
          return;
        }
        case se: {
          var jt = d !== null && d.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            n.mode & Nt
          ) {
            var Q = cr;
            cr = Q || jt, Ws(r, n), cr = Q;
          } else
            Ws(r, n);
          if (Do(n), g & li) {
            var ue = n.stateNode, q = n.memoizedState, Re = q !== null, Ke = n;
            if (ue.isHidden = Re, Re && !jt && (Ke.mode & Nt) !== st) {
              Je = Ke;
              for (var $e = Ke.child; $e !== null; )
                Je = $e, kB($e), $e = $e.sibling;
            }
            xB(Ke, Re);
          }
          return;
        }
        case ee: {
          Ws(r, n), Do(n), g & Ht && sk(n);
          return;
        }
        case oe:
          return;
        default: {
          Ws(r, n), Do(n);
          return;
        }
      }
    }
    function Do(n) {
      var r = n.flags;
      if (r & qn) {
        try {
          CB(n);
        } catch (c) {
          Mn(n, n.return, c);
        }
        n.flags &= -3;
      }
      r & ra && (n.flags &= -4097);
    }
    function DB(n, r, c) {
      zh = c, Fh = r, Je = n, lk(n, r, c), zh = null, Fh = null;
    }
    function lk(n, r, c) {
      for (var d = (n.mode & Nt) !== st; Je !== null; ) {
        var g = Je, x = g.child;
        if (g.tag === se && d) {
          var w = g.memoizedState !== null, R = w || hb;
          if (R) {
            ow(n, r, c);
            continue;
          } else {
            var k = g.alternate, L = k !== null && k.memoizedState !== null, z = L || cr, W = hb, I = cr;
            hb = R, cr = z, cr && !I && (Je = g, MB(g));
            for (var J = x; J !== null; )
              Je = J, lk(
                J,
                // New root; bubble back up to here and stop.
                r,
                c
              ), J = J.sibling;
            Je = g, hb = W, cr = I, ow(n, r, c);
            continue;
          }
        }
        (g.subtreeFlags & oo) !== at && x !== null ? (x.return = g, Je = x) : ow(n, r, c);
      }
    }
    function ow(n, r, c) {
      for (; Je !== null; ) {
        var d = Je;
        if ((d.flags & oo) !== at) {
          var g = d.alternate;
          kn(d);
          try {
            yB(r, g, d, c);
          } catch (w) {
            Mn(d, d.return, w);
          }
          Wn();
        }
        if (d === n) {
          Je = null;
          return;
        }
        var x = d.sibling;
        if (x !== null) {
          x.return = d.return, Je = x;
          return;
        }
        Je = d.return;
      }
    }
    function kB(n) {
      for (; Je !== null; ) {
        var r = Je, c = r.child;
        switch (r.tag) {
          case m:
          case F:
          case G:
          case Y: {
            if (r.mode & en)
              try {
                Ro(), Is(ji, r, r.return);
              } finally {
                Eo(r);
              }
            else
              Is(ji, r, r.return);
            break;
          }
          case v: {
            Vh(r, r.return);
            var d = r.stateNode;
            typeof d.componentWillUnmount == "function" && rw(r, r.return, d);
            break;
          }
          case E: {
            Vh(r, r.return);
            break;
          }
          case se: {
            var g = r.memoizedState !== null;
            if (g) {
              uk(n);
              continue;
            }
            break;
          }
        }
        c !== null ? (c.return = r, Je = c) : uk(n);
      }
    }
    function uk(n) {
      for (; Je !== null; ) {
        var r = Je;
        if (r === n) {
          Je = null;
          return;
        }
        var c = r.sibling;
        if (c !== null) {
          c.return = r.return, Je = c;
          return;
        }
        Je = r.return;
      }
    }
    function MB(n) {
      for (; Je !== null; ) {
        var r = Je, c = r.child;
        if (r.tag === se) {
          var d = r.memoizedState !== null;
          if (d) {
            ck(n);
            continue;
          }
        }
        c !== null ? (c.return = r, Je = c) : ck(n);
      }
    }
    function ck(n) {
      for (; Je !== null; ) {
        var r = Je;
        kn(r);
        try {
          bB(r);
        } catch (d) {
          Mn(r, r.return, d);
        }
        if (Wn(), r === n) {
          Je = null;
          return;
        }
        var c = r.sibling;
        if (c !== null) {
          c.return = r.return, Je = c;
          return;
        }
        Je = r.return;
      }
    }
    function AB(n, r, c, d) {
      Je = r, OB(r, n, c, d);
    }
    function OB(n, r, c, d) {
      for (; Je !== null; ) {
        var g = Je, x = g.child;
        (g.subtreeFlags & Ds) !== at && x !== null ? (x.return = g, Je = x) : PB(n, r, c, d);
      }
    }
    function PB(n, r, c, d) {
      for (; Je !== null; ) {
        var g = Je;
        if ((g.flags & Sr) !== at) {
          kn(g);
          try {
            LB(r, g, c, d);
          } catch (w) {
            Mn(g, g.return, w);
          }
          Wn();
        }
        if (g === n) {
          Je = null;
          return;
        }
        var x = g.sibling;
        if (x !== null) {
          x.return = g.return, Je = x;
          return;
        }
        Je = g.return;
      }
    }
    function LB(n, r, c, d) {
      switch (r.tag) {
        case m:
        case F:
        case Y: {
          if (r.mode & en) {
            EC();
            try {
              Vu(lr | Vi, r);
            } finally {
              TC(r);
            }
          } else
            Vu(lr | Vi, r);
          break;
        }
      }
    }
    function NB(n) {
      Je = n, zB();
    }
    function zB() {
      for (; Je !== null; ) {
        var n = Je, r = n.child;
        if ((Je.flags & ia) !== at) {
          var c = n.deletions;
          if (c !== null) {
            for (var d = 0; d < c.length; d++) {
              var g = c[d];
              Je = g, jB(g, n);
            }
            {
              var x = n.alternate;
              if (x !== null) {
                var w = x.child;
                if (w !== null) {
                  x.child = null;
                  do {
                    var R = w.sibling;
                    w.sibling = null, w = R;
                  } while (w !== null);
                }
              }
            }
            Je = n;
          }
        }
        (n.subtreeFlags & Ds) !== at && r !== null ? (r.return = n, Je = r) : FB();
      }
    }
    function FB() {
      for (; Je !== null; ) {
        var n = Je;
        (n.flags & Sr) !== at && (kn(n), VB(n), Wn());
        var r = n.sibling;
        if (r !== null) {
          r.return = n.return, Je = r;
          return;
        }
        Je = n.return;
      }
    }
    function VB(n) {
      switch (n.tag) {
        case m:
        case F:
        case Y: {
          n.mode & en ? (EC(), Is(lr | Vi, n, n.return), TC(n)) : Is(lr | Vi, n, n.return);
          break;
        }
      }
    }
    function jB(n, r) {
      for (; Je !== null; ) {
        var c = Je;
        kn(c), HB(c, r), Wn();
        var d = c.child;
        d !== null ? (d.return = c, Je = d) : BB(n);
      }
    }
    function BB(n) {
      for (; Je !== null; ) {
        var r = Je, c = r.sibling, d = r.return;
        if (nk(r), r === n) {
          Je = null;
          return;
        }
        if (c !== null) {
          c.return = d, Je = c;
          return;
        }
        Je = d;
      }
    }
    function HB(n, r) {
      switch (n.tag) {
        case m:
        case F:
        case Y: {
          n.mode & en ? (EC(), Is(lr, n, r), TC(n)) : Is(lr, n, r);
          break;
        }
      }
    }
    function UB(n) {
      switch (n.tag) {
        case m:
        case F:
        case Y: {
          try {
            Vu(ji | Vi, n);
          } catch (c) {
            Mn(n, n.return, c);
          }
          break;
        }
        case v: {
          var r = n.stateNode;
          try {
            r.componentDidMount();
          } catch (c) {
            Mn(n, n.return, c);
          }
          break;
        }
      }
    }
    function IB(n) {
      switch (n.tag) {
        case m:
        case F:
        case Y: {
          try {
            Vu(lr | Vi, n);
          } catch (r) {
            Mn(n, n.return, r);
          }
          break;
        }
      }
    }
    function $B(n) {
      switch (n.tag) {
        case m:
        case F:
        case Y: {
          try {
            Is(ji | Vi, n, n.return);
          } catch (c) {
            Mn(n, n.return, c);
          }
          break;
        }
        case v: {
          var r = n.stateNode;
          typeof r.componentWillUnmount == "function" && rw(n, n.return, r);
          break;
        }
      }
    }
    function WB(n) {
      switch (n.tag) {
        case m:
        case F:
        case Y:
          try {
            Is(lr | Vi, n, n.return);
          } catch (r) {
            Mn(n, n.return, r);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var bg = Symbol.for;
      bg("selector.component"), bg("selector.has_pseudo_class"), bg("selector.role"), bg("selector.test_id"), bg("selector.text");
    }
    var YB = [];
    function GB() {
      YB.forEach(function(n) {
        return n();
      });
    }
    var KB = i.ReactCurrentActQueue;
    function XB(n) {
      {
        var r = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), c = typeof jest < "u";
        return c && r !== !1;
      }
    }
    function fk() {
      {
        var n = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !n && KB.current !== null && u("The current testing environment is not configured to support act(...)"), n;
      }
    }
    var QB = Math.ceil, lw = i.ReactCurrentDispatcher, uw = i.ReactCurrentOwner, dr = i.ReactCurrentBatchConfig, Ys = i.ReactCurrentActQueue, Ui = (
      /*             */
      0
    ), dk = (
      /*               */
      1
    ), hr = (
      /*                */
      2
    ), fs = (
      /*                */
      4
    ), Al = 0, xg = 1, Cf = 2, mb = 3, Sg = 4, hk = 5, cw = 6, It = Ui, Xr = null, ii = null, Ii = be, ko = be, fw = ku(be), $i = Al, _g = null, gb = be, Cg = be, vb = be, wg = null, ma = null, dw = 0, pk = 500, mk = 1 / 0, qB = 500, Ol = null;
    function Tg() {
      mk = bi() + qB;
    }
    function gk() {
      return mk;
    }
    var yb = !1, hw = null, jh = null, wf = !1, Bu = null, Eg = be, pw = [], mw = null, ZB = 50, Rg = 0, gw = null, vw = !1, bb = !1, JB = 50, Bh = 0, xb = null, Dg = bn, Sb = be, vk = !1;
    function _b() {
      return Xr;
    }
    function Qr() {
      return (It & (hr | fs)) !== Ui ? bi() : (Dg !== bn || (Dg = bi()), Dg);
    }
    function Hu(n) {
      var r = n.mode;
      if ((r & Nt) === st)
        return mt;
      if ((It & hr) !== Ui && Ii !== be)
        return $c(Ii);
      var c = KV() !== GV;
      if (c) {
        if (dr.transition !== null) {
          var d = dr.transition;
          d._updatedFibers || (d._updatedFibers = /* @__PURE__ */ new Set()), d._updatedFibers.add(n);
        }
        return Sb === Zt && (Sb = gm()), Sb;
      }
      var g = ca();
      if (g !== Zt)
        return g;
      var x = OF();
      return x;
    }
    function eH(n) {
      var r = n.mode;
      return (r & Nt) === st ? mt : Ey();
    }
    function Wi(n, r, c, d) {
      wH(), vk && u("useInsertionEffect must not schedule updates."), vw && (bb = !0), yu(n, c, d), (It & hr) !== be && n === Xr ? RH(r) : (Tr && Gc(n, r, c), DH(r), n === Xr && ((It & hr) === Ui && (Cg = Mt(Cg, c)), $i === Sg && Uu(n, Ii)), ga(n, d), c === mt && It === Ui && (r.mode & Nt) === st && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Ys.isBatchingLegacy && (Tg(), vR()));
    }
    function tH(n, r, c) {
      var d = n.current;
      d.lanes = r, yu(n, r, c), ga(n, c);
    }
    function nH(n) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (It & hr) !== Ui
      );
    }
    function ga(n, r) {
      var c = n.callbackNode;
      Xd(n, r);
      var d = Kd(n, n === Xr ? Ii : be);
      if (d === be) {
        c !== null && Pk(c), n.callbackNode = null, n.callbackPriority = Zt;
        return;
      }
      var g = ho(d), x = n.callbackPriority;
      if (x === g && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Ys.current !== null && c !== ww)) {
        c == null && x !== mt && u("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      c != null && Pk(c);
      var w;
      if (g === mt)
        n.tag === Mu ? (Ys.isBatchingLegacy !== null && (Ys.didScheduleLegacyUpdate = !0), MV(xk.bind(null, n))) : gR(xk.bind(null, n)), Ys.current !== null ? Ys.current.push(Au) : LF(function() {
          (It & (hr | fs)) === Ui && Au();
        }), w = null;
      else {
        var R;
        switch (Py(d)) {
          case nr:
            R = Mc;
            break;
          case ts:
            R = lo;
            break;
          case la:
            R = ks;
            break;
          case ua:
            R = al;
            break;
          default:
            R = ks;
            break;
        }
        w = Tw(R, yk.bind(null, n));
      }
      n.callbackPriority = g, n.callbackNode = w;
    }
    function yk(n, r) {
      if (xj(), Dg = bn, Sb = be, (It & (hr | fs)) !== Ui)
        throw new Error("Should not already be working.");
      var c = n.callbackNode, d = Ll();
      if (d && n.callbackNode !== c)
        return null;
      var g = Kd(n, n === Xr ? Ii : be);
      if (g === be)
        return null;
      var x = !qd(n, g) && !Ty(n, g) && !r, w = x ? dH(n, g) : wb(n, g);
      if (w !== Al) {
        if (w === Cf) {
          var R = Qd(n);
          R !== be && (g = R, w = yw(n, R));
        }
        if (w === xg) {
          var k = _g;
          throw Tf(n, be), Uu(n, g), ga(n, bi()), k;
        }
        if (w === cw)
          Uu(n, g);
        else {
          var L = !qd(n, g), z = n.current.alternate;
          if (L && !rH(z)) {
            if (w = wb(n, g), w === Cf) {
              var W = Qd(n);
              W !== be && (g = W, w = yw(n, W));
            }
            if (w === xg) {
              var I = _g;
              throw Tf(n, be), Uu(n, g), ga(n, bi()), I;
            }
          }
          n.finishedWork = z, n.finishedLanes = g, iH(n, w, g);
        }
      }
      return ga(n, bi()), n.callbackNode === c ? yk.bind(null, n) : null;
    }
    function yw(n, r) {
      var c = wg;
      if (eh(n)) {
        var d = Tf(n, r);
        d.flags |= xr, CV(n.containerInfo);
      }
      var g = wb(n, r);
      if (g !== Cf) {
        var x = ma;
        ma = c, x !== null && bk(x);
      }
      return g;
    }
    function bk(n) {
      ma === null ? ma = n : ma.push.apply(ma, n);
    }
    function iH(n, r, c) {
      switch (r) {
        case Al:
        case xg:
          throw new Error("Root did not complete. This is a bug in React.");
        // Flow knows about invariant, so it complains if I add a break
        // statement, but eslint doesn't know about invariant, so it complains
        // if I do. eslint-disable-next-line no-fallthrough
        case Cf: {
          Ef(n, ma, Ol);
          break;
        }
        case mb: {
          if (Uu(n, c), gl(c) && // do not delay if we're inside an act() scope
          !Lk()) {
            var d = dw + pk - bi();
            if (d > 10) {
              var g = Kd(n, be);
              if (g !== be)
                break;
              var x = n.suspendedLanes;
              if (!vl(x, c)) {
                Qr(), Zd(n, x);
                break;
              }
              n.timeoutHandle = m_(Ef.bind(null, n, ma, Ol), d);
              break;
            }
          }
          Ef(n, ma, Ol);
          break;
        }
        case Sg: {
          if (Uu(n, c), pm(c))
            break;
          if (!Lk()) {
            var w = Pa(n, c), R = w, k = bi() - R, L = CH(k) - k;
            if (L > 10) {
              n.timeoutHandle = m_(Ef.bind(null, n, ma, Ol), L);
              break;
            }
          }
          Ef(n, ma, Ol);
          break;
        }
        case hk: {
          Ef(n, ma, Ol);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function rH(n) {
      for (var r = n; ; ) {
        if (r.flags & hu) {
          var c = r.updateQueue;
          if (c !== null) {
            var d = c.stores;
            if (d !== null)
              for (var g = 0; g < d.length; g++) {
                var x = d[g], w = x.getSnapshot, R = x.value;
                try {
                  if (!Ce(w(), R))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var k = r.child;
        if (r.subtreeFlags & hu && k !== null) {
          k.return = r, r = k;
          continue;
        }
        if (r === n)
          return !0;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === n)
            return !0;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return !0;
    }
    function Uu(n, r) {
      r = Wc(r, vb), r = Wc(r, Cg), ky(n, r);
    }
    function xk(n) {
      if (Sj(), (It & (hr | fs)) !== Ui)
        throw new Error("Should not already be working.");
      Ll();
      var r = Kd(n, be);
      if (!Er(r, mt))
        return ga(n, bi()), null;
      var c = wb(n, r);
      if (n.tag !== Mu && c === Cf) {
        var d = Qd(n);
        d !== be && (r = d, c = yw(n, d));
      }
      if (c === xg) {
        var g = _g;
        throw Tf(n, be), Uu(n, r), ga(n, bi()), g;
      }
      if (c === cw)
        throw new Error("Root did not complete. This is a bug in React.");
      var x = n.current.alternate;
      return n.finishedWork = x, n.finishedLanes = r, Ef(n, ma, Ol), ga(n, bi()), null;
    }
    function aH(n, r) {
      r !== be && (Jd(n, Mt(r, mt)), ga(n, bi()), (It & (hr | fs)) === Ui && (Tg(), Au()));
    }
    function bw(n, r) {
      var c = It;
      It |= dk;
      try {
        return n(r);
      } finally {
        It = c, It === Ui && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Ys.isBatchingLegacy && (Tg(), vR());
      }
    }
    function sH(n, r, c, d, g) {
      var x = ca(), w = dr.transition;
      try {
        return dr.transition = null, di(nr), n(r, c, d, g);
      } finally {
        di(x), dr.transition = w, It === Ui && Tg();
      }
    }
    function Pl(n) {
      Bu !== null && Bu.tag === Mu && (It & (hr | fs)) === Ui && Ll();
      var r = It;
      It |= dk;
      var c = dr.transition, d = ca();
      try {
        return dr.transition = null, di(nr), n ? n() : void 0;
      } finally {
        di(d), dr.transition = c, It = r, (It & (hr | fs)) === Ui && Au();
      }
    }
    function Sk() {
      return (It & (hr | fs)) !== Ui;
    }
    function Cb(n, r) {
      Ar(fw, ko, n), ko = Mt(ko, r);
    }
    function xw(n) {
      ko = fw.current, Mr(fw, n);
    }
    function Tf(n, r) {
      n.finishedWork = null, n.finishedLanes = be;
      var c = n.timeoutHandle;
      if (c !== g_ && (n.timeoutHandle = g_, PF(c)), ii !== null)
        for (var d = ii.return; d !== null; ) {
          var g = d.alternate;
          QD(g, d), d = d.return;
        }
      Xr = n;
      var x = Rf(n.current, null);
      return ii = x, Ii = ko = r, $i = Al, _g = null, gb = be, Cg = be, vb = be, wg = null, ma = null, tj(), Vs.discardPendingWarnings(), x;
    }
    function _k(n, r) {
      do {
        var c = ii;
        try {
          if (P0(), YR(), Wn(), uw.current = null, c === null || c.return === null) {
            $i = xg, _g = r, ii = null;
            return;
          }
          if (Ne && c.mode & en && lb(c, !0), Ae)
            if ($r(), r !== null && typeof r == "object" && typeof r.then == "function") {
              var d = r;
              es(c, d, Ii);
            } else
              Oc(c, r, Ii);
          Mj(n, c.return, c, r, Ii), Ek(c);
        } catch (g) {
          r = g, ii === c && c !== null ? (c = c.return, ii = c) : c = ii;
          continue;
        }
        return;
      } while (!0);
    }
    function Ck() {
      var n = lw.current;
      return lw.current = ib, n === null ? ib : n;
    }
    function wk(n) {
      lw.current = n;
    }
    function oH() {
      dw = bi();
    }
    function kg(n) {
      gb = Mt(n, gb);
    }
    function lH() {
      $i === Al && ($i = mb);
    }
    function Sw() {
      ($i === Al || $i === mb || $i === Cf) && ($i = Sg), Xr !== null && (Ic(gb) || Ic(Cg)) && Uu(Xr, Ii);
    }
    function uH(n) {
      $i !== Sg && ($i = Cf), wg === null ? wg = [n] : wg.push(n);
    }
    function cH() {
      return $i === Al;
    }
    function wb(n, r) {
      var c = It;
      It |= hr;
      var d = Ck();
      if (Xr !== n || Ii !== r) {
        if (Tr) {
          var g = n.memoizedUpdaters;
          g.size > 0 && (Mg(n, Ii), g.clear()), My(n, r);
        }
        Ol = xm(), Tf(n, r);
      }
      ul(r);
      do
        try {
          fH();
          break;
        } catch (x) {
          _k(n, x);
        }
      while (!0);
      if (P0(), It = c, wk(d), ii !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Md(), Xr = null, Ii = be, $i;
    }
    function fH() {
      for (; ii !== null; )
        Tk(ii);
    }
    function dH(n, r) {
      var c = It;
      It |= hr;
      var d = Ck();
      if (Xr !== n || Ii !== r) {
        if (Tr) {
          var g = n.memoizedUpdaters;
          g.size > 0 && (Mg(n, Ii), g.clear()), My(n, r);
        }
        Ol = xm(), Tg(), Tf(n, r);
      }
      ul(r);
      do
        try {
          hH();
          break;
        } catch (x) {
          _k(n, x);
        }
      while (!0);
      return P0(), wk(d), It = c, ii !== null ? (Sy(), Al) : (Md(), Xr = null, Ii = be, $i);
    }
    function hH() {
      for (; ii !== null && !Jp(); )
        Tk(ii);
    }
    function Tk(n) {
      var r = n.alternate;
      kn(n);
      var c;
      (n.mode & en) !== st ? (wC(n), c = _w(r, n, ko), lb(n, !0)) : c = _w(r, n, ko), Wn(), n.memoizedProps = n.pendingProps, c === null ? Ek(n) : ii = c, uw.current = null;
    }
    function Ek(n) {
      var r = n;
      do {
        var c = r.alternate, d = r.return;
        if ((r.flags & kc) === at) {
          kn(r);
          var g = void 0;
          if ((r.mode & en) === st ? g = XD(c, r, ko) : (wC(r), g = XD(c, r, ko), lb(r, !1)), Wn(), g !== null) {
            ii = g;
            return;
          }
        } else {
          var x = lB(c, r);
          if (x !== null) {
            x.flags &= my, ii = x;
            return;
          }
          if ((r.mode & en) !== st) {
            lb(r, !1);
            for (var w = r.actualDuration, R = r.child; R !== null; )
              w += R.actualDuration, R = R.sibling;
            r.actualDuration = w;
          }
          if (d !== null)
            d.flags |= kc, d.subtreeFlags = at, d.deletions = null;
          else {
            $i = cw, ii = null;
            return;
          }
        }
        var k = r.sibling;
        if (k !== null) {
          ii = k;
          return;
        }
        r = d, ii = r;
      } while (r !== null);
      $i === Al && ($i = hk);
    }
    function Ef(n, r, c) {
      var d = ca(), g = dr.transition;
      try {
        dr.transition = null, di(nr), pH(n, r, c, d);
      } finally {
        dr.transition = g, di(d);
      }
      return null;
    }
    function pH(n, r, c, d) {
      do
        Ll();
      while (Bu !== null);
      if (TH(), (It & (hr | fs)) !== Ui)
        throw new Error("Should not already be working.");
      var g = n.finishedWork, x = n.finishedLanes;
      if (am(x), g === null)
        return sm(), null;
      if (x === be && u("root.finishedLanes should not be empty during a commit. This is a bug in React."), n.finishedWork = null, n.finishedLanes = be, g === n.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      n.callbackNode = null, n.callbackPriority = Zt;
      var w = Mt(g.lanes, g.childLanes);
      ym(n, w), n === Xr && (Xr = null, ii = null, Ii = be), ((g.subtreeFlags & Ds) !== at || (g.flags & Ds) !== at) && (wf || (wf = !0, mw = c, Tw(ks, function() {
        return Ll(), null;
      })));
      var R = (g.subtreeFlags & (ao | so | oo | Ds)) !== at, k = (g.flags & (ao | so | oo | Ds)) !== at;
      if (R || k) {
        var L = dr.transition;
        dr.transition = null;
        var z = ca();
        di(nr);
        var W = It;
        It |= fs, uw.current = null, hB(n, g), vD(), RB(n, g, x), EF(n.containerInfo), n.current = g, Pc(x), DB(g, n, x), Lc(), em(), It = W, di(z), dr.transition = L;
      } else
        n.current = g, vD();
      var I = wf;
      if (wf ? (wf = !1, Bu = n, Eg = x) : (Bh = 0, xb = null), w = n.pendingLanes, w === be && (jh = null), I || Mk(n.current, !1), nm(g.stateNode, d), Tr && n.memoizedUpdaters.clear(), GB(), ga(n, bi()), r !== null)
        for (var J = n.onRecoverableError, ne = 0; ne < r.length; ne++) {
          var le = r[ne], Ie = le.stack, ut = le.digest;
          J(le.value, {
            componentStack: Ie,
            digest: ut
          });
        }
      if (yb) {
        yb = !1;
        var it = hw;
        throw hw = null, it;
      }
      return Er(Eg, mt) && n.tag !== Mu && Ll(), w = n.pendingLanes, Er(w, mt) ? (bj(), n === gw ? Rg++ : (Rg = 0, gw = n)) : Rg = 0, Au(), sm(), null;
    }
    function Ll() {
      if (Bu !== null) {
        var n = Py(Eg), r = Xc(la, n), c = dr.transition, d = ca();
        try {
          return dr.transition = null, di(r), gH();
        } finally {
          di(d), dr.transition = c;
        }
      }
      return !1;
    }
    function mH(n) {
      pw.push(n), wf || (wf = !0, Tw(ks, function() {
        return Ll(), null;
      }));
    }
    function gH() {
      if (Bu === null)
        return !1;
      var n = mw;
      mw = null;
      var r = Bu, c = Eg;
      if (Bu = null, Eg = be, (It & (hr | fs)) !== Ui)
        throw new Error("Cannot flush passive effects while already rendering.");
      vw = !0, bb = !1, ll(c);
      var d = It;
      It |= fs, NB(r.current), AB(r, r.current, c, n);
      {
        var g = pw;
        pw = [];
        for (var x = 0; x < g.length; x++) {
          var w = g[x];
          vB(r, w);
        }
      }
      um(), Mk(r.current, !0), It = d, Au(), bb ? r === xb ? Bh++ : (Bh = 0, xb = r) : Bh = 0, vw = !1, bb = !1, im(r);
      {
        var R = r.current.stateNode;
        R.effectDuration = 0, R.passiveEffectDuration = 0;
      }
      return !0;
    }
    function Rk(n) {
      return jh !== null && jh.has(n);
    }
    function vH(n) {
      jh === null ? jh = /* @__PURE__ */ new Set([n]) : jh.add(n);
    }
    function yH(n) {
      yb || (yb = !0, hw = n);
    }
    var bH = yH;
    function Dk(n, r, c) {
      var d = Sf(c, r), g = TD(n, d, mt), x = Pu(n, g, mt), w = Qr();
      x !== null && (yu(x, mt, w), ga(x, w));
    }
    function Mn(n, r, c) {
      if (cB(c), Ag(!1), n.tag === S) {
        Dk(n, n, c);
        return;
      }
      var d = null;
      for (d = r; d !== null; ) {
        if (d.tag === S) {
          Dk(d, n, c);
          return;
        } else if (d.tag === v) {
          var g = d.type, x = d.stateNode;
          if (typeof g.getDerivedStateFromError == "function" || typeof x.componentDidCatch == "function" && !Rk(x)) {
            var w = Sf(c, n), R = UC(d, w, mt), k = Pu(d, R, mt), L = Qr();
            k !== null && (yu(k, mt, L), ga(k, L));
            return;
          }
        }
        d = d.return;
      }
      u(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, c);
    }
    function xH(n, r, c) {
      var d = n.pingCache;
      d !== null && d.delete(r);
      var g = Qr();
      Zd(n, c), kH(n), Xr === n && vl(Ii, c) && ($i === Sg || $i === mb && gl(Ii) && bi() - dw < pk ? Tf(n, be) : vb = Mt(vb, c)), ga(n, g);
    }
    function kk(n, r) {
      r === Zt && (r = eH(n));
      var c = Qr(), d = ha(n, r);
      d !== null && (yu(d, r, c), ga(d, c));
    }
    function SH(n) {
      var r = n.memoizedState, c = Zt;
      r !== null && (c = r.retryLane), kk(n, c);
    }
    function _H(n, r) {
      var c = Zt, d;
      switch (n.tag) {
        case V:
          d = n.stateNode;
          var g = n.memoizedState;
          g !== null && (c = g.retryLane);
          break;
        case ee:
          d = n.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      d !== null && d.delete(r), kk(n, c);
    }
    function CH(n) {
      return n < 120 ? 120 : n < 480 ? 480 : n < 1080 ? 1080 : n < 1920 ? 1920 : n < 3e3 ? 3e3 : n < 4320 ? 4320 : QB(n / 1960) * 1960;
    }
    function wH() {
      if (Rg > ZB)
        throw Rg = 0, gw = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Bh > JB && (Bh = 0, xb = null, u("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function TH() {
      Vs.flushLegacyContextWarning(), Vs.flushPendingUnsafeLifecycleWarnings();
    }
    function Mk(n, r) {
      kn(n), Tb(n, ro, $B), r && Tb(n, qa, WB), Tb(n, ro, UB), r && Tb(n, qa, IB), Wn();
    }
    function Tb(n, r, c) {
      for (var d = n, g = null; d !== null; ) {
        var x = d.subtreeFlags & r;
        d !== g && d.child !== null && x !== at ? d = d.child : ((d.flags & r) !== at && c(d), d.sibling !== null ? d = d.sibling : d = g = d.return);
      }
    }
    var Eb = null;
    function Ak(n) {
      {
        if ((It & hr) !== Ui || !(n.mode & Nt))
          return;
        var r = n.tag;
        if (r !== b && r !== S && r !== v && r !== m && r !== F && r !== G && r !== Y)
          return;
        var c = kt(n) || "ReactComponent";
        if (Eb !== null) {
          if (Eb.has(c))
            return;
          Eb.add(c);
        } else
          Eb = /* @__PURE__ */ new Set([c]);
        var d = tr;
        try {
          kn(n), u("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          d ? kn(n) : Wn();
        }
      }
    }
    var _w;
    {
      var EH = null;
      _w = function(n, r, c) {
        var d = jk(EH, r);
        try {
          return $D(n, r, c);
        } catch (x) {
          if (VV() || x !== null && typeof x == "object" && typeof x.then == "function")
            throw x;
          if (P0(), YR(), QD(n, r), jk(r, d), r.mode & en && wC(r), io(null, $D, null, n, r, c), Es()) {
            var g = Dc();
            typeof g == "object" && g !== null && g._suppressLogging && typeof x == "object" && x !== null && !x._suppressLogging && (x._suppressLogging = !0);
          }
          throw x;
        }
      };
    }
    var Ok = !1, Cw;
    Cw = /* @__PURE__ */ new Set();
    function RH(n) {
      if (qs && !gj())
        switch (n.tag) {
          case m:
          case F:
          case Y: {
            var r = ii && kt(ii) || "Unknown", c = r;
            if (!Cw.has(c)) {
              Cw.add(c);
              var d = kt(n) || "Unknown";
              u("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", d, r, r);
            }
            break;
          }
          case v: {
            Ok || (u("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), Ok = !0);
            break;
          }
        }
    }
    function Mg(n, r) {
      if (Tr) {
        var c = n.memoizedUpdaters;
        c.forEach(function(d) {
          Gc(n, d, r);
        });
      }
    }
    var ww = {};
    function Tw(n, r) {
      {
        var c = Ys.current;
        return c !== null ? (c.push(r), ww) : Zp(n, r);
      }
    }
    function Pk(n) {
      if (n !== ww)
        return vy(n);
    }
    function Lk() {
      return Ys.current !== null;
    }
    function DH(n) {
      {
        if (n.mode & Nt) {
          if (!fk())
            return;
        } else if (!XB() || It !== Ui || n.tag !== m && n.tag !== F && n.tag !== Y)
          return;
        if (Ys.current === null) {
          var r = tr;
          try {
            kn(n), u(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, kt(n));
          } finally {
            r ? kn(n) : Wn();
          }
        }
      }
    }
    function kH(n) {
      n.tag !== Mu && fk() && Ys.current === null && u(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Ag(n) {
      vk = n;
    }
    var ds = null, Hh = null, MH = function(n) {
      ds = n;
    };
    function Uh(n) {
      {
        if (ds === null)
          return n;
        var r = ds(n);
        return r === void 0 ? n : r.current;
      }
    }
    function Ew(n) {
      return Uh(n);
    }
    function Rw(n) {
      {
        if (ds === null)
          return n;
        var r = ds(n);
        if (r === void 0) {
          if (n != null && typeof n.render == "function") {
            var c = Uh(n.render);
            if (n.render !== c) {
              var d = {
                $$typeof: ve,
                render: c
              };
              return n.displayName !== void 0 && (d.displayName = n.displayName), d;
            }
          }
          return n;
        }
        return r.current;
      }
    }
    function Nk(n, r) {
      {
        if (ds === null)
          return !1;
        var c = n.elementType, d = r.type, g = !1, x = typeof d == "object" && d !== null ? d.$$typeof : null;
        switch (n.tag) {
          case v: {
            typeof d == "function" && (g = !0);
            break;
          }
          case m: {
            (typeof d == "function" || x === wt) && (g = !0);
            break;
          }
          case F: {
            (x === ve || x === wt) && (g = !0);
            break;
          }
          case G:
          case Y: {
            (x === lt || x === wt) && (g = !0);
            break;
          }
          default:
            return !1;
        }
        if (g) {
          var w = ds(c);
          if (w !== void 0 && w === ds(d))
            return !0;
        }
        return !1;
      }
    }
    function zk(n) {
      {
        if (ds === null || typeof WeakSet != "function")
          return;
        Hh === null && (Hh = /* @__PURE__ */ new WeakSet()), Hh.add(n);
      }
    }
    var AH = function(n, r) {
      {
        if (ds === null)
          return;
        var c = r.staleFamilies, d = r.updatedFamilies;
        Ll(), Pl(function() {
          Dw(n.current, d, c);
        });
      }
    }, OH = function(n, r) {
      {
        if (n.context !== za)
          return;
        Ll(), Pl(function() {
          Og(r, n, null, null);
        });
      }
    };
    function Dw(n, r, c) {
      {
        var d = n.alternate, g = n.child, x = n.sibling, w = n.tag, R = n.type, k = null;
        switch (w) {
          case m:
          case Y:
          case v:
            k = R;
            break;
          case F:
            k = R.render;
            break;
        }
        if (ds === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var L = !1, z = !1;
        if (k !== null) {
          var W = ds(k);
          W !== void 0 && (c.has(W) ? z = !0 : r.has(W) && (w === v ? z = !0 : L = !0));
        }
        if (Hh !== null && (Hh.has(n) || d !== null && Hh.has(d)) && (z = !0), z && (n._debugNeedsRemount = !0), z || L) {
          var I = ha(n, mt);
          I !== null && Wi(I, n, mt, bn);
        }
        g !== null && !z && Dw(g, r, c), x !== null && Dw(x, r, c);
      }
    }
    var PH = function(n, r) {
      {
        var c = /* @__PURE__ */ new Set(), d = new Set(r.map(function(g) {
          return g.current;
        }));
        return kw(n.current, d, c), c;
      }
    };
    function kw(n, r, c) {
      {
        var d = n.child, g = n.sibling, x = n.tag, w = n.type, R = null;
        switch (x) {
          case m:
          case Y:
          case v:
            R = w;
            break;
          case F:
            R = w.render;
            break;
        }
        var k = !1;
        R !== null && r.has(R) && (k = !0), k ? LH(n, c) : d !== null && kw(d, r, c), g !== null && kw(g, r, c);
      }
    }
    function LH(n, r) {
      {
        var c = NH(n, r);
        if (c)
          return;
        for (var d = n; ; ) {
          switch (d.tag) {
            case E:
              r.add(d.stateNode);
              return;
            case C:
              r.add(d.stateNode.containerInfo);
              return;
            case S:
              r.add(d.stateNode.containerInfo);
              return;
          }
          if (d.return === null)
            throw new Error("Expected to reach root first.");
          d = d.return;
        }
      }
    }
    function NH(n, r) {
      for (var c = n, d = !1; ; ) {
        if (c.tag === E)
          d = !0, r.add(c.stateNode);
        else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === n)
          return d;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === n)
            return d;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return !1;
    }
    var Mw;
    {
      Mw = !1;
      try {
        var Fk = Object.preventExtensions({});
      } catch {
        Mw = !0;
      }
    }
    function zH(n, r, c, d) {
      this.tag = n, this.key = c, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = r, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = d, this.flags = at, this.subtreeFlags = at, this.deletions = null, this.lanes = be, this.childLanes = be, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Mw && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Fa = function(n, r, c, d) {
      return new zH(n, r, c, d);
    };
    function Aw(n) {
      var r = n.prototype;
      return !!(r && r.isReactComponent);
    }
    function FH(n) {
      return typeof n == "function" && !Aw(n) && n.defaultProps === void 0;
    }
    function VH(n) {
      if (typeof n == "function")
        return Aw(n) ? v : m;
      if (n != null) {
        var r = n.$$typeof;
        if (r === ve)
          return F;
        if (r === lt)
          return G;
      }
      return b;
    }
    function Rf(n, r) {
      var c = n.alternate;
      c === null ? (c = Fa(n.tag, r, n.key, n.mode), c.elementType = n.elementType, c.type = n.type, c.stateNode = n.stateNode, c._debugSource = n._debugSource, c._debugOwner = n._debugOwner, c._debugHookTypes = n._debugHookTypes, c.alternate = n, n.alternate = c) : (c.pendingProps = r, c.type = n.type, c.flags = at, c.subtreeFlags = at, c.deletions = null, c.actualDuration = 0, c.actualStartTime = -1), c.flags = n.flags & ui, c.childLanes = n.childLanes, c.lanes = n.lanes, c.child = n.child, c.memoizedProps = n.memoizedProps, c.memoizedState = n.memoizedState, c.updateQueue = n.updateQueue;
      var d = n.dependencies;
      switch (c.dependencies = d === null ? null : {
        lanes: d.lanes,
        firstContext: d.firstContext
      }, c.sibling = n.sibling, c.index = n.index, c.ref = n.ref, c.selfBaseDuration = n.selfBaseDuration, c.treeBaseDuration = n.treeBaseDuration, c._debugNeedsRemount = n._debugNeedsRemount, c.tag) {
        case b:
        case m:
        case Y:
          c.type = Uh(n.type);
          break;
        case v:
          c.type = Ew(n.type);
          break;
        case F:
          c.type = Rw(n.type);
          break;
      }
      return c;
    }
    function jH(n, r) {
      n.flags &= ui | qn;
      var c = n.alternate;
      if (c === null)
        n.childLanes = be, n.lanes = r, n.child = null, n.subtreeFlags = at, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null, n.selfBaseDuration = 0, n.treeBaseDuration = 0;
      else {
        n.childLanes = c.childLanes, n.lanes = c.lanes, n.child = c.child, n.subtreeFlags = at, n.deletions = null, n.memoizedProps = c.memoizedProps, n.memoizedState = c.memoizedState, n.updateQueue = c.updateQueue, n.type = c.type;
        var d = c.dependencies;
        n.dependencies = d === null ? null : {
          lanes: d.lanes,
          firstContext: d.firstContext
        }, n.selfBaseDuration = c.selfBaseDuration, n.treeBaseDuration = c.treeBaseDuration;
      }
      return n;
    }
    function BH(n, r, c) {
      var d;
      return n === C0 ? (d = Nt, r === !0 && (d |= mn, d |= tn)) : d = st, Tr && (d |= en), Fa(S, null, null, d);
    }
    function Ow(n, r, c, d, g, x) {
      var w = b, R = n;
      if (typeof n == "function")
        Aw(n) ? (w = v, R = Ew(R)) : R = Uh(R);
      else if (typeof n == "string")
        w = E;
      else
        e: switch (n) {
          case wa:
            return Iu(c.children, g, x, r);
          case Br:
            w = A, g |= mn, (g & Nt) !== st && (g |= tn);
            break;
          case Ta:
            return HH(c, g, x, r);
          case Be:
            return UH(c, g, x, r);
          case ot:
            return IH(c, g, x, r);
          case vi:
            return Vk(c, g, x, r);
          case On:
          // eslint-disable-next-line no-fallthrough
          case Pt:
          // eslint-disable-next-line no-fallthrough
          case zn:
          // eslint-disable-next-line no-fallthrough
          case er:
          // eslint-disable-next-line no-fallthrough
          case Ft:
          // eslint-disable-next-line no-fallthrough
          default: {
            if (typeof n == "object" && n !== null)
              switch (n.$$typeof) {
                case Ea:
                  w = N;
                  break e;
                case H:
                  w = P;
                  break e;
                case ve:
                  w = F, R = Rw(R);
                  break e;
                case lt:
                  w = G;
                  break e;
                case wt:
                  w = K, R = null;
                  break e;
              }
            var k = "";
            {
              (n === void 0 || typeof n == "object" && n !== null && Object.keys(n).length === 0) && (k += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var L = d ? kt(d) : null;
              L && (k += `

Check the render method of \`` + L + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (n == null ? n : typeof n) + "." + k));
          }
        }
      var z = Fa(w, c, r, g);
      return z.elementType = n, z.type = R, z.lanes = x, z._debugOwner = d, z;
    }
    function Pw(n, r, c) {
      var d = null;
      d = n._owner;
      var g = n.type, x = n.key, w = n.props, R = Ow(g, x, w, d, r, c);
      return R._debugSource = n._source, R._debugOwner = n._owner, R;
    }
    function Iu(n, r, c, d) {
      var g = Fa(M, n, d, r);
      return g.lanes = c, g;
    }
    function HH(n, r, c, d) {
      typeof n.id != "string" && u('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof n.id);
      var g = Fa(B, n, d, r | en);
      return g.elementType = Ta, g.lanes = c, g.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, g;
    }
    function UH(n, r, c, d) {
      var g = Fa(V, n, d, r);
      return g.elementType = Be, g.lanes = c, g;
    }
    function IH(n, r, c, d) {
      var g = Fa(ee, n, d, r);
      return g.elementType = ot, g.lanes = c, g;
    }
    function Vk(n, r, c, d) {
      var g = Fa(se, n, d, r);
      g.elementType = vi, g.lanes = c;
      var x = {
        isHidden: !1
      };
      return g.stateNode = x, g;
    }
    function Lw(n, r, c) {
      var d = Fa(D, n, null, r);
      return d.lanes = c, d;
    }
    function $H() {
      var n = Fa(E, null, null, st);
      return n.elementType = "DELETED", n;
    }
    function WH(n) {
      var r = Fa(ie, null, null, st);
      return r.stateNode = n, r;
    }
    function Nw(n, r, c) {
      var d = n.children !== null ? n.children : [], g = Fa(C, d, n.key, r);
      return g.lanes = c, g.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: n.implementation
      }, g;
    }
    function jk(n, r) {
      return n === null && (n = Fa(b, null, null, st)), n.tag = r.tag, n.key = r.key, n.elementType = r.elementType, n.type = r.type, n.stateNode = r.stateNode, n.return = r.return, n.child = r.child, n.sibling = r.sibling, n.index = r.index, n.ref = r.ref, n.pendingProps = r.pendingProps, n.memoizedProps = r.memoizedProps, n.updateQueue = r.updateQueue, n.memoizedState = r.memoizedState, n.dependencies = r.dependencies, n.mode = r.mode, n.flags = r.flags, n.subtreeFlags = r.subtreeFlags, n.deletions = r.deletions, n.lanes = r.lanes, n.childLanes = r.childLanes, n.alternate = r.alternate, n.actualDuration = r.actualDuration, n.actualStartTime = r.actualStartTime, n.selfBaseDuration = r.selfBaseDuration, n.treeBaseDuration = r.treeBaseDuration, n._debugSource = r._debugSource, n._debugOwner = r._debugOwner, n._debugNeedsRemount = r._debugNeedsRemount, n._debugHookTypes = r._debugHookTypes, n;
    }
    function YH(n, r, c, d, g) {
      this.tag = r, this.containerInfo = n, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = g_, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Zt, this.eventTimes = Yc(be), this.expirationTimes = Yc(bn), this.pendingLanes = be, this.suspendedLanes = be, this.pingedLanes = be, this.expiredLanes = be, this.mutableReadLanes = be, this.finishedLanes = be, this.entangledLanes = be, this.entanglements = Yc(be), this.identifierPrefix = d, this.onRecoverableError = g, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var x = this.pendingUpdatersLaneMap = [], w = 0; w < cl; w++)
          x.push(/* @__PURE__ */ new Set());
      }
      switch (r) {
        case C0:
          this._debugRootType = c ? "hydrateRoot()" : "createRoot()";
          break;
        case Mu:
          this._debugRootType = c ? "hydrate()" : "render()";
          break;
      }
    }
    function Bk(n, r, c, d, g, x, w, R, k, L) {
      var z = new YH(n, r, c, R, k), W = BH(r, x);
      z.current = W, W.stateNode = z;
      {
        var I = {
          element: d,
          isDehydrated: c,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        W.memoizedState = I;
      }
      return K_(W), z;
    }
    var zw = "18.3.1";
    function GH(n, r, c) {
      var d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return on(d), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: $n,
        key: d == null ? null : "" + d,
        children: n,
        containerInfo: r,
        implementation: c
      };
    }
    var Fw, Vw;
    Fw = !1, Vw = {};
    function Hk(n) {
      if (!n)
        return za;
      var r = du(n), c = kV(r);
      if (r.tag === v) {
        var d = r.type;
        if (_o(d))
          return pR(r, d, c);
      }
      return c;
    }
    function KH(n, r) {
      {
        var c = du(n);
        if (c === void 0) {
          if (typeof n.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var d = Object.keys(n).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + d);
        }
        var g = Cr(c);
        if (g === null)
          return null;
        if (g.mode & mn) {
          var x = kt(c) || "Component";
          if (!Vw[x]) {
            Vw[x] = !0;
            var w = tr;
            try {
              kn(g), c.mode & mn ? u("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, x) : u("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, x);
            } finally {
              w ? kn(w) : Wn();
            }
          }
        }
        return g.stateNode;
      }
    }
    function Uk(n, r, c, d, g, x, w, R) {
      var k = !1, L = null;
      return Bk(n, r, k, L, c, d, g, x, w);
    }
    function Ik(n, r, c, d, g, x, w, R, k, L) {
      var z = !0, W = Bk(c, d, z, n, g, x, w, R, k);
      W.context = Hk(null);
      var I = W.current, J = Qr(), ne = Hu(I), le = kl(J, ne);
      return le.callback = r ?? null, Pu(I, le, ne), tH(W, ne, J), W;
    }
    function Og(n, r, c, d) {
      tm(r, n);
      var g = r.current, x = Qr(), w = Hu(g);
      Vn(w);
      var R = Hk(c);
      r.context === null ? r.context = R : r.pendingContext = R, qs && tr !== null && !Fw && (Fw = !0, u(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, kt(tr) || "Unknown"));
      var k = kl(x, w);
      k.payload = {
        element: n
      }, d = d === void 0 ? null : d, d !== null && (typeof d != "function" && u("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d), k.callback = d);
      var L = Pu(g, k, w);
      return L !== null && (Wi(L, g, w, x), V0(L, g, w)), w;
    }
    function Rb(n) {
      var r = n.current;
      if (!r.child)
        return null;
      switch (r.child.tag) {
        case E:
          return r.child.stateNode;
        default:
          return r.child.stateNode;
      }
    }
    function XH(n) {
      switch (n.tag) {
        case S: {
          var r = n.stateNode;
          if (eh(r)) {
            var c = Cy(r);
            aH(r, c);
          }
          break;
        }
        case V: {
          Pl(function() {
            var g = ha(n, mt);
            if (g !== null) {
              var x = Qr();
              Wi(g, n, mt, x);
            }
          });
          var d = mt;
          jw(n, d);
          break;
        }
      }
    }
    function $k(n, r) {
      var c = n.memoizedState;
      c !== null && c.dehydrated !== null && (c.retryLane = Dy(c.retryLane, r));
    }
    function jw(n, r) {
      $k(n, r);
      var c = n.alternate;
      c && $k(c, r);
    }
    function QH(n) {
      if (n.tag === V) {
        var r = Bc, c = ha(n, r);
        if (c !== null) {
          var d = Qr();
          Wi(c, n, r, d);
        }
        jw(n, r);
      }
    }
    function qH(n) {
      if (n.tag === V) {
        var r = Hu(n), c = ha(n, r);
        if (c !== null) {
          var d = Qr();
          Wi(c, n, r, d);
        }
        jw(n, r);
      }
    }
    function Wk(n) {
      var r = Pn(n);
      return r === null ? null : r.stateNode;
    }
    var Yk = function(n) {
      return null;
    };
    function ZH(n) {
      return Yk(n);
    }
    var Gk = function(n) {
      return !1;
    };
    function JH(n) {
      return Gk(n);
    }
    var Kk = null, Xk = null, Qk = null, qk = null, Zk = null, Jk = null, eM = null, tM = null, nM = null;
    {
      var iM = function(n, r, c) {
        var d = r[c], g = Pi(n) ? n.slice() : Lt({}, n);
        return c + 1 === r.length ? (Pi(g) ? g.splice(d, 1) : delete g[d], g) : (g[d] = iM(n[d], r, c + 1), g);
      }, rM = function(n, r) {
        return iM(n, r, 0);
      }, aM = function(n, r, c, d) {
        var g = r[d], x = Pi(n) ? n.slice() : Lt({}, n);
        if (d + 1 === r.length) {
          var w = c[d];
          x[w] = x[g], Pi(x) ? x.splice(g, 1) : delete x[g];
        } else
          x[g] = aM(
            // $FlowFixMe number or string is fine here
            n[g],
            r,
            c,
            d + 1
          );
        return x;
      }, sM = function(n, r, c) {
        if (r.length !== c.length) {
          f("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var d = 0; d < c.length - 1; d++)
            if (r[d] !== c[d]) {
              f("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return aM(n, r, c, 0);
      }, oM = function(n, r, c, d) {
        if (c >= r.length)
          return d;
        var g = r[c], x = Pi(n) ? n.slice() : Lt({}, n);
        return x[g] = oM(n[g], r, c + 1, d), x;
      }, lM = function(n, r, c) {
        return oM(n, r, 0, c);
      }, Bw = function(n, r) {
        for (var c = n.memoizedState; c !== null && r > 0; )
          c = c.next, r--;
        return c;
      };
      Kk = function(n, r, c, d) {
        var g = Bw(n, r);
        if (g !== null) {
          var x = lM(g.memoizedState, c, d);
          g.memoizedState = x, g.baseState = x, n.memoizedProps = Lt({}, n.memoizedProps);
          var w = ha(n, mt);
          w !== null && Wi(w, n, mt, bn);
        }
      }, Xk = function(n, r, c) {
        var d = Bw(n, r);
        if (d !== null) {
          var g = rM(d.memoizedState, c);
          d.memoizedState = g, d.baseState = g, n.memoizedProps = Lt({}, n.memoizedProps);
          var x = ha(n, mt);
          x !== null && Wi(x, n, mt, bn);
        }
      }, Qk = function(n, r, c, d) {
        var g = Bw(n, r);
        if (g !== null) {
          var x = sM(g.memoizedState, c, d);
          g.memoizedState = x, g.baseState = x, n.memoizedProps = Lt({}, n.memoizedProps);
          var w = ha(n, mt);
          w !== null && Wi(w, n, mt, bn);
        }
      }, qk = function(n, r, c) {
        n.pendingProps = lM(n.memoizedProps, r, c), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var d = ha(n, mt);
        d !== null && Wi(d, n, mt, bn);
      }, Zk = function(n, r) {
        n.pendingProps = rM(n.memoizedProps, r), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var c = ha(n, mt);
        c !== null && Wi(c, n, mt, bn);
      }, Jk = function(n, r, c) {
        n.pendingProps = sM(n.memoizedProps, r, c), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var d = ha(n, mt);
        d !== null && Wi(d, n, mt, bn);
      }, eM = function(n) {
        var r = ha(n, mt);
        r !== null && Wi(r, n, mt, bn);
      }, tM = function(n) {
        Yk = n;
      }, nM = function(n) {
        Gk = n;
      };
    }
    function eU(n) {
      var r = Cr(n);
      return r === null ? null : r.stateNode;
    }
    function tU(n) {
      return null;
    }
    function nU() {
      return tr;
    }
    function iU(n) {
      var r = n.findFiberByHostInstance, c = i.ReactCurrentDispatcher;
      return mu({
        bundleType: n.bundleType,
        version: n.version,
        rendererPackageName: n.rendererPackageName,
        rendererConfig: n.rendererConfig,
        overrideHookState: Kk,
        overrideHookStateDeletePath: Xk,
        overrideHookStateRenamePath: Qk,
        overrideProps: qk,
        overridePropsDeletePath: Zk,
        overridePropsRenamePath: Jk,
        setErrorHandler: tM,
        setSuspenseHandler: nM,
        scheduleUpdate: eM,
        currentDispatcherRef: c,
        findHostInstanceByFiber: eU,
        findFiberByHostInstance: r || tU,
        // React Refresh
        findHostInstancesForRefresh: PH,
        scheduleRefresh: AH,
        scheduleRoot: OH,
        setRefreshHandler: MH,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: nU,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: zw
      });
    }
    var uM = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(n) {
      console.error(n);
    };
    function Hw(n) {
      this._internalRoot = n;
    }
    Db.prototype.render = Hw.prototype.render = function(n) {
      var r = this._internalRoot;
      if (r === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? u("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : kb(arguments[1]) ? u("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && u("You passed a second argument to root.render(...) but it only accepts one argument.");
        var c = r.containerInfo;
        if (c.nodeType !== oi) {
          var d = Wk(r.current);
          d && d.parentNode !== c && u("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Og(n, r, null, null);
    }, Db.prototype.unmount = Hw.prototype.unmount = function() {
      typeof arguments[0] == "function" && u("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var n = this._internalRoot;
      if (n !== null) {
        this._internalRoot = null;
        var r = n.containerInfo;
        Sk() && u("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Pl(function() {
          Og(null, n, null, null);
        }), uR(r);
      }
    };
    function rU(n, r) {
      if (!kb(n))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      cM(n);
      var c = !1, d = !1, g = "", x = uM;
      r != null && (r.hydrate ? f("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof r == "object" && r !== null && r.$$typeof === yn && u(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), r.unstable_strictMode === !0 && (c = !0), r.identifierPrefix !== void 0 && (g = r.identifierPrefix), r.onRecoverableError !== void 0 && (x = r.onRecoverableError), r.transitionCallbacks !== void 0 && r.transitionCallbacks);
      var w = Uk(n, C0, null, c, d, g, x);
      g0(w.current, n);
      var R = n.nodeType === oi ? n.parentNode : n;
      return Vm(R), new Hw(w);
    }
    function Db(n) {
      this._internalRoot = n;
    }
    function aU(n) {
      n && Vy(n);
    }
    Db.prototype.unstable_scheduleHydration = aU;
    function sU(n, r, c) {
      if (!kb(n))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      cM(n), r === void 0 && u("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var d = c ?? null, g = c != null && c.hydratedSources || null, x = !1, w = !1, R = "", k = uM;
      c != null && (c.unstable_strictMode === !0 && (x = !0), c.identifierPrefix !== void 0 && (R = c.identifierPrefix), c.onRecoverableError !== void 0 && (k = c.onRecoverableError));
      var L = Ik(r, null, n, C0, d, x, w, R, k);
      if (g0(L.current, n), Vm(n), g)
        for (var z = 0; z < g.length; z++) {
          var W = g[z];
          cj(L, W);
        }
      return new Db(L);
    }
    function kb(n) {
      return !!(n && (n.nodeType === br || n.nodeType === Ts || n.nodeType === Bp));
    }
    function Pg(n) {
      return !!(n && (n.nodeType === br || n.nodeType === Ts || n.nodeType === Bp || n.nodeType === oi && n.nodeValue === " react-mount-point-unstable "));
    }
    function cM(n) {
      n.nodeType === br && n.tagName && n.tagName.toUpperCase() === "BODY" && u("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Xm(n) && (n._reactRootContainer ? u("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : u("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var oU = i.ReactCurrentOwner, fM;
    fM = function(n) {
      if (n._reactRootContainer && n.nodeType !== oi) {
        var r = Wk(n._reactRootContainer.current);
        r && r.parentNode !== n && u("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var c = !!n._reactRootContainer, d = Uw(n), g = !!(d && Du(d));
      g && !c && u("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), n.nodeType === br && n.tagName && n.tagName.toUpperCase() === "BODY" && u("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function Uw(n) {
      return n ? n.nodeType === Ts ? n.documentElement : n.firstChild : null;
    }
    function dM() {
    }
    function lU(n, r, c, d, g) {
      if (g) {
        if (typeof d == "function") {
          var x = d;
          d = function() {
            var I = Rb(w);
            x.call(I);
          };
        }
        var w = Ik(
          r,
          d,
          n,
          Mu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          dM
        );
        n._reactRootContainer = w, g0(w.current, n);
        var R = n.nodeType === oi ? n.parentNode : n;
        return Vm(R), Pl(), w;
      } else {
        for (var k; k = n.lastChild; )
          n.removeChild(k);
        if (typeof d == "function") {
          var L = d;
          d = function() {
            var I = Rb(z);
            L.call(I);
          };
        }
        var z = Uk(
          n,
          Mu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          dM
        );
        n._reactRootContainer = z, g0(z.current, n);
        var W = n.nodeType === oi ? n.parentNode : n;
        return Vm(W), Pl(function() {
          Og(r, z, c, d);
        }), z;
      }
    }
    function uU(n, r) {
      n !== null && typeof n != "function" && u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, n);
    }
    function Mb(n, r, c, d, g) {
      fM(c), uU(g === void 0 ? null : g, "render");
      var x = c._reactRootContainer, w;
      if (!x)
        w = lU(c, r, n, g, d);
      else {
        if (w = x, typeof g == "function") {
          var R = g;
          g = function() {
            var k = Rb(w);
            R.call(k);
          };
        }
        Og(r, w, n, g);
      }
      return Rb(w);
    }
    var hM = !1;
    function cU(n) {
      {
        hM || (hM = !0, u("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var r = oU.current;
        if (r !== null && r.stateNode !== null) {
          var c = r.stateNode._warnedAboutRefsInRender;
          c || u("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", pn(r.type) || "A component"), r.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return n == null ? null : n.nodeType === br ? n : KH(n, "findDOMNode");
    }
    function fU(n, r, c) {
      if (u("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Pg(r))
        throw new Error("Target container is not a DOM element.");
      {
        var d = Xm(r) && r._reactRootContainer === void 0;
        d && u("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return Mb(null, n, r, !0, c);
    }
    function dU(n, r, c) {
      if (u("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Pg(r))
        throw new Error("Target container is not a DOM element.");
      {
        var d = Xm(r) && r._reactRootContainer === void 0;
        d && u("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return Mb(null, n, r, !1, c);
    }
    function hU(n, r, c, d) {
      if (u("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Pg(c))
        throw new Error("Target container is not a DOM element.");
      if (n == null || !jS(n))
        throw new Error("parentComponent must be a valid React Component");
      return Mb(n, r, c, !1, d);
    }
    var pM = !1;
    function pU(n) {
      if (pM || (pM = !0, u("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !Pg(n))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var r = Xm(n) && n._reactRootContainer === void 0;
        r && u("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (n._reactRootContainer) {
        {
          var c = Uw(n), d = c && !Du(c);
          d && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Pl(function() {
          Mb(null, null, n, !1, function() {
            n._reactRootContainer = null, uR(n);
          });
        }), !0;
      } else {
        {
          var g = Uw(n), x = !!(g && Du(g)), w = n.nodeType === br && Pg(n.parentNode) && !!n.parentNode._reactRootContainer;
          x && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", w ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Qi(XH), bu(QH), Ly(qH), qc(ca), Sm(Ay), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && u("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), vd(gF), VS(bw, sH, Pl);
    function mU(n, r) {
      var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!kb(r))
        throw new Error("Target container is not a DOM element.");
      return GH(n, r, null, c);
    }
    function gU(n, r, c, d) {
      return hU(n, r, c, d);
    }
    var Iw = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Du, bh, v0, lu, yd, bw]
    };
    function vU(n, r) {
      return Iw.usingClientEntryPoint || u('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), rU(n, r);
    }
    function yU(n, r, c) {
      return Iw.usingClientEntryPoint || u('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), sU(n, r, c);
    }
    function bU(n) {
      return Sk() && u("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Pl(n);
    }
    var xU = iU({
      findFiberByHostInstance: df,
      bundleType: 1,
      version: zw,
      rendererPackageName: "react-dom"
    });
    if (!xU && pt && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var mM = window.location.protocol;
      /^(https?|file):$/.test(mM) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (mM === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Iw, ba.createPortal = mU, ba.createRoot = vU, ba.findDOMNode = cU, ba.flushSync = bU, ba.hydrate = fU, ba.hydrateRoot = yU, ba.render = dU, ba.unmountComponentAtNode = pU, ba.unstable_batchedUpdates = bw, ba.unstable_renderSubtreeIntoContainer = gU, ba.version = zw, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), ba;
}
var YA;
function $4() {
  if (YA) return Yb.exports;
  YA = 1;
  function t() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
      } catch (e) {
        console.error(e);
      }
    }
  }
  return process.env.NODE_ENV === "production" ? (t(), Yb.exports = U4()) : Yb.exports = I4(), Yb.exports;
}
var xa = $4();
const eN = Io(void 0), Sa = (t) => t.replace(/\./g, "-"), W4 = ({
  children: t,
  selectedValue: e = Yh(),
  dayFormat: i = ["일", "월", "화", "수", "목", "금", "토"],
  monthLength: a = 4,
  yearLength: o = 3,
  yearBeforeAfterLength: f = 4,
  type: u = QL.DEFAULT,
  isDisabled: h = !1,
  disabledDates: m = [],
  disabledDatesRange: v = [],
  rangeType: b = "",
  scrollEventRefs: S = void 0,
  onBlur: C = () => {
  },
  updateSelectedValue: E = () => {
  },
  className: D = "",
  style: M = {},
  ...A
}) => {
  const { selectedRange: P, setStartDateRange: N, setEndDateRange: F } = ZL(), B = (He) => {
    if (P.length === 0)
      return !1;
    const Ve = Sa(He);
    return new Date(Sa(P[0])) <= new Date(Ve) && new Date(Ve) <= new Date(Sa(P[1]));
  }, V = (He) => {
    if (P.length === 0)
      return !1;
    const [Ve, Qe] = P[0].split("."), [ft, ce] = P[1].split("."), ye = `${Ve}-${Qe}`, ke = `${ft}-${ce}`;
    return new Date(ye) <= new Date(Sa(He)) && new Date(Sa(He)) <= new Date(ke);
  }, G = (He) => {
    if (P.length === 0)
      return !1;
    const [Ve] = P[0].split("."), [Qe] = P[1].split("."), ft = `${Ve}`, ce = `${Qe}`;
    return new Date(ft) <= new Date(Sa(He)) && new Date(Sa(He)) <= new Date(ce);
  }, Y = (He) => {
    const Ve = Sa(He), Qe = m.includes(He), ft = v.some((ce) => {
      const [ye, ke] = ce.split("~");
      if (ye.length === 0 && ke.length > 0)
        return new Date(Ve) < new Date(Sa(ke));
      if (ye.length > 0 && ke.length === 0)
        return new Date(Sa(ye)) < new Date(Ve);
      if (ye.length > 0 && ke.length > 0)
        return new Date(Sa(ye)) < new Date(Ve) && new Date(Ve) < new Date(Sa(ke));
    });
    return Qe || ft;
  }, K = (He) => {
    const Ve = Sa(He);
    return v.some((Qe) => {
      const [ft, ce] = Qe.split("~");
      if (ft.length === 0 && ce.length > 0)
        return new Date(Ve) < /* @__PURE__ */ new Date(
          `${ce.split(".")[0]}-${ce.split(".")[1]}`
        );
      if (ft.length > 0 && ce.length === 0)
        return /* @__PURE__ */ new Date(`${ft.split(".")[0]}-${ft.split(".")[1]}`) < new Date(Ve);
      if (ft.length > 0 && ce.length > 0)
        return /* @__PURE__ */ new Date(`${ft.split(".")[0]}-${ft.split(".")[1]}`) < new Date(Ve) && new Date(Ve) < /* @__PURE__ */ new Date(`${ce.split(".")[0]}-${ce.split(".")[1]}`);
    });
  }, ae = (He) => {
    const Ve = Sa(He);
    return v.some((Qe) => {
      const [ft, ce] = Qe.split("~");
      if (ft.length === 0 && ce.length > 0)
        return new Date(Ve).getFullYear() < (/* @__PURE__ */ new Date(`${ce.split(".")[0]}`)).getFullYear();
      if (ft.length > 0 && ce.length === 0)
        return (/* @__PURE__ */ new Date(`${ft.split(".")[0]}`)).getFullYear() < new Date(Ve).getFullYear();
      if (ft.length > 0 && ce.length > 0)
        return (/* @__PURE__ */ new Date(`${ft.split(".")[0]}`)).getFullYear() < new Date(Ve).getFullYear() && new Date(Ve).getFullYear() < (/* @__PURE__ */ new Date(`${ce.split(".")[0]}`)).getFullYear();
    });
  }, [ie, ee] = Tn({
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    minusWidth: 0,
    clientWidth: 0,
    clientHeight: 0
  }), [oe, se] = Tn(!1), Pe = () => {
    if (se(!0), re(!1), Se(!1), !me.current)
      return;
    const { bottom: He, left: Ve, right: Qe, top: ft, width: ce } = me.current.getBoundingClientRect();
    ee({
      bottom: He,
      left: Ve,
      right: Qe,
      top: ft,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight,
      minusWidth: ce
    });
  }, [Te, Se] = Tn(!1);
  Xn(() => {
    Te ? (window.addEventListener("click", Ne), window.addEventListener("scroll", pe), window.addEventListener("resize", Ae), Array.isArray(S) && S.forEach((He) => {
      const Ve = document.querySelector(He);
      Ve instanceof HTMLElement && Ve.addEventListener("scroll", pe);
    })) : (window.removeEventListener("click", Ne), window.removeEventListener("scroll", pe), window.removeEventListener("resize", Ae), Array.isArray(S) && S.forEach((He) => {
      const Ve = document.querySelector(He);
      Ve instanceof HTMLElement && Ve.removeEventListener(
        "scroll",
        pe
      );
    }));
  }, [Te]);
  const [Oe, re] = Tn(!1), ge = () => {
    if (re(!0), se(!1), Se(!1), !me.current)
      return;
    const { bottom: He, left: Ve, right: Qe, top: ft, width: ce } = me.current.getBoundingClientRect();
    ee({
      bottom: He,
      left: Ve,
      right: Qe,
      top: ft,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight,
      minusWidth: ce
    });
  }, me = Sn(null), fe = Sn(null), pe = () => {
    if (!me.current)
      return;
    const { top: He, bottom: Ve, left: Qe, right: ft, width: ce } = me.current.getBoundingClientRect();
    ee((ye) => ({
      ...ye,
      top: He,
      bottom: Ve,
      left: Qe,
      right: ft,
      minusWidth: ce
    }));
  }, Ae = () => {
    ee((He) => ({
      ...He,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight
    }));
  }, Ne = (He) => {
    const Ve = He.target;
    if (!(Ve instanceof HTMLElement))
      return;
    const Qe = Ve.closest(".inp_datepicker");
    if (Qe) {
      Qe !== fe.current && (se(!1), Se(!1), re(!1), C());
      return;
    }
    Ve.closest(".h_calendar_area") || Ve.closest(".h_calendar_month_area") || Ve.closest(".h_calendar_year_area") || (se(!1), Se(!1), re(!1), C());
  }, de = (He) => {
    switch (b) {
      case mv.START_DATE:
        N(He);
        break;
      case mv.END_DATE:
        F(He);
        break;
    }
  }, ze = (He) => {
    if (He instanceof KeyboardEvent && He.key !== "Enter")
      return;
    const Ve = He.target;
    if (!(Ve instanceof HTMLInputElement))
      return;
    const Qe = Ve.value, ft = (/* @__PURE__ */ new Date()).getFullYear() % 100;
    switch (Qe.length) {
      // 4- 2311(2023.01.01) // 2325(2023.02.05)
      case 4:
        (() => {
          const ce = Qe.toString();
          let ye = parseInt(ce.slice(0, 2), 10);
          ye > ft ? ye += 1900 : ye += 2e3;
          const ke = ce.slice(2, 3).padStart(2, "0"), Ge = ce.slice(3).padStart(2, "0");
          if (!ps(`${ye}.${ke}.${Ge}`) || Y(`${ye}.${ke}.${Ge}`)) {
            const yn = De;
            wn(() => {
              xa.flushSync(() => {
                we("");
              }), wn(() => {
                we(yn), de(yn);
              });
            });
            return;
          }
          pt(ye), xt(Number(ke)), wn(() => {
            xa.flushSync(() => {
              we("");
            }), wn(() => {
              we(`${ye}.${ke}.${Ge}`), de(`${ye}.${ke}.${Ge}`);
            });
          });
        })();
        break;
      // 5 - 23.21(2023.02.01) // 232.1(2023.02.01) // 23210(2023.02.10) // 23101(2023.01.01) // 23131(2023.01.31)
      case 5:
        (() => {
          const ce = Qe.replace(/\./g, ""), ye = ft >= parseInt(ce.slice(0, 2)) ? 2e3 + parseInt(ce.slice(0, 2)) : 1900 + parseInt(ce.slice(0, 2));
          let ke = "", Ge = "";
          if (ce.length === 5 ? (ke = ce.slice(2, 3).toString().padStart(2, "0"), Ge = ce.slice(3)) : ce.length === 4 && (ke = "0" + ce.charAt(2), Ge = "0" + ce.charAt(3)), !ps(`${ye}.${ke}.${Ge}`) || Y(`${ye}.${ke}.${Ge}`)) {
            const yn = De;
            wn(() => {
              xa.flushSync(() => {
                we("");
              }), wn(() => {
                we(yn), de(yn);
              });
            });
            return;
          }
          pt(ye), xt(Number(ke)), wn(() => {
            xa.flushSync(() => {
              we("");
            }), wn(() => {
              we(`${ye}.${ke}.${Ge}`), de(`${ye}.${ke}.${Ge}`);
            });
          });
        })();
        break;
      // 6 - 202321(2023.02.01) // 23.2.1(2023.02.01) // 23.210(2023.02.10) // 232.10(2023.02.10)
      case 6:
        (() => {
          let ce = "", ye = "", ke = "";
          if (Qe.includes(".")) {
            const Ge = Qe.replace(/\./g, "");
            ce = ft >= parseInt(Ge.slice(0, 2)) ? (2e3 + parseInt(Ge.slice(0, 2))).toString() : (1900 + parseInt(Ge.slice(0, 2))).toString(), ye = Ge.slice(2, 3).toString().padStart(2, "0"), ke = Ge.slice(3).toString().padStart(2, "0");
          } else
            ce = Qe.slice(0, 2), ye = Qe.slice(2, 4).toString().padStart(2, "0"), ke = Qe.slice(4, 6).toString().padStart(2, "0"), ps(`${ce}.${ye}.${ke}`) || (ce = `${ce}${ye}`, ye = ke.toString().split("")[0].padStart(2, "0"), ke = ke.toString().split("")[1].padStart(2, "0"));
          if (!ps(`${ce}.${ye}.${ke}`) || Y(`${ce}.${ye}.${ke}`)) {
            const Ge = De;
            wn(() => {
              xa.flushSync(() => {
                we("");
              }), wn(() => {
                we(Ge), de(Ge);
              });
            });
            return;
          }
          pt(Number(ce)), xt(Number(ye)), wn(() => {
            xa.flushSync(() => {
              we("");
            }), wn(() => {
              we(`${ce}.${ye}.${ke}`), de(`${ce}.${ye}.${ke}`);
            });
          });
        })();
        break;
      // 7 - 20232.1(2023.02.01) // 2023.21(2023.02.01) // 20.0511(2020.05.11) // 2023201(2023.02.01) // 2023101(2023.01.01) // 2023130(2023.01.30)
      case 7:
        (() => {
          let ce = "", ye = "", ke = "";
          if (Qe.includes(".")) {
            const Ge = Qe.replace(/\./g, "");
            ce = ft >= parseInt(Ge.slice(0, 2)) ? (2e3 + parseInt(Ge.slice(0, 2))).toString() : (1900 + parseInt(Ge.slice(0, 2))).toString(), ye = Ge.slice(2, 4).padStart(2, "0"), ke = Ge.slice(4, 6).padStart(2, "0"), ps(`${ce}.${ye}.${ke}`) || (ce = `${ce.slice(2)}${ye}`, ye = `${ke.split("")[0].padStart(2, "0")}`, ke = `${ke.split("")[1].padStart(2, "0")}`);
          } else
            ce = Qe.slice(0, 4), ye = Qe.slice(4, 5).toString().padStart(2, "0"), ke = Qe.slice(5).toString().padStart(2, "0");
          if (!ps(`${ce}.${ye}.${ke}`) || Y(`${ce}.${ye}.${ke}`)) {
            const Ge = De;
            wn(() => {
              xa.flushSync(() => {
                we("");
              }), wn(() => {
                we(Ge), de(Ge);
              });
            });
            return;
          }
          pt(Number(ce)), xt(Number(ye)), wn(() => {
            xa.flushSync(() => {
              we("");
            }), wn(() => {
              we(`${ce}.${ye}.${ke}`), de(`${ce}.${ye}.${ke}`);
            });
          });
        })();
        break;
      // 8 - 20230212(2023.02.12) // 2023.2.1(2023.02.01) // 20.02.05(2020.02.05) // 2023.021(2023.02.01) // 20232.11(2023.02.11)
      case 8:
        (() => {
          let ce = "", ye = "", ke = "";
          if (Qe.includes(".")) {
            const Ge = Qe.replace(/\./g, "");
            Ge.length === 6 ? (ce = ft >= parseInt(Ge.slice(0, 2)) ? (2e3 + parseInt(
              Ge.slice(0, 2)
            )).toString() : (1900 + parseInt(
              Ge.slice(0, 2)
            )).toString(), ye = Ge.slice(2, 4).padStart(2, "0"), ke = Ge.slice(4, 6).padStart(2, "0"), ps(`${ce}.${ye}.${ke}`) || (ce = `${ce.slice(2)}${ye}`, ye = `${ke.split("")[0].padStart(2, "0")}`, ke = `${ke.split("")[1].padStart(2, "0")}`)) : (ce = Ge.slice(0, 4), ye = Ge.slice(4, 5).padStart(2, "0"), ke = Ge.slice(5).padStart(2, "0"), ps(`${ce}.${ye}.${ke}`) || (ye = ke.split("")[0].padStart(2, "0"), ke = ke.split("")[1].padStart(2, "0")));
          } else
            ce = Qe.slice(0, 4), ye = Qe.slice(4, 6), ke = Qe.slice(6, 8);
          if (!ps(`${ce}.${ye}.${ke}`) || Y(`${ce}.${ye}.${ke}`)) {
            const Ge = De;
            wn(() => {
              xa.flushSync(() => {
                we("");
              }), wn(() => {
                we(Ge), de(Ge);
              });
            });
            return;
          }
          pt(Number(ce)), xt(Number(ye)), wn(() => {
            xa.flushSync(() => {
              we("");
            }), wn(() => {
              we(`${ce}.${ye}.${ke}`), de(`${ce}.${ye}.${ke}`);
            });
          });
        })();
        break;
      // 9 - 2023.02.1(2023.02.01) // 2023.0212(2023.02.12) // 202302.12(2023.02.12) // 2023.2.11(2023.02.11) // 2023.02.1(2023.02.01) // 2023.19.1(2023.09.01)
      case 9:
        (() => {
          let ce = "", ye = "", ke = "";
          if (Qe.includes(".")) {
            const Ge = Qe.replace(/\./g, "");
            if (ce = Ge.slice(0, 4), ye = Ge.slice(4, 5).padStart(2, "0"), ke = Ge.slice(5).padStart(2, "0"), !ps(`${ce}.${ye}.${ke}`)) {
              const [yn, ...$n] = ke.split("");
              ye = yn.padStart(2, "0"), ke = $n.join("").padStart(2, "0");
            }
          }
          if (!ps(`${ce}.${ye}.${ke}`) || Y(`${ce}.${ye}.${ke}`)) {
            const Ge = De;
            wn(() => {
              xa.flushSync(() => {
                we("");
              }), wn(() => {
                we(Ge), de(Ge);
              });
            });
            return;
          }
          pt(Number(ce)), xt(Number(ye)), wn(() => {
            xa.flushSync(() => {
              we("");
            }), wn(() => {
              we(`${ce}.${ye}.${ke}`), de(`${ce}.${ye}.${ke}`);
            });
          });
        })();
        break;
      // 10 - 2023.02.12
      case 10:
      default:
        (() => {
          if (!ps(Qe) || Y(Qe)) {
            const Ge = De;
            wn(() => {
              xa.flushSync(() => {
                we("");
              }), wn(() => {
                we(Ge), de(Ge);
              });
            });
            return;
          }
          const [ce, ye, ke] = Qe.split(".");
          pt(Number(ce)), xt(Number(ye)), wn(() => {
            xa.flushSync(() => {
              we("");
            }), wn(() => {
              we(`${ce}.${ye}.${ke}`), de(`${ce}.${ye}.${ke}`);
            });
          });
        })();
        break;
    }
  }, [De, we] = Tn(e);
  Xn(() => {
    we(e);
  }, [e]);
  const ct = (He) => {
    we(He), Se(!1), re(!1), se(!1), E(He);
  }, [gt, pt] = Tn(
    Number(De == null ? void 0 : De.split(".")[0]) || (/* @__PURE__ */ new Date()).getFullYear()
  ), [At, xt] = Tn(
    Number(De == null ? void 0 : De.split(".")[1]) || (/* @__PURE__ */ new Date()).getMonth() + 1
  ), tt = (He) => {
    const Ve = At + He;
    Ve > 12 ? (xt(1), pt((Qe) => Qe + 1)) : Ve < 1 ? (xt(12), pt((Qe) => Qe - 1)) : xt(Ve);
  }, [Et, Wt] = Tn(gt), on = (He) => {
    Wt((Ve) => Ve + He);
  }, [ln, Yt] = Tn(gt), [Xt, Dt] = Tn(ln - f), [Rt, Bt] = Tn(ln + f), Dn = (He) => {
    Dt((Ve) => Ve + He), Bt((Ve) => Ve + He);
  };
  Xn(() => {
    Wt(gt), Yt(gt);
  }, [gt]);
  const An = () => {
    fe.current && (fe.current.addEventListener(
      "keyup",
      ze
    ), fe.current.addEventListener(
      "blur",
      ze
    ));
  }, si = () => {
    fe.current && (fe.current.removeEventListener(
      "keyup",
      ze
    ), fe.current.removeEventListener(
      "blur",
      ze
    ));
  }, Ki = () => {
    if (Te || Oe || oe)
      switch (!0) {
        case Te:
          Se(!0), re(!1), se(!1);
          break;
        case Oe:
          Se(!1), re(!0), se(!1);
          break;
        case oe:
          Se(!1), re(!1), se(!0);
          break;
      }
    else
      Se(!0), re(!1), se(!1);
    if (!me.current)
      return;
    const { bottom: He, left: Ve, right: Qe, top: ft, width: ce } = me.current.getBoundingClientRect();
    ee({
      bottom: He,
      left: Ve,
      right: Qe,
      top: ft,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight,
      minusWidth: ce
    });
  }, Ji = (() => {
    const [He, Ve] = Yh().split("."), ft = Array.from({ length: 12 }, (ye, ke) => ke + 1).map((ye) => {
      var ke, Ge, yn, $n;
      return {
        year: String(Et),
        month: String(ye),
        isActive: Number(De.split(".")[0]) === Et && At === ye,
        inRange: V(
          `${String(Et)}.${String(
            ye
          ).padStart(2, "0")}`
        ),
        isDisabled: K(
          `${String(Et)}.${String(
            ye
          ).padStart(2, "0")}`
        ),
        isCurrentMonth: Et === Number(He) && ye === Number(Ve),
        isStartMonth: Number((ke = P[0]) == null ? void 0 : ke.split(".")[0]) === Et && Number((Ge = P[0]) == null ? void 0 : Ge.split(".")[1]) === ye,
        isEndMonth: Number((yn = P[1]) == null ? void 0 : yn.split(".")[0]) === Et && Number(($n = P[1]) == null ? void 0 : $n.split(".")[1]) === ye
      };
    }), ce = [];
    for (let ye = 0; ye < ft.length; ye += a)
      ce.push(ft.slice(ye, ye + a));
    return ce;
  })(), Le = Xs(() => f * 2 + 1, [f]), Ct = (() => {
    const [He] = Yh().split("."), Ve = [];
    for (let ce = Xt; ce <= Rt; ce++)
      Ve.push(ce);
    const Qe = Ve.map((ce) => {
      var ye, ke;
      return {
        year: String(ce),
        isActive: Number(De.split(".")[0]) === ce,
        inRange: G(String(ce)),
        // Todo
        isDisabled: ae(String(ce)),
        isCurrentYear: ce === Number(He),
        isStartYear: Number((ye = P[0]) == null ? void 0 : ye.split(".")[0]) === ce,
        isEndYear: Number((ke = P[1]) == null ? void 0 : ke.split(".")[0]) === ce
      };
    }), ft = [];
    for (let ce = 0; ce < Qe.length; ce += o)
      ft.push(Qe.slice(ce, ce + o));
    return ft;
  })(), Vt = ((He, Ve) => {
    var Ta, Ea, H, ve, Be, ot;
    const [Qe, ft, ce] = Yh().split("."), [ye, ke, Ge] = (De == null ? void 0 : De.split(".")) || [null, null, null], yn = Number(ye) === He && Number(ke) === Ve, $n = new Date(He, Ve, 0).getDate(), wa = [];
    let Br = Array(7).fill(null);
    for (let lt = 1; lt <= $n; lt++) {
      const Pt = new Date(He, Ve - 1, lt).getDay();
      Br[Pt] = {
        year: String(He),
        month: String(Ve).padStart(2, "0"),
        date: String(lt),
        isActive: yn && Number(Ge) === lt,
        inRange: B(
          `${String(He)}.${String(Ve).padStart(
            2,
            "0"
          )}.${String(lt).padStart(2, "0")}`
        ),
        isDisabled: Y(
          `${String(He)}.${String(Ve).padStart(
            2,
            "0"
          )}.${String(lt).padStart(2, "0")}`
        ),
        isCurrentDate: Number(Qe) === He && Number(ft) === Ve && Number(ce) === lt,
        isStartDate: Number((Ta = P[0]) == null ? void 0 : Ta.split(".")[0]) === He && Number((Ea = P[0]) == null ? void 0 : Ea.split(".")[1]) === Ve && Number((H = P[0]) == null ? void 0 : H.split(".")[2]) === lt,
        isEndDate: Number((ve = P[1]) == null ? void 0 : ve.split(".")[0]) === He && Number((Be = P[1]) == null ? void 0 : Be.split(".")[1]) === Ve && Number((ot = P[1]) == null ? void 0 : ot.split(".")[2]) === lt
      }, (Pt === 6 || lt === $n) && (wa.push(Br), Br = Array(7).fill(null));
    }
    return wa;
  })(gt, At), In = (He) => {
    const [Ve, Qe] = He.split(".");
    pt(Number(Ve)), xt(Number(Qe)), re(!1), se(!1), Se(!0);
  }, dn = (He) => {
    pt(Number(He)), se(!1), re(!0), Se(!1);
  }, _n = Sn(null), Jt = Sn(null), Gt = Sn(null), qt = Xs(() => h, [h]), Mi = {
    selectedDatePickerValue: De,
    clickedDatePickerInput: Ki,
    updateSelectedDatePickerValue: ct,
    // setSelectedDatePickerValue
    updateNowMonth: tt,
    // setNowMonth
    updateYearForYearCalendar: Dn,
    // setYearForYearCalendar
    updateYearForMonthCalendar: on,
    // setYearForMonthCalendar
    yearsArrLength: Le,
    updateIsActiveYearCalendar: Pe,
    // setIsActiveYearCalendar
    updateIsActiveMonthCalendar: ge,
    // setIsActiveMonthCalendar
    setNowMonthByMonthCalendar: In,
    setNowYearByYearCalendar: dn,
    calendarInputButtonRef: fe,
    // calendarInput
    calendarInputAreaRef: me,
    // calendarInputArea
    calendarPosition: ie,
    calendarAreaRef: _n,
    // calendarArea
    calendarMonthAreaRef: Jt,
    // calendarMonthArea
    calendarYearAreaRef: Gt,
    // calendarYearArea
    type: u,
    // calendarType
    focusInDatePickerInput: An,
    focusOutDatePickerInput: si,
    rangeType: b,
    isDisabledValue: qt
    // isDisabled
  }, Ai = () => {
    se(!1), re(!1), Se(!1);
  };
  return /* @__PURE__ */ Me.jsx(eN.Provider, { value: Mi, children: /* @__PURE__ */ Me.jsx("div", { className: `h_single_datepicker_area ${u} ${D}`, style: M, ...A, children: t({
    isActiveCalendar: Te,
    isActiveMonthCalendar: Oe,
    isActiveYearCalendar: oe,
    dayFormat: i,
    monthDates: Vt,
    nowYear: gt,
    nowMonth: At,
    months: Ji,
    years: Ct,
    startYear: Xt,
    endYear: Rt,
    yearForYearCalendar: ln,
    yearForMonthCalendar: Et,
    closeAllCalendar: Ai
  }) }) });
};
W4.displayName = "HSingleDatePickerArea";
const Gi = () => {
  const t = ki(eN);
  if (!t)
    throw new Error("useHSingleDatePickerAreaContext must be used within a HSingleDatePickerAreaProvider");
  return t;
}, Y4 = ({
  children: t,
  childrenTableHead: e,
  className: i = "",
  tableClassName: a = "",
  tableHeadClassName: o = "",
  tableBodyClassName: f = "",
  style: u = {},
  ...h
}) => {
  const { type: m } = Gi();
  return /* @__PURE__ */ Me.jsx("div", { className: `h_calendar ${m} ${i}`, style: u, ...h, children: /* @__PURE__ */ Me.jsxs("table", { className: `h_calendar_table ${a}`, children: [
    /* @__PURE__ */ Me.jsx("caption", { children: /* @__PURE__ */ Me.jsx("span", { className: "blind", children: "Dates" }) }),
    /* @__PURE__ */ Me.jsx("thead", { className: `calendar_head ${o}`, children: e }),
    /* @__PURE__ */ Me.jsx("tbody", { className: `calendar_body ${f}`, children: t })
  ] }) });
};
Y4.displayName = "HSingleDatePickerCalendar";
const G4 = ({
  value: t,
  children: e,
  className: i = "",
  style: a = {},
  disabled: o = !1
}) => {
  const { type: f, updateSelectedDatePickerValue: u, rangeType: h } = Gi(), { setStartDateRange: m, setEndDateRange: v } = ZL(), b = () => {
    switch (u(t), h) {
      case mv.START_DATE:
        m(t);
        break;
      case mv.END_DATE:
        v(t);
        break;
    }
  };
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_common ${f} ${i}`,
      style: a,
      onClick: b,
      disabled: o,
      children: e
    }
  );
};
G4.displayName = "HSingleDatePickerCalendarDateButton";
const K4 = ({
  children: t,
  className: e = "",
  style: i = {},
  ...a
}) => {
  const { type: o, calendarPosition: f, calendarAreaRef: u } = Gi(), [h, m] = Tn({});
  return Xn(() => {
    if (!f)
      return;
    const {
      bottom: v,
      left: b,
      right: S,
      top: C,
      clientWidth: E,
      clientHeight: D,
      minusWidth: M
    } = f;
    if (!u.current)
      return;
    const { height: A, width: P } = u.current.getBoundingClientRect();
    m({
      position: "fixed",
      zIndex: "220",
      ...HE(C, v, A, D),
      ...UE(b, S, P, E, M)
    });
  }, [f, u]), /* @__PURE__ */ Me.jsx(
    "div",
    {
      ref: u,
      className: `h_calendar_area ${o} ${e}`,
      style: {
        position: "fixed",
        ...i,
        ...h
      },
      ...a,
      children: t
    }
  );
};
K4.displayName = "HSingleDatePickerCalendarArea";
const X4 = ({
  children: t,
  className: e = "",
  style: i = {},
  ...a
}) => {
  const { type: o, calendarPosition: f, calendarMonthAreaRef: u } = Gi(), [h, m] = Tn({});
  return Xn(() => {
    if (!f)
      return;
    const {
      bottom: v,
      left: b,
      right: S,
      top: C,
      clientWidth: E,
      clientHeight: D,
      minusWidth: M
    } = f;
    if (!u.current)
      return;
    const { height: A, width: P } = u.current.getBoundingClientRect();
    m({
      position: "fixed",
      zIndex: "220",
      ...HE(C, v, A, D),
      ...UE(b, S, P, E, M)
    });
  }, [f, u]), /* @__PURE__ */ Me.jsx(
    "div",
    {
      ref: u,
      className: `h_calendar_month_area ${o} ${e}`,
      style: {
        position: "fixed",
        ...i,
        ...h
      },
      ...a,
      children: t
    }
  );
};
X4.displayName = "HSingleDatePickerCalendarMonthArea";
const Q4 = ({
  children: t,
  className: e = "",
  tableClassName: i = "",
  style: a = {},
  childrenTableHead: o
}) => {
  const { type: f } = Gi();
  return /* @__PURE__ */ Me.jsx("div", { className: `h_calendar_month ${f} ${e}`, style: a, children: /* @__PURE__ */ Me.jsxs("table", { className: `h_calendar_month_table ${i}`, children: [
    /* @__PURE__ */ Me.jsx("caption", { children: /* @__PURE__ */ Me.jsx("span", { className: "blind", children: "Months" }) }),
    /* @__PURE__ */ Me.jsx("thead", { children: o }),
    /* @__PURE__ */ Me.jsx("tbody", { children: t })
  ] }) });
};
Q4.displayName = "HSingleDatePickerCalendarMonth";
const q4 = ({
  children: t,
  className: e = "",
  style: i = {},
  disabled: a = !1
}) => {
  const { type: o, updateIsActiveMonthCalendar: f } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_month ${o} ${e}`,
      onClick: f,
      style: i,
      disabled: a,
      children: t
    }
  );
};
q4.displayName = "HSingleDatePickerMonthButton";
const Z4 = ({
  value: t,
  children: e,
  className: i = "",
  style: a = {},
  disabled: o = !1
}) => {
  const { type: f, setNowMonthByMonthCalendar: u } = Gi(), h = () => {
    u(t);
  };
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_common ${f} ${i}`,
      onClick: h,
      disabled: o,
      style: a,
      children: e
    }
  );
};
Z4.displayName = "HSingleDatePickerCalendarMonthButton";
const J4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAZCAYAAAABmx/yAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADBSURBVHgBvdSxCQMhFABQFQS73Ai3QWa4USytQkbIBukUG0dJRsgIN4KlWEjUIuRyen4t8kH8IE8E//8I/SOMMZPW+pJy3IO898+YnuO6guAPWkMISxOWkBBixSMoneERVIUtVIQQtINQtIE96AN7UYYjKAVxzk1xP+VbMLaMMYsAkZ8qpZwJIY+YzhG/KKUL59w24QjefEcP3hUAFBdLDoKrRd7Ch211hJuNXMOg0VHC4GH1jWNZ3lBPJKyUuqf8DUy8w9O6XZwQAAAAAElFTkSuQmCC", Zx = () => /* @__PURE__ */ Me.jsx("span", { children: /* @__PURE__ */ Me.jsx("img", { src: J4, alt: "왼쪽 화살표" }) });
Zx.displayName = "IconArrowLeft";
const eW = ({
  children: t,
  className: e = "",
  style: i = {}
}) => {
  const { type: a, updateYearForMonthCalendar: o } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_month_prev ${a} ${e}`,
      onClick: () => o(-1),
      style: i,
      children: t || a === "type1" && /* @__PURE__ */ Me.jsx(Zx, {})
    }
  );
};
eW.displayName = "HSingleDatePickerMonthPrevButton";
const tW = ({
  children: t,
  childrenTableHead: e,
  childrenTableBody: i,
  className: a = "",
  tableClassName: o = "",
  style: f = {}
}) => {
  const { type: u } = Gi();
  return /* @__PURE__ */ Me.jsxs("div", { className: `h_calendar_year ${u} ${a}`, style: f, children: [
    t,
    /* @__PURE__ */ Me.jsxs("table", { className: `h_calendar_year_table ${o}`, children: [
      /* @__PURE__ */ Me.jsx("caption", { children: /* @__PURE__ */ Me.jsx("span", { className: "blind", children: "Years" }) }),
      /* @__PURE__ */ Me.jsx("thead", { children: e }),
      /* @__PURE__ */ Me.jsx("tbody", { children: i })
    ] })
  ] });
};
tW.displayName = "HSingleDatePickerCalendarYear";
const nW = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAZCAYAAAABmx/yAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAC+SURBVHgBpdS9FcIgEADgHEVqR8gIruAGjiAllRnFCh40uIEjZIWMkBHseQ88LfKi8nOnFBx3730cDdd1/yzn3NkYM3CMsNaOKaWLEGLiYNH3/RUAZjwPHAzPzXu/CyFM2HmP6RJjPCillib8BcM24WD4LFAx5G6j4Cyk4CJs4Sqs4SYsYUGBUso7hnlbI3XET+Cx24n11BxqdiyhKqyhImyhLKSgL0hFb5CDVshFL4jD6ojxxkHr0lqP3PH4AAMhEevOZzQ6AAAAAElFTkSuQmCC", Jx = () => /* @__PURE__ */ Me.jsx("span", { children: /* @__PURE__ */ Me.jsx("img", { src: nW, alt: "오른쪽 화살표" }) });
Jx.displayName = "IconArrowRight";
const iW = ({
  children: t,
  className: e = "",
  style: i = {},
  disabled: a = !1
}) => {
  const { type: o, updateNowMonth: f } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_next ${o} ${e}`,
      disabled: a,
      onClick: () => f(1),
      style: i,
      children: t || o === "type1" && /* @__PURE__ */ Me.jsx(Jx, {})
    }
  );
};
iW.displayName = "HSingleDatePickerNextButton";
const rW = ({
  children: t,
  className: e = "",
  style: i = {},
  disabled: a = !1
}) => {
  const { type: o, updateNowMonth: f } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_prev ${o} ${e}`,
      disabled: a,
      onClick: () => f(-1),
      style: i,
      children: t || o === "type1" && /* @__PURE__ */ Me.jsx(Zx, {})
    }
  );
};
rW.displayName = "HSingleDatePickerPrevButton";
const aW = ({
  children: t,
  className: e = "",
  style: i = {},
  ...a
}) => {
  const { calendarYearAreaRef: o, type: f, calendarPosition: u } = Gi(), [h, m] = Tn({});
  return Xn(() => {
    if (!u)
      return;
    const {
      bottom: v,
      left: b,
      right: S,
      top: C,
      clientWidth: E,
      clientHeight: D,
      minusWidth: M
    } = u;
    if (!o.current)
      return;
    const { height: A, width: P } = o.current.getBoundingClientRect();
    m({
      position: "fixed",
      zIndex: "220",
      ...HE(C, v, A, D),
      ...UE(b, S, P, E, M)
    });
  }, [u, o]), /* @__PURE__ */ Me.jsx(
    "div",
    {
      ref: o,
      className: `h_calendar_year_area ${f} ${e}`,
      style: {
        position: "fixed",
        ...i,
        ...h
      },
      ...a,
      children: t
    }
  );
};
aW.displayName = "HSingleDatePickerCalendarYearArea";
const sW = ({
  children: t,
  className: e = "",
  style: i = {},
  disabled: a = !1
}) => {
  const { type: o, updateIsActiveYearCalendar: f } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_year ${o} ${e}`,
      onClick: f,
      style: i,
      disabled: a,
      children: t
    }
  );
};
sW.displayName = "HSingleDatePickerYearButton";
const oW = ({
  children: t,
  className: e = "",
  style: i = {}
}) => {
  const { type: a, updateYearForYearCalendar: o, yearsArrLength: f } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_year_next ${a} ${e}`,
      onClick: () => o(f),
      style: i,
      children: t || a === "type1" && /* @__PURE__ */ Me.jsx(Jx, {})
    }
  );
};
oW.displayName = "HSingleDatePickerYearNextButton";
const lW = ({
  children: t,
  className: e = "",
  value: i,
  disabled: a = !1,
  style: o = {}
}) => {
  const { type: f, setNowYearByYearCalendar: u } = Gi(), h = () => {
    u(i);
  };
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_common ${f} ${e}`,
      onClick: h,
      disabled: a,
      style: o,
      children: t
    }
  );
};
lW.displayName = "HSingleDatePickerCalendarYearButton";
const tN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFgSURBVHgB7ZnRbYNADIZ9iAceM8J1g3aDdJL2CcRTlQ3aEfqE4KXqBO0G7QbpBmUEFgDii4gURbkAZ0cOkj/pMNKPJf9wdzIAoCiKokhRluW/GxAINd8RAw0LNCwQiWDhGJ9QVdULhue+71fgxw6xhjDsWL4xpsEa3rIs+z6ne6cQJr1iuFT8uUJCseCvw4UPHPMMwFA83oGHtm2bU7HrulUcx9vh/A5mMiX/6BrvjRxdxGma/vk03EH2Mc/zGgKYkn+4xsfiFzF1G62BRg1ESAZwjj4mSdJAINR8B8lA6Nznyncsfg2oAWnUgDRqQBoWA9h633NrUyEbwGbrC1veLRbzw6XNgeMJrN0Bi1kzapMhG8B+ZoPvDL94uuHSWMBH3LsBwozVobuQNGpAGjUgjRqQRg1IM/pZhfoD4tp4DWCz9RlF0RMw/ISggh3ru08zlxKLorBwA3B8AFMU5UbZAevho9IdayVBAAAAAElFTkSuQmCC";
var mr = [];
for (var aT = 0; aT < 256; ++aT)
  mr.push((aT + 256).toString(16).slice(1));
function uW(t, e = 0) {
  return (mr[t[e + 0]] + mr[t[e + 1]] + mr[t[e + 2]] + mr[t[e + 3]] + "-" + mr[t[e + 4]] + mr[t[e + 5]] + "-" + mr[t[e + 6]] + mr[t[e + 7]] + "-" + mr[t[e + 8]] + mr[t[e + 9]] + "-" + mr[t[e + 10]] + mr[t[e + 11]] + mr[t[e + 12]] + mr[t[e + 13]] + mr[t[e + 14]] + mr[t[e + 15]]).toLowerCase();
}
var Kb, cW = new Uint8Array(16);
function fW() {
  if (!Kb && (Kb = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Kb))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Kb(cW);
}
var dW = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const GA = {
  randomUUID: dW
};
function hW(t, e, i) {
  if (GA.randomUUID && !t)
    return GA.randomUUID();
  t = t || {};
  var a = t.random || (t.rng || fW)();
  return a[6] = a[6] & 15 | 64, a[8] = a[8] & 63 | 128, uW(a);
}
function KA() {
  return hW();
}
const nN = ({ className: t }) => /* @__PURE__ */ Me.jsx("img", { src: tN, alt: "달력 이미지", className: t });
nN.displayName = "IconCalendar";
const pW = ({
  reactiveImage: t = !1,
  placeholder: e = "",
  className: i = "",
  inputClassName: a = "",
  iconClassName: o = "",
  style: f = {},
  inputName: u = "",
  ...h
}) => {
  const {
    calendarInputAreaRef: m,
    calendarInputButtonRef: v,
    type: b,
    selectedDatePickerValue: S,
    clickedDatePickerInput: C,
    focusInDatePickerInput: E,
    focusOutDatePickerInput: D,
    isDisabledValue: M,
    updateSelectedDatePickerValue: A
  } = Gi(), [P, N] = Tn(KA());
  return Xn(() => {
    N(KA()), A(S);
  }, [S]), /* @__PURE__ */ Me.jsxs(
    "div",
    {
      ref: m,
      className: `h_inp_datepicker_area ${b} ${i}`,
      style: f,
      ...h,
      children: [
        t ? /* @__PURE__ */ Me.jsx("img", { className: `icon_calendar ${o}`, src: tN, alt: "달력 이미지" }) : b === "type1" && /* @__PURE__ */ Me.jsx(nN, { className: o }),
        /* @__PURE__ */ Me.jsx(
          "input",
          {
            id: P,
            ref: v,
            type: "text",
            className: `inp_datepicker ${a}`,
            defaultValue: S,
            disabled: M,
            placeholder: e,
            onClick: C,
            onKeyUp: E,
            onBlur: D,
            onChange: () => {
            },
            name: u
          },
          P
        )
      ]
    }
  );
};
pW.displayName = "HSingleDatePickerInput";
const mW = ({
  children: t,
  className: e = "",
  style: i = {}
}) => {
  const { type: a, updateYearForMonthCalendar: o } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_month_next ${a} ${e}`,
      onClick: () => o(1),
      style: i,
      children: t || a === "type1" && /* @__PURE__ */ Me.jsx(Jx, {})
    }
  );
};
mW.displayName = "HSingleDatePickerMonthNextButton";
const gW = ({ children: t, className: e = "", style: i = {} }) => {
  const { type: a, updateIsActiveYearCalendar: o } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_year_in_month ${a} ${e}`,
      onClick: o,
      style: i,
      children: t
    }
  );
};
gW.displayName = "HSingleDatePickerMonthYearButton";
const vW = ({
  children: t,
  className: e = "",
  style: i = {}
}) => {
  const { type: a, updateYearForYearCalendar: o, yearsArrLength: f } = Gi();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      className: `h_btn_calendar_year_prev ${a} ${e}`,
      onClick: () => o(-1 * f),
      style: i,
      children: t || a === "type1" && /* @__PURE__ */ Me.jsx(Zx, {})
    }
  );
};
vW.displayName = "HSingleDatePickerYearPrevButton";
const iN = Io(void 0), yW = pp(({
  children: t,
  initialSelectedValue: e = null,
  onBlurDropdown: i = () => {
  },
  onChangeSelectedValue: a = () => {
  },
  scrollEventRefs: o = [],
  disabled: f = !1,
  style: u,
  ...h
}, m) => {
  const v = Sn(null), b = Sn(null), S = Sn(null), [C, E] = Tn(e), [D, M] = Tn(!1), [A, P] = Tn(0), [N, F] = Tn({
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    clientWidth: 0,
    clientHeight: 0
  });
  $x(m, () => ({
    selectedValue: C,
    dropdownAreaWidth: A,
    isActiveList: D
  }));
  const B = () => {
    if (M((Oe) => !Oe), !v.current)
      return;
    const { bottom: oe, left: se, right: Pe, top: Te, width: Se } = v.current.getBoundingClientRect();
    P(Se), F({
      top: Te,
      bottom: oe,
      left: se,
      right: Pe,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight
    });
  }, V = () => {
    if (!v.current)
      return;
    const { top: oe, bottom: se, left: Pe, right: Te } = v.current.getBoundingClientRect();
    F((Se) => ({
      ...Se,
      top: oe,
      bottom: se,
      left: Pe,
      right: Te
    }));
  }, G = () => {
    F((oe) => ({
      ...oe,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight
    }));
  }, Y = (oe) => {
    const se = oe.target;
    if (!(se instanceof HTMLElement))
      return;
    const Pe = se.closest(
      ".h_dropdown_button"
    );
    if (Pe) {
      Pe !== b.current && (M(!1), i());
      return;
    }
    const Te = se.closest(".h_dropdown_list");
    Te || (M(!1), i()), Te !== S.current && (M(!1), i());
  }, K = (oe, se) => {
    E(se), M(!1), a(se);
  };
  Xn(() => (D ? (window.addEventListener("scroll", V), Array.isArray(o) && o.forEach((oe) => {
    const se = document.querySelector(oe);
    se instanceof HTMLElement && se.addEventListener("scroll", V);
  }), window.addEventListener("resize", G), window.addEventListener("click", Y)) : (window.removeEventListener("scroll", V), Array.isArray(o) && o.forEach((oe) => {
    const se = document.querySelector(oe);
    se instanceof HTMLElement && se.removeEventListener(
      "scroll",
      V
    );
  }), window.removeEventListener("resize", G), window.removeEventListener("click", Y)), () => {
    window.removeEventListener("scroll", V), window.removeEventListener("resize", G), window.removeEventListener("click", Y);
  }), [D]);
  const [ae, ie] = Tn(f);
  Xn(() => {
    ie(f);
  }, [f]);
  const ee = {
    onClickedDropdownButton: B,
    isActiveList: D,
    listPosition: N,
    dropdownListRef: S,
    dropdownButtonRef: b,
    onClickedDropdownItemButton: K,
    isButtonDisabled: ae
  };
  return /* @__PURE__ */ Me.jsx(iN.Provider, { value: ee, children: /* @__PURE__ */ Me.jsx("div", { ref: v, className: "h_dropdown_area", style: u, ...h, children: t({ isActiveList: D, dropdownAreaWidth: A }) }) });
});
yW.displayName = "HDropdownArea";
const bW = ({ children: t }) => /* @__PURE__ */ Me.jsx("div", { className: "h_dropdown_item", children: t });
bW.displayName = "HDropdownItem";
const IE = () => {
  const t = ki(iN);
  if (!t)
    throw new Error("useHDropdownAreaContext must be used within a HDropdownAreaProvider");
  return t;
}, xW = ({ children: t, ...e }) => {
  const { onClickedDropdownButton: i, dropdownButtonRef: a, isButtonDisabled: o } = IE();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      ref: a,
      onClick: i,
      disabled: o,
      className: "h_dropdown_button",
      ...e,
      children: t
    }
  );
};
xW.displayName = "HDropdownButton";
const SW = ({
  children: t,
  disabled: e = !1,
  optionValue: i,
  onClick: a,
  className: o,
  ...f
}) => {
  const { onClickedDropdownItemButton: u } = IE();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      disabled: e,
      onClick: (h) => {
        u(h, i), a == null || a(h, i);
      },
      className: `h_dropdown_item_button ${o}`,
      ...f,
      children: t
    }
  );
};
SW.displayName = "HDropdownItemButton";
/*!
 * OverlayScrollbars
 * Version: 2.10.0
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */
const Ba = (t, e) => {
  const { o: i, i: a, u: o } = t;
  let f = i, u;
  const h = (b, S) => {
    const C = f, E = b, D = S || (a ? !a(C, E) : C !== E);
    return (D || o) && (f = E, u = C), [f, D, u];
  };
  return [e ? (b) => h(e(f, u), b) : h, (b) => [f, !!b, u]];
}, _W = typeof window < "u" && typeof HTMLElement < "u" && !!window.document, Ca = _W ? window : {}, rN = Math.max, CW = Math.min, BT = Math.round, Rx = Math.abs, XA = Math.sign, aN = Ca.cancelAnimationFrame, $E = Ca.requestAnimationFrame, Dx = Ca.setTimeout, HT = Ca.clearTimeout, eS = (t) => typeof Ca[t] < "u" ? Ca[t] : void 0, wW = eS("MutationObserver"), QA = eS("IntersectionObserver"), kx = eS("ResizeObserver"), dx = eS("ScrollTimeline"), WE = (t) => t === void 0, tS = (t) => t === null, Vo = (t) => typeof t == "number", kv = (t) => typeof t == "string", YE = (t) => typeof t == "boolean", vs = (t) => typeof t == "function", Uo = (t) => Array.isArray(t), Mx = (t) => typeof t == "object" && !Uo(t) && !tS(t), GE = (t) => {
  const e = !!t && t.length, i = Vo(e) && e > -1 && e % 1 == 0;
  return Uo(t) || !vs(t) && i ? e > 0 && Mx(t) ? e - 1 in t : !0 : !1;
}, Ax = (t) => !!t && t.constructor === Object, Ox = (t) => t instanceof HTMLElement, nS = (t) => t instanceof Element;
function Rn(t, e) {
  if (GE(t))
    for (let i = 0; i < t.length && e(t[i], i, t) !== !1; i++)
      ;
  else t && Rn(Object.keys(t), (i) => e(t[i], i, t));
  return t;
}
const sN = (t, e) => t.indexOf(e) >= 0, gv = (t, e) => t.concat(e), ri = (t, e, i) => (!kv(e) && GE(e) ? Array.prototype.push.apply(t, e) : t.push(e), t), sc = (t) => Array.from(t || []), KE = (t) => Uo(t) ? t : !kv(t) && GE(t) ? sc(t) : [t], UT = (t) => !!t && !t.length, IT = (t) => sc(new Set(t)), $a = (t, e, i) => {
  Rn(t, (o) => o ? o.apply(void 0, e || []) : !0), !i && (t.length = 0);
}, oN = "paddingTop", lN = "paddingRight", uN = "paddingLeft", cN = "paddingBottom", fN = "marginLeft", dN = "marginRight", hN = "marginBottom", pN = "overflowX", mN = "overflowY", iS = "width", rS = "height", Yu = "visible", Vf = "hidden", op = "scroll", TW = (t) => {
  const e = String(t || "");
  return e ? e[0].toUpperCase() + e.slice(1) : "";
}, aS = (t, e, i, a) => {
  if (t && e) {
    let o = !0;
    return Rn(i, (f) => {
      const u = t[f], h = e[f];
      u !== h && (o = !1);
    }), o;
  }
  return !1;
}, gN = (t, e) => aS(t, e, ["w", "h"]), hx = (t, e) => aS(t, e, ["x", "y"]), EW = (t, e) => aS(t, e, ["t", "r", "b", "l"]), Uf = () => {
}, _t = (t, ...e) => t.bind(0, ...e), Gh = (t) => {
  let e;
  const i = t ? Dx : $E, a = t ? HT : aN;
  return [(o) => {
    a(e), e = i(() => o(), vs(t) ? t() : t);
  }, () => a(e)];
}, $T = (t, e) => {
  const { _: i, v: a, p: o, S: f } = e || {};
  let u, h, m, v, b = Uf;
  const S = function(A) {
    b(), HT(u), v = u = h = void 0, b = Uf, t.apply(this, A);
  }, C = (M) => f && h ? f(h, M) : M, E = () => {
    b !== Uf && S(C(m) || m);
  }, D = function() {
    const A = sc(arguments), P = vs(i) ? i() : i;
    if (Vo(P) && P >= 0) {
      const F = vs(a) ? a() : a, B = Vo(F) && F >= 0, V = P > 0 ? Dx : $E, G = P > 0 ? HT : aN, K = C(A) || A, ae = S.bind(0, K);
      let ie;
      b(), o && !v ? (ae(), v = !0, ie = V(() => v = void 0, P)) : (ie = V(ae, P), B && !u && (u = Dx(E, F))), b = () => G(ie), h = m = K;
    } else
      S(A);
  };
  return D.m = E, D;
}, vN = (t, e) => Object.prototype.hasOwnProperty.call(t, e), Qs = (t) => t ? Object.keys(t) : [], fn = (t, e, i, a, o, f, u) => {
  const h = [e, i, a, o, f, u];
  return (typeof t != "object" || tS(t)) && !vs(t) && (t = {}), Rn(h, (m) => {
    Rn(m, (v, b) => {
      const S = m[b];
      if (t === S)
        return !0;
      const C = Uo(S);
      if (S && Ax(S)) {
        const E = t[b];
        let D = E;
        C && !Uo(E) ? D = [] : !C && !Ax(E) && (D = {}), t[b] = fn(D, S);
      } else
        t[b] = C ? S.slice() : S;
    });
  }), t;
}, yN = (t, e) => Rn(fn({}, t), (i, a, o) => {
  i === void 0 ? delete o[a] : i && Ax(i) && (o[a] = yN(i));
}), XE = (t) => !Qs(t).length, bN = (t, e, i) => rN(t, CW(e, i)), If = (t) => IT((Uo(t) ? t : (t || "").split(" ")).filter((e) => e)), QE = (t, e) => t && t.getAttribute(e), qA = (t, e) => t && t.hasAttribute(e), jl = (t, e, i) => {
  Rn(If(e), (a) => {
    t && t.setAttribute(a, String(i || ""));
  });
}, Oo = (t, e) => {
  Rn(If(e), (i) => t && t.removeAttribute(i));
}, sS = (t, e) => {
  const i = If(QE(t, e)), a = _t(jl, t, e), o = (f, u) => {
    const h = new Set(i);
    return Rn(If(f), (m) => {
      h[u](m);
    }), sc(h).join(" ");
  };
  return {
    O: (f) => a(o(f, "delete")),
    $: (f) => a(o(f, "add")),
    C: (f) => {
      const u = If(f);
      return u.reduce((h, m) => h && i.includes(m), u.length > 0);
    }
  };
}, xN = (t, e, i) => (sS(t, e).O(i), _t(qE, t, e, i)), qE = (t, e, i) => (sS(t, e).$(i), _t(xN, t, e, i)), Px = (t, e, i, a) => (a ? qE : xN)(t, e, i), ZE = (t, e, i) => sS(t, e).C(i), SN = (t) => sS(t, "class"), _N = (t, e) => {
  SN(t).O(e);
}, JE = (t, e) => (SN(t).$(e), _t(_N, t, e)), CN = (t, e) => {
  const i = e ? nS(e) && e : document;
  return i ? sc(i.querySelectorAll(t)) : [];
}, RW = (t, e) => {
  const i = e ? nS(e) && e : document;
  return i && i.querySelector(t);
}, WT = (t, e) => nS(t) && t.matches(e), wN = (t) => WT(t, "body"), YT = (t) => t ? sc(t.childNodes) : [], vv = (t) => t && t.parentElement, Kh = (t, e) => nS(t) && t.closest(e), GT = (t) => document.activeElement, DW = (t, e, i) => {
  const a = Kh(t, e), o = t && RW(i, a), f = Kh(o, e) === a;
  return a && o ? a === t || o === t || f && Kh(Kh(t, i), e) !== a : !1;
}, lp = (t) => {
  Rn(KE(t), (e) => {
    const i = vv(e);
    e && i && i.removeChild(e);
  });
}, Ua = (t, e) => _t(lp, t && e && Rn(KE(e), (i) => {
  i && t.appendChild(i);
})), tp = (t) => {
  const e = document.createElement("div");
  return jl(e, "class", t), e;
}, TN = (t) => {
  const e = tp();
  return e.innerHTML = t.trim(), Rn(YT(e), (i) => lp(i));
}, ZA = (t, e) => t.getPropertyValue(e) || t[e] || "", EN = (t) => {
  const e = t || 0;
  return isFinite(e) ? e : 0;
}, Xb = (t) => EN(parseFloat(t || "")), KT = (t) => Math.round(t * 1e4) / 1e4, RN = (t) => `${KT(EN(t))}px`;
function yv(t, e) {
  t && e && Rn(e, (i, a) => {
    try {
      const o = t.style, f = tS(i) || YE(i) ? "" : Vo(i) ? RN(i) : i;
      a.indexOf("--") === 0 ? o.setProperty(a, f) : o[a] = f;
    } catch {
    }
  });
}
function Xl(t, e, i) {
  const a = kv(e);
  let o = a ? "" : {};
  if (t) {
    const f = Ca.getComputedStyle(t, i) || t.style;
    o = a ? ZA(f, e) : sc(e).reduce((u, h) => (u[h] = ZA(f, h), u), o);
  }
  return o;
}
const JA = (t, e, i) => {
  const a = e ? `${e}-` : "", o = i ? `-${i}` : "", f = `${a}top${o}`, u = `${a}right${o}`, h = `${a}bottom${o}`, m = `${a}left${o}`, v = Xl(t, [f, u, h, m]);
  return {
    t: Xb(v[f]),
    r: Xb(v[u]),
    b: Xb(v[h]),
    l: Xb(v[m])
  };
}, kW = (t, e) => `translate${Mx(t) ? `(${t.x},${t.y})` : `Y(${t})`}`, MW = (t) => !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length), AW = {
  w: 0,
  h: 0
}, oS = (t, e) => e ? {
  w: e[`${t}Width`],
  h: e[`${t}Height`]
} : AW, OW = (t) => oS("inner", t || Ca), np = _t(oS, "offset"), DN = _t(oS, "client"), Lx = _t(oS, "scroll"), e1 = (t) => {
  const e = parseFloat(Xl(t, iS)) || 0, i = parseFloat(Xl(t, rS)) || 0;
  return {
    w: e - BT(e),
    h: i - BT(i)
  };
}, sT = (t) => t.getBoundingClientRect(), PW = (t) => !!t && MW(t), XT = (t) => !!(t && (t[rS] || t[iS])), kN = (t, e) => {
  const i = XT(t);
  return !XT(e) && i;
}, eO = (t, e, i, a) => {
  Rn(If(e), (o) => {
    t && t.removeEventListener(o, i, a);
  });
}, Gn = (t, e, i, a) => {
  var o;
  const f = (o = a && a.H) != null ? o : !0, u = a && a.I || !1, h = a && a.A || !1, m = {
    passive: f,
    capture: u
  };
  return _t($a, If(e).map((v) => {
    const b = h ? (S) => {
      eO(t, v, b, u), i && i(S);
    } : i;
    return t && t.addEventListener(v, b, m), _t(eO, t, v, b, u);
  }));
}, MN = (t) => t.stopPropagation(), QT = (t) => t.preventDefault(), AN = (t) => MN(t) || QT(t), No = (t, e) => {
  const { x: i, y: a } = Vo(e) ? {
    x: e,
    y: e
  } : e || {};
  Vo(i) && (t.scrollLeft = i), Vo(a) && (t.scrollTop = a);
}, Ia = (t) => ({
  x: t.scrollLeft,
  y: t.scrollTop
}), ON = () => ({
  D: {
    x: 0,
    y: 0
  },
  M: {
    x: 0,
    y: 0
  }
}), LW = (t, e) => {
  const { D: i, M: a } = t, { w: o, h: f } = e, u = (S, C, E) => {
    let D = XA(S) * E, M = XA(C) * E;
    if (D === M) {
      const A = Rx(S), P = Rx(C);
      M = A > P ? 0 : M, D = A < P ? 0 : D;
    }
    return D = D === M ? 0 : D, [D + 0, M + 0];
  }, [h, m] = u(i.x, a.x, o), [v, b] = u(i.y, a.y, f);
  return {
    D: {
      x: h,
      y: v
    },
    M: {
      x: m,
      y: b
    }
  };
}, tO = ({ D: t, M: e }) => {
  const i = (a, o) => a === 0 && a <= o;
  return {
    x: i(t.x, e.x),
    y: i(t.y, e.y)
  };
}, nO = ({ D: t, M: e }, i) => {
  const a = (o, f, u) => bN(0, 1, (o - u) / (o - f) || 0);
  return {
    x: a(t.x, e.x, i.x),
    y: a(t.y, e.y, i.y)
  };
}, qT = (t) => {
  t && t.focus && t.focus({
    preventScroll: !0
  });
}, iO = (t, e) => {
  Rn(KE(e), t);
}, ZT = (t) => {
  const e = /* @__PURE__ */ new Map(), i = (f, u) => {
    if (f) {
      const h = e.get(f);
      iO((m) => {
        h && h[m ? "delete" : "clear"](m);
      }, u);
    } else
      e.forEach((h) => {
        h.clear();
      }), e.clear();
  }, a = (f, u) => {
    if (kv(f)) {
      const v = e.get(f) || /* @__PURE__ */ new Set();
      return e.set(f, v), iO((b) => {
        vs(b) && v.add(b);
      }, u), _t(i, f, u);
    }
    YE(u) && u && i();
    const h = Qs(f), m = [];
    return Rn(h, (v) => {
      const b = f[v];
      b && ri(m, a(v, b));
    }), _t($a, m);
  }, o = (f, u) => {
    Rn(sc(e.get(f)), (h) => {
      u && !UT(u) ? h.apply(0, u) : h();
    });
  };
  return a(t || {}), [a, i, o];
}, rO = (t) => JSON.stringify(t, (e, i) => {
  if (vs(i))
    throw 0;
  return i;
}), aO = (t, e) => t ? `${e}`.split(".").reduce((i, a) => i && vN(i, a) ? i[a] : void 0, t) : void 0, NW = {
  paddingAbsolute: !1,
  showNativeOverlaidScrollbars: !1,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    autoHideSuspend: !1,
    dragScroll: !0,
    clickScroll: !1,
    pointers: ["mouse", "touch", "pen"]
  }
}, PN = (t, e) => {
  const i = {}, a = gv(Qs(e), Qs(t));
  return Rn(a, (o) => {
    const f = t[o], u = e[o];
    if (Mx(f) && Mx(u))
      fn(i[o] = {}, PN(f, u)), XE(i[o]) && delete i[o];
    else if (vN(e, o) && u !== f) {
      let h = !0;
      if (Uo(f) || Uo(u))
        try {
          rO(f) === rO(u) && (h = !1);
        } catch {
        }
      h && (i[o] = u);
    }
  }), i;
}, sO = (t, e, i) => (a) => [aO(t, a), i || aO(e, a) !== void 0], mp = "data-overlayscrollbars", px = "os-environment", Qb = `${px}-scrollbar-hidden`, oT = `${mp}-initialize`, mx = "noClipping", oO = `${mp}-body`, Zu = mp, zW = "host", Bl = `${mp}-viewport`, FW = pN, VW = mN, jW = "arrange", LN = "measuring", BW = "scrolling", NN = "scrollbarHidden", HW = "noContent", JT = `${mp}-padding`, lO = `${mp}-content`, t1 = "os-size-observer", UW = `${t1}-appear`, IW = `${t1}-listener`, $W = "os-trinsic-observer", WW = "os-theme-none", Ya = "os-scrollbar", YW = `${Ya}-rtl`, GW = `${Ya}-horizontal`, KW = `${Ya}-vertical`, zN = `${Ya}-track`, n1 = `${Ya}-handle`, XW = `${Ya}-visible`, QW = `${Ya}-cornerless`, uO = `${Ya}-interaction`, cO = `${Ya}-unusable`, eE = `${Ya}-auto-hide`, fO = `${eE}-hidden`, dO = `${Ya}-wheel`, qW = `${zN}-interactive`, ZW = `${n1}-interactive`;
let FN;
const JW = () => FN, e8 = (t) => {
  FN = t;
};
let lT;
const t8 = () => {
  const t = (B, V, G) => {
    Ua(document.body, B), Ua(document.body, B);
    const Y = DN(B), K = np(B), ae = e1(V);
    return G && lp(B), {
      x: K.h - Y.h + ae.h,
      y: K.w - Y.w + ae.w
    };
  }, e = (B) => {
    let V = !1;
    const G = JE(B, Qb);
    try {
      V = Xl(B, "scrollbar-width") === "none" || Xl(B, "display", "::-webkit-scrollbar") === "none";
    } catch {
    }
    return G(), V;
  }, i = `.${px}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${px} div{width:200%;height:200%;margin:10px 0}.${Qb}{scrollbar-width:none!important}.${Qb}::-webkit-scrollbar,.${Qb}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`, o = TN(`<div class="${px}"><div></div><style>${i}</style></div>`)[0], f = o.firstChild, u = o.lastChild, h = JW();
  h && (u.nonce = h);
  const [m, , v] = ZT(), [b, S] = Ba({
    o: t(o, f),
    i: hx
  }, _t(t, o, f, !0)), [C] = S(), E = e(o), D = {
    x: C.x === 0,
    y: C.y === 0
  }, M = {
    elements: {
      host: null,
      padding: !E,
      viewport: (B) => E && wN(B) && B,
      content: !1
    },
    scrollbars: {
      slot: !0
    },
    cancel: {
      nativeScrollbarsOverlaid: !1,
      body: null
    }
  }, A = fn({}, NW), P = _t(fn, {}, A), N = _t(fn, {}, M), F = {
    T: C,
    k: D,
    R: E,
    V: !!dx,
    L: _t(m, "r"),
    U: N,
    P: (B) => fn(M, B) && N(),
    N: P,
    q: (B) => fn(A, B) && P(),
    B: fn({}, M),
    F: fn({}, A)
  };
  if (Oo(o, "style"), lp(o), Gn(Ca, "resize", () => {
    v("r", []);
  }), vs(Ca.matchMedia) && !E && (!D.x || !D.y)) {
    const B = (V) => {
      const G = Ca.matchMedia(`(resolution: ${Ca.devicePixelRatio}dppx)`);
      Gn(G, "change", () => {
        V(), B(V);
      }, {
        A: !0
      });
    };
    B(() => {
      const [V, G] = b();
      fn(F.T, V), v("r", [G]);
    });
  }
  return F;
}, $o = () => (lT || (lT = t8()), lT), VN = (t, e) => vs(e) ? e.apply(0, t) : e, n8 = (t, e, i, a) => {
  const o = WE(a) ? i : a;
  return VN(t, o) || e.apply(0, t);
}, jN = (t, e, i, a) => {
  const o = WE(a) ? i : a, f = VN(t, o);
  return !!f && (Ox(f) ? f : e.apply(0, t));
}, i8 = (t, e) => {
  const { nativeScrollbarsOverlaid: i, body: a } = e || {}, { k: o, R: f, U: u } = $o(), { nativeScrollbarsOverlaid: h, body: m } = u().cancel, v = i ?? h, b = WE(a) ? m : a, S = (o.x || o.y) && v, C = t && (tS(b) ? !f : b);
  return !!S || !!C;
}, i1 = /* @__PURE__ */ new WeakMap(), r8 = (t, e) => {
  i1.set(t, e);
}, a8 = (t) => {
  i1.delete(t);
}, BN = (t) => i1.get(t), s8 = (t, e, i) => {
  let a = !1;
  const o = i ? /* @__PURE__ */ new WeakMap() : !1, f = () => {
    a = !0;
  }, u = (h) => {
    if (o && i) {
      const m = i.map((v) => {
        const [b, S] = v || [];
        return [S && b ? (h || CN)(b, t) : [], S];
      });
      Rn(m, (v) => Rn(v[0], (b) => {
        const S = v[1], C = o.get(b) || [];
        if (t.contains(b) && S) {
          const D = Gn(b, S, (M) => {
            a ? (D(), o.delete(b)) : e(M);
          });
          o.set(b, ri(C, D));
        } else
          $a(C), o.delete(b);
      }));
    }
  };
  return u(), [f, u];
}, hO = (t, e, i, a) => {
  let o = !1;
  const { j: f, X: u, Y: h, W: m, J: v, G: b } = a || {}, S = $T(() => o && i(!0), {
    _: 33,
    v: 99
  }), [C, E] = s8(t, S, h), D = f || [], M = u || [], A = gv(D, M), P = (F, B) => {
    if (!UT(B)) {
      const V = v || Uf, G = b || Uf, Y = [], K = [];
      let ae = !1, ie = !1;
      if (Rn(B, (ee) => {
        const { attributeName: oe, target: se, type: Pe, oldValue: Te, addedNodes: Se, removedNodes: Oe } = ee, re = Pe === "attributes", ge = Pe === "childList", me = t === se, fe = re && oe, pe = fe && QE(se, oe || ""), Ae = kv(pe) ? pe : null, Ne = fe && Te !== Ae, de = sN(M, oe) && Ne;
        if (e && (ge || !me)) {
          const ze = re && Ne, De = ze && m && WT(se, m), ct = (De ? !V(se, oe, Te, Ae) : !re || ze) && !G(ee, !!De, t, a);
          Rn(Se, (gt) => ri(Y, gt)), Rn(Oe, (gt) => ri(Y, gt)), ie = ie || ct;
        }
        !e && me && Ne && !V(se, oe, Te, Ae) && (ri(K, oe), ae = ae || de);
      }), E((ee) => IT(Y).reduce((oe, se) => (ri(oe, CN(ee, se)), WT(se, ee) ? ri(oe, se) : oe), [])), e)
        return !F && ie && i(!1), [!1];
      if (!UT(K) || ae) {
        const ee = [IT(K), ae];
        return !F && i.apply(0, ee), ee;
      }
    }
  }, N = new wW(_t(P, !1));
  return [() => (N.observe(t, {
    attributes: !0,
    attributeOldValue: !0,
    attributeFilter: A,
    subtree: e,
    childList: e,
    characterData: e
  }), o = !0, () => {
    o && (C(), N.disconnect(), o = !1);
  }), () => {
    if (o)
      return S.m(), P(!0, N.takeRecords());
  }];
}, HN = {}, UN = {}, o8 = (t) => {
  Rn(t, (e) => Rn(e, (i, a) => {
    HN[a] = e[a];
  }));
}, IN = (t, e, i) => Qs(t).map((a) => {
  const { static: o, instance: f } = t[a], [u, h, m] = i || [], v = i ? f : o;
  if (v) {
    const b = i ? v(u, h, e) : v(e);
    return (m || UN)[a] = b;
  }
}), Mv = (t) => UN[t], l8 = "__osOptionsValidationPlugin", u8 = "__osSizeObserverPlugin", c8 = (t, e) => {
  const { k: i } = e, [a, o] = t("showNativeOverlaidScrollbars");
  return [a && i.x && i.y, o];
}, up = (t) => t.indexOf(Yu) === 0, f8 = (t, e) => {
  const i = (o, f, u, h) => {
    const m = o === Yu ? Vf : o.replace(`${Yu}-`, ""), v = up(o), b = up(u);
    return !f && !h ? Vf : v && b ? Yu : v ? f && h ? m : f ? Yu : Vf : f ? m : b && h ? Yu : Vf;
  }, a = {
    x: i(e.x, t.x, e.y, t.y),
    y: i(e.y, t.y, e.x, t.x)
  };
  return {
    K: a,
    Z: {
      x: a.x === op,
      y: a.y === op
    }
  };
}, $N = "__osScrollbarsHidingPlugin", d8 = "__osClickScrollPlugin", WN = (t, e, i) => {
  const { dt: a } = i || {}, o = Mv(u8), [f] = Ba({
    o: !1,
    u: !0
  });
  return () => {
    const u = [], m = TN(`<div class="${t1}"><div class="${IW}"></div></div>`)[0], v = m.firstChild, b = (S) => {
      const C = S instanceof ResizeObserverEntry;
      let E = !1, D = !1;
      if (C) {
        const [M, , A] = f(S.contentRect), P = XT(M);
        D = kN(M, A), E = !D && !P;
      } else
        D = S === !0;
      E || e({
        ft: !0,
        dt: D
      });
    };
    if (kx) {
      const S = new kx((C) => b(C.pop()));
      S.observe(v), ri(u, () => {
        S.disconnect();
      });
    } else if (o) {
      const [S, C] = o(v, b, a);
      ri(u, gv([JE(m, UW), Gn(m, "animationstart", S)], C));
    } else
      return Uf;
    return _t($a, ri(u, Ua(t, m)));
  };
}, h8 = (t, e) => {
  let i;
  const a = (m) => m.h === 0 || m.isIntersecting || m.intersectionRatio > 0, o = tp($W), [f] = Ba({
    o: !1
  }), u = (m, v) => {
    if (m) {
      const b = f(a(m)), [, S] = b;
      return S && !v && e(b) && [b];
    }
  }, h = (m, v) => u(v.pop(), m);
  return [() => {
    const m = [];
    if (QA)
      i = new QA(_t(h, !1), {
        root: t
      }), i.observe(o), ri(m, () => {
        i.disconnect();
      });
    else {
      const v = () => {
        const b = np(o);
        u(b);
      };
      ri(m, WN(o, v)()), v();
    }
    return _t($a, ri(m, Ua(t, o)));
  }, () => i && h(!0, i.takeRecords())];
}, p8 = (t, e, i, a) => {
  let o, f, u, h, m, v;
  const b = `[${Zu}]`, S = `[${Bl}]`, C = ["id", "class", "style", "open", "wrap", "cols", "rows"], { vt: E, ht: D, ot: M, gt: A, bt: P, nt: N, wt: F, yt: B, St: V, Ot: G } = t, Y = (de) => Xl(de, "direction") === "rtl", K = {
    $t: !1,
    ct: Y(E)
  }, ae = $o(), ie = Mv($N), [ee] = Ba({
    i: gN,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const de = ie && ie.tt(t, e, K, ae, i).ut, De = !(F && N) && ZE(D, Zu, mx), we = !N && B(jW), ct = we && Ia(A), gt = ct && G(), pt = V(LN, De), At = we && de && de()[0], xt = Lx(M), tt = e1(M);
    return At && At(), No(A, ct), gt && gt(), De && pt(), {
      w: xt.w + tt.w,
      h: xt.h + tt.h
    };
  }), oe = $T(a, {
    _: () => o,
    v: () => f,
    S(de, ze) {
      const [De] = de, [we] = ze;
      return [gv(Qs(De), Qs(we)).reduce((ct, gt) => (ct[gt] = De[gt] || we[gt], ct), {})];
    }
  }), se = (de) => {
    const ze = Y(E);
    fn(de, {
      Ct: v !== ze
    }), fn(K, {
      ct: ze
    }), v = ze;
  }, Pe = (de, ze) => {
    const [De, we] = de, ct = {
      xt: we
    };
    return fn(K, {
      $t: De
    }), !ze && a(ct), ct;
  }, Te = ({ ft: de, dt: ze }) => {
    const we = !(de && !ze) && ae.R ? oe : a, ct = {
      ft: de || ze,
      dt: ze
    };
    se(ct), we(ct);
  }, Se = (de, ze) => {
    const [, De] = ee(), we = {
      Ht: De
    };
    return se(we), De && !ze && (de ? a : oe)(we), we;
  }, Oe = (de, ze, De) => {
    const we = {
      Et: ze
    };
    return se(we), ze && !De && oe(we), we;
  }, [re, ge] = P ? h8(D, Pe) : [], me = !N && WN(D, Te, {
    dt: !0
  }), [fe, pe] = hO(D, !1, Oe, {
    X: C,
    j: C
  }), Ae = N && kx && new kx((de) => {
    const ze = de[de.length - 1].contentRect;
    Te({
      ft: !0,
      dt: kN(ze, m)
    }), m = ze;
  }), Ne = $T(() => {
    const [, de] = ee();
    a({
      Ht: de
    });
  }, {
    _: 222,
    p: !0
  });
  return [() => {
    Ae && Ae.observe(D);
    const de = me && me(), ze = re && re(), De = fe(), we = ae.L((ct) => {
      ct ? oe({
        zt: ct
      }) : Ne();
    });
    return () => {
      Ae && Ae.disconnect(), de && de(), ze && ze(), h && h(), De(), we();
    };
  }, ({ It: de, At: ze, Dt: De }) => {
    const we = {}, [ct] = de("update.ignoreMutation"), [gt, pt] = de("update.attributes"), [At, xt] = de("update.elementEvents"), [tt, Et] = de("update.debounce"), Wt = xt || pt, on = ze || De, ln = (Yt) => vs(ct) && ct(Yt);
    if (Wt) {
      u && u(), h && h();
      const [Yt, Xt] = hO(P || M, !0, Se, {
        j: gv(C, gt || []),
        Y: At,
        W: b,
        G: (Dt, Rt) => {
          const { target: Bt, attributeName: Dn } = Dt;
          return (!Rt && Dn && !N ? DW(Bt, b, S) : !1) || !!Kh(Bt, `.${Ya}`) || !!ln(Dt);
        }
      });
      h = Yt(), u = Xt;
    }
    if (Et)
      if (oe.m(), Uo(tt)) {
        const Yt = tt[0], Xt = tt[1];
        o = Vo(Yt) && Yt, f = Vo(Xt) && Xt;
      } else Vo(tt) ? (o = tt, f = !1) : (o = !1, f = !1);
    if (on) {
      const Yt = pe(), Xt = ge && ge(), Dt = u && u();
      Yt && fn(we, Oe(Yt[0], Yt[1], on)), Xt && fn(we, Pe(Xt[0], on)), Dt && fn(we, Se(Dt[0], on));
    }
    return se(we), we;
  }, K];
}, m8 = (t, e, i, a) => {
  const o = "--os-viewport-percent", f = "--os-scroll-percent", u = "--os-scroll-direction", { U: h } = $o(), { scrollbars: m } = h(), { slot: v } = m, { vt: b, ht: S, ot: C, Mt: E, gt: D, wt: M, nt: A } = e, { scrollbars: P } = E ? {} : t, { slot: N } = P || {}, F = [], B = [], V = [], G = jN([b, S, C], () => A && M ? b : S, v, N), Y = (fe) => {
    if (dx) {
      const pe = new dx({
        source: D,
        axis: fe
      });
      return {
        kt: (Ne) => {
          const de = Ne.Tt.animate({
            clear: ["left"],
            [f]: [0, 1]
          }, {
            timeline: pe
          });
          return () => de.cancel();
        }
      };
    }
  }, K = {
    x: Y("x"),
    y: Y("y")
  }, ae = () => {
    const { Rt: fe, Vt: pe } = i, Ae = (Ne, de) => bN(0, 1, Ne / (Ne + de) || 0);
    return {
      x: Ae(pe.x, fe.x),
      y: Ae(pe.y, fe.y)
    };
  }, ie = (fe, pe, Ae) => {
    const Ne = Ae ? JE : _N;
    Rn(fe, (de) => {
      Ne(de.Tt, pe);
    });
  }, ee = (fe, pe) => {
    Rn(fe, (Ae) => {
      const [Ne, de] = pe(Ae);
      yv(Ne, de);
    });
  }, oe = (fe, pe, Ae) => {
    const Ne = YE(Ae), de = Ne ? Ae : !0, ze = Ne ? !Ae : !0;
    de && ie(B, fe, pe), ze && ie(V, fe, pe);
  }, se = () => {
    const fe = ae(), pe = (Ae) => (Ne) => [Ne.Tt, {
      [o]: KT(Ae) + ""
    }];
    ee(B, pe(fe.x)), ee(V, pe(fe.y));
  }, Pe = () => {
    if (!dx) {
      const { Lt: fe } = i, pe = nO(fe, Ia(D)), Ae = (Ne) => (de) => [de.Tt, {
        [f]: KT(Ne) + ""
      }];
      ee(B, Ae(pe.x)), ee(V, Ae(pe.y));
    }
  }, Te = () => {
    const { Lt: fe } = i, pe = tO(fe), Ae = (Ne) => (de) => [de.Tt, {
      [u]: Ne ? "0" : "1"
    }];
    ee(B, Ae(pe.x)), ee(V, Ae(pe.y));
  }, Se = () => {
    if (A && !M) {
      const { Rt: fe, Lt: pe } = i, Ae = tO(pe), Ne = nO(pe, Ia(D)), de = (ze) => {
        const { Tt: De } = ze, we = vv(De) === C && De, ct = (gt, pt, At) => {
          const xt = pt * gt;
          return RN(At ? xt : -xt);
        };
        return [we, we && {
          transform: kW({
            x: ct(Ne.x, fe.x, Ae.x),
            y: ct(Ne.y, fe.y, Ae.y)
          })
        }];
      };
      ee(B, de), ee(V, de);
    }
  }, Oe = (fe) => {
    const pe = fe ? "x" : "y", Ne = tp(`${Ya} ${fe ? GW : KW}`), de = tp(zN), ze = tp(n1), De = {
      Tt: Ne,
      Ut: de,
      Pt: ze
    }, we = K[pe];
    return ri(fe ? B : V, De), ri(F, [Ua(Ne, de), Ua(de, ze), _t(lp, Ne), we && we.kt(De), a(De, oe, fe)]), De;
  }, re = _t(Oe, !0), ge = _t(Oe, !1), me = () => (Ua(G, B[0].Tt), Ua(G, V[0].Tt), _t($a, F));
  return re(), ge(), [{
    Nt: se,
    qt: Pe,
    Bt: Te,
    Ft: Se,
    jt: oe,
    Xt: {
      Yt: B,
      Wt: re,
      Jt: _t(ee, B)
    },
    Gt: {
      Yt: V,
      Wt: ge,
      Jt: _t(ee, V)
    }
  }, me];
}, g8 = (t, e, i, a) => (o, f, u) => {
  const { ht: h, ot: m, nt: v, gt: b, Kt: S, Ot: C } = e, { Tt: E, Ut: D, Pt: M } = o, [A, P] = Gh(333), [N, F] = Gh(444), B = (Y) => {
    vs(b.scrollBy) && b.scrollBy({
      behavior: "smooth",
      left: Y.x,
      top: Y.y
    });
  }, V = () => {
    const Y = "pointerup pointercancel lostpointercapture", K = `client${u ? "X" : "Y"}`, ae = u ? iS : rS, ie = u ? "left" : "top", ee = u ? "w" : "h", oe = u ? "x" : "y", se = (Te, Se) => (Oe) => {
      const { Rt: re } = i, ge = np(D)[ee] - np(M)[ee], fe = Se * Oe / ge * re[oe];
      No(b, {
        [oe]: Te + fe
      });
    }, Pe = [];
    return Gn(D, "pointerdown", (Te) => {
      const Se = Kh(Te.target, `.${n1}`) === M, Oe = Se ? M : D, re = t.scrollbars, ge = re[Se ? "dragScroll" : "clickScroll"], { button: me, isPrimary: fe, pointerType: pe } = Te, { pointers: Ae } = re;
      if (me === 0 && fe && ge && (Ae || []).includes(pe)) {
        $a(Pe), F();
        const de = !Se && (Te.shiftKey || ge === "instant"), ze = _t(sT, M), De = _t(sT, D), we = (Rt, Bt) => (Rt || ze())[ie] - (Bt || De())[ie], ct = BT(sT(b)[ae]) / np(b)[ee] || 1, gt = se(Ia(b)[oe], 1 / ct), pt = Te[K], At = ze(), xt = De(), tt = At[ae], Et = we(At, xt) + tt / 2, Wt = pt - xt[ie], on = Se ? 0 : Wt - Et, ln = (Rt) => {
          $a(Dt), Oe.releasePointerCapture(Rt.pointerId);
        }, Yt = Se || de, Xt = C(), Dt = [Gn(S, Y, ln), Gn(S, "selectstart", (Rt) => QT(Rt), {
          H: !1
        }), Gn(D, Y, ln), Yt && Gn(D, "pointermove", (Rt) => gt(on + (Rt[K] - pt))), Yt && (() => {
          const Rt = Ia(b);
          Xt();
          const Bt = Ia(b), Dn = {
            x: Bt.x - Rt.x,
            y: Bt.y - Rt.y
          };
          (Rx(Dn.x) > 3 || Rx(Dn.y) > 3) && (C(), No(b, Rt), B(Dn), N(Xt));
        })];
        if (Oe.setPointerCapture(Te.pointerId), de)
          gt(on);
        else if (!Se) {
          const Rt = Mv(d8);
          if (Rt) {
            const Bt = Rt(gt, on, tt, (Dn) => {
              Dn ? Xt() : ri(Dt, Xt);
            });
            ri(Dt, Bt), ri(Pe, _t(Bt, !0));
          }
        }
      }
    });
  };
  let G = !0;
  return _t($a, [Gn(M, "pointermove pointerleave", a), Gn(E, "pointerenter", () => {
    f(uO, !0);
  }), Gn(E, "pointerleave pointercancel", () => {
    f(uO, !1);
  }), !v && Gn(E, "mousedown", () => {
    const Y = GT();
    (qA(Y, Bl) || qA(Y, Zu) || Y === document.body) && Dx(_t(qT, m), 25);
  }), Gn(E, "wheel", (Y) => {
    const { deltaX: K, deltaY: ae, deltaMode: ie } = Y;
    G && ie === 0 && vv(E) === h && B({
      x: K,
      y: ae
    }), G = !1, f(dO, !0), A(() => {
      G = !0, f(dO);
    }), QT(Y);
  }, {
    H: !1,
    I: !0
  }), Gn(E, "pointerdown", _t(Gn, S, "click", AN, {
    A: !0,
    I: !0,
    H: !1
  }), {
    I: !0
  }), V(), P, F]);
}, v8 = (t, e, i, a, o, f) => {
  let u, h, m, v, b, S = Uf, C = 0;
  const E = (fe) => fe.pointerType === "mouse", [D, M] = Gh(), [A, P] = Gh(100), [N, F] = Gh(100), [B, V] = Gh(() => C), [G, Y] = m8(t, o, a, g8(e, o, a, (fe) => E(fe) && Oe())), { ht: K, Qt: ae, wt: ie } = o, { jt: ee, Nt: oe, qt: se, Bt: Pe, Ft: Te } = G, Se = (fe, pe) => {
    if (V(), fe)
      ee(fO);
    else {
      const Ae = _t(ee, fO, !0);
      C > 0 && !pe ? B(Ae) : Ae();
    }
  }, Oe = () => {
    (m ? !u : !v) && (Se(!0), A(() => {
      Se(!1);
    }));
  }, re = (fe) => {
    ee(eE, fe, !0), ee(eE, fe, !1);
  }, ge = (fe) => {
    E(fe) && (u = m, m && Se(!0));
  }, me = [V, P, F, M, () => S(), Gn(K, "pointerover", ge, {
    A: !0
  }), Gn(K, "pointerenter", ge), Gn(K, "pointerleave", (fe) => {
    E(fe) && (u = !1, m && Se(!1));
  }), Gn(K, "pointermove", (fe) => {
    E(fe) && h && Oe();
  }), Gn(ae, "scroll", (fe) => {
    D(() => {
      se(), Oe();
    }), f(fe), Te();
  })];
  return [() => _t($a, ri(me, Y())), ({ It: fe, Dt: pe, Zt: Ae, tn: Ne }) => {
    const { nn: de, sn: ze, en: De, cn: we } = Ne || {}, { Ct: ct, dt: gt } = Ae || {}, { ct: pt } = i, { k: At } = $o(), { K: xt, rn: tt } = a, [Et, Wt] = fe("showNativeOverlaidScrollbars"), [on, ln] = fe("scrollbars.theme"), [Yt, Xt] = fe("scrollbars.visibility"), [Dt, Rt] = fe("scrollbars.autoHide"), [Bt, Dn] = fe("scrollbars.autoHideSuspend"), [An] = fe("scrollbars.autoHideDelay"), [si, Ki] = fe("scrollbars.dragScroll"), [wi, Ji] = fe("scrollbars.clickScroll"), [Le, nt] = fe("overflow"), Ct = gt && !pe, Qt = tt.x || tt.y, Vt = de || ze || we || ct || pe, In = De || Xt || nt, dn = Et && At.x && At.y, _n = (Jt, Gt, qt) => {
      const Mi = Jt.includes(op) && (Yt === Yu || Yt === "auto" && Gt === op);
      return ee(XW, Mi, qt), Mi;
    };
    if (C = An, Ct && (Bt && Qt ? (re(!1), S(), N(() => {
      S = Gn(ae, "scroll", _t(re, !0), {
        A: !0
      });
    })) : re(!0)), Wt && ee(WW, dn), ln && (ee(b), ee(on, !0), b = on), Dn && !Bt && re(!0), Rt && (h = Dt === "move", m = Dt === "leave", v = Dt === "never", Se(v, !0)), Ki && ee(ZW, si), Ji && ee(qW, !!wi), In) {
      const Jt = _n(Le.x, xt.x, !0), Gt = _n(Le.y, xt.y, !1);
      ee(QW, !(Jt && Gt));
    }
    Vt && (se(), oe(), Te(), we && Pe(), ee(cO, !tt.x, !0), ee(cO, !tt.y, !1), ee(YW, pt && !ie));
  }, {}, G];
}, y8 = (t) => {
  const e = $o(), { U: i, R: a } = e, { elements: o } = i(), { padding: f, viewport: u, content: h } = o, m = Ox(t), v = m ? {} : t, { elements: b } = v, { padding: S, viewport: C, content: E } = b || {}, D = m ? t : v.target, M = wN(D), A = D.ownerDocument, P = A.documentElement, N = () => A.defaultView || Ca, F = _t(n8, [D]), B = _t(jN, [D]), V = _t(tp, ""), G = _t(F, V, u), Y = _t(B, V, h), K = (tt) => {
    const Et = np(tt), Wt = Lx(tt), on = Xl(tt, pN), ln = Xl(tt, mN);
    return Wt.w - Et.w > 0 && !up(on) || Wt.h - Et.h > 0 && !up(ln);
  }, ae = G(C), ie = ae === D, ee = ie && M, oe = !ie && Y(E), se = !ie && ae === oe, Pe = ee ? P : ae, Te = ee ? Pe : D, Se = !ie && B(V, f, S), Oe = !se && oe, re = [Oe, Pe, Se, Te].map((tt) => Ox(tt) && !vv(tt) && tt), ge = (tt) => tt && sN(re, tt), me = !ge(Pe) && K(Pe) ? Pe : D, fe = ee ? P : Pe, Ae = {
    vt: D,
    ht: Te,
    ot: Pe,
    ln: Se,
    bt: Oe,
    gt: fe,
    Qt: ee ? A : Pe,
    an: M ? P : me,
    Kt: A,
    wt: M,
    Mt: m,
    nt: ie,
    un: N,
    yt: (tt) => ZE(Pe, Bl, tt),
    St: (tt, Et) => Px(Pe, Bl, tt, Et),
    Ot: () => Px(fe, Bl, BW, !0)
  }, { vt: Ne, ht: de, ln: ze, ot: De, bt: we } = Ae, ct = [() => {
    Oo(de, [Zu, oT]), Oo(Ne, oT), M && Oo(P, [oT, Zu]);
  }];
  let gt = YT([we, De, ze, de, Ne].find((tt) => tt && !ge(tt)));
  const pt = ee ? Ne : we || De, At = _t($a, ct);
  return [Ae, () => {
    const tt = N(), Et = GT(), Wt = (Dt) => {
      Ua(vv(Dt), YT(Dt)), lp(Dt);
    }, on = (Dt) => Gn(Dt, "focusin focusout focus blur", AN, {
      I: !0,
      H: !1
    }), ln = "tabindex", Yt = QE(De, ln), Xt = on(Et);
    return jl(de, Zu, ie ? "" : zW), jl(ze, JT, ""), jl(De, Bl, ""), jl(we, lO, ""), ie || (jl(De, ln, Yt || "-1"), M && jl(P, oO, "")), Ua(pt, gt), Ua(de, ze), Ua(ze || de, !ie && De), Ua(De, we), ri(ct, [Xt, () => {
      const Dt = GT(), Rt = ge(De), Bt = Rt && Dt === De ? Ne : Dt, Dn = on(Bt);
      Oo(ze, JT), Oo(we, lO), Oo(De, Bl), M && Oo(P, oO), Yt ? jl(De, ln, Yt) : Oo(De, ln), ge(we) && Wt(we), Rt && Wt(De), ge(ze) && Wt(ze), qT(Bt), Dn();
    }]), a && !ie && (qE(De, Bl, NN), ri(ct, _t(Oo, De, Bl))), qT(!ie && M && Et === Ne && tt.top === tt ? De : Et), Xt(), gt = 0, At;
  }, At];
}, b8 = ({ bt: t }) => ({ Zt: e, _n: i, Dt: a }) => {
  const { xt: o } = e || {}, { $t: f } = i;
  t && (o || a) && yv(t, {
    [rS]: f && "100%"
  });
}, x8 = ({ ht: t, ln: e, ot: i, nt: a }, o) => {
  const [f, u] = Ba({
    i: EW,
    o: JA()
  }, _t(JA, t, "padding", ""));
  return ({ It: h, Zt: m, _n: v, Dt: b }) => {
    let [S, C] = u(b);
    const { R: E } = $o(), { ft: D, Ht: M, Ct: A } = m || {}, { ct: P } = v, [N, F] = h("paddingAbsolute");
    (D || C || (b || M)) && ([S, C] = f(b));
    const V = !a && (F || A || C);
    if (V) {
      const G = !N || !e && !E, Y = S.r + S.l, K = S.t + S.b, ae = {
        [dN]: G && !P ? -Y : 0,
        [hN]: G ? -K : 0,
        [fN]: G && P ? -Y : 0,
        top: G ? -S.t : 0,
        right: G ? P ? -S.r : "auto" : 0,
        left: G ? P ? "auto" : -S.l : 0,
        [iS]: G && `calc(100% + ${Y}px)`
      }, ie = {
        [oN]: G ? S.t : 0,
        [lN]: G ? S.r : 0,
        [cN]: G ? S.b : 0,
        [uN]: G ? S.l : 0
      };
      yv(e || i, ae), yv(i, ie), fn(o, {
        ln: S,
        dn: !G,
        rt: e ? ie : fn({}, ae, ie)
      });
    }
    return {
      fn: V
    };
  };
}, S8 = (t, e) => {
  const i = $o(), { ht: a, ln: o, ot: f, nt: u, Qt: h, gt: m, wt: v, St: b, un: S } = t, { R: C } = i, E = v && u, D = _t(rN, 0), M = {
    display: () => !1,
    direction: (pe) => pe !== "ltr",
    flexDirection: (pe) => pe.endsWith("-reverse"),
    writingMode: (pe) => pe !== "horizontal-tb"
  }, A = Qs(M), P = {
    i: gN,
    o: {
      w: 0,
      h: 0
    }
  }, N = {
    i: hx,
    o: {}
  }, F = (pe) => {
    b(LN, !E && pe);
  }, B = (pe) => {
    if (!A.some((pt) => {
      const At = pe[pt];
      return At && M[pt](At);
    }))
      return {
        D: {
          x: 0,
          y: 0
        },
        M: {
          x: 1,
          y: 1
        }
      };
    F(!0);
    const Ne = Ia(m), de = b(HW, !0), ze = Gn(h, op, (pt) => {
      const At = Ia(m);
      pt.isTrusted && At.x === Ne.x && At.y === Ne.y && MN(pt);
    }, {
      I: !0,
      A: !0
    });
    No(m, {
      x: 0,
      y: 0
    }), de();
    const De = Ia(m), we = Lx(m);
    No(m, {
      x: we.w,
      y: we.h
    });
    const ct = Ia(m);
    No(m, {
      x: ct.x - De.x < 1 && -we.w,
      y: ct.y - De.y < 1 && -we.h
    });
    const gt = Ia(m);
    return No(m, Ne), $E(() => ze()), {
      D: De,
      M: gt
    };
  }, V = (pe, Ae) => {
    const Ne = Ca.devicePixelRatio % 1 !== 0 ? 1 : 0, de = {
      w: D(pe.w - Ae.w),
      h: D(pe.h - Ae.h)
    };
    return {
      w: de.w > Ne ? de.w : 0,
      h: de.h > Ne ? de.h : 0
    };
  }, [G, Y] = Ba(P, _t(e1, f)), [K, ae] = Ba(P, _t(Lx, f)), [ie, ee] = Ba(P), [oe] = Ba(N), [se, Pe] = Ba(P), [Te] = Ba(N), [Se] = Ba({
    i: (pe, Ae) => aS(pe, Ae, A),
    o: {}
  }, () => PW(f) ? Xl(f, A) : {}), [Oe, re] = Ba({
    i: (pe, Ae) => hx(pe.D, Ae.D) && hx(pe.M, Ae.M),
    o: ON()
  }), ge = Mv($N), me = (pe, Ae) => `${Ae ? FW : VW}${TW(pe)}`, fe = (pe) => {
    const Ae = (de) => [Yu, Vf, op].map((ze) => me(ze, de)), Ne = Ae(!0).concat(Ae()).join(" ");
    b(Ne), b(Qs(pe).map((de) => me(pe[de], de === "x")).join(" "), !0);
  };
  return ({ It: pe, Zt: Ae, _n: Ne, Dt: de }, { fn: ze }) => {
    const { ft: De, Ht: we, Ct: ct, dt: gt, zt: pt } = Ae || {}, At = ge && ge.tt(t, e, Ne, i, pe), { it: xt, ut: tt, _t: Et } = At || {}, [Wt, on] = c8(pe, i), [ln, Yt] = pe("overflow"), Xt = up(ln.x), Dt = up(ln.y);
    let Rt = Y(de), Bt = ae(de), Dn = ee(de), An = Pe(de);
    on && C && b(NN, !Wt);
    {
      ZE(a, Zu, mx) && F(!0);
      const [Qe] = tt ? tt() : [], [ft] = Rt = G(de), [ce] = Bt = K(de), ye = DN(f), ke = E && OW(S()), Ge = {
        w: D(ce.w + ft.w),
        h: D(ce.h + ft.h)
      }, yn = {
        w: D((ke ? ke.w : ye.w + D(ye.w - ce.w)) + ft.w),
        h: D((ke ? ke.h : ye.h + D(ye.h - ce.h)) + ft.h)
      };
      Qe && Qe(), An = se(yn), Dn = ie(V(Ge, yn), de);
    }
    const [si, Ki] = An, [wi, Ji] = Dn, [Le, nt] = Bt, [Ct, Qt] = Rt, [Vt, In] = oe({
      x: wi.w > 0,
      y: wi.h > 0
    }), dn = Xt && Dt && (Vt.x || Vt.y) || Xt && Vt.x && !Vt.y || Dt && Vt.y && !Vt.x, _n = f8(Vt, ln), [Jt, Gt] = Te(_n.K), [qt, Mi] = Se(de), Ai = ct || gt || Mi || In || de, [He, Ve] = Ai ? Oe(B(qt), de) : re();
    return Gt && fe(_n.K), Et && xt && yv(f, Et(_n, Ne, xt(_n, Le, Ct))), F(!1), Px(a, Zu, mx, dn), Px(o, JT, mx, dn), fn(e, {
      K: Jt,
      Vt: {
        x: si.w,
        y: si.h
      },
      Rt: {
        x: wi.w,
        y: wi.h
      },
      rn: Vt,
      Lt: LW(He, wi)
    }), {
      en: Gt,
      nn: Ki,
      sn: Ji,
      cn: Ve || Ji,
      vn: Ai
    };
  };
}, _8 = (t) => {
  const [e, i, a] = y8(t), o = {
    ln: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    },
    dn: !1,
    rt: {
      [dN]: 0,
      [hN]: 0,
      [fN]: 0,
      [oN]: 0,
      [lN]: 0,
      [cN]: 0,
      [uN]: 0
    },
    Vt: {
      x: 0,
      y: 0
    },
    Rt: {
      x: 0,
      y: 0
    },
    K: {
      x: Vf,
      y: Vf
    },
    rn: {
      x: !1,
      y: !1
    },
    Lt: ON()
  }, { vt: f, gt: u, nt: h, Ot: m } = e, { R: v, k: b } = $o(), S = !v && (b.x || b.y), C = [b8(e), x8(e, o), S8(e, o)];
  return [i, (E) => {
    const D = {}, A = S && Ia(u), P = A && m();
    return Rn(C, (N) => {
      fn(D, N(E, D) || {});
    }), No(u, A), P && P(), !h && No(f, 0), D;
  }, o, e, a];
}, C8 = (t, e, i, a, o) => {
  let f = !1;
  const u = sO(e, {}), [h, m, v, b, S] = _8(t), [C, E, D] = p8(b, v, u, (B) => {
    F({}, B);
  }), [M, A, , P] = v8(t, e, D, v, b, o), N = (B) => Qs(B).some((V) => !!B[V]), F = (B, V) => {
    if (i())
      return !1;
    const { pn: G, Dt: Y, At: K, hn: ae } = B, ie = G || {}, ee = !!Y || !f, oe = {
      It: sO(e, ie, ee),
      pn: ie,
      Dt: ee
    };
    if (ae)
      return A(oe), !1;
    const se = V || E(fn({}, oe, {
      At: K
    })), Pe = m(fn({}, oe, {
      _n: D,
      Zt: se
    }));
    A(fn({}, oe, {
      Zt: se,
      tn: Pe
    }));
    const Te = N(se), Se = N(Pe), Oe = Te || Se || !XE(ie) || ee;
    return f = !0, Oe && a(B, {
      Zt: se,
      tn: Pe
    }), Oe;
  };
  return [() => {
    const { an: B, gt: V, Ot: G } = b, Y = Ia(B), K = [C(), h(), M()], ae = G();
    return No(V, Y), ae(), _t($a, K);
  }, F, () => ({
    gn: D,
    bn: v
  }), {
    wn: b,
    yn: P
  }, S];
}, zo = (t, e, i) => {
  const { N: a } = $o(), o = Ox(t), f = o ? t : t.target, u = BN(f);
  if (e && !u) {
    let h = !1;
    const m = [], v = {}, b = (ie) => {
      const ee = yN(ie), oe = Mv(l8);
      return oe ? oe(ee, !0) : ee;
    }, S = fn({}, a(), b(e)), [C, E, D] = ZT(), [M, A, P] = ZT(i), N = (ie, ee) => {
      P(ie, ee), D(ie, ee);
    }, [F, B, V, G, Y] = C8(t, S, () => h, ({ pn: ie, Dt: ee }, { Zt: oe, tn: se }) => {
      const { ft: Pe, Ct: Te, xt: Se, Ht: Oe, Et: re, dt: ge } = oe, { nn: me, sn: fe, en: pe, cn: Ae } = se;
      N("updated", [ae, {
        updateHints: {
          sizeChanged: !!Pe,
          directionChanged: !!Te,
          heightIntrinsicChanged: !!Se,
          overflowEdgeChanged: !!me,
          overflowAmountChanged: !!fe,
          overflowStyleChanged: !!pe,
          scrollCoordinatesChanged: !!Ae,
          contentMutation: !!Oe,
          hostMutation: !!re,
          appear: !!ge
        },
        changedOptions: ie || {},
        force: !!ee
      }]);
    }, (ie) => N("scroll", [ae, ie])), K = (ie) => {
      a8(f), $a(m), h = !0, N("destroyed", [ae, ie]), E(), A();
    }, ae = {
      options(ie, ee) {
        if (ie) {
          const oe = ee ? a() : {}, se = PN(S, fn(oe, b(ie)));
          XE(se) || (fn(S, se), B({
            pn: se
          }));
        }
        return fn({}, S);
      },
      on: M,
      off: (ie, ee) => {
        ie && ee && A(ie, ee);
      },
      state() {
        const { gn: ie, bn: ee } = V(), { ct: oe } = ie, { Vt: se, Rt: Pe, K: Te, rn: Se, ln: Oe, dn: re, Lt: ge } = ee;
        return fn({}, {
          overflowEdge: se,
          overflowAmount: Pe,
          overflowStyle: Te,
          hasOverflow: Se,
          scrollCoordinates: {
            start: ge.D,
            end: ge.M
          },
          padding: Oe,
          paddingAbsolute: re,
          directionRTL: oe,
          destroyed: h
        });
      },
      elements() {
        const { vt: ie, ht: ee, ln: oe, ot: se, bt: Pe, gt: Te, Qt: Se } = G.wn, { Xt: Oe, Gt: re } = G.yn, ge = (fe) => {
          const { Pt: pe, Ut: Ae, Tt: Ne } = fe;
          return {
            scrollbar: Ne,
            track: Ae,
            handle: pe
          };
        }, me = (fe) => {
          const { Yt: pe, Wt: Ae } = fe, Ne = ge(pe[0]);
          return fn({}, Ne, {
            clone: () => {
              const de = ge(Ae());
              return B({
                hn: !0
              }), de;
            }
          });
        };
        return fn({}, {
          target: ie,
          host: ee,
          padding: oe || se,
          viewport: se,
          content: Pe || se,
          scrollOffsetElement: Te,
          scrollEventElement: Se,
          scrollbarHorizontal: me(Oe),
          scrollbarVertical: me(re)
        });
      },
      update: (ie) => B({
        Dt: ie,
        At: !0
      }),
      destroy: _t(K, !1),
      plugin: (ie) => v[Qs(ie)[0]]
    };
    return ri(m, [Y]), r8(f, ae), IN(HN, zo, [ae, C, v]), i8(G.wn.wt, !o && t.cancel) ? (K(!0), ae) : (ri(m, F()), N("initialized", [ae]), ae.update(), ae);
  }
  return u;
};
zo.plugin = (t) => {
  const e = Uo(t), i = e ? t : [t], a = i.map((o) => IN(o, zo)[0]);
  return o8(i), e ? a : a[0];
};
zo.valid = (t) => {
  const e = t && t.elements, i = vs(e) && e();
  return Ax(i) && !!BN(i.target);
};
zo.env = () => {
  const { T: t, k: e, R: i, V: a, B: o, F: f, U: u, P: h, N: m, q: v } = $o();
  return fn({}, {
    scrollbarsSize: t,
    scrollbarsOverlaid: e,
    scrollbarsHiding: i,
    scrollTimeline: a,
    staticDefaultInitialization: o,
    staticDefaultOptions: f,
    getDefaultInitialization: u,
    setDefaultInitialization: h,
    getDefaultOptions: m,
    setDefaultOptions: v
  });
};
zo.nonce = e8;
const w8 = () => {
  if (typeof window > "u") {
    const v = () => {
    };
    return [v, v];
  }
  let t, e;
  const i = window, a = typeof i.requestIdleCallback == "function", o = i.requestAnimationFrame, f = i.cancelAnimationFrame, u = a ? i.requestIdleCallback : o, h = a ? i.cancelIdleCallback : f, m = () => {
    h(t), f(e);
  };
  return [
    (v, b) => {
      m(), t = u(
        a ? () => {
          m(), e = o(v);
        } : v,
        typeof b == "object" ? b : { timeout: 2233 }
      );
    },
    m
  ];
}, T8 = (t) => {
  const { options: e, events: i, defer: a } = t || {}, [o, f] = Xs(w8, []), u = Sn(null), h = Sn(a), m = Sn(e), v = Sn(i);
  return Xn(() => {
    h.current = a;
  }, [a]), Xn(() => {
    const { current: b } = u;
    m.current = e, zo.valid(b) && b.options(e || {}, !0);
  }, [e]), Xn(() => {
    const { current: b } = u;
    v.current = i, zo.valid(b) && b.on(i || {}, !0);
  }, [i]), Xn(
    () => () => {
      var b;
      f(), (b = u.current) == null || b.destroy();
    },
    []
  ), Xs(
    () => [
      (b) => {
        const S = u.current;
        if (zo.valid(S))
          return;
        const C = h.current, E = m.current || {}, D = v.current || {}, M = () => u.current = zo(b, E, D);
        C ? o(M, C) : M();
      },
      () => u.current
    ],
    []
  );
}, E8 = (t, e) => {
  const { element: i = "div", options: a, events: o, defer: f, children: u, ...h } = t, m = i, v = Sn(null), b = Sn(null), [S, C] = T8({ options: a, events: o, defer: f });
  return Xn(() => {
    const { current: E } = v, { current: D } = b;
    if (!E)
      return;
    const M = E;
    return S(
      i === "body" ? {
        target: M,
        cancel: {
          body: null
        }
      } : {
        target: M,
        elements: {
          viewport: D,
          content: D
        }
      }
    ), () => {
      var A;
      return (A = C()) == null ? void 0 : A.destroy();
    };
  }, [S, i]), $x(
    e,
    () => ({
      osInstance: C,
      getElement: () => v.current
    }),
    []
  ), // @ts-ignore
  /* @__PURE__ */ ip.createElement(m, { "data-overlayscrollbars-initialize": "", ref: v, ...h }, i === "body" ? u : /* @__PURE__ */ ip.createElement("div", { "data-overlayscrollbars-contents": "", ref: b }, u));
}, R8 = pp(E8), YN = ({
  children: t,
  maxHeight: e,
  options: i,
  onScroll: a = () => {
  },
  onScrollEndX: o = () => {
  },
  onScrollEndY: f = () => {
  }
}) => {
  const u = (b) => {
    console.debug("initialized:", b);
  }, h = (b) => {
    console.debug("destroyed:", b);
  }, m = (b) => {
    console.debug("updated:", b);
  }, v = (b) => {
    a({
      x: b.elements().viewport.scrollLeft,
      y: b.elements().viewport.scrollTop
    }), b.state().hasOverflow.x && b.state().overflowAmount.x === b.elements().viewport.scrollLeft && o(b), b.state().hasOverflow.y && b.state().overflowAmount.y === b.elements().viewport.scrollTop && f(b);
  };
  return /* @__PURE__ */ Me.jsx(
    R8,
    {
      className: "h-overlay-scroll",
      style: {
        maxHeight: e === 0 ? "none" : `${e}px`
      },
      options: {
        ...i
      },
      events: {
        initialized: u,
        destroyed: h,
        updated: m,
        scroll: v
      },
      defer: !0,
      children: t
    }
  );
};
YN.displayName = "HScrollbars";
const D8 = ({ children: t, listWidth: e }) => {
  const { isActiveList: i, listPosition: a, dropdownListRef: o } = IE(), f = (v, b, S, C) => b + S > C ? {
    top: "auto",
    bottom: `${C - v}px`,
    marginBottom: "-1px"
  } : {
    top: `${b}px`,
    bottom: "auto",
    marginTop: "-1px"
  }, u = (v, b, S, C) => b + S > C ? {
    left: "auto",
    right: `${C - b}px`
  } : {
    left: `${v}px`,
    right: "auto"
  }, [h, m] = Tn({});
  return Xn(() => {
    (() => {
      if (!a) {
        m({
          position: "fixed"
        });
        return;
      }
      const { bottom: v, left: b, right: S, top: C, clientWidth: E, clientHeight: D } = a;
      if (!o.current) {
        m({});
        return;
      }
      const { height: M, width: A } = o.current.getBoundingClientRect();
      m({
        position: "fixed",
        zIndex: "220",
        ...f(C, v, M, D),
        ...u(b, S, A, E),
        width: `${e}px`
      });
    })();
  }, [a]), /* @__PURE__ */ Me.jsx(Me.Fragment, { children: i && /* @__PURE__ */ Me.jsx(
    "div",
    {
      ref: o,
      style: h,
      className: "h_dropdown_list",
      children: /* @__PURE__ */ Me.jsx(YN, { maxHeight: 300, children: t })
    }
  ) });
};
D8.displayName = "HDropdownList";
var GN = typeof global == "object" && global && global.Object === Object && global, k8 = typeof self == "object" && self && self.Object === Object && self, Zl = GN || k8 || Function("return this")(), cp = Zl.Symbol, KN = Object.prototype, M8 = KN.hasOwnProperty, A8 = KN.toString, Ug = cp ? cp.toStringTag : void 0;
function O8(t) {
  var e = M8.call(t, Ug), i = t[Ug];
  try {
    t[Ug] = void 0;
    var a = !0;
  } catch {
  }
  var o = A8.call(t);
  return a && (e ? t[Ug] = i : delete t[Ug]), o;
}
var P8 = Object.prototype, L8 = P8.toString;
function N8(t) {
  return L8.call(t);
}
var z8 = "[object Null]", F8 = "[object Undefined]", pO = cp ? cp.toStringTag : void 0;
function Av(t) {
  return t == null ? t === void 0 ? F8 : z8 : pO && pO in Object(t) ? O8(t) : N8(t);
}
function bv(t) {
  return t != null && typeof t == "object";
}
var Nx = Array.isArray;
function XN(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var V8 = "[object AsyncFunction]", j8 = "[object Function]", B8 = "[object GeneratorFunction]", H8 = "[object Proxy]";
function QN(t) {
  if (!XN(t))
    return !1;
  var e = Av(t);
  return e == j8 || e == B8 || e == V8 || e == H8;
}
var uT = Zl["__core-js_shared__"], mO = function() {
  var t = /[^.]+$/.exec(uT && uT.keys && uT.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function U8(t) {
  return !!mO && mO in t;
}
var I8 = Function.prototype, $8 = I8.toString;
function Xf(t) {
  if (t != null) {
    try {
      return $8.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var W8 = /[\\^$.*+?()[\]{}|]/g, Y8 = /^\[object .+?Constructor\]$/, G8 = Function.prototype, K8 = Object.prototype, X8 = G8.toString, Q8 = K8.hasOwnProperty, q8 = RegExp(
  "^" + X8.call(Q8).replace(W8, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Z8(t) {
  if (!XN(t) || U8(t))
    return !1;
  var e = QN(t) ? q8 : Y8;
  return e.test(Xf(t));
}
function J8(t, e) {
  return t == null ? void 0 : t[e];
}
function gp(t, e) {
  var i = J8(t, e);
  return Z8(i) ? i : void 0;
}
var tE = gp(Zl, "WeakMap"), e6 = 9007199254740991, t6 = /^(?:0|[1-9]\d*)$/;
function n6(t, e) {
  var i = typeof t;
  return e = e ?? e6, !!e && (i == "number" || i != "symbol" && t6.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function qN(t, e) {
  return t === e || t !== t && e !== e;
}
var i6 = 9007199254740991;
function ZN(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= i6;
}
function r6(t) {
  return t != null && ZN(t.length) && !QN(t);
}
var a6 = Object.prototype;
function s6(t) {
  var e = t && t.constructor, i = typeof e == "function" && e.prototype || a6;
  return t === i;
}
function o6(t, e) {
  for (var i = -1, a = Array(t); ++i < t; )
    a[i] = e(i);
  return a;
}
var l6 = "[object Arguments]";
function gO(t) {
  return bv(t) && Av(t) == l6;
}
var JN = Object.prototype, u6 = JN.hasOwnProperty, c6 = JN.propertyIsEnumerable, f6 = gO(/* @__PURE__ */ function() {
  return arguments;
}()) ? gO : function(t) {
  return bv(t) && u6.call(t, "callee") && !c6.call(t, "callee");
};
function d6() {
  return !1;
}
var e2 = typeof exports == "object" && exports && !exports.nodeType && exports, vO = e2 && typeof module == "object" && module && !module.nodeType && module, h6 = vO && vO.exports === e2, yO = h6 ? Zl.Buffer : void 0, p6 = yO ? yO.isBuffer : void 0, nE = p6 || d6, m6 = "[object Arguments]", g6 = "[object Array]", v6 = "[object Boolean]", y6 = "[object Date]", b6 = "[object Error]", x6 = "[object Function]", S6 = "[object Map]", _6 = "[object Number]", C6 = "[object Object]", w6 = "[object RegExp]", T6 = "[object Set]", E6 = "[object String]", R6 = "[object WeakMap]", D6 = "[object ArrayBuffer]", k6 = "[object DataView]", M6 = "[object Float32Array]", A6 = "[object Float64Array]", O6 = "[object Int8Array]", P6 = "[object Int16Array]", L6 = "[object Int32Array]", N6 = "[object Uint8Array]", z6 = "[object Uint8ClampedArray]", F6 = "[object Uint16Array]", V6 = "[object Uint32Array]", Bn = {};
Bn[M6] = Bn[A6] = Bn[O6] = Bn[P6] = Bn[L6] = Bn[N6] = Bn[z6] = Bn[F6] = Bn[V6] = !0;
Bn[m6] = Bn[g6] = Bn[D6] = Bn[v6] = Bn[k6] = Bn[y6] = Bn[b6] = Bn[x6] = Bn[S6] = Bn[_6] = Bn[C6] = Bn[w6] = Bn[T6] = Bn[E6] = Bn[R6] = !1;
function j6(t) {
  return bv(t) && ZN(t.length) && !!Bn[Av(t)];
}
function B6(t) {
  return function(e) {
    return t(e);
  };
}
var t2 = typeof exports == "object" && exports && !exports.nodeType && exports, iv = t2 && typeof module == "object" && module && !module.nodeType && module, H6 = iv && iv.exports === t2, cT = H6 && GN.process, bO = function() {
  try {
    var t = iv && iv.require && iv.require("util").types;
    return t || cT && cT.binding && cT.binding("util");
  } catch {
  }
}(), xO = bO && bO.isTypedArray, n2 = xO ? B6(xO) : j6, U6 = Object.prototype, I6 = U6.hasOwnProperty;
function $6(t, e) {
  var i = Nx(t), a = !i && f6(t), o = !i && !a && nE(t), f = !i && !a && !o && n2(t), u = i || a || o || f, h = u ? o6(t.length, String) : [], m = h.length;
  for (var v in t)
    I6.call(t, v) && !(u && // Safari 9 has enumerable `arguments.length` in strict mode.
    (v == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    o && (v == "offset" || v == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    f && (v == "buffer" || v == "byteLength" || v == "byteOffset") || // Skip index properties.
    n6(v, m))) && h.push(v);
  return h;
}
function W6(t, e) {
  return function(i) {
    return t(e(i));
  };
}
var Y6 = W6(Object.keys, Object), G6 = Object.prototype, K6 = G6.hasOwnProperty;
function X6(t) {
  if (!s6(t))
    return Y6(t);
  var e = [];
  for (var i in Object(t))
    K6.call(t, i) && i != "constructor" && e.push(i);
  return e;
}
function Q6(t) {
  return r6(t) ? $6(t) : X6(t);
}
var xv = gp(Object, "create");
function q6() {
  this.__data__ = xv ? xv(null) : {}, this.size = 0;
}
function Z6(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var J6 = "__lodash_hash_undefined__", eY = Object.prototype, tY = eY.hasOwnProperty;
function nY(t) {
  var e = this.__data__;
  if (xv) {
    var i = e[t];
    return i === J6 ? void 0 : i;
  }
  return tY.call(e, t) ? e[t] : void 0;
}
var iY = Object.prototype, rY = iY.hasOwnProperty;
function aY(t) {
  var e = this.__data__;
  return xv ? e[t] !== void 0 : rY.call(e, t);
}
var sY = "__lodash_hash_undefined__";
function oY(t, e) {
  var i = this.__data__;
  return this.size += this.has(t) ? 0 : 1, i[t] = xv && e === void 0 ? sY : e, this;
}
function Gf(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var a = t[e];
    this.set(a[0], a[1]);
  }
}
Gf.prototype.clear = q6;
Gf.prototype.delete = Z6;
Gf.prototype.get = nY;
Gf.prototype.has = aY;
Gf.prototype.set = oY;
function lY() {
  this.__data__ = [], this.size = 0;
}
function lS(t, e) {
  for (var i = t.length; i--; )
    if (qN(t[i][0], e))
      return i;
  return -1;
}
var uY = Array.prototype, cY = uY.splice;
function fY(t) {
  var e = this.__data__, i = lS(e, t);
  if (i < 0)
    return !1;
  var a = e.length - 1;
  return i == a ? e.pop() : cY.call(e, i, 1), --this.size, !0;
}
function dY(t) {
  var e = this.__data__, i = lS(e, t);
  return i < 0 ? void 0 : e[i][1];
}
function hY(t) {
  return lS(this.__data__, t) > -1;
}
function pY(t, e) {
  var i = this.__data__, a = lS(i, t);
  return a < 0 ? (++this.size, i.push([t, e])) : i[a][1] = e, this;
}
function Jl(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var a = t[e];
    this.set(a[0], a[1]);
  }
}
Jl.prototype.clear = lY;
Jl.prototype.delete = fY;
Jl.prototype.get = dY;
Jl.prototype.has = hY;
Jl.prototype.set = pY;
var Sv = gp(Zl, "Map");
function mY() {
  this.size = 0, this.__data__ = {
    hash: new Gf(),
    map: new (Sv || Jl)(),
    string: new Gf()
  };
}
function gY(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function uS(t, e) {
  var i = t.__data__;
  return gY(e) ? i[typeof e == "string" ? "string" : "hash"] : i.map;
}
function vY(t) {
  var e = uS(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function yY(t) {
  return uS(this, t).get(t);
}
function bY(t) {
  return uS(this, t).has(t);
}
function xY(t, e) {
  var i = uS(this, t), a = i.size;
  return i.set(t, e), this.size += i.size == a ? 0 : 1, this;
}
function Qf(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var a = t[e];
    this.set(a[0], a[1]);
  }
}
Qf.prototype.clear = mY;
Qf.prototype.delete = vY;
Qf.prototype.get = yY;
Qf.prototype.has = bY;
Qf.prototype.set = xY;
function SY(t, e) {
  for (var i = -1, a = e.length, o = t.length; ++i < a; )
    t[o + i] = e[i];
  return t;
}
function _Y() {
  this.__data__ = new Jl(), this.size = 0;
}
function CY(t) {
  var e = this.__data__, i = e.delete(t);
  return this.size = e.size, i;
}
function wY(t) {
  return this.__data__.get(t);
}
function TY(t) {
  return this.__data__.has(t);
}
var EY = 200;
function RY(t, e) {
  var i = this.__data__;
  if (i instanceof Jl) {
    var a = i.__data__;
    if (!Sv || a.length < EY - 1)
      return a.push([t, e]), this.size = ++i.size, this;
    i = this.__data__ = new Qf(a);
  }
  return i.set(t, e), this.size = i.size, this;
}
function Ju(t) {
  var e = this.__data__ = new Jl(t);
  this.size = e.size;
}
Ju.prototype.clear = _Y;
Ju.prototype.delete = CY;
Ju.prototype.get = wY;
Ju.prototype.has = TY;
Ju.prototype.set = RY;
function DY(t, e) {
  for (var i = -1, a = t == null ? 0 : t.length, o = 0, f = []; ++i < a; ) {
    var u = t[i];
    e(u, i, t) && (f[o++] = u);
  }
  return f;
}
function kY() {
  return [];
}
var MY = Object.prototype, AY = MY.propertyIsEnumerable, SO = Object.getOwnPropertySymbols, OY = SO ? function(t) {
  return t == null ? [] : (t = Object(t), DY(SO(t), function(e) {
    return AY.call(t, e);
  }));
} : kY;
function PY(t, e, i) {
  var a = e(t);
  return Nx(t) ? a : SY(a, i(t));
}
function _O(t) {
  return PY(t, Q6, OY);
}
var iE = gp(Zl, "DataView"), rE = gp(Zl, "Promise"), aE = gp(Zl, "Set"), CO = "[object Map]", LY = "[object Object]", wO = "[object Promise]", TO = "[object Set]", EO = "[object WeakMap]", RO = "[object DataView]", NY = Xf(iE), zY = Xf(Sv), FY = Xf(rE), VY = Xf(aE), jY = Xf(tE), Wu = Av;
(iE && Wu(new iE(new ArrayBuffer(1))) != RO || Sv && Wu(new Sv()) != CO || rE && Wu(rE.resolve()) != wO || aE && Wu(new aE()) != TO || tE && Wu(new tE()) != EO) && (Wu = function(t) {
  var e = Av(t), i = e == LY ? t.constructor : void 0, a = i ? Xf(i) : "";
  if (a)
    switch (a) {
      case NY:
        return RO;
      case zY:
        return CO;
      case FY:
        return wO;
      case VY:
        return TO;
      case jY:
        return EO;
    }
  return e;
});
var DO = Zl.Uint8Array, BY = "__lodash_hash_undefined__";
function HY(t) {
  return this.__data__.set(t, BY), this;
}
function UY(t) {
  return this.__data__.has(t);
}
function zx(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.__data__ = new Qf(); ++e < i; )
    this.add(t[e]);
}
zx.prototype.add = zx.prototype.push = HY;
zx.prototype.has = UY;
function IY(t, e) {
  for (var i = -1, a = t == null ? 0 : t.length; ++i < a; )
    if (e(t[i], i, t))
      return !0;
  return !1;
}
function $Y(t, e) {
  return t.has(e);
}
var WY = 1, YY = 2;
function i2(t, e, i, a, o, f) {
  var u = i & WY, h = t.length, m = e.length;
  if (h != m && !(u && m > h))
    return !1;
  var v = f.get(t), b = f.get(e);
  if (v && b)
    return v == e && b == t;
  var S = -1, C = !0, E = i & YY ? new zx() : void 0;
  for (f.set(t, e), f.set(e, t); ++S < h; ) {
    var D = t[S], M = e[S];
    if (a)
      var A = u ? a(M, D, S, e, t, f) : a(D, M, S, t, e, f);
    if (A !== void 0) {
      if (A)
        continue;
      C = !1;
      break;
    }
    if (E) {
      if (!IY(e, function(P, N) {
        if (!$Y(E, N) && (D === P || o(D, P, i, a, f)))
          return E.push(N);
      })) {
        C = !1;
        break;
      }
    } else if (!(D === M || o(D, M, i, a, f))) {
      C = !1;
      break;
    }
  }
  return f.delete(t), f.delete(e), C;
}
function GY(t) {
  var e = -1, i = Array(t.size);
  return t.forEach(function(a, o) {
    i[++e] = [o, a];
  }), i;
}
function KY(t) {
  var e = -1, i = Array(t.size);
  return t.forEach(function(a) {
    i[++e] = a;
  }), i;
}
var XY = 1, QY = 2, qY = "[object Boolean]", ZY = "[object Date]", JY = "[object Error]", e9 = "[object Map]", t9 = "[object Number]", n9 = "[object RegExp]", i9 = "[object Set]", r9 = "[object String]", a9 = "[object Symbol]", s9 = "[object ArrayBuffer]", o9 = "[object DataView]", kO = cp ? cp.prototype : void 0, fT = kO ? kO.valueOf : void 0;
function l9(t, e, i, a, o, f, u) {
  switch (i) {
    case o9:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case s9:
      return !(t.byteLength != e.byteLength || !f(new DO(t), new DO(e)));
    case qY:
    case ZY:
    case t9:
      return qN(+t, +e);
    case JY:
      return t.name == e.name && t.message == e.message;
    case n9:
    case r9:
      return t == e + "";
    case e9:
      var h = GY;
    case i9:
      var m = a & XY;
      if (h || (h = KY), t.size != e.size && !m)
        return !1;
      var v = u.get(t);
      if (v)
        return v == e;
      a |= QY, u.set(t, e);
      var b = i2(h(t), h(e), a, o, f, u);
      return u.delete(t), b;
    case a9:
      if (fT)
        return fT.call(t) == fT.call(e);
  }
  return !1;
}
var u9 = 1, c9 = Object.prototype, f9 = c9.hasOwnProperty;
function d9(t, e, i, a, o, f) {
  var u = i & u9, h = _O(t), m = h.length, v = _O(e), b = v.length;
  if (m != b && !u)
    return !1;
  for (var S = m; S--; ) {
    var C = h[S];
    if (!(u ? C in e : f9.call(e, C)))
      return !1;
  }
  var E = f.get(t), D = f.get(e);
  if (E && D)
    return E == e && D == t;
  var M = !0;
  f.set(t, e), f.set(e, t);
  for (var A = u; ++S < m; ) {
    C = h[S];
    var P = t[C], N = e[C];
    if (a)
      var F = u ? a(N, P, C, e, t, f) : a(P, N, C, t, e, f);
    if (!(F === void 0 ? P === N || o(P, N, i, a, f) : F)) {
      M = !1;
      break;
    }
    A || (A = C == "constructor");
  }
  if (M && !A) {
    var B = t.constructor, V = e.constructor;
    B != V && "constructor" in t && "constructor" in e && !(typeof B == "function" && B instanceof B && typeof V == "function" && V instanceof V) && (M = !1);
  }
  return f.delete(t), f.delete(e), M;
}
var h9 = 1, MO = "[object Arguments]", AO = "[object Array]", qb = "[object Object]", p9 = Object.prototype, OO = p9.hasOwnProperty;
function m9(t, e, i, a, o, f) {
  var u = Nx(t), h = Nx(e), m = u ? AO : Wu(t), v = h ? AO : Wu(e);
  m = m == MO ? qb : m, v = v == MO ? qb : v;
  var b = m == qb, S = v == qb, C = m == v;
  if (C && nE(t)) {
    if (!nE(e))
      return !1;
    u = !0, b = !1;
  }
  if (C && !b)
    return f || (f = new Ju()), u || n2(t) ? i2(t, e, i, a, o, f) : l9(t, e, m, i, a, o, f);
  if (!(i & h9)) {
    var E = b && OO.call(t, "__wrapped__"), D = S && OO.call(e, "__wrapped__");
    if (E || D) {
      var M = E ? t.value() : t, A = D ? e.value() : e;
      return f || (f = new Ju()), o(M, A, i, a, f);
    }
  }
  return C ? (f || (f = new Ju()), d9(t, e, i, a, o, f)) : !1;
}
function r2(t, e, i, a, o) {
  return t === e ? !0 : t == null || e == null || !bv(t) && !bv(e) ? t !== t && e !== e : m9(t, e, i, a, r2, o);
}
function sE(t, e) {
  return r2(t, e);
}
const sQ = (t, e) => sE(t, e), oQ = ({ data: t, backgroundColor: e, borderColor: i, borderWidth: a, labelFillStyle: o, legendLabelsColor: f }) => {
  const u = Sn(null), h = Sn(null);
  return Xn(() => {
    var v;
    h.current && h.current.destroy();
    const m = (v = u.current) == null ? void 0 : v.getContext("2d");
    if (m)
      return h.current = new Lo(m, {
        type: "pie",
        data: {
          labels: t.map((b) => b.label),
          datasets: [
            {
              data: t.map((b) => b.value),
              backgroundColor: e || Array.from({ length: t.length }, (b, S) => S % 2 === 0 ? "#4CAF50" : "#2196F3"),
              borderColor: i || Array.from({ length: t.length }, (b, S) => S % 2 === 0 ? "#45a049" : "#1e88e5"),
              borderWidth: a || 1
            }
          ]
        },
        options: {
          responsive: !0,
          maintainAspectRatio: !1,
          plugins: {
            legend: {
              display: !0,
              position: "bottom",
              labels: {
                color: f || "#333"
              }
            },
            tooltip: {
              enabled: !0,
              callbacks: {
                label: (b) => `${b.label}: ${b.parsed}`
              }
            }
          },
          animation: {
            duration: 1e3,
            easing: "easeInOutQuart"
          },
          layout: {
            padding: {
              top: 20,
              right: 10,
              bottom: 10,
              left: 10
            }
          }
        },
        plugins: [
          {
            id: "percentage",
            afterDraw: (b) => {
              const S = b.ctx, C = b.data.datasets[0].data.reduce((E, D) => E + parseFloat(D + ""), 0);
              b.data.datasets.forEach((E, D) => {
                b.getDatasetMeta(D).data.forEach((A) => {
                  const P = A.innerRadius + (A.outerRadius - A.innerRadius) / 2, N = A.startAngle, F = A.endAngle, B = N + (F - N) / 2, V = P * Math.cos(B), G = P * Math.sin(B);
                  S.save(), S.translate(A.x, A.y), S.fillStyle = o || "#000000", S.font = "12px Arial", S.textAlign = "center", S.textBaseline = "middle";
                  const Y = (parseFloat(E.data[A.$context.index] + "") / C * 100).toFixed(1) + "%";
                  S.fillText(Y, V, G), S.restore();
                });
              });
            }
          }
        ]
      }), () => {
        h.current && h.current.destroy();
      };
  }, [t]), /* @__PURE__ */ Me.jsx("canvas", { ref: u });
}, PO = /* @__PURE__ */ new Set();
function cS(t, e, i) {
  t || PO.has(e) || (console.warn(e), PO.add(e));
}
function g9(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), i = (...a) => (process.env.NODE_ENV !== "production" && cS(!1, "motion() is deprecated. Use motion.create() instead."), t(...a));
  return new Proxy(i, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (a, o) => o === "create" ? t : (e.has(o) || e.set(o, t(o)), e.get(o))
  });
}
function _v(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const oE = (t) => Array.isArray(t);
function a2(t, e) {
  if (!Array.isArray(e))
    return !1;
  const i = e.length;
  if (i !== t.length)
    return !1;
  for (let a = 0; a < i; a++)
    if (e[a] !== t[a])
      return !1;
  return !0;
}
function Cv(t) {
  return typeof t == "string" || Array.isArray(t);
}
function LO(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((i, a) => {
    e[0][a] = i.get(), e[1][a] = i.getVelocity();
  }), e;
}
function r1(t, e, i, a) {
  if (typeof e == "function") {
    const [o, f] = LO(a);
    e = e(i !== void 0 ? i : t.custom, o, f);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [o, f] = LO(a);
    e = e(i !== void 0 ? i : t.custom, o, f);
  }
  return e;
}
function fS(t, e, i) {
  const a = t.getProps();
  return r1(a, e, i !== void 0 ? i : a.custom, t);
}
const a1 = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], s1 = ["initial", ...a1], Ov = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], oc = new Set(Ov), jo = (t) => t * 1e3, Yl = (t) => t / 1e3, v9 = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, y9 = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), b9 = {
  type: "keyframes",
  duration: 0.8
}, x9 = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, S9 = (t, { keyframes: e }) => e.length > 2 ? b9 : oc.has(t) ? t.startsWith("scale") ? y9(e[1]) : v9 : x9;
function o1(t, e) {
  return t ? t[e] || t.default || t : void 0;
}
const _9 = {
  useManualTiming: !1
}, C9 = (t) => t !== null;
function dS(t, { repeat: e, repeatType: i = "loop" }, a) {
  const o = t.filter(C9), f = e && i !== "loop" && e % 2 === 1 ? 0 : o.length - 1;
  return !f || a === void 0 ? o[f] : a;
}
const vr = (t) => t;
function w9(t) {
  let e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), a = !1, o = !1;
  const f = /* @__PURE__ */ new WeakSet();
  let u = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function h(v) {
    f.has(v) && (m.schedule(v), t()), v(u);
  }
  const m = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (v, b = !1, S = !1) => {
      const E = S && a ? e : i;
      return b && f.add(v), E.has(v) || E.add(v), v;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (v) => {
      i.delete(v), f.delete(v);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (v) => {
      if (u = v, a) {
        o = !0;
        return;
      }
      a = !0, [e, i] = [i, e], i.clear(), e.forEach(h), a = !1, o && (o = !1, m.process(v));
    }
  };
  return m;
}
const Zb = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], T9 = 40;
function s2(t, e) {
  let i = !1, a = !0;
  const o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, f = () => i = !0, u = Zb.reduce((P, N) => (P[N] = w9(f), P), {}), { read: h, resolveKeyframes: m, update: v, preRender: b, render: S, postRender: C } = u, E = () => {
    const P = performance.now();
    i = !1, o.delta = a ? 1e3 / 60 : Math.max(Math.min(P - o.timestamp, T9), 1), o.timestamp = P, o.isProcessing = !0, h.process(o), m.process(o), v.process(o), b.process(o), S.process(o), C.process(o), o.isProcessing = !1, i && e && (a = !1, t(E));
  }, D = () => {
    i = !0, a = !0, o.isProcessing || t(E);
  };
  return { schedule: Zb.reduce((P, N) => {
    const F = u[N];
    return P[N] = (B, V = !1, G = !1) => (i || D(), F.schedule(B, V, G)), P;
  }, {}), cancel: (P) => {
    for (let N = 0; N < Zb.length; N++)
      u[Zb[N]].cancel(P);
  }, state: o, steps: u };
}
const { schedule: En, cancel: nc, state: gr, steps: dT } = s2(typeof requestAnimationFrame < "u" ? requestAnimationFrame : vr, !0), o2 = (t, e, i) => (((1 - 3 * i + 3 * e) * t + (3 * i - 6 * e)) * t + 3 * e) * t, E9 = 1e-7, R9 = 12;
function D9(t, e, i, a, o) {
  let f, u, h = 0;
  do
    u = e + (i - e) / 2, f = o2(u, a, o) - t, f > 0 ? i = u : e = u;
  while (Math.abs(f) > E9 && ++h < R9);
  return u;
}
function Pv(t, e, i, a) {
  if (t === e && i === a)
    return vr;
  const o = (f) => D9(f, 0, 1, t, i);
  return (f) => f === 0 || f === 1 ? f : o2(o(f), e, a);
}
const l2 = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, u2 = (t) => (e) => 1 - t(1 - e), c2 = /* @__PURE__ */ Pv(0.33, 1.53, 0.69, 0.99), l1 = /* @__PURE__ */ u2(c2), f2 = /* @__PURE__ */ l2(l1), d2 = (t) => (t *= 2) < 1 ? 0.5 * l1(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), u1 = (t) => 1 - Math.sin(Math.acos(t)), h2 = u2(u1), p2 = l2(u1), m2 = (t) => /^0[^.\s]+$/u.test(t);
function k9(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || m2(t) : !0;
}
let vp = vr, Ql = vr;
process.env.NODE_ENV !== "production" && (vp = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, Ql = (t, e) => {
  if (!t)
    throw new Error(e);
});
const g2 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), v2 = (t) => (e) => typeof e == "string" && e.startsWith(t), y2 = /* @__PURE__ */ v2("--"), M9 = /* @__PURE__ */ v2("var(--"), c1 = (t) => M9(t) ? A9.test(t.split("/*")[0].trim()) : !1, A9 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, O9 = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function P9(t) {
  const e = O9.exec(t);
  if (!e)
    return [,];
  const [, i, a, o] = e;
  return [`--${i ?? a}`, o];
}
const L9 = 4;
function b2(t, e, i = 1) {
  Ql(i <= L9, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [a, o] = P9(t);
  if (!a)
    return;
  const f = window.getComputedStyle(e).getPropertyValue(a);
  if (f) {
    const u = f.trim();
    return g2(u) ? parseFloat(u) : u;
  }
  return c1(o) ? b2(o, e, i + 1) : o;
}
const ic = (t, e, i) => i > e ? e : i < t ? t : i, yp = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, wv = {
  ...yp,
  transform: (t) => ic(0, 1, t)
}, Jb = {
  ...yp,
  default: 1
}, Lv = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), $u = /* @__PURE__ */ Lv("deg"), Bo = /* @__PURE__ */ Lv("%"), bt = /* @__PURE__ */ Lv("px"), N9 = /* @__PURE__ */ Lv("vh"), z9 = /* @__PURE__ */ Lv("vw"), NO = {
  ...Bo,
  parse: (t) => Bo.parse(t) / 100,
  transform: (t) => Bo.transform(t * 100)
}, F9 = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), zO = (t) => t === yp || t === bt, FO = (t, e) => parseFloat(t.split(", ")[e]), VO = (t, e) => (i, { transform: a }) => {
  if (a === "none" || !a)
    return 0;
  const o = a.match(/^matrix3d\((.+)\)$/u);
  if (o)
    return FO(o[1], e);
  {
    const f = a.match(/^matrix\((.+)\)$/u);
    return f ? FO(f[1], t) : 0;
  }
}, V9 = /* @__PURE__ */ new Set(["x", "y", "z"]), j9 = Ov.filter((t) => !V9.has(t));
function B9(t) {
  const e = [];
  return j9.forEach((i) => {
    const a = t.getValue(i);
    a !== void 0 && (e.push([i, a.get()]), a.set(i.startsWith("scale") ? 1 : 0));
  }), e;
}
const fp = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: i = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(i),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: i = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(i),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: VO(4, 13),
  y: VO(5, 14)
};
fp.translateX = fp.x;
fp.translateY = fp.y;
const x2 = (t) => (e) => e.test(t), H9 = {
  test: (t) => t === "auto",
  parse: (t) => t
}, S2 = [yp, bt, Bo, $u, z9, N9, H9], jO = (t) => S2.find(x2(t)), $f = /* @__PURE__ */ new Set();
let lE = !1, uE = !1;
function _2() {
  if (uE) {
    const t = Array.from($f).filter((a) => a.needsMeasurement), e = new Set(t.map((a) => a.element)), i = /* @__PURE__ */ new Map();
    e.forEach((a) => {
      const o = B9(a);
      o.length && (i.set(a, o), a.render());
    }), t.forEach((a) => a.measureInitialState()), e.forEach((a) => {
      a.render();
      const o = i.get(a);
      o && o.forEach(([f, u]) => {
        var h;
        (h = a.getValue(f)) === null || h === void 0 || h.set(u);
      });
    }), t.forEach((a) => a.measureEndState()), t.forEach((a) => {
      a.suspendedScrollY !== void 0 && window.scrollTo(0, a.suspendedScrollY);
    });
  }
  uE = !1, lE = !1, $f.forEach((t) => t.complete()), $f.clear();
}
function C2() {
  $f.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (uE = !0);
  });
}
function U9() {
  C2(), _2();
}
class f1 {
  constructor(e, i, a, o, f, u = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = i, this.name = a, this.motionValue = o, this.element = f, this.isAsync = u;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? ($f.add(this), lE || (lE = !0, En.read(C2), En.resolveKeyframes(_2))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: i, element: a, motionValue: o } = this;
    for (let f = 0; f < e.length; f++)
      if (e[f] === null)
        if (f === 0) {
          const u = o == null ? void 0 : o.get(), h = e[e.length - 1];
          if (u !== void 0)
            e[0] = u;
          else if (a && i) {
            const m = a.readValue(i, h);
            m != null && (e[0] = m);
          }
          e[0] === void 0 && (e[0] = h), o && u === void 0 && o.set(e[0]);
        } else
          e[f] = e[f - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), $f.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, $f.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const rv = (t) => Math.round(t * 1e5) / 1e5, d1 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function I9(t) {
  return t == null;
}
const $9 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, h1 = (t, e) => (i) => !!(typeof i == "string" && $9.test(i) && i.startsWith(t) || e && !I9(i) && Object.prototype.hasOwnProperty.call(i, e)), w2 = (t, e, i) => (a) => {
  if (typeof a != "string")
    return a;
  const [o, f, u, h] = a.match(d1);
  return {
    [t]: parseFloat(o),
    [e]: parseFloat(f),
    [i]: parseFloat(u),
    alpha: h !== void 0 ? parseFloat(h) : 1
  };
}, W9 = (t) => ic(0, 255, t), hT = {
  ...yp,
  transform: (t) => Math.round(W9(t))
}, jf = {
  test: /* @__PURE__ */ h1("rgb", "red"),
  parse: /* @__PURE__ */ w2("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: i, alpha: a = 1 }) => "rgba(" + hT.transform(t) + ", " + hT.transform(e) + ", " + hT.transform(i) + ", " + rv(wv.transform(a)) + ")"
};
function Y9(t) {
  let e = "", i = "", a = "", o = "";
  return t.length > 5 ? (e = t.substring(1, 3), i = t.substring(3, 5), a = t.substring(5, 7), o = t.substring(7, 9)) : (e = t.substring(1, 2), i = t.substring(2, 3), a = t.substring(3, 4), o = t.substring(4, 5), e += e, i += i, a += a, o += o), {
    red: parseInt(e, 16),
    green: parseInt(i, 16),
    blue: parseInt(a, 16),
    alpha: o ? parseInt(o, 16) / 255 : 1
  };
}
const cE = {
  test: /* @__PURE__ */ h1("#"),
  parse: Y9,
  transform: jf.transform
}, Xh = {
  test: /* @__PURE__ */ h1("hsl", "hue"),
  parse: /* @__PURE__ */ w2("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: i, alpha: a = 1 }) => "hsla(" + Math.round(t) + ", " + Bo.transform(rv(e)) + ", " + Bo.transform(rv(i)) + ", " + rv(wv.transform(a)) + ")"
}, zr = {
  test: (t) => jf.test(t) || cE.test(t) || Xh.test(t),
  parse: (t) => jf.test(t) ? jf.parse(t) : Xh.test(t) ? Xh.parse(t) : cE.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? jf.transform(t) : Xh.transform(t)
}, G9 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function K9(t) {
  var e, i;
  return isNaN(t) && typeof t == "string" && (((e = t.match(d1)) === null || e === void 0 ? void 0 : e.length) || 0) + (((i = t.match(G9)) === null || i === void 0 ? void 0 : i.length) || 0) > 0;
}
const T2 = "number", E2 = "color", X9 = "var", Q9 = "var(", BO = "${}", q9 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Tv(t) {
  const e = t.toString(), i = [], a = {
    color: [],
    number: [],
    var: []
  }, o = [];
  let f = 0;
  const h = e.replace(q9, (m) => (zr.test(m) ? (a.color.push(f), o.push(E2), i.push(zr.parse(m))) : m.startsWith(Q9) ? (a.var.push(f), o.push(X9), i.push(m)) : (a.number.push(f), o.push(T2), i.push(parseFloat(m))), ++f, BO)).split(BO);
  return { values: i, split: h, indexes: a, types: o };
}
function R2(t) {
  return Tv(t).values;
}
function D2(t) {
  const { split: e, types: i } = Tv(t), a = e.length;
  return (o) => {
    let f = "";
    for (let u = 0; u < a; u++)
      if (f += e[u], o[u] !== void 0) {
        const h = i[u];
        h === T2 ? f += rv(o[u]) : h === E2 ? f += zr.transform(o[u]) : f += o[u];
      }
    return f;
  };
}
const Z9 = (t) => typeof t == "number" ? 0 : t;
function J9(t) {
  const e = R2(t);
  return D2(t)(e.map(Z9));
}
const rc = {
  test: K9,
  parse: R2,
  createTransformer: D2,
  getAnimatableNone: J9
}, e7 = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function t7(t) {
  const [e, i] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [a] = i.match(d1) || [];
  if (!a)
    return t;
  const o = i.replace(a, "");
  let f = e7.has(e) ? 1 : 0;
  return a !== i && (f *= 100), e + "(" + f + o + ")";
}
const n7 = /\b([a-z-]*)\(.*?\)/gu, fE = {
  ...rc,
  getAnimatableNone: (t) => {
    const e = t.match(n7);
    return e ? e.map(t7).join(" ") : t;
  }
}, i7 = {
  // Border props
  borderWidth: bt,
  borderTopWidth: bt,
  borderRightWidth: bt,
  borderBottomWidth: bt,
  borderLeftWidth: bt,
  borderRadius: bt,
  radius: bt,
  borderTopLeftRadius: bt,
  borderTopRightRadius: bt,
  borderBottomRightRadius: bt,
  borderBottomLeftRadius: bt,
  // Positioning props
  width: bt,
  maxWidth: bt,
  height: bt,
  maxHeight: bt,
  top: bt,
  right: bt,
  bottom: bt,
  left: bt,
  // Spacing props
  padding: bt,
  paddingTop: bt,
  paddingRight: bt,
  paddingBottom: bt,
  paddingLeft: bt,
  margin: bt,
  marginTop: bt,
  marginRight: bt,
  marginBottom: bt,
  marginLeft: bt,
  // Misc
  backgroundPositionX: bt,
  backgroundPositionY: bt
}, r7 = {
  rotate: $u,
  rotateX: $u,
  rotateY: $u,
  rotateZ: $u,
  scale: Jb,
  scaleX: Jb,
  scaleY: Jb,
  scaleZ: Jb,
  skew: $u,
  skewX: $u,
  skewY: $u,
  distance: bt,
  translateX: bt,
  translateY: bt,
  translateZ: bt,
  x: bt,
  y: bt,
  z: bt,
  perspective: bt,
  transformPerspective: bt,
  opacity: wv,
  originX: NO,
  originY: NO,
  originZ: bt
}, HO = {
  ...yp,
  transform: Math.round
}, p1 = {
  ...i7,
  ...r7,
  zIndex: HO,
  size: bt,
  // SVG
  fillOpacity: wv,
  strokeOpacity: wv,
  numOctaves: HO
}, a7 = {
  ...p1,
  // Color props
  color: zr,
  backgroundColor: zr,
  outlineColor: zr,
  fill: zr,
  stroke: zr,
  // Border props
  borderColor: zr,
  borderTopColor: zr,
  borderRightColor: zr,
  borderBottomColor: zr,
  borderLeftColor: zr,
  filter: fE,
  WebkitFilter: fE
}, m1 = (t) => a7[t];
function k2(t, e) {
  let i = m1(t);
  return i !== fE && (i = rc), i.getAnimatableNone ? i.getAnimatableNone(e) : void 0;
}
const s7 = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function o7(t, e, i) {
  let a = 0, o;
  for (; a < t.length && !o; ) {
    const f = t[a];
    typeof f == "string" && !s7.has(f) && Tv(f).values.length && (o = t[a]), a++;
  }
  if (o && i)
    for (const f of e)
      t[f] = k2(i, o);
}
class M2 extends f1 {
  constructor(e, i, a, o, f) {
    super(e, i, a, o, f, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: i, name: a } = this;
    if (!i || !i.current)
      return;
    super.readKeyframes();
    for (let m = 0; m < e.length; m++) {
      let v = e[m];
      if (typeof v == "string" && (v = v.trim(), c1(v))) {
        const b = b2(v, i.current);
        b !== void 0 && (e[m] = b), m === e.length - 1 && (this.finalKeyframe = v);
      }
    }
    if (this.resolveNoneKeyframes(), !F9.has(a) || e.length !== 2)
      return;
    const [o, f] = e, u = jO(o), h = jO(f);
    if (u !== h)
      if (zO(u) && zO(h))
        for (let m = 0; m < e.length; m++) {
          const v = e[m];
          typeof v == "string" && (e[m] = parseFloat(v));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: i } = this, a = [];
    for (let o = 0; o < e.length; o++)
      k9(e[o]) && a.push(o);
    a.length && o7(e, a, i);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: i, name: a } = this;
    if (!e || !e.current)
      return;
    a === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = fp[a](e.measureViewportBox(), window.getComputedStyle(e.current)), i[0] = this.measuredOrigin;
    const o = i[i.length - 1];
    o !== void 0 && e.getValue(a, o).jump(o, !1);
  }
  measureEndState() {
    var e;
    const { element: i, name: a, unresolvedKeyframes: o } = this;
    if (!i || !i.current)
      return;
    const f = i.getValue(a);
    f && f.jump(this.measuredOrigin, !1);
    const u = o.length - 1, h = o[u];
    o[u] = fp[a](i.measureViewportBox(), window.getComputedStyle(i.current)), h !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = h), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([m, v]) => {
      i.getValue(m).set(v);
    }), this.resolveNoneKeyframes();
  }
}
function g1(t) {
  return typeof t == "function";
}
let gx;
function l7() {
  gx = void 0;
}
const Ho = {
  now: () => (gx === void 0 && Ho.set(gr.isProcessing || _9.useManualTiming ? gr.timestamp : performance.now()), gx),
  set: (t) => {
    gx = t, queueMicrotask(l7);
  }
}, UO = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(rc.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function u7(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let i = 0; i < t.length; i++)
    if (t[i] !== e)
      return !0;
}
function c7(t, e, i, a) {
  const o = t[0];
  if (o === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const f = t[t.length - 1], u = UO(o, e), h = UO(f, e);
  return vp(u === h, `You are trying to animate ${e} from "${o}" to "${f}". ${o} is not an animatable value - to enable this animation set ${o} to a value animatable to ${f} via the \`style\` property.`), !u || !h ? !1 : u7(t) || (i === "spring" || g1(i)) && a;
}
const f7 = 40;
class A2 {
  constructor({ autoplay: e = !0, delay: i = 0, type: a = "keyframes", repeat: o = 0, repeatDelay: f = 0, repeatType: u = "loop", ...h }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Ho.now(), this.options = {
      autoplay: e,
      delay: i,
      type: a,
      repeat: o,
      repeatDelay: f,
      repeatType: u,
      ...h
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > f7 ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && U9(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, i) {
    this.resolvedAt = Ho.now(), this.hasAttemptedResolve = !0;
    const { name: a, type: o, velocity: f, delay: u, onComplete: h, onUpdate: m, isGenerator: v } = this.options;
    if (!v && !c7(e, a, o, f))
      if (u)
        this.options.duration = 0;
      else {
        m == null || m(dS(e, this.options, i)), h == null || h(), this.resolveFinishedPromise();
        return;
      }
    const b = this.initPlayback(e, i);
    b !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: i,
      ...b
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, i) {
    return this.currentFinishedPromise.then(e, i);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
function O2(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const d7 = 5;
function P2(t, e, i) {
  const a = Math.max(e - d7, 0);
  return O2(i - t(a), e - a);
}
const IO = 1e-3, h7 = 0.01, $O = 10, p7 = 0.05, m7 = 1;
function g7({ duration: t = 800, bounce: e = 0.25, velocity: i = 0, mass: a = 1 }) {
  let o, f;
  vp(t <= jo($O), "Spring duration must be 10 seconds or less");
  let u = 1 - e;
  u = ic(p7, m7, u), t = ic(h7, $O, Yl(t)), u < 1 ? (o = (v) => {
    const b = v * u, S = b * t, C = b - i, E = dE(v, u), D = Math.exp(-S);
    return IO - C / E * D;
  }, f = (v) => {
    const S = v * u * t, C = S * i + i, E = Math.pow(u, 2) * Math.pow(v, 2) * t, D = Math.exp(-S), M = dE(Math.pow(v, 2), u);
    return (-o(v) + IO > 0 ? -1 : 1) * ((C - E) * D) / M;
  }) : (o = (v) => {
    const b = Math.exp(-v * t), S = (v - i) * t + 1;
    return -1e-3 + b * S;
  }, f = (v) => {
    const b = Math.exp(-v * t), S = (i - v) * (t * t);
    return b * S;
  });
  const h = 5 / t, m = y7(o, f, h);
  if (t = jo(t), isNaN(m))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const v = Math.pow(m, 2) * a;
    return {
      stiffness: v,
      damping: u * 2 * Math.sqrt(a * v),
      duration: t
    };
  }
}
const v7 = 12;
function y7(t, e, i) {
  let a = i;
  for (let o = 1; o < v7; o++)
    a = a - t(a) / e(a);
  return a;
}
function dE(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const b7 = ["duration", "bounce"], x7 = ["stiffness", "damping", "mass"];
function WO(t, e) {
  return e.some((i) => t[i] !== void 0);
}
function S7(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!WO(t, x7) && WO(t, b7)) {
    const i = g7(t);
    e = {
      ...e,
      ...i,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function L2({ keyframes: t, restDelta: e, restSpeed: i, ...a }) {
  const o = t[0], f = t[t.length - 1], u = { done: !1, value: o }, { stiffness: h, damping: m, mass: v, duration: b, velocity: S, isResolvedFromDuration: C } = S7({
    ...a,
    velocity: -Yl(a.velocity || 0)
  }), E = S || 0, D = m / (2 * Math.sqrt(h * v)), M = f - o, A = Yl(Math.sqrt(h / v)), P = Math.abs(M) < 5;
  i || (i = P ? 0.01 : 2), e || (e = P ? 5e-3 : 0.5);
  let N;
  if (D < 1) {
    const F = dE(A, D);
    N = (B) => {
      const V = Math.exp(-D * A * B);
      return f - V * ((E + D * A * M) / F * Math.sin(F * B) + M * Math.cos(F * B));
    };
  } else if (D === 1)
    N = (F) => f - Math.exp(-A * F) * (M + (E + A * M) * F);
  else {
    const F = A * Math.sqrt(D * D - 1);
    N = (B) => {
      const V = Math.exp(-D * A * B), G = Math.min(F * B, 300);
      return f - V * ((E + D * A * M) * Math.sinh(G) + F * M * Math.cosh(G)) / F;
    };
  }
  return {
    calculatedDuration: C && b || null,
    next: (F) => {
      const B = N(F);
      if (C)
        u.done = F >= b;
      else {
        let V = 0;
        D < 1 && (V = F === 0 ? jo(E) : P2(N, F, B));
        const G = Math.abs(V) <= i, Y = Math.abs(f - B) <= e;
        u.done = G && Y;
      }
      return u.value = u.done ? f : B, u;
    }
  };
}
function YO({ keyframes: t, velocity: e = 0, power: i = 0.8, timeConstant: a = 325, bounceDamping: o = 10, bounceStiffness: f = 500, modifyTarget: u, min: h, max: m, restDelta: v = 0.5, restSpeed: b }) {
  const S = t[0], C = {
    done: !1,
    value: S
  }, E = (K) => h !== void 0 && K < h || m !== void 0 && K > m, D = (K) => h === void 0 ? m : m === void 0 || Math.abs(h - K) < Math.abs(m - K) ? h : m;
  let M = i * e;
  const A = S + M, P = u === void 0 ? A : u(A);
  P !== A && (M = P - S);
  const N = (K) => -M * Math.exp(-K / a), F = (K) => P + N(K), B = (K) => {
    const ae = N(K), ie = F(K);
    C.done = Math.abs(ae) <= v, C.value = C.done ? P : ie;
  };
  let V, G;
  const Y = (K) => {
    E(C.value) && (V = K, G = L2({
      keyframes: [C.value, D(C.value)],
      velocity: P2(F, K, C.value),
      // TODO: This should be passing * 1000
      damping: o,
      stiffness: f,
      restDelta: v,
      restSpeed: b
    }));
  };
  return Y(0), {
    calculatedDuration: null,
    next: (K) => {
      let ae = !1;
      return !G && V === void 0 && (ae = !0, B(K), Y(K)), V !== void 0 && K >= V ? G.next(K - V) : (!ae && B(K), C);
    }
  };
}
const _7 = /* @__PURE__ */ Pv(0.42, 0, 1, 1), C7 = /* @__PURE__ */ Pv(0, 0, 0.58, 1), N2 = /* @__PURE__ */ Pv(0.42, 0, 0.58, 1), w7 = (t) => Array.isArray(t) && typeof t[0] != "number", v1 = (t) => Array.isArray(t) && typeof t[0] == "number", GO = {
  linear: vr,
  easeIn: _7,
  easeInOut: N2,
  easeOut: C7,
  circIn: u1,
  circInOut: p2,
  circOut: h2,
  backIn: l1,
  backInOut: f2,
  backOut: c2,
  anticipate: d2
}, KO = (t) => {
  if (v1(t)) {
    Ql(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, i, a, o] = t;
    return Pv(e, i, a, o);
  } else if (typeof t == "string")
    return Ql(GO[t] !== void 0, `Invalid easing type '${t}'`), GO[t];
  return t;
}, T7 = (t, e) => (i) => e(t(i)), Gl = (...t) => t.reduce(T7), dp = (t, e, i) => {
  const a = e - t;
  return a === 0 ? 1 : (i - t) / a;
}, ai = (t, e, i) => t + (e - t) * i;
function pT(t, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + (e - t) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t;
}
function E7({ hue: t, saturation: e, lightness: i, alpha: a }) {
  t /= 360, e /= 100, i /= 100;
  let o = 0, f = 0, u = 0;
  if (!e)
    o = f = u = i;
  else {
    const h = i < 0.5 ? i * (1 + e) : i + e - i * e, m = 2 * i - h;
    o = pT(m, h, t + 1 / 3), f = pT(m, h, t), u = pT(m, h, t - 1 / 3);
  }
  return {
    red: Math.round(o * 255),
    green: Math.round(f * 255),
    blue: Math.round(u * 255),
    alpha: a
  };
}
function Fx(t, e) {
  return (i) => i > 0 ? e : t;
}
const mT = (t, e, i) => {
  const a = t * t, o = i * (e * e - a) + a;
  return o < 0 ? 0 : Math.sqrt(o);
}, R7 = [cE, jf, Xh], D7 = (t) => R7.find((e) => e.test(t));
function XO(t) {
  const e = D7(t);
  if (vp(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let i = e.parse(t);
  return e === Xh && (i = E7(i)), i;
}
const QO = (t, e) => {
  const i = XO(t), a = XO(e);
  if (!i || !a)
    return Fx(t, e);
  const o = { ...i };
  return (f) => (o.red = mT(i.red, a.red, f), o.green = mT(i.green, a.green, f), o.blue = mT(i.blue, a.blue, f), o.alpha = ai(i.alpha, a.alpha, f), jf.transform(o));
}, hE = /* @__PURE__ */ new Set(["none", "hidden"]);
function k7(t, e) {
  return hE.has(t) ? (i) => i <= 0 ? t : e : (i) => i >= 1 ? e : t;
}
function M7(t, e) {
  return (i) => ai(t, e, i);
}
function y1(t) {
  return typeof t == "number" ? M7 : typeof t == "string" ? c1(t) ? Fx : zr.test(t) ? QO : P7 : Array.isArray(t) ? z2 : typeof t == "object" ? zr.test(t) ? QO : A7 : Fx;
}
function z2(t, e) {
  const i = [...t], a = i.length, o = t.map((f, u) => y1(f)(f, e[u]));
  return (f) => {
    for (let u = 0; u < a; u++)
      i[u] = o[u](f);
    return i;
  };
}
function A7(t, e) {
  const i = { ...t, ...e }, a = {};
  for (const o in i)
    t[o] !== void 0 && e[o] !== void 0 && (a[o] = y1(t[o])(t[o], e[o]));
  return (o) => {
    for (const f in a)
      i[f] = a[f](o);
    return i;
  };
}
function O7(t, e) {
  var i;
  const a = [], o = { color: 0, var: 0, number: 0 };
  for (let f = 0; f < e.values.length; f++) {
    const u = e.types[f], h = t.indexes[u][o[u]], m = (i = t.values[h]) !== null && i !== void 0 ? i : 0;
    a[f] = m, o[u]++;
  }
  return a;
}
const P7 = (t, e) => {
  const i = rc.createTransformer(e), a = Tv(t), o = Tv(e);
  return a.indexes.var.length === o.indexes.var.length && a.indexes.color.length === o.indexes.color.length && a.indexes.number.length >= o.indexes.number.length ? hE.has(t) && !o.values.length || hE.has(e) && !a.values.length ? k7(t, e) : Gl(z2(O7(a, o), o.values), i) : (vp(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Fx(t, e));
};
function F2(t, e, i) {
  return typeof t == "number" && typeof e == "number" && typeof i == "number" ? ai(t, e, i) : y1(t)(t, e);
}
function L7(t, e, i) {
  const a = [], o = i || F2, f = t.length - 1;
  for (let u = 0; u < f; u++) {
    let h = o(t[u], t[u + 1]);
    if (e) {
      const m = Array.isArray(e) ? e[u] || vr : e;
      h = Gl(m, h);
    }
    a.push(h);
  }
  return a;
}
function N7(t, e, { clamp: i = !0, ease: a, mixer: o } = {}) {
  const f = t.length;
  if (Ql(f === e.length, "Both input and output ranges must be the same length"), f === 1)
    return () => e[0];
  if (f === 2 && t[0] === t[1])
    return () => e[1];
  t[0] > t[f - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const u = L7(e, a, o), h = u.length, m = (v) => {
    let b = 0;
    if (h > 1)
      for (; b < t.length - 2 && !(v < t[b + 1]); b++)
        ;
    const S = dp(t[b], t[b + 1], v);
    return u[b](S);
  };
  return i ? (v) => m(ic(t[0], t[f - 1], v)) : m;
}
function z7(t, e) {
  const i = t[t.length - 1];
  for (let a = 1; a <= e; a++) {
    const o = dp(0, e, a);
    t.push(ai(i, 1, o));
  }
}
function F7(t) {
  const e = [0];
  return z7(e, t.length - 1), e;
}
function V7(t, e) {
  return t.map((i) => i * e);
}
function j7(t, e) {
  return t.map(() => e || N2).splice(0, t.length - 1);
}
function Vx({ duration: t = 300, keyframes: e, times: i, ease: a = "easeInOut" }) {
  const o = w7(a) ? a.map(KO) : KO(a), f = {
    done: !1,
    value: e[0]
  }, u = V7(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    i && i.length === e.length ? i : F7(e),
    t
  ), h = N7(u, e, {
    ease: Array.isArray(o) ? o : j7(e, o)
  });
  return {
    calculatedDuration: t,
    next: (m) => (f.value = h(m), f.done = m >= t, f)
  };
}
const qO = 2e4;
function B7(t) {
  let e = 0;
  const i = 50;
  let a = t.next(e);
  for (; !a.done && e < qO; )
    e += i, a = t.next(e);
  return e >= qO ? 1 / 0 : e;
}
const H7 = (t) => {
  const e = ({ timestamp: i }) => t(i);
  return {
    start: () => En.update(e, !0),
    stop: () => nc(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => gr.isProcessing ? gr.timestamp : Ho.now()
  };
}, U7 = {
  decay: YO,
  inertia: YO,
  tween: Vx,
  keyframes: Vx,
  spring: L2
}, I7 = (t) => t / 100;
class b1 extends A2 {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: m } = this.options;
      m && m();
    };
    const { name: i, motionValue: a, element: o, keyframes: f } = this.options, u = (o == null ? void 0 : o.KeyframeResolver) || f1, h = (m, v) => this.onKeyframesResolved(m, v);
    this.resolver = new u(f, h, i, a, o), this.resolver.scheduleResolve();
  }
  initPlayback(e) {
    const { type: i = "keyframes", repeat: a = 0, repeatDelay: o = 0, repeatType: f, velocity: u = 0 } = this.options, h = g1(i) ? i : U7[i] || Vx;
    let m, v;
    h !== Vx && typeof e[0] != "number" && (process.env.NODE_ENV !== "production" && Ql(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), m = Gl(I7, F2(e[0], e[1])), e = [0, 100]);
    const b = h({ ...this.options, keyframes: e });
    f === "mirror" && (v = h({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -u
    })), b.calculatedDuration === null && (b.calculatedDuration = B7(b));
    const { calculatedDuration: S } = b, C = S + o, E = C * (a + 1) - o;
    return {
      generator: b,
      mirroredGenerator: v,
      mapPercentToKeyframes: m,
      calculatedDuration: S,
      resolvedDuration: C,
      totalDuration: E
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, i = !1) {
    const { resolved: a } = this;
    if (!a) {
      const { keyframes: K } = this.options;
      return { done: !0, value: K[K.length - 1] };
    }
    const { finalKeyframe: o, generator: f, mirroredGenerator: u, mapPercentToKeyframes: h, keyframes: m, calculatedDuration: v, totalDuration: b, resolvedDuration: S } = a;
    if (this.startTime === null)
      return f.next(0);
    const { delay: C, repeat: E, repeatType: D, repeatDelay: M, onUpdate: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - b / this.speed, this.startTime)), i ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const P = this.currentTime - C * (this.speed >= 0 ? 1 : -1), N = this.speed >= 0 ? P < 0 : P > b;
    this.currentTime = Math.max(P, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = b);
    let F = this.currentTime, B = f;
    if (E) {
      const K = Math.min(this.currentTime, b) / S;
      let ae = Math.floor(K), ie = K % 1;
      !ie && K >= 1 && (ie = 1), ie === 1 && ae--, ae = Math.min(ae, E + 1), !!(ae % 2) && (D === "reverse" ? (ie = 1 - ie, M && (ie -= M / S)) : D === "mirror" && (B = u)), F = ic(0, 1, ie) * S;
    }
    const V = N ? { done: !1, value: m[0] } : B.next(F);
    h && (V.value = h(V.value));
    let { done: G } = V;
    !N && v !== null && (G = this.speed >= 0 ? this.currentTime >= b : this.currentTime <= 0);
    const Y = this.holdTime === null && (this.state === "finished" || this.state === "running" && G);
    return Y && o !== void 0 && (V.value = dS(m, this.options, o)), A && A(V.value), Y && this.finish(), V;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? Yl(e.calculatedDuration) : 0;
  }
  get time() {
    return Yl(this.currentTime);
  }
  set time(e) {
    e = jo(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const i = this.playbackSpeed !== e;
    this.playbackSpeed = e, i && (this.time = Yl(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = H7, onPlay: i, startTime: a } = this.options;
    this.driver || (this.driver = e((f) => this.tick(f))), i && i();
    const o = this.driver.now();
    this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = o) : this.startTime = a ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const V2 = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), $7 = 10, W7 = (t, e) => {
  let i = "";
  const a = Math.max(Math.round(e / $7), 2);
  for (let o = 0; o < a; o++)
    i += t(dp(0, a - 1, o)) + ", ";
  return `linear(${i.substring(0, i.length - 2)})`;
};
function x1(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const Y7 = {
  linearEasing: void 0
};
function G7(t, e) {
  const i = x1(t);
  return () => {
    var a;
    return (a = Y7[e]) !== null && a !== void 0 ? a : i();
  };
}
const jx = /* @__PURE__ */ G7(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function j2(t) {
  return !!(typeof t == "function" && jx() || !t || typeof t == "string" && (t in pE || jx()) || v1(t) || Array.isArray(t) && t.every(j2));
}
const Qg = ([t, e, i, a]) => `cubic-bezier(${t}, ${e}, ${i}, ${a})`, pE = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Qg([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Qg([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Qg([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Qg([0.33, 1.53, 0.69, 0.99])
};
function B2(t, e) {
  if (t)
    return typeof t == "function" && jx() ? W7(t, e) : v1(t) ? Qg(t) : Array.isArray(t) ? t.map((i) => B2(i, e) || pE.easeOut) : pE[t];
}
function K7(t, e, i, { delay: a = 0, duration: o = 300, repeat: f = 0, repeatType: u = "loop", ease: h, times: m } = {}) {
  const v = { [e]: i };
  m && (v.offset = m);
  const b = B2(h, o);
  return Array.isArray(b) && (v.easing = b), t.animate(v, {
    delay: a,
    duration: o,
    easing: Array.isArray(b) ? "linear" : b,
    fill: "both",
    iterations: f + 1,
    direction: u === "reverse" ? "alternate" : "normal"
  });
}
function ZO(t, e) {
  t.timeline = e, t.onfinish = null;
}
const X7 = /* @__PURE__ */ x1(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Bx = 10, Q7 = 2e4;
function q7(t) {
  return g1(t.type) || t.type === "spring" || !j2(t.ease);
}
function Z7(t, e) {
  const i = new b1({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let a = { done: !1, value: t[0] };
  const o = [];
  let f = 0;
  for (; !a.done && f < Q7; )
    a = i.sample(f), o.push(a.value), f += Bx;
  return {
    times: void 0,
    keyframes: o,
    duration: f - Bx,
    ease: "linear"
  };
}
const H2 = {
  anticipate: d2,
  backInOut: f2,
  circInOut: p2
};
function J7(t) {
  return t in H2;
}
class JO extends A2 {
  constructor(e) {
    super(e);
    const { name: i, motionValue: a, element: o, keyframes: f } = this.options;
    this.resolver = new M2(f, (u, h) => this.onKeyframesResolved(u, h), i, a, o), this.resolver.scheduleResolve();
  }
  initPlayback(e, i) {
    var a;
    let { duration: o = 300, times: f, ease: u, type: h, motionValue: m, name: v, startTime: b } = this.options;
    if (!(!((a = m.owner) === null || a === void 0) && a.current))
      return !1;
    if (typeof u == "string" && jx() && J7(u) && (u = H2[u]), q7(this.options)) {
      const { onComplete: C, onUpdate: E, motionValue: D, element: M, ...A } = this.options, P = Z7(e, A);
      e = P.keyframes, e.length === 1 && (e[1] = e[0]), o = P.duration, f = P.times, u = P.ease, h = "keyframes";
    }
    const S = K7(m.owner.current, v, e, { ...this.options, duration: o, times: f, ease: u });
    return S.startTime = b ?? this.calcStartTime(), this.pendingTimeline ? (ZO(S, this.pendingTimeline), this.pendingTimeline = void 0) : S.onfinish = () => {
      const { onComplete: C } = this.options;
      m.set(dS(e, this.options, i)), C && C(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: S,
      duration: o,
      times: f,
      type: h,
      ease: u,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: i } = e;
    return Yl(i);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: i } = e;
    return Yl(i.currentTime || 0);
  }
  set time(e) {
    const { resolved: i } = this;
    if (!i)
      return;
    const { animation: a } = i;
    a.currentTime = jo(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: i } = e;
    return i.playbackRate;
  }
  set speed(e) {
    const { resolved: i } = this;
    if (!i)
      return;
    const { animation: a } = i;
    a.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: i } = e;
    return i.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: i } = e;
    return i.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: i } = this;
      if (!i)
        return vr;
      const { animation: a } = i;
      ZO(a, e);
    }
    return vr;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: i } = e;
    i.playState === "finished" && this.updateFinishedPromise(), i.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: i } = e;
    i.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: i, keyframes: a, duration: o, type: f, ease: u, times: h } = e;
    if (i.playState === "idle" || i.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: v, onUpdate: b, onComplete: S, element: C, ...E } = this.options, D = new b1({
        ...E,
        keyframes: a,
        duration: o,
        type: f,
        ease: u,
        times: h,
        isGenerator: !0
      }), M = jo(this.time);
      v.setWithVelocity(D.sample(M - Bx).value, D.sample(M).value, Bx);
    }
    const { onStop: m } = this.options;
    m && m(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: i, name: a, repeatDelay: o, repeatType: f, damping: u, type: h } = e;
    return X7() && a && V2.has(a) && i && i.owner && i.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !i.owner.getProps().onUpdate && !o && f !== "mirror" && u !== 0 && h !== "inertia";
  }
}
const eG = x1(() => window.ScrollTimeline !== void 0);
class tG {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  then(e, i) {
    return Promise.all(this.animations).then(e).catch(i);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, i) {
    for (let a = 0; a < this.animations.length; a++)
      this.animations[a][e] = i;
  }
  attachTimeline(e, i) {
    const a = this.animations.map((o) => eG() && o.attachTimeline ? o.attachTimeline(e) : i(o));
    return () => {
      a.forEach((o, f) => {
        o && o(), this.animations[f].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let i = 0; i < this.animations.length; i++)
      e = Math.max(e, this.animations[i].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((i) => i[e]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function nG({ when: t, delay: e, delayChildren: i, staggerChildren: a, staggerDirection: o, repeat: f, repeatType: u, repeatDelay: h, from: m, elapsed: v, ...b }) {
  return !!Object.keys(b).length;
}
const S1 = (t, e, i, a = {}, o, f) => (u) => {
  const h = o1(a, t) || {}, m = h.delay || a.delay || 0;
  let { elapsed: v = 0 } = a;
  v = v - jo(m);
  let b = {
    keyframes: Array.isArray(i) ? i : [null, i],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...h,
    delay: -v,
    onUpdate: (C) => {
      e.set(C), h.onUpdate && h.onUpdate(C);
    },
    onComplete: () => {
      u(), h.onComplete && h.onComplete();
    },
    name: t,
    motionValue: e,
    element: f ? void 0 : o
  };
  nG(h) || (b = {
    ...b,
    ...S9(t, b)
  }), b.duration && (b.duration = jo(b.duration)), b.repeatDelay && (b.repeatDelay = jo(b.repeatDelay)), b.from !== void 0 && (b.keyframes[0] = b.from);
  let S = !1;
  if ((b.type === !1 || b.duration === 0 && !b.repeatDelay) && (b.duration = 0, b.delay === 0 && (S = !0)), S && !f && e.get() !== void 0) {
    const C = dS(b.keyframes, h);
    if (C !== void 0)
      return En.update(() => {
        b.onUpdate(C), b.onComplete();
      }), new tG([]);
  }
  return !f && JO.supports(b) ? new JO(b) : new b1(b);
}, iG = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), rG = (t) => oE(t) ? t[t.length - 1] || 0 : t;
function _1(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function C1(t, e) {
  const i = t.indexOf(e);
  i > -1 && t.splice(i, 1);
}
class w1 {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return _1(this.subscriptions, e), () => C1(this.subscriptions, e);
  }
  notify(e, i, a) {
    const o = this.subscriptions.length;
    if (o)
      if (o === 1)
        this.subscriptions[0](e, i, a);
      else
        for (let f = 0; f < o; f++) {
          const u = this.subscriptions[f];
          u && u(e, i, a);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const eP = 30, aG = (t) => !isNaN(parseFloat(t));
class sG {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, i = {}) {
    this.version = "11.11.9", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (a, o = !0) => {
      const f = Ho.now();
      this.updatedAt !== f && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(a), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), o && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = i.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = Ho.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = aG(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && cS(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, i) {
    this.events[e] || (this.events[e] = new w1());
    const a = this.events[e].add(i);
    return e === "change" ? () => {
      a(), En.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : a;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, i) {
    this.passiveEffect = e, this.stopPassiveEffect = i;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, i = !0) {
    !i || !this.passiveEffect ? this.updateAndNotify(e, i) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, i, a) {
    this.set(i), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - a;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, i = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, i && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = Ho.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > eP)
      return 0;
    const i = Math.min(this.updatedAt - this.prevUpdatedAt, eP);
    return O2(parseFloat(this.current) - parseFloat(this.prevFrameValue), i);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((i) => {
      this.hasAnimated = !0, this.animation = e(i), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Ev(t, e) {
  return new sG(t, e);
}
function oG(t, e, i) {
  t.hasValue(e) ? t.getValue(e).set(i) : t.addValue(e, Ev(i));
}
function lG(t, e) {
  const i = fS(t, e);
  let { transitionEnd: a = {}, transition: o = {}, ...f } = i || {};
  f = { ...f, ...a };
  for (const u in f) {
    const h = rG(f[u]);
    oG(t, u, h);
  }
}
const hS = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), uG = "framerAppearId", U2 = "data-" + hS(uG);
function I2(t) {
  return t.props[U2];
}
const Vr = (t) => !!(t && t.getVelocity);
function cG(t) {
  return !!(Vr(t) && t.add);
}
function mE(t, e) {
  if (!t.applyWillChange)
    return;
  const i = t.getValue("willChange");
  if (cG(i))
    return i.add(e);
}
function fG({ protectedKeys: t, needsAnimating: e }, i) {
  const a = t.hasOwnProperty(i) && e[i] !== !0;
  return e[i] = !1, a;
}
function $2(t, e, { delay: i = 0, transitionOverride: a, type: o } = {}) {
  var f;
  let { transition: u = t.getDefaultTransition(), transitionEnd: h, ...m } = e;
  a && (u = a);
  const v = [], b = o && t.animationState && t.animationState.getState()[o];
  for (const S in m) {
    const C = t.getValue(S, (f = t.latestValues[S]) !== null && f !== void 0 ? f : null), E = m[S];
    if (E === void 0 || b && fG(b, S))
      continue;
    const D = {
      delay: i,
      ...o1(u || {}, S)
    };
    let M = !1;
    if (window.MotionHandoffAnimation) {
      const P = I2(t);
      if (P) {
        const N = window.MotionHandoffAnimation(P, S, En);
        N !== null && (D.startTime = N, M = !0);
      }
    }
    mE(t, S), C.start(S1(S, C, E, t.shouldReduceMotion && oc.has(S) ? { type: !1 } : D, t, M));
    const A = C.animation;
    A && v.push(A);
  }
  return h && Promise.all(v).then(() => {
    En.update(() => {
      h && lG(t, h);
    });
  }), v;
}
function gE(t, e, i = {}) {
  var a;
  const o = fS(t, e, i.type === "exit" ? (a = t.presenceContext) === null || a === void 0 ? void 0 : a.custom : void 0);
  let { transition: f = t.getDefaultTransition() || {} } = o || {};
  i.transitionOverride && (f = i.transitionOverride);
  const u = o ? () => Promise.all($2(t, o, i)) : () => Promise.resolve(), h = t.variantChildren && t.variantChildren.size ? (v = 0) => {
    const { delayChildren: b = 0, staggerChildren: S, staggerDirection: C } = f;
    return dG(t, e, b + v, S, C, i);
  } : () => Promise.resolve(), { when: m } = f;
  if (m) {
    const [v, b] = m === "beforeChildren" ? [u, h] : [h, u];
    return v().then(() => b());
  } else
    return Promise.all([u(), h(i.delay)]);
}
function dG(t, e, i = 0, a = 0, o = 1, f) {
  const u = [], h = (t.variantChildren.size - 1) * a, m = o === 1 ? (v = 0) => v * a : (v = 0) => h - v * a;
  return Array.from(t.variantChildren).sort(hG).forEach((v, b) => {
    v.notify("AnimationStart", e), u.push(gE(v, e, {
      ...f,
      delay: i + m(b)
    }).then(() => v.notify("AnimationComplete", e)));
  }), Promise.all(u);
}
function hG(t, e) {
  return t.sortNodePosition(e);
}
function pG(t, e, i = {}) {
  t.notify("AnimationStart", e);
  let a;
  if (Array.isArray(e)) {
    const o = e.map((f) => gE(t, f, i));
    a = Promise.all(o);
  } else if (typeof e == "string")
    a = gE(t, e, i);
  else {
    const o = typeof e == "function" ? fS(t, e, i.custom) : e;
    a = Promise.all($2(t, o, i));
  }
  return a.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const mG = s1.length;
function W2(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const i = t.parent ? W2(t.parent) || {} : {};
    return t.props.initial !== void 0 && (i.initial = t.props.initial), i;
  }
  const e = {};
  for (let i = 0; i < mG; i++) {
    const a = s1[i], o = t.props[a];
    (Cv(o) || o === !1) && (e[a] = o);
  }
  return e;
}
const gG = [...a1].reverse(), vG = a1.length;
function yG(t) {
  return (e) => Promise.all(e.map(({ animation: i, options: a }) => pG(t, i, a)));
}
function bG(t) {
  let e = yG(t), i = tP(), a = !0;
  const o = (m) => (v, b) => {
    var S;
    const C = fS(t, b, m === "exit" ? (S = t.presenceContext) === null || S === void 0 ? void 0 : S.custom : void 0);
    if (C) {
      const { transition: E, transitionEnd: D, ...M } = C;
      v = { ...v, ...M, ...D };
    }
    return v;
  };
  function f(m) {
    e = m(t);
  }
  function u(m) {
    const { props: v } = t, b = W2(t.parent) || {}, S = [], C = /* @__PURE__ */ new Set();
    let E = {}, D = 1 / 0;
    for (let A = 0; A < vG; A++) {
      const P = gG[A], N = i[P], F = v[P] !== void 0 ? v[P] : b[P], B = Cv(F), V = P === m ? N.isActive : null;
      V === !1 && (D = A);
      let G = F === b[P] && F !== v[P] && B;
      if (G && a && t.manuallyAnimateOnMount && (G = !1), N.protectedKeys = { ...E }, // If it isn't active and hasn't *just* been set as inactive
      !N.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !F && !N.prevProp || // Or if the prop doesn't define an animation
      _v(F) || typeof F == "boolean")
        continue;
      const Y = xG(N.prevProp, F);
      let K = Y || // If we're making this variant active, we want to always make it active
      P === m && N.isActive && !G && B || // If we removed a higher-priority variant (i is in reverse order)
      A > D && B, ae = !1;
      const ie = Array.isArray(F) ? F : [F];
      let ee = ie.reduce(o(P), {});
      V === !1 && (ee = {});
      const { prevResolvedValues: oe = {} } = N, se = {
        ...oe,
        ...ee
      }, Pe = (Oe) => {
        K = !0, C.has(Oe) && (ae = !0, C.delete(Oe)), N.needsAnimating[Oe] = !0;
        const re = t.getValue(Oe);
        re && (re.liveStyle = !1);
      };
      for (const Oe in se) {
        const re = ee[Oe], ge = oe[Oe];
        if (E.hasOwnProperty(Oe))
          continue;
        let me = !1;
        oE(re) && oE(ge) ? me = !a2(re, ge) : me = re !== ge, me ? re != null ? Pe(Oe) : C.add(Oe) : re !== void 0 && C.has(Oe) ? Pe(Oe) : N.protectedKeys[Oe] = !0;
      }
      N.prevProp = F, N.prevResolvedValues = ee, N.isActive && (E = { ...E, ...ee }), a && t.blockInitialAnimation && (K = !1), K && (!(G && Y) || ae) && S.push(...ie.map((Oe) => ({
        animation: Oe,
        options: { type: P }
      })));
    }
    if (C.size) {
      const A = {};
      C.forEach((P) => {
        const N = t.getBaseTarget(P), F = t.getValue(P);
        F && (F.liveStyle = !0), A[P] = N ?? null;
      }), S.push({ animation: A });
    }
    let M = !!S.length;
    return a && (v.initial === !1 || v.initial === v.animate) && !t.manuallyAnimateOnMount && (M = !1), a = !1, M ? e(S) : Promise.resolve();
  }
  function h(m, v) {
    var b;
    if (i[m].isActive === v)
      return Promise.resolve();
    (b = t.variantChildren) === null || b === void 0 || b.forEach((C) => {
      var E;
      return (E = C.animationState) === null || E === void 0 ? void 0 : E.setActive(m, v);
    }), i[m].isActive = v;
    const S = u(m);
    for (const C in i)
      i[C].protectedKeys = {};
    return S;
  }
  return {
    animateChanges: u,
    setActive: h,
    setAnimateFunction: f,
    getState: () => i,
    reset: () => {
      i = tP(), a = !0;
    }
  };
}
function xG(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !a2(e, t) : !1;
}
function Of(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function tP() {
  return {
    animate: Of(!0),
    whileInView: Of(),
    whileHover: Of(),
    whileTap: Of(),
    whileDrag: Of(),
    whileFocus: Of(),
    exit: Of()
  };
}
class lc {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class SG extends lc {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = bG(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    _v(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: i } = this.node.prevProps || {};
    e !== i && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let _G = 0;
class CG extends lc {
  constructor() {
    super(...arguments), this.id = _G++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: i } = this.node.presenceContext, { isPresent: a } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === a)
      return;
    const o = this.node.animationState.setActive("exit", !e);
    i && !e && o.then(() => i(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const wG = {
  animation: {
    Feature: SG
  },
  exit: {
    Feature: CG
  }
}, Y2 = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function pS(t, e = "page") {
  return {
    point: {
      x: t[`${e}X`],
      y: t[`${e}Y`]
    }
  };
}
const TG = (t) => (e) => Y2(e) && t(e, pS(e));
function Wl(t, e, i, a = { passive: !0 }) {
  return t.addEventListener(e, i, a), () => t.removeEventListener(e, i);
}
function Kl(t, e, i, a) {
  return Wl(t, e, TG(i), a);
}
const nP = (t, e) => Math.abs(t - e);
function EG(t, e) {
  const i = nP(t.x, e.x), a = nP(t.y, e.y);
  return Math.sqrt(i ** 2 + a ** 2);
}
class G2 {
  constructor(e, i, { transformPagePoint: a, contextWindow: o, dragSnapToOrigin: f = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const S = vT(this.lastMoveEventInfo, this.history), C = this.startEvent !== null, E = EG(S.offset, { x: 0, y: 0 }) >= 3;
      if (!C && !E)
        return;
      const { point: D } = S, { timestamp: M } = gr;
      this.history.push({ ...D, timestamp: M });
      const { onStart: A, onMove: P } = this.handlers;
      C || (A && A(this.lastMoveEvent, S), this.startEvent = this.lastMoveEvent), P && P(this.lastMoveEvent, S);
    }, this.handlePointerMove = (S, C) => {
      this.lastMoveEvent = S, this.lastMoveEventInfo = gT(C, this.transformPagePoint), En.update(this.updatePoint, !0);
    }, this.handlePointerUp = (S, C) => {
      this.end();
      const { onEnd: E, onSessionEnd: D, resumeAnimation: M } = this.handlers;
      if (this.dragSnapToOrigin && M && M(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const A = vT(S.type === "pointercancel" ? this.lastMoveEventInfo : gT(C, this.transformPagePoint), this.history);
      this.startEvent && E && E(S, A), D && D(S, A);
    }, !Y2(e))
      return;
    this.dragSnapToOrigin = f, this.handlers = i, this.transformPagePoint = a, this.contextWindow = o || window;
    const u = pS(e), h = gT(u, this.transformPagePoint), { point: m } = h, { timestamp: v } = gr;
    this.history = [{ ...m, timestamp: v }];
    const { onSessionStart: b } = i;
    b && b(e, vT(h, this.history)), this.removeListeners = Gl(Kl(this.contextWindow, "pointermove", this.handlePointerMove), Kl(this.contextWindow, "pointerup", this.handlePointerUp), Kl(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), nc(this.updatePoint);
  }
}
function gT(t, e) {
  return e ? { point: e(t.point) } : t;
}
function iP(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function vT({ point: t }, e) {
  return {
    point: t,
    delta: iP(t, K2(e)),
    offset: iP(t, RG(e)),
    velocity: DG(e, 0.1)
  };
}
function RG(t) {
  return t[0];
}
function K2(t) {
  return t[t.length - 1];
}
function DG(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let i = t.length - 1, a = null;
  const o = K2(t);
  for (; i >= 0 && (a = t[i], !(o.timestamp - a.timestamp > jo(e))); )
    i--;
  if (!a)
    return { x: 0, y: 0 };
  const f = Yl(o.timestamp - a.timestamp);
  if (f === 0)
    return { x: 0, y: 0 };
  const u = {
    x: (o.x - a.x) / f,
    y: (o.y - a.y) / f
  };
  return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u;
}
function X2(t) {
  let e = null;
  return () => {
    const i = () => {
      e = null;
    };
    return e === null ? (e = t, i) : !1;
  };
}
const rP = X2("dragHorizontal"), aP = X2("dragVertical");
function Q2(t) {
  let e = !1;
  if (t === "y")
    e = aP();
  else if (t === "x")
    e = rP();
  else {
    const i = rP(), a = aP();
    i && a ? e = () => {
      i(), a();
    } : (i && i(), a && a());
  }
  return e;
}
function q2() {
  const t = Q2(!0);
  return t ? (t(), !1) : !0;
}
function Qh(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
const Z2 = 1e-4, kG = 1 - Z2, MG = 1 + Z2, J2 = 0.01, AG = 0 - J2, OG = 0 + J2;
function Wa(t) {
  return t.max - t.min;
}
function PG(t, e, i) {
  return Math.abs(t - e) <= i;
}
function sP(t, e, i, a = 0.5) {
  t.origin = a, t.originPoint = ai(e.min, e.max, t.origin), t.scale = Wa(i) / Wa(e), t.translate = ai(i.min, i.max, t.origin) - t.originPoint, (t.scale >= kG && t.scale <= MG || isNaN(t.scale)) && (t.scale = 1), (t.translate >= AG && t.translate <= OG || isNaN(t.translate)) && (t.translate = 0);
}
function av(t, e, i, a) {
  sP(t.x, e.x, i.x, a ? a.originX : void 0), sP(t.y, e.y, i.y, a ? a.originY : void 0);
}
function oP(t, e, i) {
  t.min = i.min + e.min, t.max = t.min + Wa(e);
}
function LG(t, e, i) {
  oP(t.x, e.x, i.x), oP(t.y, e.y, i.y);
}
function lP(t, e, i) {
  t.min = e.min - i.min, t.max = t.min + Wa(e);
}
function sv(t, e, i) {
  lP(t.x, e.x, i.x), lP(t.y, e.y, i.y);
}
function NG(t, { min: e, max: i }, a) {
  return e !== void 0 && t < e ? t = a ? ai(e, t, a.min) : Math.max(t, e) : i !== void 0 && t > i && (t = a ? ai(i, t, a.max) : Math.min(t, i)), t;
}
function uP(t, e, i) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: i !== void 0 ? t.max + i - (t.max - t.min) : void 0
  };
}
function zG(t, { top: e, left: i, bottom: a, right: o }) {
  return {
    x: uP(t.x, i, o),
    y: uP(t.y, e, a)
  };
}
function cP(t, e) {
  let i = e.min - t.min, a = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([i, a] = [a, i]), { min: i, max: a };
}
function FG(t, e) {
  return {
    x: cP(t.x, e.x),
    y: cP(t.y, e.y)
  };
}
function VG(t, e) {
  let i = 0.5;
  const a = Wa(t), o = Wa(e);
  return o > a ? i = dp(e.min, e.max - a, t.min) : a > o && (i = dp(t.min, t.max - o, e.min)), ic(0, 1, i);
}
function jG(t, e) {
  const i = {};
  return e.min !== void 0 && (i.min = e.min - t.min), e.max !== void 0 && (i.max = e.max - t.min), i;
}
const vE = 0.35;
function BG(t = vE) {
  return t === !1 ? t = 0 : t === !0 && (t = vE), {
    x: fP(t, "left", "right"),
    y: fP(t, "top", "bottom")
  };
}
function fP(t, e, i) {
  return {
    min: dP(t, e),
    max: dP(t, i)
  };
}
function dP(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const hP = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), qh = () => ({
  x: hP(),
  y: hP()
}), pP = () => ({ min: 0, max: 0 }), _i = () => ({
  x: pP(),
  y: pP()
});
function gs(t) {
  return [t("x"), t("y")];
}
function ez({ top: t, left: e, right: i, bottom: a }) {
  return {
    x: { min: e, max: i },
    y: { min: t, max: a }
  };
}
function HG({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function UG(t, e) {
  if (!e)
    return t;
  const i = e({ x: t.left, y: t.top }), a = e({ x: t.right, y: t.bottom });
  return {
    top: i.y,
    left: i.x,
    bottom: a.y,
    right: a.x
  };
}
function yT(t) {
  return t === void 0 || t === 1;
}
function yE({ scale: t, scaleX: e, scaleY: i }) {
  return !yT(t) || !yT(e) || !yT(i);
}
function Nf(t) {
  return yE(t) || tz(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function tz(t) {
  return mP(t.x) || mP(t.y);
}
function mP(t) {
  return t && t !== "0%";
}
function Hx(t, e, i) {
  const a = t - i, o = e * a;
  return i + o;
}
function gP(t, e, i, a, o) {
  return o !== void 0 && (t = Hx(t, o, a)), Hx(t, i, a) + e;
}
function bE(t, e = 0, i = 1, a, o) {
  t.min = gP(t.min, e, i, a, o), t.max = gP(t.max, e, i, a, o);
}
function nz(t, { x: e, y: i }) {
  bE(t.x, e.translate, e.scale, e.originPoint), bE(t.y, i.translate, i.scale, i.originPoint);
}
const vP = 0.999999999999, yP = 1.0000000000001;
function IG(t, e, i, a = !1) {
  const o = i.length;
  if (!o)
    return;
  e.x = e.y = 1;
  let f, u;
  for (let h = 0; h < o; h++) {
    f = i[h], u = f.projectionDelta;
    const { visualElement: m } = f.options;
    m && m.props.style && m.props.style.display === "contents" || (a && f.options.layoutScroll && f.scroll && f !== f.root && Jh(t, {
      x: -f.scroll.offset.x,
      y: -f.scroll.offset.y
    }), u && (e.x *= u.x.scale, e.y *= u.y.scale, nz(t, u)), a && Nf(f.latestValues) && Jh(t, f.latestValues));
  }
  e.x < yP && e.x > vP && (e.x = 1), e.y < yP && e.y > vP && (e.y = 1);
}
function Zh(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function bP(t, e, i, a, o = 0.5) {
  const f = ai(t.min, t.max, o);
  bE(t, e, i, f, a);
}
function Jh(t, e) {
  bP(t.x, e.x, e.scaleX, e.scale, e.originX), bP(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function iz(t, e) {
  return ez(UG(t.getBoundingClientRect(), e));
}
function $G(t, e, i) {
  const a = iz(t, i), { scroll: o } = e;
  return o && (Zh(a.x, o.offset.x), Zh(a.y, o.offset.y)), a;
}
const rz = ({ current: t }) => t ? t.ownerDocument.defaultView : null, WG = /* @__PURE__ */ new WeakMap();
class YG {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = _i(), this.visualElement = e;
  }
  start(e, { snapToCursor: i = !1 } = {}) {
    const { presenceContext: a } = this.visualElement;
    if (a && a.isPresent === !1)
      return;
    const o = (b) => {
      const { dragSnapToOrigin: S } = this.getProps();
      S ? this.pauseAnimation() : this.stopAnimation(), i && this.snapToCursor(pS(b, "page").point);
    }, f = (b, S) => {
      const { drag: C, dragPropagation: E, onDragStart: D } = this.getProps();
      if (C && !E && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Q2(C), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), gs((A) => {
        let P = this.getAxisMotionValue(A).get() || 0;
        if (Bo.test(P)) {
          const { projection: N } = this.visualElement;
          if (N && N.layout) {
            const F = N.layout.layoutBox[A];
            F && (P = Wa(F) * (parseFloat(P) / 100));
          }
        }
        this.originPoint[A] = P;
      }), D && En.postRender(() => D(b, S)), mE(this.visualElement, "transform");
      const { animationState: M } = this.visualElement;
      M && M.setActive("whileDrag", !0);
    }, u = (b, S) => {
      const { dragPropagation: C, dragDirectionLock: E, onDirectionLock: D, onDrag: M } = this.getProps();
      if (!C && !this.openGlobalLock)
        return;
      const { offset: A } = S;
      if (E && this.currentDirection === null) {
        this.currentDirection = GG(A), this.currentDirection !== null && D && D(this.currentDirection);
        return;
      }
      this.updateAxis("x", S.point, A), this.updateAxis("y", S.point, A), this.visualElement.render(), M && M(b, S);
    }, h = (b, S) => this.stop(b, S), m = () => gs((b) => {
      var S;
      return this.getAnimationState(b) === "paused" && ((S = this.getAxisMotionValue(b).animation) === null || S === void 0 ? void 0 : S.play());
    }), { dragSnapToOrigin: v } = this.getProps();
    this.panSession = new G2(e, {
      onSessionStart: o,
      onStart: f,
      onMove: u,
      onSessionEnd: h,
      resumeAnimation: m
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: v,
      contextWindow: rz(this.visualElement)
    });
  }
  stop(e, i) {
    const a = this.isDragging;
    if (this.cancel(), !a)
      return;
    const { velocity: o } = i;
    this.startAnimation(o);
    const { onDragEnd: f } = this.getProps();
    f && En.postRender(() => f(e, i));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: i } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: a } = this.getProps();
    !a && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), i && i.setActive("whileDrag", !1);
  }
  updateAxis(e, i, a) {
    const { drag: o } = this.getProps();
    if (!a || !ex(e, o, this.currentDirection))
      return;
    const f = this.getAxisMotionValue(e);
    let u = this.originPoint[e] + a[e];
    this.constraints && this.constraints[e] && (u = NG(u, this.constraints[e], this.elastic[e])), f.set(u);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: i, dragElastic: a } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, f = this.constraints;
    i && Qh(i) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : i && o ? this.constraints = zG(o.layoutBox, i) : this.constraints = !1, this.elastic = BG(a), f !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && gs((u) => {
      this.constraints !== !1 && this.getAxisMotionValue(u) && (this.constraints[u] = jG(o.layoutBox[u], this.constraints[u]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: i } = this.getProps();
    if (!e || !Qh(e))
      return !1;
    const a = e.current;
    Ql(a !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: o } = this.visualElement;
    if (!o || !o.layout)
      return !1;
    const f = $G(a, o.root, this.visualElement.getTransformPagePoint());
    let u = FG(o.layout.layoutBox, f);
    if (i) {
      const h = i(HG(u));
      this.hasMutatedConstraints = !!h, h && (u = ez(h));
    }
    return u;
  }
  startAnimation(e) {
    const { drag: i, dragMomentum: a, dragElastic: o, dragTransition: f, dragSnapToOrigin: u, onDragTransitionEnd: h } = this.getProps(), m = this.constraints || {}, v = gs((b) => {
      if (!ex(b, i, this.currentDirection))
        return;
      let S = m && m[b] || {};
      u && (S = { min: 0, max: 0 });
      const C = o ? 200 : 1e6, E = o ? 40 : 1e7, D = {
        type: "inertia",
        velocity: a ? e[b] : 0,
        bounceStiffness: C,
        bounceDamping: E,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...f,
        ...S
      };
      return this.startAxisValueAnimation(b, D);
    });
    return Promise.all(v).then(h);
  }
  startAxisValueAnimation(e, i) {
    const a = this.getAxisMotionValue(e);
    return mE(this.visualElement, e), a.start(S1(e, a, 0, i, this.visualElement, !1));
  }
  stopAnimation() {
    gs((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    gs((e) => {
      var i;
      return (i = this.getAxisMotionValue(e).animation) === null || i === void 0 ? void 0 : i.pause();
    });
  }
  getAnimationState(e) {
    var i;
    return (i = this.getAxisMotionValue(e).animation) === null || i === void 0 ? void 0 : i.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const i = `_drag${e.toUpperCase()}`, a = this.visualElement.getProps(), o = a[i];
    return o || this.visualElement.getValue(e, (a.initial ? a.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    gs((i) => {
      const { drag: a } = this.getProps();
      if (!ex(i, a, this.currentDirection))
        return;
      const { projection: o } = this.visualElement, f = this.getAxisMotionValue(i);
      if (o && o.layout) {
        const { min: u, max: h } = o.layout.layoutBox[i];
        f.set(e[i] - ai(u, h, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: i } = this.getProps(), { projection: a } = this.visualElement;
    if (!Qh(i) || !a || !this.constraints)
      return;
    this.stopAnimation();
    const o = { x: 0, y: 0 };
    gs((u) => {
      const h = this.getAxisMotionValue(u);
      if (h && this.constraints !== !1) {
        const m = h.get();
        o[u] = VG({ min: m, max: m }, this.constraints[u]);
      }
    });
    const { transformTemplate: f } = this.visualElement.getProps();
    this.visualElement.current.style.transform = f ? f({}, "") : "none", a.root && a.root.updateScroll(), a.updateLayout(), this.resolveConstraints(), gs((u) => {
      if (!ex(u, e, null))
        return;
      const h = this.getAxisMotionValue(u), { min: m, max: v } = this.constraints[u];
      h.set(ai(m, v, o[u]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    WG.set(this.visualElement, this);
    const e = this.visualElement.current, i = Kl(e, "pointerdown", (m) => {
      const { drag: v, dragListener: b = !0 } = this.getProps();
      v && b && this.start(m);
    }), a = () => {
      const { dragConstraints: m } = this.getProps();
      Qh(m) && m.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: o } = this.visualElement, f = o.addEventListener("measure", a);
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), En.read(a);
    const u = Wl(window, "resize", () => this.scalePositionWithinConstraints()), h = o.addEventListener("didUpdate", ({ delta: m, hasLayoutChanged: v }) => {
      this.isDragging && v && (gs((b) => {
        const S = this.getAxisMotionValue(b);
        S && (this.originPoint[b] += m[b].translate, S.set(S.get() + m[b].translate));
      }), this.visualElement.render());
    });
    return () => {
      u(), i(), f(), h && h();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: i = !1, dragDirectionLock: a = !1, dragPropagation: o = !1, dragConstraints: f = !1, dragElastic: u = vE, dragMomentum: h = !0 } = e;
    return {
      ...e,
      drag: i,
      dragDirectionLock: a,
      dragPropagation: o,
      dragConstraints: f,
      dragElastic: u,
      dragMomentum: h
    };
  }
}
function ex(t, e, i) {
  return (e === !0 || e === t) && (i === null || i === t);
}
function GG(t, e = 10) {
  let i = null;
  return Math.abs(t.y) > e ? i = "y" : Math.abs(t.x) > e && (i = "x"), i;
}
class KG extends lc {
  constructor(e) {
    super(e), this.removeGroupControls = vr, this.removeListeners = vr, this.controls = new YG(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || vr;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const xP = (t) => (e, i) => {
  t && En.postRender(() => t(e, i));
};
class XG extends lc {
  constructor() {
    super(...arguments), this.removePointerDownListener = vr;
  }
  onPointerDown(e) {
    this.session = new G2(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: rz(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: i, onPan: a, onPanEnd: o } = this.node.getProps();
    return {
      onSessionStart: xP(e),
      onStart: xP(i),
      onMove: a,
      onEnd: (f, u) => {
        delete this.session, o && En.postRender(() => o(f, u));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Kl(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const mS = Io(null);
function QG() {
  const t = ki(mS);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: i, register: a } = t, o = Wx();
  Xn(() => a(o), []);
  const f = CE(() => i && i(o), [o, i]);
  return !e && i ? [!1, f] : [!0];
}
const T1 = Io({}), az = Io({}), vx = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function SP(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const Ig = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (bt.test(t))
        t = parseFloat(t);
      else
        return t;
    const i = SP(t, e.target.x), a = SP(t, e.target.y);
    return `${i}% ${a}%`;
  }
}, qG = {
  correct: (t, { treeScale: e, projectionDelta: i }) => {
    const a = t, o = rc.parse(t);
    if (o.length > 5)
      return a;
    const f = rc.createTransformer(t), u = typeof o[0] != "number" ? 1 : 0, h = i.x.scale * e.x, m = i.y.scale * e.y;
    o[0 + u] /= h, o[1 + u] /= m;
    const v = ai(h, m, 0.5);
    return typeof o[2 + u] == "number" && (o[2 + u] /= v), typeof o[3 + u] == "number" && (o[3 + u] /= v), f(o);
  }
}, Ux = {};
function ZG(t) {
  Object.assign(Ux, t);
}
const { schedule: E1 } = s2(queueMicrotask, !1);
class JG extends TU {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: i, switchLayoutGroup: a, layoutId: o } = this.props, { projection: f } = e;
    ZG(eK), f && (i.group && i.group.add(f), a && a.register && o && a.register(f), f.root.didUpdate(), f.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), f.setOptions({
      ...f.options,
      onExitComplete: () => this.safeToRemove()
    })), vx.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: i, visualElement: a, drag: o, isPresent: f } = this.props, u = a.projection;
    return u && (u.isPresent = f, o || e.layoutDependency !== i || i === void 0 ? u.willUpdate() : this.safeToRemove(), e.isPresent !== f && (f ? u.promote() : u.relegate() || En.postRender(() => {
      const h = u.getStack();
      (!h || !h.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), E1.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: i, switchLayoutGroup: a } = this.props, { projection: o } = e;
    o && (o.scheduleCheckAfterUnmount(), i && i.group && i.group.remove(o), a && a.deregister && a.deregister(o));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function sz(t) {
  const [e, i] = QG(), a = ki(T1);
  return Me.jsx(JG, { ...t, layoutGroup: a, switchLayoutGroup: ki(az), isPresent: e, safeToRemove: i });
}
const eK = {
  borderRadius: {
    ...Ig,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Ig,
  borderTopRightRadius: Ig,
  borderBottomLeftRadius: Ig,
  borderBottomRightRadius: Ig,
  boxShadow: qG
}, oz = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], tK = oz.length, _P = (t) => typeof t == "string" ? parseFloat(t) : t, CP = (t) => typeof t == "number" || bt.test(t);
function nK(t, e, i, a, o, f) {
  o ? (t.opacity = ai(
    0,
    // TODO Reinstate this if only child
    i.opacity !== void 0 ? i.opacity : 1,
    iK(a)
  ), t.opacityExit = ai(e.opacity !== void 0 ? e.opacity : 1, 0, rK(a))) : f && (t.opacity = ai(e.opacity !== void 0 ? e.opacity : 1, i.opacity !== void 0 ? i.opacity : 1, a));
  for (let u = 0; u < tK; u++) {
    const h = `border${oz[u]}Radius`;
    let m = wP(e, h), v = wP(i, h);
    if (m === void 0 && v === void 0)
      continue;
    m || (m = 0), v || (v = 0), m === 0 || v === 0 || CP(m) === CP(v) ? (t[h] = Math.max(ai(_P(m), _P(v), a), 0), (Bo.test(v) || Bo.test(m)) && (t[h] += "%")) : t[h] = v;
  }
  (e.rotate || i.rotate) && (t.rotate = ai(e.rotate || 0, i.rotate || 0, a));
}
function wP(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const iK = /* @__PURE__ */ lz(0, 0.5, h2), rK = /* @__PURE__ */ lz(0.5, 0.95, vr);
function lz(t, e, i) {
  return (a) => a < t ? 0 : a > e ? 1 : i(dp(t, e, a));
}
function TP(t, e) {
  t.min = e.min, t.max = e.max;
}
function ms(t, e) {
  TP(t.x, e.x), TP(t.y, e.y);
}
function EP(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function RP(t, e, i, a, o) {
  return t -= e, t = Hx(t, 1 / i, a), o !== void 0 && (t = Hx(t, 1 / o, a)), t;
}
function aK(t, e = 0, i = 1, a = 0.5, o, f = t, u = t) {
  if (Bo.test(e) && (e = parseFloat(e), e = ai(u.min, u.max, e / 100) - u.min), typeof e != "number")
    return;
  let h = ai(f.min, f.max, a);
  t === f && (h -= e), t.min = RP(t.min, e, i, h, o), t.max = RP(t.max, e, i, h, o);
}
function DP(t, e, [i, a, o], f, u) {
  aK(t, e[i], e[a], e[o], e.scale, f, u);
}
const sK = ["x", "scaleX", "originX"], oK = ["y", "scaleY", "originY"];
function kP(t, e, i, a) {
  DP(t.x, e, sK, i ? i.x : void 0, a ? a.x : void 0), DP(t.y, e, oK, i ? i.y : void 0, a ? a.y : void 0);
}
function MP(t) {
  return t.translate === 0 && t.scale === 1;
}
function uz(t) {
  return MP(t.x) && MP(t.y);
}
function AP(t, e) {
  return t.min === e.min && t.max === e.max;
}
function lK(t, e) {
  return AP(t.x, e.x) && AP(t.y, e.y);
}
function OP(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function cz(t, e) {
  return OP(t.x, e.x) && OP(t.y, e.y);
}
function PP(t) {
  return Wa(t.x) / Wa(t.y);
}
function LP(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class uK {
  constructor() {
    this.members = [];
  }
  add(e) {
    _1(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (C1(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const i = this.members[this.members.length - 1];
      i && this.promote(i);
    }
  }
  relegate(e) {
    const i = this.members.findIndex((o) => e === o);
    if (i === 0)
      return !1;
    let a;
    for (let o = i; o >= 0; o--) {
      const f = this.members[o];
      if (f.isPresent !== !1) {
        a = f;
        break;
      }
    }
    return a ? (this.promote(a), !0) : !1;
  }
  promote(e, i) {
    const a = this.lead;
    if (e !== a && (this.prevLead = a, this.lead = e, e.show(), a)) {
      a.instance && a.scheduleRender(), e.scheduleRender(), e.resumeFrom = a, i && (e.resumeFrom.preserveOpacity = !0), a.snapshot && (e.snapshot = a.snapshot, e.snapshot.latestValues = a.animationValues || a.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: o } = e.options;
      o === !1 && a.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: i, resumingFrom: a } = e;
      i.onExitComplete && i.onExitComplete(), a && a.options.onExitComplete && a.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function cK(t, e, i) {
  let a = "";
  const o = t.x.translate / e.x, f = t.y.translate / e.y, u = (i == null ? void 0 : i.z) || 0;
  if ((o || f || u) && (a = `translate3d(${o}px, ${f}px, ${u}px) `), (e.x !== 1 || e.y !== 1) && (a += `scale(${1 / e.x}, ${1 / e.y}) `), i) {
    const { transformPerspective: v, rotate: b, rotateX: S, rotateY: C, skewX: E, skewY: D } = i;
    v && (a = `perspective(${v}px) ${a}`), b && (a += `rotate(${b}deg) `), S && (a += `rotateX(${S}deg) `), C && (a += `rotateY(${C}deg) `), E && (a += `skewX(${E}deg) `), D && (a += `skewY(${D}deg) `);
  }
  const h = t.x.scale * e.x, m = t.y.scale * e.y;
  return (h !== 1 || m !== 1) && (a += `scale(${h}, ${m})`), a || "none";
}
const fK = (t, e) => t.depth - e.depth;
class dK {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    _1(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    C1(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(fK), this.isDirty = !1, this.children.forEach(e);
  }
}
function yx(t) {
  const e = Vr(t) ? t.get() : t;
  return iG(e) ? e.toValue() : e;
}
function hK(t, e) {
  const i = Ho.now(), a = ({ timestamp: o }) => {
    const f = o - i;
    f >= e && (nc(a), t(f - e));
  };
  return En.read(a, !0), () => nc(a);
}
function pK(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
function mK(t, e, i) {
  const a = Vr(t) ? t : Ev(t);
  return a.start(S1("", a, e, i)), a.animation;
}
const zf = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, qg = typeof window < "u" && window.MotionDebug !== void 0, bT = ["", "X", "Y", "Z"], gK = { visibility: "hidden" }, NP = 1e3;
let vK = 0;
function xT(t, e, i, a) {
  const { latestValues: o } = e;
  o[t] && (i[t] = o[t], e.setStaticValue(t, 0), a && (a[t] = 0));
}
function fz(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const i = I2(e);
  if (window.MotionHasOptimisedAnimation(i, "transform")) {
    const { layout: o, layoutId: f } = t.options;
    window.MotionCancelOptimisedAnimation(i, "transform", En, !(o || f));
  }
  const { parent: a } = t;
  a && !a.hasCheckedOptimisedAppear && fz(a);
}
function dz({ attachResizeListener: t, defaultParent: e, measureScroll: i, checkIsScrollRoot: a, resetTransform: o }) {
  return class {
    constructor(u = {}, h = e == null ? void 0 : e()) {
      this.id = vK++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, qg && (zf.totalNodes = zf.resolvedTargetDeltas = zf.recalculatedProjection = 0), this.nodes.forEach(xK), this.nodes.forEach(TK), this.nodes.forEach(EK), this.nodes.forEach(SK), qg && window.MotionDebug.record(zf);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = u, this.root = h ? h.root || h : this, this.path = h ? [...h.path, h] : [], this.parent = h, this.depth = h ? h.depth + 1 : 0;
      for (let m = 0; m < this.path.length; m++)
        this.path[m].shouldResetTransform = !0;
      this.root === this && (this.nodes = new dK());
    }
    addEventListener(u, h) {
      return this.eventHandlers.has(u) || this.eventHandlers.set(u, new w1()), this.eventHandlers.get(u).add(h);
    }
    notifyListeners(u, ...h) {
      const m = this.eventHandlers.get(u);
      m && m.notify(...h);
    }
    hasListeners(u) {
      return this.eventHandlers.has(u);
    }
    /**
     * Lifecycles
     */
    mount(u, h = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = pK(u), this.instance = u;
      const { layoutId: m, layout: v, visualElement: b } = this.options;
      if (b && !b.current && b.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), h && (v || m) && (this.isLayoutDirty = !0), t) {
        let S;
        const C = () => this.root.updateBlockedByResize = !1;
        t(u, () => {
          this.root.updateBlockedByResize = !0, S && S(), S = hK(C, 250), vx.hasAnimatedSinceResize && (vx.hasAnimatedSinceResize = !1, this.nodes.forEach(FP));
        });
      }
      m && this.root.registerSharedNode(m, this), this.options.animate !== !1 && b && (m || v) && this.addEventListener("didUpdate", ({ delta: S, hasLayoutChanged: C, hasRelativeTargetChanged: E, layout: D }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const M = this.options.transition || b.getDefaultTransition() || AK, { onLayoutAnimationStart: A, onLayoutAnimationComplete: P } = b.getProps(), N = !this.targetLayout || !cz(this.targetLayout, D) || E, F = !C && E;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || F || C && (N || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(S, F);
          const B = {
            ...o1(M, "layout"),
            onPlay: A,
            onComplete: P
          };
          (b.shouldReduceMotion || this.options.layoutRoot) && (B.delay = 0, B.type = !1), this.startAnimation(B);
        } else
          C || FP(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = D;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const u = this.getStack();
      u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, nc(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(RK), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: u } = this.options;
      return u && u.getProps().transformTemplate;
    }
    willUpdate(u = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && fz(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let b = 0; b < this.path.length; b++) {
        const S = this.path[b];
        S.shouldResetTransform = !0, S.updateScroll("snapshot"), S.options.layoutRoot && S.willUpdate(!1);
      }
      const { layoutId: h, layout: m } = this.options;
      if (h === void 0 && !m)
        return;
      const v = this.getTransformTemplate();
      this.prevTransformTemplateValue = v ? v(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(zP);
        return;
      }
      this.isUpdating || this.nodes.forEach(CK), this.isUpdating = !1, this.nodes.forEach(wK), this.nodes.forEach(yK), this.nodes.forEach(bK), this.clearAllSnapshots();
      const h = Ho.now();
      gr.delta = ic(0, 1e3 / 60, h - gr.timestamp), gr.timestamp = h, gr.isProcessing = !0, dT.update.process(gr), dT.preRender.process(gr), dT.render.process(gr), gr.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, E1.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(_K), this.sharedNodes.forEach(DK);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, En.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      En.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let m = 0; m < this.path.length; m++)
          this.path[m].updateScroll();
      const u = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = _i(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: h } = this.options;
      h && h.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0);
    }
    updateScroll(u = "measure") {
      let h = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (h = !1), h) {
        const m = a(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: u,
          isRoot: m,
          offset: i(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : m
        };
      }
    }
    resetTransform() {
      if (!o)
        return;
      const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, h = this.projectionDelta && !uz(this.projectionDelta), m = this.getTransformTemplate(), v = m ? m(this.latestValues, "") : void 0, b = v !== this.prevTransformTemplateValue;
      u && (h || Nf(this.latestValues) || b) && (o(this.instance, v), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(u = !0) {
      const h = this.measurePageBox();
      let m = this.removeElementScroll(h);
      return u && (m = this.removeTransform(m)), OK(m), {
        animationId: this.root.animationId,
        measuredBox: h,
        layoutBox: m,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var u;
      const { visualElement: h } = this.options;
      if (!h)
        return _i();
      const m = h.measureViewportBox();
      if (!(((u = this.scroll) === null || u === void 0 ? void 0 : u.wasRoot) || this.path.some(PK))) {
        const { scroll: b } = this.root;
        b && (Zh(m.x, b.offset.x), Zh(m.y, b.offset.y));
      }
      return m;
    }
    removeElementScroll(u) {
      var h;
      const m = _i();
      if (ms(m, u), !((h = this.scroll) === null || h === void 0) && h.wasRoot)
        return m;
      for (let v = 0; v < this.path.length; v++) {
        const b = this.path[v], { scroll: S, options: C } = b;
        b !== this.root && S && C.layoutScroll && (S.wasRoot && ms(m, u), Zh(m.x, S.offset.x), Zh(m.y, S.offset.y));
      }
      return m;
    }
    applyTransform(u, h = !1) {
      const m = _i();
      ms(m, u);
      for (let v = 0; v < this.path.length; v++) {
        const b = this.path[v];
        !h && b.options.layoutScroll && b.scroll && b !== b.root && Jh(m, {
          x: -b.scroll.offset.x,
          y: -b.scroll.offset.y
        }), Nf(b.latestValues) && Jh(m, b.latestValues);
      }
      return Nf(this.latestValues) && Jh(m, this.latestValues), m;
    }
    removeTransform(u) {
      const h = _i();
      ms(h, u);
      for (let m = 0; m < this.path.length; m++) {
        const v = this.path[m];
        if (!v.instance || !Nf(v.latestValues))
          continue;
        yE(v.latestValues) && v.updateSnapshot();
        const b = _i(), S = v.measurePageBox();
        ms(b, S), kP(h, v.latestValues, v.snapshot ? v.snapshot.layoutBox : void 0, b);
      }
      return Nf(this.latestValues) && kP(h, this.latestValues), h;
    }
    setTargetDelta(u) {
      this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(u) {
      this.options = {
        ...this.options,
        ...u,
        crossfade: u.crossfade !== void 0 ? u.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== gr.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(u = !1) {
      var h;
      const m = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = m.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = m.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = m.isSharedProjectionDirty);
      const v = !!this.resumingFrom || this !== m;
      if (!(u || v && this.isSharedProjectionDirty || this.isProjectionDirty || !((h = this.parent) === null || h === void 0) && h.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: S, layoutId: C } = this.options;
      if (!(!this.layout || !(S || C))) {
        if (this.resolvedRelativeTargetAt = gr.timestamp, !this.targetDelta && !this.relativeTarget) {
          const E = this.getClosestProjectingParent();
          E && E.layout && this.animationProgress !== 1 ? (this.relativeParent = E, this.forceRelativeParentToResolveTarget(), this.relativeTarget = _i(), this.relativeTargetOrigin = _i(), sv(this.relativeTargetOrigin, this.layout.layoutBox, E.layout.layoutBox), ms(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = _i(), this.targetWithTransforms = _i()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), LG(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : ms(this.target, this.layout.layoutBox), nz(this.target, this.targetDelta)) : ms(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const E = this.getClosestProjectingParent();
            E && !!E.resumingFrom == !!this.resumingFrom && !E.options.layoutScroll && E.target && this.animationProgress !== 1 ? (this.relativeParent = E, this.forceRelativeParentToResolveTarget(), this.relativeTarget = _i(), this.relativeTargetOrigin = _i(), sv(this.relativeTargetOrigin, this.target, E.target), ms(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          qg && zf.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || yE(this.parent.latestValues) || tz(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var u;
      const h = this.getLead(), m = !!this.resumingFrom || this !== h;
      let v = !0;
      if ((this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty) && (v = !1), m && (this.isSharedProjectionDirty || this.isTransformDirty) && (v = !1), this.resolvedRelativeTargetAt === gr.timestamp && (v = !1), v)
        return;
      const { layout: b, layoutId: S } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(b || S))
        return;
      ms(this.layoutCorrected, this.layout.layoutBox);
      const C = this.treeScale.x, E = this.treeScale.y;
      IG(this.layoutCorrected, this.treeScale, this.path, m), h.layout && !h.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (h.target = h.layout.layoutBox, h.targetWithTransforms = _i());
      const { target: D } = h;
      if (!D) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (EP(this.prevProjectionDelta.x, this.projectionDelta.x), EP(this.prevProjectionDelta.y, this.projectionDelta.y)), av(this.projectionDelta, this.layoutCorrected, D, this.latestValues), (this.treeScale.x !== C || this.treeScale.y !== E || !LP(this.projectionDelta.x, this.prevProjectionDelta.x) || !LP(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", D)), qg && zf.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(u = !0) {
      var h;
      if ((h = this.options.visualElement) === null || h === void 0 || h.scheduleRender(), u) {
        const m = this.getStack();
        m && m.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = qh(), this.projectionDelta = qh(), this.projectionDeltaWithTransform = qh();
    }
    setAnimationOrigin(u, h = !1) {
      const m = this.snapshot, v = m ? m.latestValues : {}, b = { ...this.latestValues }, S = qh();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !h;
      const C = _i(), E = m ? m.source : void 0, D = this.layout ? this.layout.source : void 0, M = E !== D, A = this.getStack(), P = !A || A.members.length <= 1, N = !!(M && !P && this.options.crossfade === !0 && !this.path.some(MK));
      this.animationProgress = 0;
      let F;
      this.mixTargetDelta = (B) => {
        const V = B / 1e3;
        VP(S.x, u.x, V), VP(S.y, u.y, V), this.setTargetDelta(S), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (sv(C, this.layout.layoutBox, this.relativeParent.layout.layoutBox), kK(this.relativeTarget, this.relativeTargetOrigin, C, V), F && lK(this.relativeTarget, F) && (this.isProjectionDirty = !1), F || (F = _i()), ms(F, this.relativeTarget)), M && (this.animationValues = b, nK(b, v, this.latestValues, V, N, P)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = V;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(u) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (nc(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = En.update(() => {
        vx.hasAnimatedSinceResize = !0, this.currentAnimation = mK(0, NP, {
          ...u,
          onUpdate: (h) => {
            this.mixTargetDelta(h), u.onUpdate && u.onUpdate(h);
          },
          onComplete: () => {
            u.onComplete && u.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const u = this.getStack();
      u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(NP), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const u = this.getLead();
      let { targetWithTransforms: h, target: m, layout: v, latestValues: b } = u;
      if (!(!h || !m || !v)) {
        if (this !== u && this.layout && v && hz(this.options.animationType, this.layout.layoutBox, v.layoutBox)) {
          m = this.target || _i();
          const S = Wa(this.layout.layoutBox.x);
          m.x.min = u.target.x.min, m.x.max = m.x.min + S;
          const C = Wa(this.layout.layoutBox.y);
          m.y.min = u.target.y.min, m.y.max = m.y.min + C;
        }
        ms(h, m), Jh(h, b), av(this.projectionDeltaWithTransform, this.layoutCorrected, h, b);
      }
    }
    registerSharedNode(u, h) {
      this.sharedNodes.has(u) || this.sharedNodes.set(u, new uK()), this.sharedNodes.get(u).add(h);
      const v = h.options.initialPromotionConfig;
      h.promote({
        transition: v ? v.transition : void 0,
        preserveFollowOpacity: v && v.shouldPreserveFollowOpacity ? v.shouldPreserveFollowOpacity(h) : void 0
      });
    }
    isLead() {
      const u = this.getStack();
      return u ? u.lead === this : !0;
    }
    getLead() {
      var u;
      const { layoutId: h } = this.options;
      return h ? ((u = this.getStack()) === null || u === void 0 ? void 0 : u.lead) || this : this;
    }
    getPrevLead() {
      var u;
      const { layoutId: h } = this.options;
      return h ? (u = this.getStack()) === null || u === void 0 ? void 0 : u.prevLead : void 0;
    }
    getStack() {
      const { layoutId: u } = this.options;
      if (u)
        return this.root.sharedNodes.get(u);
    }
    promote({ needsReset: u, transition: h, preserveFollowOpacity: m } = {}) {
      const v = this.getStack();
      v && v.promote(this, m), u && (this.projectionDelta = void 0, this.needsReset = !0), h && this.setOptions({ transition: h });
    }
    relegate() {
      const u = this.getStack();
      return u ? u.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: u } = this.options;
      if (!u)
        return;
      let h = !1;
      const { latestValues: m } = u;
      if ((m.z || m.rotate || m.rotateX || m.rotateY || m.rotateZ || m.skewX || m.skewY) && (h = !0), !h)
        return;
      const v = {};
      m.z && xT("z", u, v, this.animationValues);
      for (let b = 0; b < bT.length; b++)
        xT(`rotate${bT[b]}`, u, v, this.animationValues), xT(`skew${bT[b]}`, u, v, this.animationValues);
      u.render();
      for (const b in v)
        u.setStaticValue(b, v[b]), this.animationValues && (this.animationValues[b] = v[b]);
      u.scheduleRender();
    }
    getProjectionStyles(u) {
      var h, m;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return gK;
      const v = {
        visibility: ""
      }, b = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, v.opacity = "", v.pointerEvents = yx(u == null ? void 0 : u.pointerEvents) || "", v.transform = b ? b(this.latestValues, "") : "none", v;
      const S = this.getLead();
      if (!this.projectionDelta || !this.layout || !S.target) {
        const M = {};
        return this.options.layoutId && (M.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, M.pointerEvents = yx(u == null ? void 0 : u.pointerEvents) || ""), this.hasProjected && !Nf(this.latestValues) && (M.transform = b ? b({}, "") : "none", this.hasProjected = !1), M;
      }
      const C = S.animationValues || S.latestValues;
      this.applyTransformsToTarget(), v.transform = cK(this.projectionDeltaWithTransform, this.treeScale, C), b && (v.transform = b(C, v.transform));
      const { x: E, y: D } = this.projectionDelta;
      v.transformOrigin = `${E.origin * 100}% ${D.origin * 100}% 0`, S.animationValues ? v.opacity = S === this ? (m = (h = C.opacity) !== null && h !== void 0 ? h : this.latestValues.opacity) !== null && m !== void 0 ? m : 1 : this.preserveOpacity ? this.latestValues.opacity : C.opacityExit : v.opacity = S === this ? C.opacity !== void 0 ? C.opacity : "" : C.opacityExit !== void 0 ? C.opacityExit : 0;
      for (const M in Ux) {
        if (C[M] === void 0)
          continue;
        const { correct: A, applyTo: P } = Ux[M], N = v.transform === "none" ? C[M] : A(C[M], S);
        if (P) {
          const F = P.length;
          for (let B = 0; B < F; B++)
            v[P[B]] = N;
        } else
          v[M] = N;
      }
      return this.options.layoutId && (v.pointerEvents = S === this ? yx(u == null ? void 0 : u.pointerEvents) || "" : "none"), v;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((u) => {
        var h;
        return (h = u.currentAnimation) === null || h === void 0 ? void 0 : h.stop();
      }), this.root.nodes.forEach(zP), this.root.sharedNodes.clear();
    }
  };
}
function yK(t) {
  t.updateLayout();
}
function bK(t) {
  var e;
  const i = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && i && t.hasListeners("didUpdate")) {
    const { layoutBox: a, measuredBox: o } = t.layout, { animationType: f } = t.options, u = i.source !== t.layout.source;
    f === "size" ? gs((S) => {
      const C = u ? i.measuredBox[S] : i.layoutBox[S], E = Wa(C);
      C.min = a[S].min, C.max = C.min + E;
    }) : hz(f, i.layoutBox, a) && gs((S) => {
      const C = u ? i.measuredBox[S] : i.layoutBox[S], E = Wa(a[S]);
      C.max = C.min + E, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[S].max = t.relativeTarget[S].min + E);
    });
    const h = qh();
    av(h, a, i.layoutBox);
    const m = qh();
    u ? av(m, t.applyTransform(o, !0), i.measuredBox) : av(m, a, i.layoutBox);
    const v = !uz(h);
    let b = !1;
    if (!t.resumeFrom) {
      const S = t.getClosestProjectingParent();
      if (S && !S.resumeFrom) {
        const { snapshot: C, layout: E } = S;
        if (C && E) {
          const D = _i();
          sv(D, i.layoutBox, C.layoutBox);
          const M = _i();
          sv(M, a, E.layoutBox), cz(D, M) || (b = !0), S.options.layoutRoot && (t.relativeTarget = M, t.relativeTargetOrigin = D, t.relativeParent = S);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: a,
      snapshot: i,
      delta: m,
      layoutDelta: h,
      hasLayoutChanged: v,
      hasRelativeTargetChanged: b
    });
  } else if (t.isLead()) {
    const { onExitComplete: a } = t.options;
    a && a();
  }
  t.options.transition = void 0;
}
function xK(t) {
  qg && zf.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function SK(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function _K(t) {
  t.clearSnapshot();
}
function zP(t) {
  t.clearMeasurements();
}
function CK(t) {
  t.isLayoutDirty = !1;
}
function wK(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function FP(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function TK(t) {
  t.resolveTargetDelta();
}
function EK(t) {
  t.calcProjection();
}
function RK(t) {
  t.resetSkewAndRotation();
}
function DK(t) {
  t.removeLeadSnapshot();
}
function VP(t, e, i) {
  t.translate = ai(e.translate, 0, i), t.scale = ai(e.scale, 1, i), t.origin = e.origin, t.originPoint = e.originPoint;
}
function jP(t, e, i, a) {
  t.min = ai(e.min, i.min, a), t.max = ai(e.max, i.max, a);
}
function kK(t, e, i, a) {
  jP(t.x, e.x, i.x, a), jP(t.y, e.y, i.y, a);
}
function MK(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const AK = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, BP = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), HP = BP("applewebkit/") && !BP("chrome/") ? Math.round : vr;
function UP(t) {
  t.min = HP(t.min), t.max = HP(t.max);
}
function OK(t) {
  UP(t.x), UP(t.y);
}
function hz(t, e, i) {
  return t === "position" || t === "preserve-aspect" && !PG(PP(e), PP(i), 0.2);
}
function PK(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const LK = dz({
  attachResizeListener: (t, e) => Wl(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), ST = {
  current: void 0
}, pz = dz({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!ST.current) {
      const t = new LK({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), ST.current = t;
    }
    return ST.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), NK = {
  pan: {
    Feature: XG
  },
  drag: {
    Feature: KG,
    ProjectionNode: pz,
    MeasureLayout: sz
  }
};
function IP(t, e) {
  const i = e ? "pointerenter" : "pointerleave", a = e ? "onHoverStart" : "onHoverEnd", o = (f, u) => {
    if (f.pointerType === "touch" || q2())
      return;
    const h = t.getProps();
    t.animationState && h.whileHover && t.animationState.setActive("whileHover", e);
    const m = h[a];
    m && En.postRender(() => m(f, u));
  };
  return Kl(t.current, i, o, {
    passive: !t.getProps()[a]
  });
}
class zK extends lc {
  mount() {
    this.unmount = Gl(IP(this.node, !0), IP(this.node, !1));
  }
  unmount() {
  }
}
class FK extends lc {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Gl(Wl(this.node.current, "focus", () => this.onFocus()), Wl(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const mz = (t, e) => e ? t === e ? !0 : mz(t, e.parentElement) : !1;
function _T(t, e) {
  if (!e)
    return;
  const i = new PointerEvent("pointer" + t);
  e(i, pS(i));
}
class VK extends lc {
  constructor() {
    super(...arguments), this.removeStartListeners = vr, this.removeEndListeners = vr, this.removeAccessibleListeners = vr, this.startPointerPress = (e, i) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const a = this.node.getProps(), f = Kl(window, "pointerup", (h, m) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: v, onTapCancel: b, globalTapTarget: S } = this.node.getProps(), C = !S && !mz(this.node.current, h.target) ? b : v;
        C && En.update(() => C(h, m));
      }, {
        passive: !(a.onTap || a.onPointerUp)
      }), u = Kl(window, "pointercancel", (h, m) => this.cancelPress(h, m), {
        passive: !(a.onTapCancel || a.onPointerCancel)
      });
      this.removeEndListeners = Gl(f, u), this.startPress(e, i);
    }, this.startAccessiblePress = () => {
      const e = (f) => {
        if (f.key !== "Enter" || this.isPressing)
          return;
        const u = (h) => {
          h.key !== "Enter" || !this.checkPressEnd() || _T("up", (m, v) => {
            const { onTap: b } = this.node.getProps();
            b && En.postRender(() => b(m, v));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Wl(this.node.current, "keyup", u), _T("down", (h, m) => {
          this.startPress(h, m);
        });
      }, i = Wl(this.node.current, "keydown", e), a = () => {
        this.isPressing && _T("cancel", (f, u) => this.cancelPress(f, u));
      }, o = Wl(this.node.current, "blur", a);
      this.removeAccessibleListeners = Gl(i, o);
    };
  }
  startPress(e, i) {
    this.isPressing = !0;
    const { onTapStart: a, whileTap: o } = this.node.getProps();
    o && this.node.animationState && this.node.animationState.setActive("whileTap", !0), a && En.postRender(() => a(e, i));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !q2();
  }
  cancelPress(e, i) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: a } = this.node.getProps();
    a && En.postRender(() => a(e, i));
  }
  mount() {
    const e = this.node.getProps(), i = Kl(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(e.onTapStart || e.onPointerStart)
    }), a = Wl(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Gl(i, a);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const xE = /* @__PURE__ */ new WeakMap(), CT = /* @__PURE__ */ new WeakMap(), jK = (t) => {
  const e = xE.get(t.target);
  e && e(t);
}, BK = (t) => {
  t.forEach(jK);
};
function HK({ root: t, ...e }) {
  const i = t || document;
  CT.has(i) || CT.set(i, {});
  const a = CT.get(i), o = JSON.stringify(e);
  return a[o] || (a[o] = new IntersectionObserver(BK, { root: t, ...e })), a[o];
}
function UK(t, e, i) {
  const a = HK(e);
  return xE.set(t, i), a.observe(t), () => {
    xE.delete(t), a.unobserve(t);
  };
}
const IK = {
  some: 0,
  all: 1
};
class $K extends lc {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: i, margin: a, amount: o = "some", once: f } = e, u = {
      root: i ? i.current : void 0,
      rootMargin: a,
      threshold: typeof o == "number" ? o : IK[o]
    }, h = (m) => {
      const { isIntersecting: v } = m;
      if (this.isInView === v || (this.isInView = v, f && !v && this.hasEnteredView))
        return;
      v && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", v);
      const { onViewportEnter: b, onViewportLeave: S } = this.node.getProps(), C = v ? b : S;
      C && C(m);
    };
    return UK(this.node.current, u, h);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: i } = this.node;
    ["amount", "margin", "root"].some(WK(e, i)) && this.startObserver();
  }
  unmount() {
  }
}
function WK({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (i) => t[i] !== e[i];
}
const YK = {
  inView: {
    Feature: $K
  },
  tap: {
    Feature: VK
  },
  focus: {
    Feature: FK
  },
  hover: {
    Feature: zK
  }
}, GK = {
  layout: {
    ProjectionNode: pz,
    MeasureLayout: sz
  }
}, R1 = Io({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), gS = Io({}), D1 = typeof window < "u", gz = D1 ? EU : Xn, vz = Io({ strict: !1 });
function KK(t, e, i, a, o) {
  var f, u;
  const { visualElement: h } = ki(gS), m = ki(vz), v = ki(mS), b = ki(R1).reducedMotion, S = Sn();
  a = a || m.renderer, !S.current && a && (S.current = a(t, {
    visualState: e,
    parent: h,
    props: i,
    presenceContext: v,
    blockInitialAnimation: v ? v.initial === !1 : !1,
    reducedMotionConfig: b
  }));
  const C = S.current, E = ki(az);
  C && !C.projection && o && (C.type === "html" || C.type === "svg") && XK(S.current, i, o, E), qP(() => {
    C && C.update(i, v);
  });
  const D = i[U2], M = Sn(!!D && !(!((f = window.MotionHandoffIsComplete) === null || f === void 0) && f.call(window, D)) && ((u = window.MotionHasOptimisedAnimation) === null || u === void 0 ? void 0 : u.call(window, D)));
  return gz(() => {
    C && (window.MotionIsMounted = !0, C.updateFeatures(), E1.render(C.render), M.current && C.animationState && C.animationState.animateChanges());
  }), Xn(() => {
    C && (!M.current && C.animationState && C.animationState.animateChanges(), M.current && (queueMicrotask(() => {
      var A;
      (A = window.MotionHandoffMarkAsComplete) === null || A === void 0 || A.call(window, D);
    }), M.current = !1));
  }), C;
}
function XK(t, e, i, a) {
  const { layoutId: o, layout: f, drag: u, dragConstraints: h, layoutScroll: m, layoutRoot: v } = e;
  t.projection = new i(t.latestValues, e["data-framer-portal-id"] ? void 0 : yz(t.parent)), t.projection.setOptions({
    layoutId: o,
    layout: f,
    alwaysMeasureLayout: !!u || h && Qh(h),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof f == "string" ? f : "both",
    initialPromotionConfig: a,
    layoutScroll: m,
    layoutRoot: v
  });
}
function yz(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : yz(t.parent);
}
function QK(t, e, i) {
  return CE(
    (a) => {
      a && t.mount && t.mount(a), e && (a ? e.mount(a) : e.unmount()), i && (typeof i == "function" ? i(a) : Qh(i) && (i.current = a));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function vS(t) {
  return _v(t.animate) || s1.some((e) => Cv(t[e]));
}
function bz(t) {
  return !!(vS(t) || t.variants);
}
function qK(t, e) {
  if (vS(t)) {
    const { initial: i, animate: a } = t;
    return {
      initial: i === !1 || Cv(i) ? i : void 0,
      animate: Cv(a) ? a : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function ZK(t) {
  const { initial: e, animate: i } = qK(t, ki(gS));
  return Xs(() => ({ initial: e, animate: i }), [$P(e), $P(i)]);
}
function $P(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const WP = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, hp = {};
for (const t in WP)
  hp[t] = {
    isEnabled: (e) => WP[t].some((i) => !!e[i])
  };
function JK(t) {
  for (const e in t)
    hp[e] = {
      ...hp[e],
      ...t[e]
    };
}
const eX = Symbol.for("motionComponentSymbol");
function tX({ preloadedFeatures: t, createVisualElement: e, useRender: i, useVisualState: a, Component: o }) {
  t && JK(t);
  function f(h, m) {
    let v;
    const b = {
      ...ki(R1),
      ...h,
      layoutId: nX(h)
    }, { isStatic: S } = b, C = ZK(h), E = a(h, S);
    if (!S && D1) {
      iX(b, t);
      const D = rX(b);
      v = D.MeasureLayout, C.visualElement = KK(o, E, b, e, D.ProjectionNode);
    }
    return Me.jsxs(gS.Provider, { value: C, children: [v && C.visualElement ? Me.jsx(v, { visualElement: C.visualElement, ...b }) : null, i(o, h, QK(E, C.visualElement, m), E, S, C.visualElement)] });
  }
  const u = pp(f);
  return u[eX] = o, u;
}
function nX({ layoutId: t }) {
  const e = ki(T1).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function iX(t, e) {
  const i = ki(vz).strict;
  if (process.env.NODE_ENV !== "production" && e && i) {
    const a = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? vp(!1, a) : Ql(!1, a);
  }
}
function rX(t) {
  const { drag: e, layout: i } = hp;
  if (!e && !i)
    return {};
  const a = { ...e, ...i };
  return {
    MeasureLayout: e != null && e.isEnabled(t) || i != null && i.isEnabled(t) ? a.MeasureLayout : void 0,
    ProjectionNode: a.ProjectionNode
  };
}
const aX = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function k1(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(aX.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function xz(t, { style: e, vars: i }, a, o) {
  Object.assign(t.style, e, o && o.getProjectionStyles(a));
  for (const f in i)
    t.style.setProperty(f, i[f]);
}
const Sz = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function _z(t, e, i, a) {
  xz(t, e, void 0, a);
  for (const o in e.attrs)
    t.setAttribute(Sz.has(o) ? o : hS(o), e.attrs[o]);
}
function Cz(t, { layout: e, layoutId: i }) {
  return oc.has(t) || t.startsWith("origin") || (e || i !== void 0) && (!!Ux[t] || t === "opacity");
}
function M1(t, e, i) {
  var a;
  const { style: o } = t, f = {};
  for (const u in o)
    (Vr(o[u]) || e.style && Vr(e.style[u]) || Cz(u, t) || ((a = i == null ? void 0 : i.getValue(u)) === null || a === void 0 ? void 0 : a.liveStyle) !== void 0) && (f[u] = o[u]);
  return i && o && typeof o.willChange == "string" && (i.applyWillChange = !1), f;
}
function wz(t, e, i) {
  const a = M1(t, e, i);
  for (const o in t)
    if (Vr(t[o]) || Vr(e[o])) {
      const f = Ov.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
      a[f] = t[o];
    }
  return a;
}
function A1(t) {
  const e = Sn(null);
  return e.current === null && (e.current = t()), e.current;
}
function sX(t) {
  if (oc.has(t))
    return "transform";
  if (V2.has(t))
    return hS(t);
}
function oX({ applyWillChange: t = !1, scrapeMotionValuesFromProps: e, createRenderState: i, onMount: a }, o, f, u, h) {
  const m = {
    latestValues: lX(o, f, u, h ? !1 : t, e),
    renderState: i()
  };
  return a && (m.mount = (v) => a(o, v, m)), m;
}
const Tz = (t) => (e, i) => {
  const a = ki(gS), o = ki(mS), f = () => oX(t, e, a, o, i);
  return i ? f() : A1(f);
};
function YP(t, e, i) {
  const a = Array.isArray(e) ? e : [e];
  for (let o = 0; o < a.length; o++) {
    const f = r1(t, a[o]);
    if (f) {
      const { transitionEnd: u, transition: h, ...m } = f;
      i(m, u);
    }
  }
}
function lX(t, e, i, a, o) {
  var f;
  const u = {}, h = /* @__PURE__ */ new Set(), m = a && ((f = t.style) === null || f === void 0 ? void 0 : f.willChange) === void 0, v = o(t, {});
  for (const A in v)
    u[A] = yx(v[A]);
  let { initial: b, animate: S } = t;
  const C = vS(t), E = bz(t);
  e && E && !C && t.inherit !== !1 && (b === void 0 && (b = e.initial), S === void 0 && (S = e.animate));
  let D = i ? i.initial === !1 : !1;
  D = D || b === !1;
  const M = D ? S : b;
  return M && typeof M != "boolean" && !_v(M) && YP(t, M, (A, P) => {
    for (const N in A) {
      let F = A[N];
      if (Array.isArray(F)) {
        const B = D ? F.length - 1 : 0;
        F = F[B];
      }
      F !== null && (u[N] = F);
    }
    for (const N in P)
      u[N] = P[N];
  }), m && (S && b !== !1 && !_v(S) && YP(t, S, (A) => {
    for (const P in A) {
      const N = sX(P);
      N && h.add(N);
    }
  }), h.size && (u.willChange = Array.from(h).join(","))), u;
}
const O1 = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), Ez = () => ({
  ...O1(),
  attrs: {}
}), Rz = (t, e) => e && typeof t == "number" ? e.transform(t) : t, uX = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, cX = Ov.length;
function fX(t, e, i) {
  let a = "", o = !0;
  for (let f = 0; f < cX; f++) {
    const u = Ov[f], h = t[u];
    if (h === void 0)
      continue;
    let m = !0;
    if (typeof h == "number" ? m = h === (u.startsWith("scale") ? 1 : 0) : m = parseFloat(h) === 0, !m || i) {
      const v = Rz(h, p1[u]);
      if (!m) {
        o = !1;
        const b = uX[u] || u;
        a += `${b}(${v}) `;
      }
      i && (e[u] = v);
    }
  }
  return a = a.trim(), i ? a = i(e, o ? "" : a) : o && (a = "none"), a;
}
function P1(t, e, i) {
  const { style: a, vars: o, transformOrigin: f } = t;
  let u = !1, h = !1;
  for (const m in e) {
    const v = e[m];
    if (oc.has(m)) {
      u = !0;
      continue;
    } else if (y2(m)) {
      o[m] = v;
      continue;
    } else {
      const b = Rz(v, p1[m]);
      m.startsWith("origin") ? (h = !0, f[m] = b) : a[m] = b;
    }
  }
  if (e.transform || (u || i ? a.transform = fX(e, t.transform, i) : a.transform && (a.transform = "none")), h) {
    const { originX: m = "50%", originY: v = "50%", originZ: b = 0 } = f;
    a.transformOrigin = `${m} ${v} ${b}`;
  }
}
function GP(t, e, i) {
  return typeof t == "string" ? t : bt.transform(e + i * t);
}
function dX(t, e, i) {
  const a = GP(e, t.x, t.width), o = GP(i, t.y, t.height);
  return `${a} ${o}`;
}
const hX = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, pX = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function mX(t, e, i = 1, a = 0, o = !0) {
  t.pathLength = 1;
  const f = o ? hX : pX;
  t[f.offset] = bt.transform(-a);
  const u = bt.transform(e), h = bt.transform(i);
  t[f.array] = `${u} ${h}`;
}
function L1(t, {
  attrX: e,
  attrY: i,
  attrScale: a,
  originX: o,
  originY: f,
  pathLength: u,
  pathSpacing: h = 1,
  pathOffset: m = 0,
  // This is object creation, which we try to avoid per-frame.
  ...v
}, b, S) {
  if (P1(t, v, S), b) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: C, style: E, dimensions: D } = t;
  C.transform && (D && (E.transform = C.transform), delete C.transform), D && (o !== void 0 || f !== void 0 || E.transform) && (E.transformOrigin = dX(D, o !== void 0 ? o : 0.5, f !== void 0 ? f : 0.5)), e !== void 0 && (C.x = e), i !== void 0 && (C.y = i), a !== void 0 && (C.scale = a), u !== void 0 && mX(C, u, h, m, !1);
}
const N1 = (t) => typeof t == "string" && t.toLowerCase() === "svg", gX = {
  useVisualState: Tz({
    scrapeMotionValuesFromProps: wz,
    createRenderState: Ez,
    onMount: (t, e, { renderState: i, latestValues: a }) => {
      En.read(() => {
        try {
          i.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          i.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), En.render(() => {
        L1(i, a, N1(e.tagName), t.transformTemplate), _z(e, i);
      });
    }
  })
}, vX = {
  useVisualState: Tz({
    applyWillChange: !0,
    scrapeMotionValuesFromProps: M1,
    createRenderState: O1
  })
};
function Dz(t, e, i) {
  for (const a in e)
    !Vr(e[a]) && !Cz(a, i) && (t[a] = e[a]);
}
function yX({ transformTemplate: t }, e) {
  return Xs(() => {
    const i = O1();
    return P1(i, e, t), Object.assign({}, i.vars, i.style);
  }, [e]);
}
function bX(t, e) {
  const i = t.style || {}, a = {};
  return Dz(a, i, t), Object.assign(a, yX(t, e)), a;
}
function xX(t, e) {
  const i = {}, a = bX(t, e);
  return t.drag && t.dragListener !== !1 && (i.draggable = !1, a.userSelect = a.WebkitUserSelect = a.WebkitTouchCallout = "none", a.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (i.tabIndex = 0), i.style = a, i;
}
const SX = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function Ix(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || SX.has(t);
}
let kz = (t) => !Ix(t);
function _X(t) {
  t && (kz = (e) => e.startsWith("on") ? !Ix(e) : t(e));
}
try {
  _X(require("@emotion/is-prop-valid").default);
} catch {
}
function CX(t, e, i) {
  const a = {};
  for (const o in t)
    o === "values" && typeof t.values == "object" || (kz(o) || i === !0 && Ix(o) || !e && !Ix(o) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && o.startsWith("onDrag")) && (a[o] = t[o]);
  return a;
}
function wX(t, e, i, a) {
  const o = Xs(() => {
    const f = Ez();
    return L1(f, e, N1(a), t.transformTemplate), {
      ...f.attrs,
      style: { ...f.style }
    };
  }, [e]);
  if (t.style) {
    const f = {};
    Dz(f, t.style, t), o.style = { ...f, ...o.style };
  }
  return o;
}
function TX(t = !1) {
  return (i, a, o, { latestValues: f }, u) => {
    const m = (k1(i) ? wX : xX)(a, f, u, i), v = CX(a, typeof i == "string", t), b = i !== ZP ? { ...v, ...m, ref: o } : {}, { children: S } = a, C = Xs(() => Vr(S) ? S.get() : S, [S]);
    return RU(i, {
      ...b,
      children: C
    });
  };
}
function EX(t, e) {
  return function(a, { forwardMotionProps: o } = { forwardMotionProps: !1 }) {
    const u = {
      ...k1(a) ? gX : vX,
      preloadedFeatures: t,
      useRender: TX(o),
      createVisualElement: e,
      Component: a
    };
    return tX(u);
  };
}
const SE = { current: null }, Mz = { current: !1 };
function RX() {
  if (Mz.current = !0, !!D1)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => SE.current = t.matches;
      t.addListener(e), e();
    } else
      SE.current = !1;
}
function DX(t, e, i) {
  for (const a in e) {
    const o = e[a], f = i[a];
    if (Vr(o))
      t.addValue(a, o), process.env.NODE_ENV === "development" && cS(o.version === "11.11.9", `Attempting to mix Framer Motion versions ${o.version} with 11.11.9 may not work as expected.`);
    else if (Vr(f))
      t.addValue(a, Ev(o, { owner: t }));
    else if (f !== o)
      if (t.hasValue(a)) {
        const u = t.getValue(a);
        u.liveStyle === !0 ? u.jump(o) : u.hasAnimated || u.set(o);
      } else {
        const u = t.getStaticValue(a);
        t.addValue(a, Ev(u !== void 0 ? u : o, { owner: t }));
      }
  }
  for (const a in i)
    e[a] === void 0 && t.removeValue(a);
  return e;
}
const KP = /* @__PURE__ */ new WeakMap(), kX = [...S2, zr, rc], MX = (t) => kX.find(x2(t)), XP = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class AX {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, i, a) {
    return {};
  }
  constructor({ parent: e, props: i, presenceContext: a, reducedMotionConfig: o, blockInitialAnimation: f, visualState: u }, h = {}) {
    this.applyWillChange = !1, this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = f1, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const C = Ho.now();
      this.renderScheduledAt < C && (this.renderScheduledAt = C, En.render(this.render, !1, !0));
    };
    const { latestValues: m, renderState: v } = u;
    this.latestValues = m, this.baseTarget = { ...m }, this.initialValues = i.initial ? { ...m } : {}, this.renderState = v, this.parent = e, this.props = i, this.presenceContext = a, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = o, this.options = h, this.blockInitialAnimation = !!f, this.isControllingVariants = vS(i), this.isVariantNode = bz(i), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: b, ...S } = this.scrapeMotionValuesFromProps(i, {}, this);
    for (const C in S) {
      const E = S[C];
      m[C] !== void 0 && Vr(E) && E.set(m[C], !1);
    }
  }
  mount(e) {
    this.current = e, KP.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((i, a) => this.bindToMotionValue(a, i)), Mz.current || RX(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : SE.current, process.env.NODE_ENV !== "production" && cS(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    KP.delete(this.current), this.projection && this.projection.unmount(), nc(this.notifyUpdate), nc(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const i = this.features[e];
      i && (i.unmount(), i.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, i) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const a = oc.has(e), o = i.on("change", (h) => {
      this.latestValues[e] = h, this.props.onUpdate && En.preRender(this.notifyUpdate), a && this.projection && (this.projection.isTransformDirty = !0);
    }), f = i.on("renderRequest", this.scheduleRender);
    let u;
    window.MotionCheckAppearSync && (u = window.MotionCheckAppearSync(this, e, i)), this.valueSubscriptions.set(e, () => {
      o(), f(), u && u(), i.owner && i.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in hp) {
      const i = hp[e];
      if (!i)
        continue;
      const { isEnabled: a, Feature: o } = i;
      if (!this.features[e] && o && a(this.props) && (this.features[e] = new o(this)), this.features[e]) {
        const f = this.features[e];
        f.isMounted ? f.update() : (f.mount(), f.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : _i();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, i) {
    this.latestValues[e] = i;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, i) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = i;
    for (let a = 0; a < XP.length; a++) {
      const o = XP[a];
      this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]);
      const f = "on" + o, u = e[f];
      u && (this.propEventSubscriptions[o] = this.on(o, u));
    }
    this.prevMotionValues = DX(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const i = this.getClosestVariantNode();
    if (i)
      return i.variantChildren && i.variantChildren.add(e), () => i.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, i) {
    const a = this.values.get(e);
    i !== a && (a && this.removeValue(e), this.bindToMotionValue(e, i), this.values.set(e, i), this.latestValues[e] = i.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const i = this.valueSubscriptions.get(e);
    i && (i(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, i) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let a = this.values.get(e);
    return a === void 0 && i !== void 0 && (a = Ev(i === null ? void 0 : i, { owner: this }), this.addValue(e, a)), a;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, i) {
    var a;
    let o = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (a = this.getBaseTargetFromProps(this.props, e)) !== null && a !== void 0 ? a : this.readValueFromInstance(this.current, e, this.options);
    return o != null && (typeof o == "string" && (g2(o) || m2(o)) ? o = parseFloat(o) : !MX(o) && rc.test(i) && (o = k2(e, i)), this.setBaseTarget(e, Vr(o) ? o.get() : o)), Vr(o) ? o.get() : o;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, i) {
    this.baseTarget[e] = i;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var i;
    const { initial: a } = this.props;
    let o;
    if (typeof a == "string" || typeof a == "object") {
      const u = r1(this.props, a, (i = this.presenceContext) === null || i === void 0 ? void 0 : i.custom);
      u && (o = u[e]);
    }
    if (a && o !== void 0)
      return o;
    const f = this.getBaseTargetFromProps(this.props, e);
    return f !== void 0 && !Vr(f) ? f : this.initialValues[e] !== void 0 && o === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, i) {
    return this.events[e] || (this.events[e] = new w1()), this.events[e].add(i);
  }
  notify(e, ...i) {
    this.events[e] && this.events[e].notify(...i);
  }
}
class Az extends AX {
  constructor() {
    super(...arguments), this.KeyframeResolver = M2;
  }
  sortInstanceNodePosition(e, i) {
    return e.compareDocumentPosition(i) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, i) {
    return e.style ? e.style[i] : void 0;
  }
  removeValueFromRenderState(e, { vars: i, style: a }) {
    delete i[e], delete a[e];
  }
}
function OX(t) {
  return window.getComputedStyle(t);
}
class PX extends Az {
  constructor() {
    super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = xz;
  }
  readValueFromInstance(e, i) {
    if (oc.has(i)) {
      const a = m1(i);
      return a && a.default || 0;
    } else {
      const a = OX(e), o = (y2(i) ? a.getPropertyValue(i) : a[i]) || 0;
      return typeof o == "string" ? o.trim() : o;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: i }) {
    return iz(e, i);
  }
  build(e, i, a) {
    P1(e, i, a.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, i, a) {
    return M1(e, i, a);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Vr(e) && (this.childSubscription = e.on("change", (i) => {
      this.current && (this.current.textContent = `${i}`);
    }));
  }
}
class LX extends Az {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = _i;
  }
  getBaseTargetFromProps(e, i) {
    return e[i];
  }
  readValueFromInstance(e, i) {
    if (oc.has(i)) {
      const a = m1(i);
      return a && a.default || 0;
    }
    return i = Sz.has(i) ? i : hS(i), e.getAttribute(i);
  }
  scrapeMotionValuesFromProps(e, i, a) {
    return wz(e, i, a);
  }
  build(e, i, a) {
    L1(e, i, this.isSVGTag, a.transformTemplate);
  }
  renderInstance(e, i, a, o) {
    _z(e, i, a, o);
  }
  mount(e) {
    this.isSVGTag = N1(e.tagName), super.mount(e);
  }
}
const NX = (t, e) => k1(t) ? new LX(e) : new PX(e, {
  allowProjection: t !== ZP
}), zX = /* @__PURE__ */ EX({
  ...wG,
  ...YK,
  ...NK,
  ...GK
}, NX), Oz = /* @__PURE__ */ g9(zX);
class FX extends _E.Component {
  getSnapshotBeforeUpdate(e) {
    const i = this.props.childRef.current;
    if (i && e.isPresent && !this.props.isPresent) {
      const a = this.props.sizeRef.current;
      a.height = i.offsetHeight || 0, a.width = i.offsetWidth || 0, a.top = i.offsetTop, a.left = i.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function VX({ children: t, isPresent: e }) {
  const i = Wx(), a = Sn(null), o = Sn({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: f } = ki(R1);
  return qP(() => {
    const { width: u, height: h, top: m, left: v } = o.current;
    if (e || !a.current || !u || !h)
      return;
    a.current.dataset.motionPopId = i;
    const b = document.createElement("style");
    return f && (b.nonce = f), document.head.appendChild(b), b.sheet && b.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${u}px !important;
            height: ${h}px !important;
            top: ${m}px !important;
            left: ${v}px !important;
          }
        `), () => {
      document.head.removeChild(b);
    };
  }, [e]), Me.jsx(FX, { isPresent: e, childRef: a, sizeRef: o, children: _E.cloneElement(t, { ref: a }) });
}
const jX = ({ children: t, initial: e, isPresent: i, onExitComplete: a, custom: o, presenceAffectsLayout: f, mode: u }) => {
  const h = A1(BX), m = Wx(), v = CE((S) => {
    h.set(S, !0);
    for (const C of h.values())
      if (!C)
        return;
    a && a();
  }, [h, a]), b = Xs(
    () => ({
      id: m,
      initial: e,
      isPresent: i,
      custom: o,
      onExitComplete: v,
      register: (S) => (h.set(S, !1), () => h.delete(S))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    f ? [Math.random(), v] : [i, v]
  );
  return Xs(() => {
    h.forEach((S, C) => h.set(C, !1));
  }, [i]), _E.useEffect(() => {
    !i && !h.size && a && a();
  }, [i]), u === "popLayout" && (t = Me.jsx(VX, { isPresent: i, children: t })), Me.jsx(mS.Provider, { value: b, children: t });
};
function BX() {
  return /* @__PURE__ */ new Map();
}
const tx = (t) => t.key || "";
function QP(t) {
  const e = [];
  return DU.forEach(t, (i) => {
    JP(i) && e.push(i);
  }), e;
}
const Pz = ({ children: t, exitBeforeEnter: e, custom: i, initial: a = !0, onExitComplete: o, presenceAffectsLayout: f = !0, mode: u = "sync" }) => {
  Ql(!e, "Replace exitBeforeEnter with mode='wait'");
  const h = Xs(() => QP(t), [t]), m = h.map(tx), v = Sn(!0), b = Sn(h), S = A1(() => /* @__PURE__ */ new Map()), [C, E] = Tn(h), [D, M] = Tn(h);
  gz(() => {
    v.current = !1, b.current = h;
    for (let N = 0; N < D.length; N++) {
      const F = tx(D[N]);
      m.includes(F) ? S.delete(F) : S.get(F) !== !0 && S.set(F, !1);
    }
  }, [D, m.length, m.join("-")]);
  const A = [];
  if (h !== C) {
    let N = [...h];
    for (let F = 0; F < D.length; F++) {
      const B = D[F], V = tx(B);
      m.includes(V) || (N.splice(F, 0, B), A.push(B));
    }
    u === "wait" && A.length && (N = A), M(QP(N)), E(h);
    return;
  }
  process.env.NODE_ENV !== "production" && u === "wait" && D.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: P } = ki(T1);
  return Me.jsx(Me.Fragment, { children: D.map((N) => {
    const F = tx(N), B = h === D || m.includes(F), V = () => {
      if (S.has(F))
        S.set(F, !0);
      else
        return;
      let G = !0;
      S.forEach((Y) => {
        Y || (G = !1);
      }), G && (P == null || P(), M(b.current), o && o());
    };
    return Me.jsx(jX, { isPresent: B, initial: !v.current || a ? void 0 : !1, custom: B ? void 0 : i, presenceAffectsLayout: f, mode: u, onExitComplete: B ? void 0 : V, children: N }, F);
  }) });
}, Lz = Io(void 0), Nz = ({
  children: t,
  onClose: e = () => {
  }
}) => {
  const [i, a] = Tn(!0), o = () => {
    a(!1), e();
  };
  return /* @__PURE__ */ Me.jsx(Lz.Provider, { value: { handleClose: o, isVisible: i, setIsVisible: a }, children: t });
};
Nz.displayName = "HToastPopupProvider";
const HX = ({ children: t, onClose: e }) => /* @__PURE__ */ Me.jsx(Nz, { onClose: e, children: /* @__PURE__ */ Me.jsx(
  Oz.div,
  {
    initial: { opacity: 0, y: 50, height: 0 },
    animate: { opacity: 1, y: 0, height: "auto" },
    exit: { opacity: 0, height: 0 },
    transition: { duration: 0.3 },
    layout: !0,
    children: t
  }
) });
HX.displayName = "HToastPopupArea";
const zz = () => {
  const t = ki(Lz);
  if (!t)
    throw new Error("useToastContext must be used within a ToastPopupProvider");
  return t;
}, UX = ({
  duration: t = 3e3,
  className: e,
  children: i
}) => {
  const { setIsVisible: a, isVisible: o, handleClose: f } = zz();
  return Xn(() => {
    const u = setTimeout(() => {
      a(!1), f();
    }, t);
    return () => clearTimeout(u);
  }, [t]), /* @__PURE__ */ Me.jsx(Pz, { children: o && /* @__PURE__ */ Me.jsx(
    Oz.div,
    {
      initial: { opacity: 0, y: 50 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: 50 },
      transition: { duration: 0.3 },
      className: `rounded-lg shadow-lg overflow-hidden w-full md:w-96 text-[#888] bg-black/70 ${e}`,
      role: "alert",
      "aria-live": "assertive",
      children: i
    }
  ) });
};
UX.displayName = "HToastPopup";
const IX = ({ className: t, children: e, style: i }) => /* @__PURE__ */ Me.jsx("div", { style: i, className: `fixed bottom-4 right-4 z-[200] p-4 space-y-4 flex flex-col ${t}`, children: /* @__PURE__ */ Me.jsx(Pz, { children: e }) });
IX.displayName = "HToastPopupContainer";
const $X = ({ children: t, className: e }) => {
  const { handleClose: i } = zz();
  return /* @__PURE__ */ Me.jsx(
    "button",
    {
      type: "button",
      onClick: i,
      className: `focus:outline-none focus:ring-2 focus:ring-gray-400 rounded-full p-1 text-[#fff] ${e}`,
      "aria-label": "Close",
      children: t
    }
  );
};
$X.displayName = "HToastPopupCloseButton";
const WX = ({ target: t, children: e, className: i, style: a }) => {
  const o = (h) => {
    var m;
    (m = t.current) == null || m.show(h);
  }, f = (h) => {
    var m;
    (m = t.current) == null || m.updatePosition(h);
  }, u = () => {
    var h;
    (h = t.current) == null || h.hide();
  };
  return /* @__PURE__ */ Me.jsx(
    "div",
    {
      onMouseEnter: o,
      onMouseMove: f,
      onMouseLeave: u,
      className: i,
      style: a,
      children: e
    }
  );
};
WX.displayName = "HTooltipArea";
const YX = pp((t, e) => {
  const [i, a] = Tn(!1), [o, f] = Tn({
    x: 0,
    y: 0
  });
  $x(e, () => ({
    show(h) {
      f({ x: h.clientX, y: h.clientY }), a(!0);
    },
    hide() {
      a(!1);
    },
    updatePosition(h) {
      i && f({ x: h.clientX, y: h.clientY });
    }
  }));
  const u = {
    position: "fixed",
    // Changed from 'absolute' to 'fixed'
    top: o.y + 10,
    // Slight offset for better visibility
    left: o.x + 10,
    backgroundColor: "#333",
    color: "#fff",
    padding: "8px",
    borderRadius: "4px",
    zIndex: 1e3,
    pointerEvents: "none"
    // Ensure tooltip doesn't intercept mouse events
  };
  return i ? /* @__PURE__ */ Me.jsx(
    "div",
    {
      style: {
        ...u,
        ...t.style
      },
      className: t.className,
      children: t.children
    }
  ) : null;
});
YX.displayName = "HTooltip";
const GX = pp((t, e) => {
  const {
    backdrop: i,
    escBeforeFunc: a,
    escAfterFunc: o,
    onBackdropClick: f,
    children: u,
    className: h,
    style: m
  } = t, v = Sn(null), b = async () => {
    v.current && v.current.close();
  }, S = () => {
    v.current && v.current.showModal();
  };
  $x(e, () => ({
    open: S,
    closeFunc: b
  })), Xn(() => (i && document.documentElement.style.setProperty("--modal-backdrop-color", i), () => {
    i && document.documentElement.style.removeProperty("--modal-backdrop-color");
  }), [i]);
  const C = async (D) => {
    D.key === "Escape" && (D.preventDefault(), a && await a(), b(), o && await o());
  }, E = (D) => {
    D.target === v.current && (f == null || f(D));
  };
  return /* @__PURE__ */ Me.jsx(
    "dialog",
    {
      ref: v,
      className: `h-modal ${h}`,
      onKeyDown: C,
      onClick: E,
      style: m,
      children: u && u(b)
    }
  );
});
GX.displayName = "HModal";
const KX = ({
  target: t,
  beforeFunc: e,
  afterFunc: i,
  children: a,
  className: o,
  style: f,
  disabled: u = !1
}) => {
  const h = async () => {
    var m;
    e && await e(), (m = t.current) == null || m.open(), i && i();
  };
  return /* @__PURE__ */ Me.jsx("button", { onClick: h, type: "button", className: o, style: f, disabled: u, children: a || "모달 열기" });
};
KX.displayName = "HModalOpenButton";
const XX = ({
  target: t,
  beforeFunc: e,
  afterFunc: i,
  children: a,
  className: o,
  style: f
}) => {
  const u = async () => {
    var h;
    e && await e(), (h = t.current) == null || h.closeFunc(), i && i();
  };
  return /* @__PURE__ */ Me.jsx("button", { onClick: u, type: "button", className: o, style: f, children: a || "닫기" });
};
XX.displayName = "HModalCloseButton";
const QX = "button", qX = pp((t) => {
  const {
    isAuth: e,
    noAuthList: i,
    originalEventTarget: a = QX,
    originalEventTargetEvent: o = null,
    onAuthVerificationResult: f,
    children: u
  } = t, h = Sn(null), m = Sn(), v = Sn(null), b = () => e ? !(i != null && i.includes(e)) : !0;
  function S(D) {
    var A;
    console.debug(D);
    const M = (A = h.current) == null ? void 0 : A.querySelector(a);
    M && (M.removeEventListener("click", m.current, {
      capture: !0
    }), M.click(), M.addEventListener("click", m.current, {
      capture: !0
    }));
  }
  function C(D) {
    D.preventDefault(), D.stopPropagation();
    const M = b();
    f == null || f({
      event: D,
      result: M,
      originalFunc: S
    });
  }
  const E = (() => {
    if (!u || !JP(u)) return u;
    const D = u, M = D.props || {}, A = o ? M[o] : M.onClick;
    return v.current = A || null, kU(D, {
      // ...가능하면 onClick 다시 세팅, etc.
    });
  })();
  return Xn(() => {
    const D = h.current;
    if (!D) return;
    const M = D.querySelector(a);
    if (M)
      return m.current = C, M.addEventListener("click", m.current, {
        capture: !0
      }), () => {
        M.removeEventListener(
          "click",
          m.current,
          { capture: !0 }
        );
      };
  }, [e, i, a, o, f]), /* @__PURE__ */ Me.jsx("div", { ref: h, children: E });
});
qX.displayName = "AuthVerifyWrapper";
function ZX(t) {
  const {
    data: e,
    value: i,
    inputValue: a,
    onChange: o,
    name: f,
    className: u,
    labelClassName: h,
    inputClassName: m,
    labelStyle: v,
    disabled: b,
    readOnly: S,
    required: C,
    children: E
  } = t, D = Wx(), M = i.some((P) => sE(P, e)), A = () => {
    o(M ? i.filter((P) => !sE(P, e)) : [...i, e]);
  };
  return /* @__PURE__ */ Me.jsxs("div", { className: u, children: [
    /* @__PURE__ */ Me.jsx("label", { htmlFor: D, className: h, style: v, children: E }),
    /* @__PURE__ */ Me.jsx(
      "input",
      {
        id: D,
        type: "checkbox",
        name: f,
        checked: M,
        onChange: A,
        disabled: b,
        readOnly: S,
        required: C,
        className: `h-input-checkbox ${m}`,
        value: a
      }
    )
  ] });
}
ZX.displayName = "HInputCheckbox";
const uQ = ({ children: t, style: e, className: i }) => /* @__PURE__ */ Me.jsx("div", { style: { position: "relative", ...e }, className: i, children: t }), cQ = ({ value: t, style: e, className: i }) => /* @__PURE__ */ Me.jsx("div", { style: {
  width: `${t}%`,
  height: "100%",
  ...e
}, className: i });
export {
  QL as CALENDAR_TYPES,
  mv as DATE_AREA_TYPE,
  aQ as HBarChart,
  qX as HCheckAuth,
  yW as HDropdownArea,
  xW as HDropdownButton,
  bW as HDropdownItem,
  SW as HDropdownItemButton,
  D8 as HDropdownList,
  ZX as HInputCheckbox,
  GX as HModal,
  XX as HModalCloseButton,
  KX as HModalOpenButton,
  oQ as HPieChart,
  uQ as HProgress,
  cQ as HProgressBar,
  YN as HScrollbars,
  W4 as HSingleDatePickerArea,
  Y4 as HSingleDatePickerCalendar,
  K4 as HSingleDatePickerCalendarArea,
  G4 as HSingleDatePickerCalendarDateButton,
  Q4 as HSingleDatePickerCalendarMonth,
  X4 as HSingleDatePickerCalendarMonthArea,
  Z4 as HSingleDatePickerCalendarMonthButton,
  tW as HSingleDatePickerCalendarYear,
  aW as HSingleDatePickerCalendarYearArea,
  lW as HSingleDatePickerCalendarYearButton,
  pW as HSingleDatePickerInput,
  q4 as HSingleDatePickerMonthButton,
  mW as HSingleDatePickerMonthNextButton,
  eW as HSingleDatePickerMonthPrevButton,
  gW as HSingleDatePickerMonthYearButton,
  iW as HSingleDatePickerNextButton,
  rW as HSingleDatePickerPrevButton,
  j4 as HSingleDatePickerRangeArea,
  sW as HSingleDatePickerYearButton,
  oW as HSingleDatePickerYearNextButton,
  vW as HSingleDatePickerYearPrevButton,
  UX as HToastPopup,
  HX as HToastPopupArea,
  $X as HToastPopupCloseButton,
  IX as HToastPopupContainer,
  YX as HTooltip,
  WX as HTooltipArea,
  sQ as checkEqual
};
